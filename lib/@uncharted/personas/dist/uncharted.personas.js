/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 388);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(2)
  , core      = __webpack_require__(28)
  , hide      = __webpack_require__(15)
  , redefine  = __webpack_require__(16)
  , ctx       = __webpack_require__(29)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(72)('wks')
  , uid        = __webpack_require__(46)
  , Symbol     = __webpack_require__(2).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(1)
  , IE8_DOM_DEFINE = __webpack_require__(130)
  , toPrimitive    = __webpack_require__(26)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parsing utility functions



var check = __webpack_require__(11);

// Retrieve an unsigned byte from the DataView.
exports.getByte = function getByte(dataView, offset) {
    return dataView.getUint8(offset);
};

exports.getCard8 = exports.getByte;

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
function getUShort(dataView, offset) {
    return dataView.getUint16(offset, false);
}

exports.getUShort = exports.getCard16 = getUShort;

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
exports.getShort = function(dataView, offset) {
    return dataView.getInt16(offset, false);
};

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
exports.getULong = function(dataView, offset) {
    return dataView.getUint32(offset, false);
};

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
exports.getFixed = function(dataView, offset) {
    var decimal = dataView.getInt16(offset, false);
    var fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
};

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
exports.getTag = function(dataView, offset) {
    var tag = '';
    for (var i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }

    return tag;
};

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
exports.getOffset = function(dataView, offset, offSize) {
    var v = 0;
    for (var i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }

    return v;
};

// Retrieve a number of bytes from start offset to the end offset from the DataView.
exports.getBytes = function(dataView, startOffset, endOffset) {
    var bytes = [];
    for (var i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }

    return bytes;
};

// Convert the list of bytes to a string.
exports.bytesToString = function(bytes) {
    var s = '';
    for (var i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }

    return s;
};

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function() {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function() {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function() {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseFixed = function() {
    var v = exports.getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseString = function(length) {
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    var string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }

    return string;
};

Parser.prototype.parseTag = function() {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
// + Since until 2038 those bits will be filled by zeros we can ignore them.
Parser.prototype.parseLongDateTime = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset + 4);
    // Subtract seconds between 01/01/1904 and 01/01/1970
    // to convert Apple Mac timstamp to Standard Unix timestamp
    v -= 2082844800;
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseVersion = function() {
    var major = getUShort(this.data, this.offset + this.relativeOffset);

    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // This returns the correct number if minor = 0xN000 where N is 0-9
    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    return major + minor / 0x1000 / 10;
};

Parser.prototype.skip = function(type, amount) {
    if (amount === undefined) {
        amount = 1;
    }

    this.relativeOffset += typeOffsets[type] * amount;
};

///// Parsing lists and records ///////////////////////////////

// Parse a list of 16 bit integers. The length of the list can be read on the stream
// or provided as an argument.
Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function(count) {
    if (count === undefined) { count = this.parseUShort(); }
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = dataView.getUint16(offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return offsets;
};

/**
 * Parse a list of items.
 * Record count is optional, if omitted it is read from the stream.
 * itemCallback is one of the Parser methods.
 */
Parser.prototype.parseList = function(count, itemCallback) {
    if (!itemCallback) {
        itemCallback = count;
        count = this.parseUShort();
    }
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        list[i] = itemCallback.call(this);
    }
    return list;
};

/**
 * Parse a list of records.
 * Record count is optional, if omitted it is read from the stream.
 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
 */
Parser.prototype.parseRecordList = function(count, recordDescription) {
    // If the count argument is absent, read it in the stream.
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseUShort();
    }
    var records = new Array(count);
    var fields = Object.keys(recordDescription);
    for (var i = 0; i < count; i++) {
        var rec = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this);
        }
        records[i] = rec;
    }
    return records;
};

// Parse a data structure into an object
// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
Parser.prototype.parseStruct = function(description) {
    if (typeof description === 'function') {
        return description.call(this);
    } else {
        var fields = Object.keys(description);
        var struct = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = description[fieldName];
            struct[fieldName] = fieldType.call(this);
        }
        return struct;
    }
};

Parser.prototype.parsePointer = function(description) {
    var structOffset = this.parseOffset16();
    if (structOffset > 0) {                         // NULL offset => return indefined
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    }
};

/**
 * Parse a list of offsets to lists of 16-bit integers,
 * or a list of offsets to lists of offsets to any kind of items.
 * If itemCallback is not provided, a list of list of UShort is assumed.
 * If provided, itemCallback is called on each item and must parse the item.
 * See examples in tables/gsub.js
 */
Parser.prototype.parseListOfLists = function(itemCallback) {
    var offsets = this.parseOffset16List();
    var count = offsets.length;
    var relativeOffset = this.relativeOffset;
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        var start = offsets[i];
        if (start === 0) {                  // NULL offset
            list[i] = undefined;            // Add i as owned property to list. Convenient with assert.
            continue;
        }
        this.relativeOffset = start;
        if (itemCallback) {
            var subOffsets = this.parseOffset16List();
            var subList = new Array(subOffsets.length);
            for (var j = 0; j < subOffsets.length; j++) {
                this.relativeOffset = start + subOffsets[j];
                subList[j] = itemCallback.call(this);
            }
            list[i] = subList;
        } else {
            list[i] = this.parseUShortList();
        }
    }
    this.relativeOffset = relativeOffset;
    return list;
};

///// Complex tables parsing //////////////////////////////////

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
// parser.offset must point to the start of the table containing the coverage.
Parser.prototype.parseCoverage = function() {
    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    var count = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            glyphs: this.parseUShortList(count)
        };
    } else if (format === 2) {
        var ranges = new Array(count);
        for (var i = 0; i < count; i++) {
            ranges[i] = {
                start: this.parseUShort(),
                end: this.parseUShort(),
                index: this.parseUShort()
            };
        }
        return {
            format: 2,
            ranges: ranges
        };
    }
    check.assert(false, '0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
};

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
Parser.prototype.parseClassDef = function() {
    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            startGlyph: this.parseUShort(),
            classes: this.parseUShortList()
        };
    } else if (format === 2) {
        return {
            format: 2,
            ranges: this.parseRecordList({
                start: Parser.uShort,
                end: Parser.uShort,
                classId: Parser.uShort
            })
        };
    }
    check.assert(false, '0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
};

///// Static methods ///////////////////////////////////
// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

Parser.list = function(count, itemCallback) {
    return function() {
        return this.parseList(count, itemCallback);
    };
};

Parser.recordList = function(count, recordDescription) {
    return function() {
        return this.parseRecordList(count, recordDescription);
    };
};

Parser.pointer = function(description) {
    return function() {
        return this.parsePointer(description);
    };
};

Parser.tag = Parser.prototype.parseTag;
Parser.byte = Parser.prototype.parseByte;
Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
Parser.uShortList = Parser.prototype.parseUShortList;
Parser.struct = Parser.prototype.parseStruct;
Parser.coverage = Parser.prototype.parseCoverage;
Parser.classDef = Parser.prototype.parseClassDef;

///// Script, Feature, Lookup lists ///////////////////////////////////////////////
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

var langSysTable = {
    reserved: Parser.uShort,
    reqFeatureIndex: Parser.uShort,
    featureIndexes: Parser.uShortList
};

Parser.prototype.parseScriptList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        script: Parser.pointer({
            defaultLangSys: Parser.pointer(langSysTable),
            langSysRecords: Parser.recordList({
                tag: Parser.tag,
                langSys: Parser.pointer(langSysTable)
            })
        })
    }));
};

Parser.prototype.parseFeatureList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        feature: Parser.pointer({
            featureParams: Parser.offset16,
            lookupListIndexes: Parser.uShortList
        })
    }));
};

Parser.prototype.parseLookupList = function(lookupTableParsers) {
    return this.parsePointer(Parser.list(Parser.pointer(function() {
        var lookupType = this.parseUShort();
        check.argument(1 <= lookupType && lookupType <= 8, 'GSUB lookup type ' + lookupType + ' unknown.');
        var lookupFlag = this.parseUShort();
        var useMarkFilteringSet = lookupFlag & 0x10;
        return {
            lookupType: lookupType,
            lookupFlag: lookupFlag,
            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
        };
    })));
};

exports.Parser = Parser;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(37)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(22);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Run-time checking of preconditions.



exports.fail = function(message) {
    throw new Error(message);
};

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
exports.argument = function(predicate, message) {
    if (!predicate) {
        exports.fail(message);
    }
};

// Precondition function that checks if the given assertion is true.
// If not, it will throw an error.
exports.assert = exports.argument;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Table metadata



var check = __webpack_require__(11);
var encode = __webpack_require__(75).encode;
var sizeOf = __webpack_require__(75).sizeOf;
/**
 * @exports opentype.Table
 * @class
 * @param {string} tableName
 * @param {Array} fields
 * @param {Object} options
 * @constructor
 */
function Table(tableName, fields, options) {
    var i;
    for (i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this[field.name] = field.value;
    }

    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (i = 0; i < optionKeys.length; i += 1) {
            var k = optionKeys[i];
            var v = options[k];
            if (this[k] !== undefined) {
                this[k] = v;
            }
        }
    }
}

/**
 * Encodes the table and returns an array of bytes
 * @return {Array}
 */
Table.prototype.encode = function() {
    return encode.TABLE(this);
};

/**
 * Get the size of the table.
 * @return {number}
 */
Table.prototype.sizeOf = function() {
    return sizeOf.TABLE(this);
};

/**
 * @private
 */
function ushortList(itemName, list, count) {
    if (count === undefined) {
        count = list.length;
    }
    var fields = new Array(list.length + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < list.length; i++) {
        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
    }
    return fields;
}

/**
 * @private
 */
function tableList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = new Array(count + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
    }
    return fields;
}

/**
 * @private
 */
function recordList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = [];
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields = fields.concat(itemCallback(records[i], i));
    }
    return fields;
}

// Common Layout Tables

/**
 * @exports opentype.Coverage
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function Coverage(coverageTable) {
    if (coverageTable.format === 1) {
        Table.call(this, 'coverageTable',
            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
            .concat(ushortList('glyph', coverageTable.glyphs))
        );
    } else {
        check.assert(false, 'Can\'t create coverage table format 2 yet.');
    }
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;

function ScriptList(scriptListTable) {
    Table.call(this, 'scriptListTable',
        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
            var script = scriptRecord.script;
            var defaultLangSys = script.defaultLangSys;
            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
            return [
                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
                        {name: 'lookupOrder', type: 'USHORT', value: 0},
                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
                        var langSys = langSysRecord.langSys;
                        return [
                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
                                {name: 'lookupOrder', type: 'USHORT', value: 0},
                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
                        ];
                    })))}
            ];
        })
    );
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;

/**
 * @exports opentype.FeatureList
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function FeatureList(featureListTable) {
    Table.call(this, 'featureListTable',
        recordList('featureRecord', featureListTable, function(featureRecord, i) {
            var feature = featureRecord.feature;
            return [
                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams},
                    ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
            ];
        })
    );
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;

/**
 * @exports opentype.LookupList
 * @class
 * @param {opentype.Table}
 * @param {Object}
 * @constructor
 * @extends opentype.Table
 */
function LookupList(lookupListTable, subtableMakers) {
    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
        var subtableCallback = subtableMakers[lookupTable.lookupType];
        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
        return new Table('lookupTable', [
            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
    }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;

// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
// Don't use offsets inside Records (probable bug), only in Tables.
exports.Record = exports.Table = Table;
exports.Coverage = Coverage;
exports.ScriptList = ScriptList;
exports.FeatureList = FeatureList;
exports.LookupList = LookupList;

exports.ushortList = ushortList;
exports.tableList = tableList;
exports.recordList = recordList;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(7)
  , createDesc = __webpack_require__(36);
module.exports = __webpack_require__(6) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(2)
  , hide      = __webpack_require__(15)
  , has       = __webpack_require__(12)
  , SRC       = __webpack_require__(46)('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

__webpack_require__(28).inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
  , fails   = __webpack_require__(3)
  , defined = __webpack_require__(22)
  , quot    = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function(string, tag, attribute, value) {
  var S  = String(defined(string))
    , p1 = '<' + tag;
  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function(NAME, exec){
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function(){
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(56)
  , defined = __webpack_require__(22);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(57)
  , createDesc     = __webpack_require__(36)
  , toIObject      = __webpack_require__(18)
  , toPrimitive    = __webpack_require__(26)
  , has            = __webpack_require__(12)
  , IE8_DOM_DEFINE = __webpack_require__(130)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(12)
  , toObject    = __webpack_require__(10)
  , IE_PROTO    = __webpack_require__(94)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 21 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(3);

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = __webpack_require__(29)
  , IObject  = __webpack_require__(56)
  , toObject = __webpack_require__(10)
  , toLength = __webpack_require__(9)
  , asc      = __webpack_require__(194);
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0)
  , core    = __webpack_require__(28)
  , fails   = __webpack_require__(3);
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(4);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Tuple_js__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Events_js__ = __webpack_require__(33);
/* unused harmony export Point */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */




var UNIT_TYPES = {
    PIXELS: Symbol('UNIT_TYPE_PIXELS'),
    PERCENTAGE: Symbol('UNIT_TYPE_PERCENTAGE'),
    UNSUPPORTED: Symbol('UNIT_TYPE_UNSUPPORTED')
};

/**
 * Utility class that represents a point in a 2D space.
 *
 * @class Point
 */
var Point = function (_Tuple) {
    _inherits(Point, _Tuple);

    _createClass(Point, null, [{
        key: 'fromPoint',

        /**
         * Returns a new Point with the same values as the provided point.
         *
         * @method fromPoint
         * @param {Point} point - The point to copy.
         * @returns {Point}
         * @static
         */
        value: function fromPoint(point) {
            var xValue = point.xUnits === Point.UNIT_TYPE_PERCENTAGE ? point.x * 100 + '%' : point.x;
            var yValue = point.yUnits === Point.UNIT_TYPE_PERCENTAGE ? point.y * 100 + '%' : point.y;
            return new Point(xValue, yValue);
        }

        /**
         * Flag used to define that this point uses pixels as its units.
         *
         * @type {Symbol}
         */

    }, {
        key: 'UNIT_TYPE_PIXELS',
        get: function get() {
            return UNIT_TYPES.PIXELS;
        }

        /**
         * Flag used to define that this point uses percentages as its units.
         *
         * @type {Symbol}
         */

    }, {
        key: 'UNIT_TYPE_PERCENTAGE',
        get: function get() {
            return UNIT_TYPES.PERCENTAGE;
        }

        /**
         * Flag used to define unsupported measurement units.
         *
         * @type {Symbol}
         */

    }, {
        key: 'UNIT_TYPE_UNSUPPORTED',
        get: function get() {
            return UNIT_TYPES.UNSUPPORTED;
        }

        /**
         * @constructor Point
         * @param {String|Number=} x - The X coordinate of this point.
         * @param {String|Number=} y - The Y coordinate of this point.
         */

    }]);

    function Point() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        _classCallCheck(this, Point);

        var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this, 0, 0));

        _this.mUnitsTypeX = UNIT_TYPES.UNSUPPORTED;
        _this.mUnitsTypeY = UNIT_TYPES.UNSUPPORTED;
        _this._assignValue(x, 'value1', 'mUnitsTypeX');
        _this._assignValue(y, 'value2', 'mUnitsTypeY');
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Point, [{
        key: 'destroy',
        value: function destroy() {
            delete this.mUnitsTypeX;
            delete this.mUnitsTypeY;
            _get(Point.prototype.__proto__ || Object.getPrototypeOf(Point.prototype), 'destroy', this).call(this);
        }

        /**
         * Gets the X coordinate of this point.
         * @type {Number|String}
         */

    }, {
        key: 'set',


        /**
         * Sets the X and Y coordinates of this point.
         *
         * @method set
         * @param {Number|String} x - The new X coordinate for this point.
         * @param {Number|String} y - The new Y coordinate for this point.
         */
        value: function set(x, y) {
            var changedX = this._assignValue(x, 'value1', 'mUnitsTypeX');
            var changedY = this._assignValue(y, 'value2', 'mUnitsTypeY');
            if (changedX || changedY) {
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this, this.value1, this.value2);
            }
        }

        /**
         * Sets the X and Y coordinates of this point using the provided point as reference.
         *
         * @method setFromPoint
         * @param {Point} point - The point to use as reference.
         */

    }, {
        key: 'setFromPoint',
        value: function setFromPoint(point) {
            if (point.x !== this.value1 || point.y !== this.value2) {
                this.value1 = point.x;
                this.value2 = point.y;
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this, this.value1, this.value2);
            }
        }

        /**
         * Adds the passed point to this point. The result is saved in this point.
         *
         * @method add
         * @param {Point} point - The point to add.
         */

    }, {
        key: 'add',
        value: function add(point) {
            if (point.value1 !== 0 || point.value2 !== 0) {
                this.value1 += point.value1;
                this.value2 += point.value2;
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this, this.value1, this.value2);
            }
        }

        /**
         * Subtracts the passed point from this point. The result is saved in this point.
         *
         * @method subtract
         * @param {Point} point - The point to subtract.
         */

    }, {
        key: 'subtract',
        value: function subtract(point) {
            if (point.value1 !== 0 || point.value2 !== 0) {
                this.value1 -= point.value1;
                this.value2 -= point.value2;
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this, this.value1, this.value2);
            }
        }

        /**
         * Clones this point and returns the copied point.
         * NOTE: The resulting point is returned as an auto released instance.
         *
         * @method clone
         * @returns {Point}
         */

    }, {
        key: 'clone',
        value: function clone() {
            return new Point(this.value1, this.value2).autorelease();
        }

        /**
         * Assigns the given value to the property with `valueProperty` name and changes the unit type if needed.
         *
         * @method _assignValue
         * @param {Number|String} value - The new value to parse.
         * @param {String} valueProperty - The name of the property in this object where the value will be stored.
         * @param {String} unitsProperty - The name of the property in this object where the unit type of the value should be stored.
         * @returns {Boolean} Whether or not the value or its units changed.
         * @private
         */

    }, {
        key: '_assignValue',
        value: function _assignValue(value, valueProperty, unitsProperty) {
            if (typeof value === 'string' || value instanceof String) {
                var newValue = Number.NaN;
                var numberString = value.toString();
                /* check the number type */
                var lastChar = numberString[numberString.length - 1];
                var unitsType = void 0;
                if (lastChar === '%') {
                    unitsType = UNIT_TYPES.PERCENTAGE;
                    newValue = parseFloat(numberString.slice(0, -1)) / 100;
                } else if (lastChar === 'x' && numberString[numberString.length - 2] === 'p') {
                    unitsType = UNIT_TYPES.PIXELS;
                    newValue = parseFloat(numberString.slice(0, -2));
                } else if (!isNaN(parseInt(lastChar, 10))) {
                    unitsType = UNIT_TYPES.PIXELS;
                    newValue = parseFloat(numberString);
                }

                if (isNaN(newValue)) {
                    throw new Error('Cannot parse value: ' + value);
                }

                if (newValue !== this[valueProperty] || unitsType !== this[unitsProperty]) {
                    this[valueProperty] = newValue;
                    this[unitsProperty] = unitsType;
                    return true;
                }
            } else if (value !== this[valueProperty] || this[unitsProperty] !== UNIT_TYPES.PIXELS) {
                this[valueProperty] = value;
                this[unitsProperty] = UNIT_TYPES.PIXELS;
                return true;
            }
            return false;
        }
    }, {
        key: 'x',
        get: function get() {
            return this.value1;
        }

        /**
         * Sets the X coordinate of this point.
         * @param {Number|String} value - The new value of the property.
         */
        ,
        set: function set(value) {
            if (this._assignValue(value, 'value1', 'mUnitsTypeX')) {
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this, this.value1, this.value2);
            }
        }

        /**
         * The units type that the x value uses.
         *
         * @type {Symbol}
         */

    }, {
        key: 'xUnits',
        get: function get() {
            return this.mUnitsTypeX;
        }

        /**
         * Sets the units type for the x value.
         *
         * @param {Symbol} value - The new units type.
         */
        ,
        set: function set(value) {
            if (value !== this.mUnitsTypeX) {
                this.mUnitsTypeX = value;
            }
        }

        /**
         * Gets the Y coordinate of this point.
         * @type {Number|String}
         */

    }, {
        key: 'y',
        get: function get() {
            return this.value2;
        }

        /**
         * Sets the Y coordinate of this point.
         *
         * @param {Number|String} value - The new value of the property.
         */
        ,
        set: function set(value) {
            if (this._assignValue(value, 'value2', 'mUnitsTypeY')) {
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this, this.value1, this.value2);
            }
        }

        /**
         * The units type that the y value uses.
         *
         * @type {Symbol}
         */

    }, {
        key: 'yUnits',
        get: function get() {
            return this.mUnitsTypeY;
        }

        /**
         * Sets the units type for the y value.
         *
         * @param {Symbol} value - The new units type.
         */
        ,
        set: function set(value) {
            if (value !== this.mUnitsTypeY) {
                this.mUnitsTypeY = value;
            }
        }
    }]);

    return Point;
}(__WEBPACK_IMPORTED_MODULE_0__core_Tuple_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Point;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(14);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var Map     = __webpack_require__(146)
  , $export = __webpack_require__(0)
  , shared  = __webpack_require__(72)('metadata')
  , store   = shared.store || (shared.store = new (__webpack_require__(149)));

var getOrCreateMetadataMap = function(target, targetKey, create){
  var targetMetadata = store.get(target);
  if(!targetMetadata){
    if(!create)return undefined;
    store.set(target, targetMetadata = new Map);
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if(!keyMetadata){
    if(!create)return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map);
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey){
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
    , keys        = [];
  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
  return keys;
};
var toMetaKey = function(it){
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function(O){
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if(__webpack_require__(6)){
  var LIBRARY             = __webpack_require__(39)
    , global              = __webpack_require__(2)
    , fails               = __webpack_require__(3)
    , $export             = __webpack_require__(0)
    , $typed              = __webpack_require__(73)
    , $buffer             = __webpack_require__(101)
    , ctx                 = __webpack_require__(29)
    , anInstance          = __webpack_require__(38)
    , propertyDesc        = __webpack_require__(36)
    , hide                = __webpack_require__(15)
    , redefineAll         = __webpack_require__(43)
    , toInteger           = __webpack_require__(37)
    , toLength            = __webpack_require__(9)
    , toIndex             = __webpack_require__(45)
    , toPrimitive         = __webpack_require__(26)
    , has                 = __webpack_require__(12)
    , same                = __webpack_require__(143)
    , classof             = __webpack_require__(55)
    , isObject            = __webpack_require__(4)
    , toObject            = __webpack_require__(10)
    , isArrayIter         = __webpack_require__(86)
    , create              = __webpack_require__(40)
    , getPrototypeOf      = __webpack_require__(20)
    , gOPN                = __webpack_require__(41).f
    , getIterFn           = __webpack_require__(103)
    , uid                 = __webpack_require__(46)
    , wks                 = __webpack_require__(5)
    , createArrayMethod   = __webpack_require__(24)
    , createArrayIncludes = __webpack_require__(63)
    , speciesConstructor  = __webpack_require__(95)
    , ArrayIterators      = __webpack_require__(104)
    , Iterators           = __webpack_require__(50)
    , $iterDetect         = __webpack_require__(69)
    , setSpecies          = __webpack_require__(44)
    , arrayFill           = __webpack_require__(79)
    , arrayCopyWithin     = __webpack_require__(123)
    , $DP                 = __webpack_require__(7)
    , $GOPD               = __webpack_require__(19)
    , dP                  = $DP.f
    , gOPD                = $GOPD.f
    , RangeError          = global.RangeError
    , TypeError           = global.TypeError
    , Uint8Array          = global.Uint8Array
    , ARRAY_BUFFER        = 'ArrayBuffer'
    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
    , PROTOTYPE           = 'prototype'
    , ArrayProto          = Array[PROTOTYPE]
    , $ArrayBuffer        = $buffer.ArrayBuffer
    , $DataView           = $buffer.DataView
    , arrayForEach        = createArrayMethod(0)
    , arrayFilter         = createArrayMethod(2)
    , arraySome           = createArrayMethod(3)
    , arrayEvery          = createArrayMethod(4)
    , arrayFind           = createArrayMethod(5)
    , arrayFindIndex      = createArrayMethod(6)
    , arrayIncludes       = createArrayIncludes(true)
    , arrayIndexOf        = createArrayIncludes(false)
    , arrayValues         = ArrayIterators.values
    , arrayKeys           = ArrayIterators.keys
    , arrayEntries        = ArrayIterators.entries
    , arrayLastIndexOf    = ArrayProto.lastIndexOf
    , arrayReduce         = ArrayProto.reduce
    , arrayReduceRight    = ArrayProto.reduceRight
    , arrayJoin           = ArrayProto.join
    , arraySort           = ArrayProto.sort
    , arraySlice          = ArrayProto.slice
    , arrayToString       = ArrayProto.toString
    , arrayToLocaleString = ArrayProto.toLocaleString
    , ITERATOR            = wks('iterator')
    , TAG                 = wks('toStringTag')
    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
    , DEF_CONSTRUCTOR     = uid('def_constructor')
    , ALL_CONSTRUCTORS    = $typed.CONSTR
    , TYPED_ARRAY         = $typed.TYPED
    , VIEW                = $typed.VIEW
    , WRONG_LENGTH        = 'Wrong length!';

  var $map = createArrayMethod(1, function(O, length){
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function(){
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
    new Uint8Array(1).set({});
  });

  var strictToLength = function(it, SAME){
    if(it === undefined)throw TypeError(WRONG_LENGTH);
    var number = +it
      , length = toLength(it);
    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
    return length;
  };

  var toOffset = function(it, BYTES){
    var offset = toInteger(it);
    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function(it){
    if(isObject(it) && TYPED_ARRAY in it)return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function(C, length){
    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function(O, list){
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function(C, list){
    var index  = 0
      , length = list.length
      , result = allocate(C, length);
    while(length > index)result[index] = list[index++];
    return result;
  };

  var addGetter = function(it, key, internal){
    dP(it, key, {get: function(){ return this._d[internal]; }});
  };

  var $from = function from(source /*, mapfn, thisArg */){
    var O       = toObject(source)
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , iterFn  = getIterFn(O)
      , i, length, values, result, step, iterator;
    if(iterFn != undefined && !isArrayIter(iterFn)){
      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
        values.push(step.value);
      } O = values;
    }
    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/*...items*/){
    var index  = 0
      , length = arguments.length
      , result = allocate(this, length);
    while(length > index)result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString(){
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /*, end */){
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /*, thisArg */){
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /*, thisArg */){
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /*, thisArg */){
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /*, thisArg */){
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /*, thisArg */){
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /*, fromIndex */){
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /*, fromIndex */){
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator){ // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /*, thisArg */){
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse(){
      var that   = this
        , length = validate(that).length
        , middle = Math.floor(length / 2)
        , index  = 0
        , value;
      while(index < middle){
        value         = that[index];
        that[index++] = that[--length];
        that[length]  = value;
      } return that;
    },
    some: function some(callbackfn /*, thisArg */){
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn){
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end){
      var O      = validate(this)
        , length = O.length
        , $begin = toIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end){
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /*, offset */){
    validate(this);
    var offset = toOffset(arguments[1], 1)
      , length = this.length
      , src    = toObject(arrayLike)
      , len    = toLength(src.length)
      , index  = 0;
    if(len + offset > length)throw RangeError(WRONG_LENGTH);
    while(index < len)this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries(){
      return arrayEntries.call(validate(this));
    },
    keys: function keys(){
      return arrayKeys.call(validate(this));
    },
    values: function values(){
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function(target, key){
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key){
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc){
    if(isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ){
      target[key] = desc.value;
      return target;
    } else return dP(target, key, desc);
  };

  if(!ALL_CONSTRUCTORS){
    $GOPD.f = $getDesc;
    $DP.f   = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty:           $setDesc
  });

  if(fails(function(){ arrayToString.call({}); })){
    arrayToString = arrayToLocaleString = function toString(){
      return arrayJoin.call(this);
    }
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice:          $slice,
    set:            $set,
    constructor:    function(){ /* noop */ },
    toString:       arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function(){ return this[TYPED_ARRAY]; }
  });

  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
    CLAMPED = !!CLAMPED;
    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
      , ISNT_UINT8 = NAME != 'Uint8Array'
      , GETTER     = 'get' + KEY
      , SETTER     = 'set' + KEY
      , TypedArray = global[NAME]
      , Base       = TypedArray || {}
      , TAC        = TypedArray && getPrototypeOf(TypedArray)
      , FORCED     = !TypedArray || !$typed.ABV
      , O          = {}
      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function(that, index){
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function(that, index, value){
      var data = that._d;
      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function(that, index){
      dP(that, index, {
        get: function(){
          return getter(this, index);
        },
        set: function(value){
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if(FORCED){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME, '_d');
        var index  = 0
          , offset = 0
          , buffer, byteLength, length, klass;
        if(!isObject(data)){
          length     = strictToLength(data, true)
          byteLength = length * BYTES;
          buffer     = new $ArrayBuffer(byteLength);
        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if($length === undefined){
            if($len % BYTES)throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if(TYPED_ARRAY in data){
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while(index < length)addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if(!$iterDetect(function(iter){
      // V8 works with iterators, but fails in many other cases
      // https://code.google.com/p/v8/issues/detail?id=4552
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
      , $iterator         = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
      dP(TypedArrayPrototype, TAG, {
        get: function(){ return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES,
      from: $from,
      of: $of
    });

    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

    $export($export.P + $export.F * fails(function(){
      new TypedArray(1).slice();
    }), NAME, {slice: $slice});

    $export($export.P + $export.F * (fails(function(){
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
    }) || !fails(function(){
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {toLocaleString: $toLocaleString});

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function(){ /* empty */ };

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nextTick_js__ = __webpack_require__(111);
/* unused harmony export IObject */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



var _rcKey = Symbol('ReferenceCountKey');

/**
 * Base class for all JS objects that are part of this framework.
 *
 * @class IObject
 */
var IObject = function () {
    _createClass(IObject, null, [{
        key: 'instance',

        /**
         * Utility function that returns an auto released instance of the class the method is called from.
         *
         * @method instance
         * @param {...*} varArgs - The arguments to be forwarded to the class' constructor.
         * @returns {*}
         */
        value: function instance() {
            for (var _len = arguments.length, varArgs = Array(_len), _key = 0; _key < _len; _key++) {
                varArgs[_key] = arguments[_key];
            }

            return new (Function.prototype.bind.apply(this, [null].concat(varArgs)))().autorelease();
        }

        /**
         * @constructor
         */

    }]);

    function IObject() {
        _classCallCheck(this, IObject);

        /* every object is allocated with a retain count of 1 */
        this[_rcKey] = 1;
    }

    /**
     * @method destroy
     */


    _createClass(IObject, [{
        key: 'destroy',
        value: function destroy() {
            this[_rcKey] = 0;
        }

        /**
         * The current retain count of this object.
         *
         * @type {Number}
         */

    }, {
        key: 'retain',


        /**
         * @method retain
         * @returns {*}
         */
        value: function retain() {
            if (this[_rcKey] <= 0) {
                throw new Error('IObject: Reference count under or equal to zero, are you trying to revive a zombie?');
            }
            ++this[_rcKey];
            return this;
        }

        /**
         * @method release
         * @returns {*}
         */

    }, {
        key: 'release',
        value: function release() {
            if (--this[_rcKey] === 0) {
                this.destroy();
            } else if (this[_rcKey] < 0) {
                throw new Error('IObject: Reference count under zero, are you retaining your object?');
            }
            return this;
        }

        /**
         * @method autorelease
         * @returns {*}
         */

    }, {
        key: 'autorelease',
        value: function autorelease() {
            var _this = this;

            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__nextTick_js__["a" /* default */])(function () {
                _this.release();
            });
            return this;
        }
    }, {
        key: 'retainCount',
        get: function get() {
            return this[_rcKey];
        }
    }]);

    return IObject;
}();

/* harmony default export */ __webpack_exports__["a"] = IObject;

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var Events = {
  GEOMETRY_VALUE_CHANGED: 'Geometry::ValueChanged'
};

/* harmony default export */ __webpack_exports__["a"] = Events;

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geometry_BoundingBox_js__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geometry_Size_js__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geometry_Matrix_js__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Events_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__geometry_Events_js__ = __webpack_require__(33);
/* unused harmony export Node */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */









var REDRAW_REASON = {
    REDRAW_EXTERNAL_REQUEST: Symbol('REDRAW_EXTERNAL_REQUEST'),
    REDRAW_CHILD_ADDED: Symbol('REDRAW_CHILD_ADDED'),
    REDRAW_CHILD_REMOVED: Symbol('REDRAW_CHILD_REMOVED'),
    REDRAW_TRANSFORMATION_CHANGE: Symbol('REDRAW_TRANSFORMATION_CHANGE'),
    REDRAW_CACHE_REFRESH: Symbol('REDRAW_CACHE_REFRESH')
};
Object.freeze(REDRAW_REASON);

var MATRIX_UPDATE_REASON = {
    MATRIX_UPDATE_UNDEFINED: null,
    MATRIX_UPDATE_POSITION: Symbol('MATRIX_UPDATE_POSITION'),
    MATRIX_UPDATE_SIZE: Symbol('MATRIX_UPDATE_SIZE'),
    MATRIX_UPDATE_SCALE: Symbol('MATRIX_UPDATE_SCALE'),
    MATRIX_UPDATE_ROTATION: Symbol('MATRIX_UPDATE_ROTATION'),
    MATRIX_UPDATE_ANCHOR: Symbol('MATRIX_UPDATE_ANCHOR'),
    MATRIX_UPDATE_PARENT_REQUEST: Symbol('MATRIX_UPDATE_PARENT_REQUEST')
};
Object.freeze(MATRIX_UPDATE_REASON);

/**
 * Base class for all drawable objects.
 *
 * @class Node
 */
var Node = function (_IBindable) {
    _inherits(Node, _IBindable);

    _createClass(Node, null, [{
        key: 'REDRAW_EXTERNAL_REQUEST',

        /**
         * Redrawing this node was requested by an external caller.
         * @type {Symbol}
         */
        get: function get() {
            return REDRAW_REASON.REDRAW_EXTERNAL_REQUEST;
        }

        /**
         * Redrawing this node is necessary because a child was added.
         * @type {Symbol}
         */

    }, {
        key: 'REDRAW_CHILD_ADDED',
        get: function get() {
            return REDRAW_REASON.REDRAW_CHILD_ADDED;
        }

        /**
         * Redrawing this node is necessary because a child was removed.
         * @type {Symbol}
         */

    }, {
        key: 'REDRAW_CHILD_REMOVED',
        get: function get() {
            return REDRAW_REASON.REDRAW_CHILD_REMOVED;
        }

        /**
         * Redrawing this node is necessary because the transformation matrix of this node changed.
         * @type {Symbol}
         */

    }, {
        key: 'REDRAW_TRANSFORMATION_CHANGE',
        get: function get() {
            return REDRAW_REASON.REDRAW_TRANSFORMATION_CHANGE;
        }

        /**
         * Redrawing this node is necessary because its internal cache has been updated.
         * @type {Symbol}
         */

    }, {
        key: 'REDRAW_CACHE_REFRESH',
        get: function get() {
            return REDRAW_REASON.REDRAW_CACHE_REFRESH;
        }

        /**
         * The reason why this node's matrix needs to be updated is unknown.
         * @type {null}
         */

    }, {
        key: 'MATRIX_UPDATE_UNDEFINED',
        get: function get() {
            return MATRIX_UPDATE_REASON.MATRIX_UPDATE_UNDEFINED;
        }

        /**
         * This node's matrix needs to be updated because its position changed.
         * @type {Symbol}
         */

    }, {
        key: 'MATRIX_UPDATE_POSITION',
        get: function get() {
            return MATRIX_UPDATE_REASON.MATRIX_UPDATE_POSITION;
        }

        /**
         * This node's matrix needs to be updated because its size changed.
         * @type {Symbol}
         */

    }, {
        key: 'MATRIX_UPDATE_SIZE',
        get: function get() {
            return MATRIX_UPDATE_REASON.MATRIX_UPDATE_SIZE;
        }

        /**
         * This node's matrix needs to be updated because its scale changed.
         * @type {Symbol}
         */

    }, {
        key: 'MATRIX_UPDATE_SCALE',
        get: function get() {
            return MATRIX_UPDATE_REASON.MATRIX_UPDATE_SCALE;
        }

        /**
         * This node's matrix needs to be updated because its rotation changed.
         * @type {Symbol}
         */

    }, {
        key: 'MATRIX_UPDATE_ROTATION',
        get: function get() {
            return MATRIX_UPDATE_REASON.MATRIX_UPDATE_ROTATION;
        }

        /**
         * This node's matrix needs to be updated because its anchor point changed.
         * @type {Symbol}
         */

    }, {
        key: 'MATRIX_UPDATE_ANCHOR',
        get: function get() {
            return MATRIX_UPDATE_REASON.MATRIX_UPDATE_ANCHOR;
        }

        /**
         * This node's matrix needs to be updated because its parent has updated its matrix and this node's matrix needs to
         * be recalculated if it uses percentages for its size or position.
         * @type {Symbol}
         */

    }, {
        key: 'MATRIX_UPDATE_PARENT_REQUEST',
        get: function get() {
            return MATRIX_UPDATE_REASON.MATRIX_UPDATE_PARENT_REQUEST;
        }

        /**
         * @param {Number|String=} width - The width of this node. Optional, defaults to 0.
         * @param {Number|String=} height - The height of this node. Optional, defaults to 0.
         * @constructor
         */

    }]);

    function Node() {
        var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        _classCallCheck(this, Node);

        var _this = _possibleConstructorReturn(this, (Node.__proto__ || Object.getPrototypeOf(Node)).call(this));

        _this.mRunning = false;
        _this.mChildren = [];
        _this.mParent = null;
        _this.mBoundingBox = new __WEBPACK_IMPORTED_MODULE_1__geometry_BoundingBox_js__["a" /* default */]();
        _this.mPosition = new __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */]();
        _this.mPixelPosition = new __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */]();
        _this.mSize = new __WEBPACK_IMPORTED_MODULE_3__geometry_Size_js__["a" /* default */]();
        _this.mPixelSize = new __WEBPACK_IMPORTED_MODULE_3__geometry_Size_js__["a" /* default */]();
        _this.mAnchor = new __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */]('50%', '50%');
        _this.mPixelAnchor = new __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */]();
        _this.mMatrix = new __WEBPACK_IMPORTED_MODULE_4__geometry_Matrix_js__["a" /* default */]();
        _this.mCachedMatrix = new __WEBPACK_IMPORTED_MODULE_4__geometry_Matrix_js__["a" /* default */]();
        _this.mRotation = 0;
        _this.mScale = 1;
        _this.mDeviceScale = 1;
        _this.mGlobalScale = 1;
        _this.mReviContext = null;
        _this.size.set(width, height);

        _this.mSize.on(__WEBPACK_IMPORTED_MODULE_6__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this.mSize.safeBind(_this._updateMatrix, _this, Node.MATRIX_UPDATE_SIZE));
        _this.mPosition.on(__WEBPACK_IMPORTED_MODULE_6__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this.mPosition.safeBind(_this._updateMatrix, _this, Node.MATRIX_UPDATE_POSITION));
        _this.mAnchor.on(__WEBPACK_IMPORTED_MODULE_6__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this.mAnchor.safeBind(_this._updateMatrix, _this, Node.MATRIX_UPDATE_ANCHOR));
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Node, [{
        key: 'destroy',
        value: function destroy() {
            if (this.mRunning) {
                this.onExit();
            }
            this.removeChildren();

            this.mSize.off(__WEBPACK_IMPORTED_MODULE_6__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this._updateMatrix, this);
            this.mPosition.off(__WEBPACK_IMPORTED_MODULE_6__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this._updateMatrix, this);
            this.mAnchor.off(__WEBPACK_IMPORTED_MODULE_6__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this._updateMatrix, this);

            this.mBoundingBox.release();
            this.mPosition.release();
            this.mSize.release();
            this.mAnchor.release();
            this.mMatrix.release();
            this.mCachedMatrix.release();

            delete this.mRunning;
            delete this.mChildren;
            delete this.mParent;
            delete this.mBoundingBox;
            delete this.mPosition;
            delete this.mPixelPosition;
            delete this.mSize;
            delete this.mPixelSize;
            delete this.mAnchor;
            delete this.mPixelAnchor;
            delete this.mMatrix;
            delete this.mCachedMatrix;
            delete this.mRotation;
            delete this.mDeviceScale;
            delete this.mScale;
            delete this.mGlobalScale;
            delete this.mReviContext;

            _get(Node.prototype.__proto__ || Object.getPrototypeOf(Node.prototype), 'destroy', this).call(this);
        }

        /**
         * Is this node currently added to the scene graph and running.
         *
         * @readonly
         * @type {Boolean}
         */

    }, {
        key: 'onEnter',


        /**
         * Called every time the object is added to the currently running scene graph.
         *
         * @method onEnter
         * @param {Symbol} reviContext - A unique symbol that identifies the rendering context of this object.
         */
        value: function onEnter(reviContext) {
            this.mReviContext = reviContext;
            this.mRunning = true;
            this.mChildren.forEach(function (child) {
                return child.onEnter(reviContext);
            });
        }

        /**
         * Called when this objects is removed from the scene graph.
         *
         * @method onExit
         */

    }, {
        key: 'onExit',
        value: function onExit() {
            this.mReviContext = null;
            this.mRunning = false;
            this.mChildren.forEach(function (child) {
                return child.onExit();
            });
        }

        /**
         * Called every tick, before this object is drawn.
         *
         * @method update
         * @param {Number} delta - The delta time since the last update.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when updating.
         */

    }, {
        key: 'update',
        value: function update(delta) {
            for (var _len = arguments.length, varArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                varArgs[_key - 1] = arguments[_key];
            }

            this.mChildren.forEach(function (child) {
                return child.update.apply(child, [delta].concat(varArgs));
            });
        }

        /**
         * Called every tick, drawing operations should be performed here.
         *
         * @method draw
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when drawing.
         */

    }, {
        key: 'draw',
        value: function draw(context) {
            for (var _len2 = arguments.length, varArgs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                varArgs[_key2 - 1] = arguments[_key2];
            }

            this.mChildren.forEach(function (child) {
                child._pushTransform(context);
                child.draw.apply(child, [context].concat(varArgs));
                child._popTransform(context);
            });
        }

        /**
         * Adds a child node to this object.
         *
         * @method addChild
         * @param {Node} child - The node to add as a child.
         * @returns {Node}
         */

    }, {
        key: 'addChild',
        value: function addChild(child) {
            return this.addChildAt(child, this.mChildren.length);
        }

        /**
         * Adds a new node as a children to this node at the specified position.
         *
         * @method addChildAt
         * @param {Node} child - The node to add as a child.
         * @param {Number} index - The index at which the node will be added.
         * @returns {Node}
         */

    }, {
        key: 'addChildAt',
        value: function addChildAt(child, index) {
            if (index >= 0 && index <= this.mChildren.length) {
                /* retain the child */
                child.retain();

                /* if the child node belongs to another parent, remove it from that parent */
                if (child.mParent) {
                    child.mParent.removeChild(child);
                }

                /* set the device scale of the child */
                child.deviceScale = this.mDeviceScale;

                /* set the global scale of the child */
                child.globalScale = this.mGlobalScale * this.mScale;

                /* set this node as the parent and add the child to the children array */
                child.mParent = this;
                this.mChildren.splice(index, 0, child);
            } else {
                throw new Error('addChildAt: The index (' + index + ') supplied is out of bounds.');
            }

            /* update the child's matrix, in case it uses percentages for size/position */
            child._updateMatrix(Node.MATRIX_UPDATE_PARENT_REQUEST);

            /* if this node is running, call `onEnter` on the child */
            if (this.mRunning) {
                child.onEnter(this.mReviContext);
            }

            /* start forwarding the child added/removed events */
            this.forward(child, [__WEBPACK_IMPORTED_MODULE_5__Events_js__["a" /* default */].GRAPHICS_NODE_CHILD_ADDED, __WEBPACK_IMPORTED_MODULE_5__Events_js__["a" /* default */].GRAPHICS_NODE_CHILD_REMOVED, __WEBPACK_IMPORTED_MODULE_5__Events_js__["a" /* default */].GRAPHICS_NODE_NEEDS_REDRAW]);

            /* emit the child added event */
            this.emit(__WEBPACK_IMPORTED_MODULE_5__Events_js__["a" /* default */].GRAPHICS_NODE_CHILD_ADDED, this, child);
            this._needsRedraw(Node.REDRAW_CHILD_ADDED);

            return child;
        }

        /**
         * Removes the specified node from this node's children list.
         *
         * @method removeChild
         * @param {Node} child - The node to remove.
         * @returns {Node}
         */

    }, {
        key: 'removeChild',
        value: function removeChild(child) {
            var index = this.mChildren.indexOf(child);
            if (index !== -1) {
                return this.removeChildAt(index);
            }
            return null;
        }

        /**
         * Removes the child node at the specified index.
         *
         * @method removeChildAt
         * @param {Number} index - The index of this child to remove.
         * @returns {Node}
         */

    }, {
        key: 'removeChildAt',
        value: function removeChildAt(index) {
            /* get the child to remove */
            var child = this._getChildAt(index);

            /* stop forwarding this child's events */
            this.unforward(child, [__WEBPACK_IMPORTED_MODULE_5__Events_js__["a" /* default */].GRAPHICS_NODE_CHILD_ADDED, __WEBPACK_IMPORTED_MODULE_5__Events_js__["a" /* default */].GRAPHICS_NODE_CHILD_REMOVED, __WEBPACK_IMPORTED_MODULE_5__Events_js__["a" /* default */].GRAPHICS_NODE_NEEDS_REDRAW]);

            /* if this node is running call `onExit` */
            if (this.mRunning) {
                child.onExit();
            }

            /* set the child's parent to null and remove from the children array */
            child.mParent = null;
            this.mChildren.splice(index, 1);

            /* emit the child removed event */
            this.emit(__WEBPACK_IMPORTED_MODULE_5__Events_js__["a" /* default */].GRAPHICS_NODE_CHILD_REMOVED, this, child);
            this._needsRedraw(Node.REDRAW_CHILD_REMOVED);

            /* release the child */
            return child.autorelease();
        }

        /**
         * Removes all the children of from this node.
         *
         * @method removeChildren
         */

    }, {
        key: 'removeChildren',
        value: function removeChildren() {
            while (this.mChildren.length) {
                this.removeChildAt(this.mChildren.length - 1);
            }
        }

        /**
         * Notifies the rendering system that this node needs to be redrawn to properly display its updated state.
         *
         * @method needsRedraw
         */

    }, {
        key: 'needsRedraw',
        value: function needsRedraw() {
            this._needsRedraw(Node.REDRAW_EXTERNAL_REQUEST);
        }

        /**
         * Safely makes all of this node's children perform the function with the specified method name. If the `recursive`
         * argument is set to `true` it makes invokes `makeChildrenPerform` in its children.
         *
         * @method makeChildrenPerform
         * @param {String} methodName - The name of the method to perform.
         * @param {Boolean} recursive - Should children make their children perform the specified method.
         * @param {...*} varArgs - Arguments to be forwarded when the method is performed.
         */

    }, {
        key: 'makeChildrenPerform',
        value: function makeChildrenPerform(methodName, recursive) {
            for (var _len3 = arguments.length, varArgs = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                varArgs[_key3 - 2] = arguments[_key3];
            }

            this.mChildren.forEach(function (child) {
                if (child[methodName] && typeof child[methodName] === 'function') {
                    child[methodName].apply(child, varArgs);
                }

                if (recursive && child.makeChildrenPerform && typeof child.makeChildrenPerform === 'function') {
                    child.makeChildrenPerform.apply(child, [methodName, recursive].concat(varArgs));
                }
            });
        }

        /**
         * Converts a point in global space to local space.
         *
         * @param {Point} point - The point to convert to local coordinates.
         * @return {Point}
         */

    }, {
        key: 'globalToLocalPoint',
        value: function globalToLocalPoint(point) {
            return this.globalToLocalCoords(point.x, point.y);
        }

        /**
         * Converts a set of coordinates in global space to local space.
         *
         * @param {Number} x - The x coordinate to convert to local coordinates.
         * @param {Number} y - The y coordinate to convert to local coordinates.
         * @return {Point}
         */

    }, {
        key: 'globalToLocalCoords',
        value: function globalToLocalCoords(x, y) {
            var point = __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */].instance(x, y);
            var matrix = new __WEBPACK_IMPORTED_MODULE_4__geometry_Matrix_js__["a" /* default */]();
            var nodes = [];
            var currentNode = this;
            while (currentNode) {
                nodes.push(currentNode);
                currentNode = currentNode.parent;
            }
            while (nodes.length) {
                matrix.multiply(nodes.pop().mMatrix);
            }
            matrix.applyToPointInverse(point);
            return point;
        }
    }, {
        key: 'localToGlobalPoint',
        value: function localToGlobalPoint(point) {
            return this.localToGlobalCoords(point.x, point.y);
        }
    }, {
        key: 'localToGlobalCoords',
        value: function localToGlobalCoords(x, y) {
            var point = __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */].instance(x, y);
            var matrix = new __WEBPACK_IMPORTED_MODULE_4__geometry_Matrix_js__["a" /* default */]();
            var nodes = [];
            var currentNode = this;
            while (currentNode) {
                nodes.push(currentNode);
                currentNode = currentNode.parent;
            }
            while (nodes.length) {
                matrix.multiply(nodes.pop().mMatrix);
            }
            matrix.applyToPoint(point);
            return point;
        }

        /**
         * Retrieves the child at the specified index.
         *
         * @method _getChildAt
         * @param {Number} index - The index of the children node to retrieve.
         * @returns {Node}
         * @private
         */

    }, {
        key: '_getChildAt',
        value: function _getChildAt(index) {
            if (index < 0 || index >= this.mChildren.length) {
                throw new Error('getChildAt: The index (' + index + ') supplied is out of bounds.');
            }
            return this.mChildren[index];
        }

        /**
         * Applies this node's transformations to the supplied context and saves its state.
         *
         * @method _pushTransform
         * @param {CanvasRenderingContext2D} context - The context to which the transformations should be applied.
         * @private
         */

    }, {
        key: '_pushTransform',
        value: function _pushTransform(context) {
            context.save();
            this.mMatrix.applyToContext(context);
        }

        /**
         * Removes the transformations applied by this object from the given context.
         *
         * @method _popTransform
         * @param {CanvasRenderingContext2D} context - The context to which the transformations were previously applied.
         * @private
         */

    }, {
        key: '_popTransform',
        value: function _popTransform(context) {
            context.restore();
        }

        /**
         * Updates the underlying affine matrix object.
         *
         * @method _updateMatrix
         * @param {Symbol|null} trigger - A symbol describing what triggered the update as described in the Node.MATRIX_UPDATE_* constants.
         * @private
         */

    }, {
        key: '_updateMatrix',
        value: function _updateMatrix() {
            var trigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            var x = this.mParent && this.mPosition.xUnits === __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */].UNIT_TYPE_PERCENTAGE ? this.mParent.pixelSize.width * this.mPosition.x : this.mPosition.x;
            var y = this.mParent && this.mPosition.yUnits === __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */].UNIT_TYPE_PERCENTAGE ? this.mParent.pixelSize.height * this.mPosition.y : this.mPosition.y;
            var width = this.mParent && this.mSize.xUnits === __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */].UNIT_TYPE_PERCENTAGE ? this.mParent.pixelSize.width * this.mSize.width : this.mSize.width;
            var height = this.mParent && this.mSize.yUnits === __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */].UNIT_TYPE_PERCENTAGE ? this.mParent.pixelSize.height * this.mSize.height : this.mSize.height;
            var xOff = this.mAnchor.xUnits === __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */].UNIT_TYPE_PERCENTAGE ? width * this.mAnchor.x : this.mAnchor.x;
            var yOff = this.mAnchor.yUnits === __WEBPACK_IMPORTED_MODULE_2__geometry_Point_js__["a" /* default */].UNIT_TYPE_PERCENTAGE ? height * this.mAnchor.y : this.mAnchor.y;

            this.mPixelAnchor.set(xOff, yOff);
            this.mPixelPosition.set(x, y);

            this.mMatrix.reset();
            this.mMatrix.translate(x, y);
            this.mMatrix.rotate(this.mRotation);
            this.mMatrix.scale(this.mScale, this.mScale);
            this.mMatrix.translate(-xOff, -yOff);

            if (width !== this.mPixelSize.width || height !== this.mPixelSize.height || !this.mMatrix.isEqual(this.mCachedMatrix)) {
                this.mPixelSize.set(width, height);
                this.mCachedMatrix.setFromMatrix(this.mMatrix);
                this.boundingBox.set(0, 0, width, height);
                this.mMatrix.applyToBoundingBox(this.boundingBox);
                this.makeChildrenPerform('_updateMatrix', false, null);
                this._needsRedraw(Node.REDRAW_TRANSFORMATION_CHANGE, trigger || Node.MATRIX_UPDATE_UNDEFINED);
            }
        }

        /**
         * If the node is running, triggers the event that requests for this object to be redrawn.
         *
         * @method _needsRedraw
         * @param {Symbol} reason - The reason why this node needs to be redrawn.
         * @param {...*} varArgs - Extra parameters that will be forwarded in the request to be drawn.
         * @private
         */

    }, {
        key: '_needsRedraw',
        value: function _needsRedraw(reason) {
            if (this.mRunning) {
                for (var _len4 = arguments.length, varArgs = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                    varArgs[_key4 - 1] = arguments[_key4];
                }

                /* this implementation ignores the reason and just requests redraw */
                this.emit.apply(this, [__WEBPACK_IMPORTED_MODULE_5__Events_js__["a" /* default */].GRAPHICS_NODE_NEEDS_REDRAW, this, reason].concat(varArgs));
            }
        }
    }, {
        key: 'running',
        get: function get() {
            return this.mRunning;
        }

        /**
         * This node's parent.
         *
         * @readonly
         * @type {Node|null}
         */

    }, {
        key: 'parent',
        get: function get() {
            return this.mParent;
        }

        /**
         * This node's boundingBox in non-scaled space.
         *
         * @readonly
         * @type {BoundingBox}
         */

    }, {
        key: 'boundingBox',
        get: function get() {
            return this.mBoundingBox;
        }

        /**
         * The position of this object.
         *
         * @readonly
         * @type {Point}
         */

    }, {
        key: 'position',
        get: function get() {
            return this.mPosition;
        }

        /**
         * The position, in pixels, of this object.
         *
         * @readonly
         * @type {Point}
         */

    }, {
        key: 'pixelPosition',
        get: function get() {
            return this.mPixelPosition;
        }

        /**
         * The anchor point of this object.
         *
         * @readonly
         * @type {Point}
         */

    }, {
        key: 'anchor',
        get: function get() {
            return this.mAnchor;
        }

        /**
         * The anchor point, in pixels, of this object.
         *
         * @readonly
         * @type {Point}
         */

    }, {
        key: 'pixelAnchor',
        get: function get() {
            return this.mPixelAnchor;
        }

        /**
         * The size of this object.
         *
         * @readonly
         * @type {Size}
         */

    }, {
        key: 'size',
        get: function get() {
            return this.mSize;
        }

        /**
         * The size, in pixels, of this object.
         *
         * @readonly
         * @type {Size}
         */

    }, {
        key: 'pixelSize',
        get: function get() {
            return this.mPixelSize;
        }

        /**
         * The revi context this node belongs to, or null if no context is available.
         *
         * @readonly
         * @type {Symbol|null}
         */

    }, {
        key: 'reviContext',
        get: function get() {
            return this.mReviContext;
        }

        /**
         * The rotation of this node.
         *
         * @type {Number}
         */

    }, {
        key: 'rotation',
        get: function get() {
            return this.mRotation;
        }

        /**
         * The rotation of this node.
         *
         * @param {Number} value - The new value.
         */
        ,
        set: function set(value) {
            this.mRotation = value;
            this._updateMatrix(Node.MATRIX_UPDATE_ROTATION);
        }

        /**
         * The scale of this node.
         *
         * @type {Number}
         */

    }, {
        key: 'scale',
        get: function get() {
            return this.mScale;
        }

        /**
         * The scale of this node.
         *
         * @param {Number} value - The new value.
         */
        ,
        set: function set(value) {
            this.mScale = value;
            this._updateMatrix(Node.MATRIX_UPDATE_SCALE);
        }

        /**
         * The device scale used to render this node's internal buffer.
         *
         * @type {Number}
         */

    }, {
        key: 'deviceScale',
        get: function get() {
            return this.mDeviceScale;
        }

        /**
         * Sets the device scale used to render this node's internal buffer.
         *
         * @param {Number} value - The new device scale.
         */
        ,
        set: function set(value) {
            var _this2 = this;

            this.mDeviceScale = value;
            this.mChildren.forEach(function (child) {
                child.deviceScale = _this2.mDeviceScale;
            });
        }

        /**
         * The global scale of this node.
         *
         * @type {Number}
         */

    }, {
        key: 'globalScale',
        get: function get() {
            return this.mGlobalScale;
        }

        /**
         * Sets the global scale of this node and its children. Usually this property should not be set manually.
         *
         * @param {Number} value - the new global scale of the node.
         */
        ,
        set: function set(value) {
            var _this3 = this;

            this.mGlobalScale = value;
            this.mChildren.forEach(function (child) {
                child.globalScale = _this3.mGlobalScale * _this3.mScale;
            });
        }
    }]);

    return Node;
}(__WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Node;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(46)('meta')
  , isObject = __webpack_require__(4)
  , has      = __webpack_require__(12)
  , setDesc  = __webpack_require__(7).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(3)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 37 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(1)
  , dPs         = __webpack_require__(136)
  , enumBugKeys = __webpack_require__(82)
  , IE_PROTO    = __webpack_require__(94)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(81)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(84).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(138)
  , hiddenKeys = __webpack_require__(82).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(138)
  , enumBugKeys = __webpack_require__(82);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(16);
module.exports = function(target, src, safe){
  for(var key in src)redefine(target, key, src[key], safe);
  return target;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global      = __webpack_require__(2)
  , dP          = __webpack_require__(7)
  , DESCRIPTORS = __webpack_require__(6)
  , SPECIES     = __webpack_require__(5)('species');

module.exports = function(KEY){
  var C = global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(37)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 46 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__IObject_js__ = __webpack_require__(32);
/* unused harmony export IBindable */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



var _sourceFunctionKey = Symbol('SourceFunctionKey');
var _sourceOwnerKey = Symbol('SourceOwnerKey');

/**
 * Base interface class for objects that wish to emit events.
 *
 * @class IBindable
 */
var IBindable = function (_IObject) {
    _inherits(IBindable, _IObject);

    /**
     * @constructor IBindable
     */
    function IBindable() {
        _classCallCheck(this, IBindable);

        var _this = _possibleConstructorReturn(this, (IBindable.__proto__ || Object.getPrototypeOf(IBindable)).call(this));

        _this.mHandlers = {};
        _this.mOmniHandlers = [];
        _this.mBoundForwardEvent = _this._forwardEvent.bind(_this);
        return _this;
    }

    /**
     * Unbinds all events bound to this IBindable instance.
     *
     * @method destroy
     */


    _createClass(IBindable, [{
        key: 'destroy',
        value: function destroy() {
            var _this2 = this;

            Object.keys(this.mHandlers).forEach(function (key) {
                delete _this2.mHandlers[key];
            });
            this.mOmniHandlers.length = 0;

            delete this.mHandlers;
            delete this.mOmniHandlers;
            delete this.mBoundForwardEvent;

            _get(IBindable.prototype.__proto__ || Object.getPrototypeOf(IBindable.prototype), 'destroy', this).call(this);
        }

        /**
         * Binds a list of events to the specified callback.
         *
         * @method on
         * @param {String|Array|null} events - A space-separated list or an Array of events to listen for. If null is passed, the callback will be invoked for all events.
         * @param {Function} callback - The callback to invoke when the event is triggered. If this callback returns true, event bubbling stops.
         */

    }, {
        key: 'on',
        value: function on(events, callback) {
            var _this3 = this;

            if (events === null) {
                if (this.mOmniHandlers.indexOf(callback) < 0) {
                    this.mOmniHandlers.push(callback);
                }
            } else {
                var eventArray = events instanceof Array ? events : events.split(' ');
                eventArray.forEach(function (event) {
                    var handlers = _this3.mHandlers[event];
                    if (!handlers) {
                        handlers = [];
                        _this3.mHandlers[event] = handlers;
                    }
                    if (handlers.indexOf(callback) < 0) {
                        handlers.push(callback);
                    }
                });
            }
        }

        /**
         * Unbinds the specified callback from the specified event. If no callback is specified, all callbacks for the specified event are removed.
         *
         * @method off
         * @param {String|Array|null=} events - A space-separated list or an Array of events to listen for. If null is passed the callback will be removed from the all-event handler list.
         * @param {Function=} callback - The callback to remove from the event or nothing to completely clear the event callbacks.
         * @param {*} owner - The owner of the callback, needed when unregistering callbacks created with `safeBind`.
         */

    }, {
        key: 'off',
        value: function off() {
            var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            var _this4 = this;

            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var owner = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            if (events === null) {
                if (!callback) {
                    this.mOmniHandlers.length = 0;
                } else {
                    var index = this.mOmniHandlers.indexOf(callback);
                    if (index >= 0) {
                        this.mOmniHandlers.splice(index, 1);
                    }
                }
            } else {
                var eventArray = events instanceof Array ? events : events.split(' ');
                eventArray.forEach(function (event) {
                    var handlers = _this4.mHandlers[event];
                    if (handlers) {
                        if (!callback) {
                            delete _this4.mHandlers[event];
                        } else {
                            for (var i = 0, n = handlers.length; i < n; ++i) {
                                if (callback === handlers[i] || callback === handlers[i][_sourceFunctionKey] && owner === handlers[i][_sourceOwnerKey]) {
                                    handlers.splice(i, 1);
                                    break;
                                }
                            }
                        }
                    }
                });
            }
        }

        /**
         * Emits the specified event and forwards all passed parameters.
         *
         * @method emit
         * @param {String} event - The name of the event to emit.
         * @param {...*} varArgs - Arguments to forward to the event listener callbacks.
         */

    }, {
        key: 'emit',
        value: function emit(event) {
            for (var _len = arguments.length, varArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                varArgs[_key - 1] = arguments[_key];
            }

            var handlers = this.mHandlers[event];
            if (handlers || this.mOmniHandlers.length > 0) {
                if (handlers) {
                    for (var i = 0, n = handlers.length; i < n; ++i) {
                        if (handlers[i].apply(handlers, varArgs) === true) {
                            break;
                        }
                    }
                }

                var omniHandlers = this.mOmniHandlers;
                for (var _i = 0, _n = omniHandlers.length; _i < _n; ++_i) {
                    if (omniHandlers[_i].apply(omniHandlers, arguments) === true) {
                        break;
                    }
                }
            }
        }

        /**
         * Forwards the specified events triggered by the given `bindable` as if this object was emitting them. If no events
         * are passed, all events are forwarded.
         *
         * @method forward
         * @param {IBindable} bindable - The `IBindable` instance for which all events will be forwarded through this instance.
         * @param {String|Array|null=} events - A space-separated list of events to forward or null to forward all the events.
         */

    }, {
        key: 'forward',
        value: function forward(bindable) {
            var _this5 = this;

            var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (events === null) {
                bindable.on(null, this.mBoundForwardEvent);
            } else {
                var eventArray = events instanceof Array ? events : events.split(' ');
                eventArray.forEach(function (event) {
                    bindable.on(event, _this5.safeBind(_this5._forwardEvent, _this5, event));
                });
            }
        }

        /**
         * Stops forwarding the events of the specified `bindable`
         *
         * @method unforward
         * @param {IBindable} bindable - The `IBindable` instance to stop forwarding.
         * @param {String|Array|null=} events - A space-separated list of events to stop forwarding or null to stop forwarding all the events.
         */

    }, {
        key: 'unforward',
        value: function unforward(bindable) {
            var _this6 = this;

            var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (events === null) {
                bindable.off(null, this.mBoundForwardEvent);
            } else {
                var eventArray = events instanceof Array ? events : events.split(' ');
                eventArray.forEach(function (event) {
                    bindable.off(event, _this6._forwardEvent, _this6);
                });
            }
        }

        /**
         * Binds a function so it is safe to unregister it using the `off` method with only the original function as the second argument.
         *
         * @method safeBind
         * @param {Function} func - The function to bind.
         * @param {*} owner - The owner of this function.
         * @param {...*} varArgs - The arguments used to bind this function.
         * @returns {Function}
         */

    }, {
        key: 'safeBind',
        value: function safeBind(func, owner) {
            for (var _len2 = arguments.length, varArgs = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                varArgs[_key2 - 2] = arguments[_key2];
            }

            var boundFunction = func.bind.apply(func, [owner].concat(varArgs));
            boundFunction[_sourceFunctionKey] = func;
            boundFunction[_sourceOwnerKey] = owner;
            return boundFunction;
        }

        /**
         * Internal method used to forward the events from other `IBindable` instances.
         *
         * @method _forwardEvent
         * @param {String} event - The name of the event to emit.
         * @param {...*} varArgs - Arguments to forward to the event listener callbacks.
         * @private
         */

    }, {
        key: '_forwardEvent',
        value: function _forwardEvent() /* event */ /* varArgs */{
            this.emit.apply(this, arguments);
        }
    }]);

    return IBindable;
}(__WEBPACK_IMPORTED_MODULE_0__IObject_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = IBindable;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(5)('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(15)(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var ctx         = __webpack_require__(29)
  , call        = __webpack_require__(132)
  , isArrayIter = __webpack_require__(86)
  , anObject    = __webpack_require__(1)
  , toLength    = __webpack_require__(9)
  , getIterFn   = __webpack_require__(103)
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(7).f
  , has = __webpack_require__(12)
  , TAG = __webpack_require__(5)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
  , defined = __webpack_require__(22)
  , fails   = __webpack_require__(3)
  , spaces  = __webpack_require__(99)
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Node_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Events_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__ = __webpack_require__(33);
/* unused harmony export Canvas */
var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */





var CANVAS_MAP = new Map();

/**
 * Class that wraps the HTML canvas into so it behaves as a Node.
 *
 * @class Canvas
 */
var Canvas = function (_Node) {
    _inherits(Canvas, _Node);

    _createClass(Canvas, null, [{
        key: 'getCanvasForContext',

        /**
         * Gets the canvas registered for the given revi context. If no canvas is registered for the context, this method returns null.
         *
         * @method getCanvasForContext
         * @param {Symbol} reviContext - The context for which its canvas will be retrieved.
         * @returns {Canvas}
         * @static
         */
        value: function getCanvasForContext(reviContext) {
            if (CANVAS_MAP.has(reviContext)) {
                return CANVAS_MAP.get(reviContext);
            }
            return null;
        }

        /**
         * @constructor
         * @param {HTMLElement} element - A canvas element or an element in which a new canvas will be created.
         * @param {Number=} initialPixelDensity - The initial pixel density of this canvas, this value can be overridden by the minPixelDensity.
         * @param {Number=} minPixelDensity - The minimum pixel density that elements will be rendered at.
         */

    }]);

    function Canvas(element) {
        var initialPixelDensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var minPixelDensity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        _classCallCheck(this, Canvas);

        var _this = _possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).call(this));

        _this.mElement = element;
        _this.mAnimationID = null;
        _this.mReviContext = Symbol('REVI_CONTEXT');
        _this.mMinPixelDensity = minPixelDensity;
        _this.mIdle = true;

        _this.mLastTimestamp = 0;

        if (element instanceof HTMLCanvasElement) {
            _this.mCanvas = element;
            _this.mOwnsCanvas = false;
        } else {
            _this.mCanvas = document.createElement('canvas');
            _this.mCanvas.style.width = '100%';
            _this.mCanvas.style.height = '100%';
            element.appendChild(_this.mCanvas);
            _this.mOwnsCanvas = true;
        }

        _this.anchor.set(0, 0);
        _this.size.set(_this.mCanvas.scrollWidth, _this.mCanvas.scrollHeight);
        _this.deviceScale = Math.max(initialPixelDensity || window.devicePixelRatio || 1, _this.mMinPixelDensity);
        _this.mCanvas.width = _this.size.width * _this.deviceScale * _this.globalScale;
        _this.mCanvas.height = _this.size.height * _this.deviceScale * _this.globalScale;
        _this.mBoundTick = _this._tick.bind(_this);
        _this.mContext = _this.mCanvas.getContext('2d');

        /* register a listener for changes in the devicePixelRatio */
        _this.mMediaQuery = window.matchMedia('screen and (min-resolution: 2dppx)');
        _this.mPixelRatioChanged = function () {
            _this.deviceScale = Math.max(window.devicePixelRatio || 1, _this.mMinPixelDensity); // eslint-disable-line no-warning-comments // TODO: Add a way for users to control the pixel density + device scale.
        };
        _this.mMediaQuery.addListener(_this.mPixelRatioChanged);

        /* register this canvas and its context */
        CANVAS_MAP.set(_this.mReviContext, _this);

        _this.size.on(__WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this.size.safeBind(_this._handleSizeChanged, _this));
        _this.onEnter(_this.mReviContext);
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Canvas, [{
        key: 'destroy',
        value: function destroy() {
            if (this.running) {
                this.onExit();
            }

            if (this.mOwnsCanvas) {
                this.mElement.removeChild(this.mCanvas);
            }

            CANVAS_MAP.delete(this.mReviContext);

            this.size.off(__WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this._handleSizeChanged, this);
            this.mMediaQuery.removeListener(this.mPixelRatioChanged);

            delete this.mElement;
            delete this.mAnimationID;
            delete this.mMinPixelDensity;
            delete this.mIdle;
            delete this.mCanvas;
            delete this.mOwnsCanvas;
            delete this.mContext;
            delete this.mBoundTick;
            delete this.mMediaQuery;
            delete this.mPixelRatioChanged;

            _get(Canvas.prototype.__proto__ || Object.getPrototypeOf(Canvas.prototype), 'destroy', this).call(this);
        }

        /**
         * The device scale used to render this node's internal buffer.
         *
         * @type {Number}
         */

    }, {
        key: 'onEnter',


        /**
         * Called every time the object is added to the currently running scene graph.
         *
         * @method onEnter
         * @param {Symbol} reviContext - A unique symbol that identifies the rendering context of this object.
         */
        value: function onEnter(reviContext) {
            this.on(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GRAPHICS_NODE_NEEDS_REDRAW, this.safeBind(this.needsRedraw, this));
            _get(Canvas.prototype.__proto__ || Object.getPrototypeOf(Canvas.prototype), 'onEnter', this).call(this, reviContext);
        }

        /**
         * Called when this objects is removed from the scene graph.
         *
         * @method onExit
         */

    }, {
        key: 'onExit',
        value: function onExit() {
            if (this.mAnimationID !== null) {
                cancelAnimationFrame(this.mAnimationID);
                this.mAnimationID = null;
            }
            this.off(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GRAPHICS_NODE_NEEDS_REDRAW, this.needsRedraw, this);
            _get(Canvas.prototype.__proto__ || Object.getPrototypeOf(Canvas.prototype), 'onExit', this).call(this);
        }

        /**
         * Overrides the super method and schedules a tick of the canvas (which implies an update and a redraw)
         *
         * @method needsRedraw
         */

    }, {
        key: 'needsRedraw',
        value: function needsRedraw() {
            if (this.running && this.mAnimationID === null) {
                this.mAnimationID = requestAnimationFrame(this.mBoundTick);
                this._setIdle(false);
            }
        }

        /**
         * Triggers a global scale update.
         *
         * @method updateGlobalScale
         */

    }, {
        key: 'updateGlobalScale',
        value: function updateGlobalScale() {
            this.globalScale = this.mScale;
        }

        /**
         * Function called every time the browser is ready to draw a new frame.
         *
         * @method _tick
         * @param {Number} timestamp - The time stamp of this function call.
         * @private
         */

    }, {
        key: '_tick',
        value: function _tick(timestamp) {
            var delta = Math.max(Math.min(timestamp - this.mLastTimestamp, 33.333), 1);
            this.mLastTimestamp = timestamp;
            if (this.running) {
                this.mAnimationID = null;
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GRAPHICS_CANVAS_PRE_UPDATE, this, delta);
                this.update(delta);
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GRAPHICS_CANVAS_POST_UPDATE, this, delta);
                this.mContext.setTransform(1, 0, 0, 1, 0, 0);
                this.mContext.clearRect(0, 0, this.mCanvas.width, this.mCanvas.height);
                this.mContext.scale(this.deviceScale, this.deviceScale);
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GRAPHICS_CANVAS_PRE_DRAW, this, this.mContext);
                this.draw(this.mContext);
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GRAPHICS_CANVAS_POST_DRAW, this, this.mContext);
                this._setIdle(this.mAnimationID === null);
            }
        }

        /**
         * When this node's size is modified, this method is called and also changes the size of the internal buffer.
         *
         * @method _handleSizeChanged
         * @param {*} sender - The instance that originally triggered this event.
         * @param {Number} width - The new width of this node.
         * @param {Number} height - The new height of this node.
         * @private
         */

    }, {
        key: '_handleSizeChanged',
        value: function _handleSizeChanged(sender, width, height) {
            if (sender === this.size) {
                this.mCanvas.width = width * this.deviceScale * this.globalScale;
                this.mCanvas.height = height * this.deviceScale * this.globalScale;
                if (this.running) {
                    this.needsRedraw();
                }
            }
        }

        /**
         * Sets the idle state of this canvas, used to know when a canvas is actively being redrawn.
         *
         * @method _setIdle
         * @param {Boolean} idle - The new idle state of this canvas.
         * @private
         */

    }, {
        key: '_setIdle',
        value: function _setIdle(idle) {
            if (idle !== this.mIdle) {
                if (this.mIdle) {
                    this.mLastTimestamp = performance.now();
                }
                this.mIdle = idle;
                this.emit(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GRAPHICS_CANVAS_IDLE_STATE_CHANGED, this, this.mIdle);
            }
        }
    }, {
        key: 'deviceScale',
        get: function get() {
            return _get(Canvas.prototype.__proto__ || Object.getPrototypeOf(Canvas.prototype), 'deviceScale', this);
        }

        /**
         * Sets the device scale used to render this node's internal buffer.
         *
         * @param {Number} value - The new device scale.
         */
        ,
        set: function set(value) {
            var newValue = Math.max(value, this.mMinPixelDensity);
            if (newValue !== this.deviceScale) {
                _set(Canvas.prototype.__proto__ || Object.getPrototypeOf(Canvas.prototype), 'deviceScale', newValue, this);
                this.size.emit(__WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this.size, this.size.width, this.size.height);
                this.updateGlobalScale();
                this.needsRedraw();
            } else {
                _set(Canvas.prototype.__proto__ || Object.getPrototypeOf(Canvas.prototype), 'deviceScale', newValue, this);
            }
        }

        /**
         * Is this canvas drawing in an idle state.
         *
         * @type {Boolean}
         */

    }, {
        key: 'idle',
        get: function get() {
            return this.mIdle;
        }
    }]);

    return Canvas;
}(__WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Canvas;

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var Events = {
  GRAPHICS_NODE_CHILD_ADDED: 'Graphics::Node::ChildAdded',
  GRAPHICS_NODE_CHILD_REMOVED: 'Graphics::Node::ChildRemoved',
  GRAPHICS_NODE_NEEDS_REDRAW: 'Graphics::Node::NeedsRedraw',

  GRAPHICS_CANVAS_PRE_UPDATE: 'Graphics::Canvas::PreUpdate',
  GRAPHICS_CANVAS_POST_UPDATE: 'Graphics::Canvas::PostUpdate',
  GRAPHICS_CANVAS_PRE_DRAW: 'Graphics::Canvas::PreDraw',
  GRAPHICS_CANVAS_POST_DRAW: 'Graphics::Canvas::PostDraw',
  GRAPHICS_CANVAS_IDLE_STATE_CHANGED: 'Graphics::Canvas::IdleState::Changed'
};

/* harmony default export */ __webpack_exports__["a"] = Events;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(21)
  , TAG = __webpack_require__(5)('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(21);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 57 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Geometric objects



var bbox = __webpack_require__(150);

/**
 * A bézier path containing a set of path commands similar to a SVG path.
 * Paths can be drawn on a context using `draw`.
 * @exports opentype.Path
 * @class
 * @constructor
 */
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

/**
 * @param  {number} x
 * @param  {number} y
 */
Path.prototype.moveTo = function(x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};

/**
 * @param  {number} x
 * @param  {number} y
 */
Path.prototype.lineTo = function(x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};

/**
 * Draws cubic curve
 * @function
 * curveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws cubic curve
 * @function
 * bezierCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 * @see curveTo
 */
Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};

/**
 * Draws quadratic curve
 * @function
 * quadraticCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws quadratic curve
 * @function
 * quadTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */
Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};

/**
 * Closes the path
 * @function closePath
 * @memberof opentype.Path.prototype
 */

/**
 * Close the path
 * @function close
 * @memberof opentype.Path.prototype
 */
Path.prototype.close = Path.prototype.closePath = function() {
    this.commands.push({
        type: 'Z'
    });
};

/**
 * Add the given path or list of commands to the commands of this path.
 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
 */
Path.prototype.extend = function(pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    } else if (pathOrCommands instanceof bbox.BoundingBox) {
        var box = pathOrCommands;
        this.moveTo(box.x1, box.y1);
        this.lineTo(box.x2, box.y1);
        this.lineTo(box.x2, box.y2);
        this.lineTo(box.x1, box.y2);
        this.close();
        return;
    }

    Array.prototype.push.apply(this.commands, pathOrCommands);
};

/**
 * Calculate the bounding box of the path.
 * @returns {opentype.BoundingBox}
 */
Path.prototype.getBoundingBox = function() {
    var box = new bbox.BoundingBox();

    var startX = 0;
    var startY = 0;
    var prevX = 0;
    var prevY = 0;
    for (var i = 0; i < this.commands.length; i++) {
        var cmd = this.commands[i];
        switch (cmd.type) {
            case 'M':
                box.addPoint(cmd.x, cmd.y);
                startX = prevX = cmd.x;
                startY = prevY = cmd.y;
                break;
            case 'L':
                box.addPoint(cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Q':
                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'C':
                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Z':
                prevX = startX;
                prevY = startY;
                break;
            default:
                throw new Error('Unexpected path commmand ' + cmd.type);
        }
    }
    if (box.isEmpty()) {
        box.addPoint(0, 0);
    }
    return box;
};

/**
 * Draw the path to a 2D context.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
 */
Path.prototype.draw = function(ctx) {
    ctx.beginPath();
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }

    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }

    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

/**
 * Convert the Path to a string of path data instructions
 * See http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toPathData = function(decimalPlaces) {
    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }

    function packValues() {
        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }

            s += floatToString(v);
        }

        return s;
    }

    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }

    return d;
};

/**
 * Convert the path to an SVG <path> element, as a string.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toSVG = function(decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill && this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }

    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }

    svg += '/>';
    return svg;
};

Path.prototype.toDOMElement = function(decimalPlaces) {
    var temporaryPath = this.toPathData(decimalPlaces);
    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    newPath.setAttribute('d', temporaryPath);

    return newPath;
};

exports.Path = Path;


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Point_js__ = __webpack_require__(27);
/* unused harmony export Size */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/**
 * Utility class that represents the size of 2D objects.
 *
 * @class Size
 */
var Size = function (_Point) {
  _inherits(Size, _Point);

  /**
   * @constructor Size
   * @param {Number=} width - The width of this `size` object.
   * @param {Number=} height - The height of this `size` object.
   */
  function Size(width, height) {
    _classCallCheck(this, Size);

    return _possibleConstructorReturn(this, (Size.__proto__ || Object.getPrototypeOf(Size)).call(this, width, height));
  }

  /**
   * Gets the width of this `size` object.
   *
   * @type {Number}
   */


  _createClass(Size, [{
    key: 'width',
    get: function get() {
      return this.x;
    }

    /**
     * Sets the width of this `size` object.
     *
     * @param {Number} value - The new value of the property.
     */
    ,
    set: function set(value) {
      this.x = value;
    }

    /**
     * Gets the height of this `size` object.
     *
     * @type {Number}
     */

  }, {
    key: 'height',
    get: function get() {
      return this.y;
    }

    /**
     * Sets the height of this `size` object.
     *
     * @param {Number} value - The new value of the property.
     */
    ,
    set: function set(value) {
      this.y = value;
    }
  }]);

  return Size;
}(__WEBPACK_IMPORTED_MODULE_0__Point_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Size;

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Node_js__ = __webpack_require__(34);
/* unused harmony export Primitive */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/**
 * Stroke rendering types.
 *
 * @type {{STROKE_NONE: null, STROKE_MIDDLE: Symbol, STROKE_INNER: Symbol, STROKE_OUTER: Symbol}}
 */
var STROKE_TYPES = {
    STROKE_NONE: null,
    STROKE_MIDDLE: Symbol('STROKE_MIDDLE'),
    STROKE_INNER: Symbol('STROKE_INNER'),
    STROKE_OUTER: Symbol('STROKE_OUTER')
};

var LINE_CAP_TYPES = {
    LINE_CAP_BUTT: 'butt',
    LINE_CAP_ROUND: 'round',
    LINE_CAP_SQUARE: 'square'
};

/**
 * Default options for rendering a primitive shape.
 *
 * @type {Object}
 */
var primitiveDefaultOptions = {
    fillEnabled: true,
    fillColor: '#000000',
    stroke: 1,
    strokeColor: '#000000',
    strokeType: STROKE_TYPES.STROKE_NONE,
    lineCapType: LINE_CAP_TYPES.LINE_CAP_BUTT,
    closePath: false
};

/**
 * Base class for all primitive shapes.
 *
 * @class Primitive
 */
var Primitive = function (_Node) {
    _inherits(Primitive, _Node);

    _createClass(Primitive, null, [{
        key: 'defaultOptions',

        /**
         * Returns a copy of the default rendering options. Modifying this object has no effect.
         *
         * @returns {Object}
         */
        get: function get() {
            return Object.assign({}, primitiveDefaultOptions);
        }

        /**
         * The internal type used to not render a stroke.
         *
         * @type {null}
         */

    }, {
        key: 'STROKE_NONE',
        get: function get() {
            return STROKE_TYPES.STROKE_NONE;
        }

        /**
         * The internal type used to render the stroke at the mid point of the edge.
         *
         * @type {Symbol}
         */

    }, {
        key: 'STROKE_MIDDLE',
        get: function get() {
            return STROKE_TYPES.STROKE_MIDDLE;
        }

        /**
         * The internal type used to render the stroke from the edge of the shape inwards.
         *
         * @type {Symbol}
         */

    }, {
        key: 'STROKE_INNER',
        get: function get() {
            return STROKE_TYPES.STROKE_INNER;
        }

        /**
         * The internal type used to render the stroke from the edge of the shape outwards.
         *
         * @type {Symbol}
         */

    }, {
        key: 'STROKE_OUTER',
        get: function get() {
            return STROKE_TYPES.STROKE_OUTER;
        }

        /**
         * The internal type used to render flat edge line caps.
         *
         * @type {String}
         */

    }, {
        key: 'LINE_CAP_BUTT',
        get: function get() {
            return LINE_CAP_TYPES.LINE_CAP_BUTT;
        }

        /**
         * The internal type used to render rounded line caps.
         * Note: This line cap type makes the lines slightly longer.
         *
         * @type {String}
         */

    }, {
        key: 'LINE_CAP_ROUND',
        get: function get() {
            return LINE_CAP_TYPES.LINE_CAP_ROUND;
        }

        /**
         * The internal type used to render squared line caps.
         * Note: This line cap type makes the lines slightly longer.
         *
         * @type {String}
         */

    }, {
        key: 'LINE_CAP_SQUARE',
        get: function get() {
            return LINE_CAP_TYPES.LINE_CAP_SQUARE;
        }

        /**
         * @param {Object} options - The rendering options of this primitive shape.
         * @constructor
         */

    }]);

    function Primitive() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _classCallCheck(this, Primitive);

        var _this = _possibleConstructorReturn(this, (Primitive.__proto__ || Object.getPrototypeOf(Primitive)).call(this));

        _this.mOptions = Object.assign({}, primitiveDefaultOptions, options);
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Primitive, [{
        key: 'destroy',
        value: function destroy() {
            delete this.mOptions;
            _get(Primitive.prototype.__proto__ || Object.getPrototypeOf(Primitive.prototype), 'destroy', this).call(this);
        }

        /**
         * Is the fill of this shape enabled.
         *
         * @type {Boolean}
         */

    }, {
        key: 'draw',


        /**
         * Called every tick, drawing operations should be performed here.
         *
         * @method draw
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when drawing.
         */
        value: function draw(context) {
            var _get2;

            this._renderPath(context, this.mOptions);
            this._applyRenderOptions(context, this.mOptions);

            for (var _len = arguments.length, varArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                varArgs[_key - 1] = arguments[_key];
            }

            (_get2 = _get(Primitive.prototype.__proto__ || Object.getPrototypeOf(Primitive.prototype), 'draw', this)).call.apply(_get2, [this, context].concat(varArgs));
        }

        /**
         * Renders the path of this shape to the context.
         * NOTE: This method must be overridden in Primitive subclasses.
         *
         * @method _renderPath
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {Object} options - The rendering options for this shape.
         * @private
         */

    }, {
        key: '_renderPath',
        value: function _renderPath() /* context, options */{
            throw new Error('_renderPath must be overridden in subclasses. Cannot render Primitive directly to context.');
        }

        /**
         * Applies the fill, stroke, etc. as described in the provided `options` object.
         *
         * @method _applyRenderOptions
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {Object} options - The rendering options for this shape.
         * @private
         */

    }, {
        key: '_applyRenderOptions',
        value: function _applyRenderOptions(context, options) {
            if (options.fillEnabled) {
                context.fillStyle = options.fillColor;
                context.fill();
            }

            if (options.strokeType && options.stroke > 0) {
                context.lineCap = options.lineCapType;
                context.strokeStyle = options.strokeColor;
                context.lineWidth = options.stroke;
                context.stroke();
            }
        }
    }, {
        key: 'fillEnabled',
        get: function get() {
            return this.mOptions.fillEnabled;
        }

        /**
         * Sets whether the fill of this shape is enabled or not.
         *
         * @param {Boolean} value - The new value
         */
        ,
        set: function set(value) {
            if (value !== this.mOptions.fillEnabled) {
                this.mOptions.fillEnabled = value;
                this.needsRedraw();
            }
        }

        /**
         * The fill color of this shape.
         *
         * @type {String}
         */

    }, {
        key: 'fillColor',
        get: function get() {
            return this.mOptions.fillColor;
        }

        /**
         * Sets the fill color of this shape.
         *
         * @param {String} value - The new fill color.
         */
        ,
        set: function set(value) {
            if (value !== this.mOptions.fillColor) {
                this.mOptions.fillColor = value;
                if (this.mOptions.fillEnabled) {
                    this.needsRedraw();
                }
            }
        }

        /**
         * The width of the stroke for this shape.
         *
         * @type {Number}
         */

    }, {
        key: 'stroke',
        get: function get() {
            return this.mOptions.stroke;
        }

        /**
         * Sets the width of the stroke for this shape.
         *
         * @param {Number} value - The new width of the stroke.
         */
        ,
        set: function set(value) {
            if (value !== this.mOptions.stroke) {
                this.mOptions.stroke = value;
                if (this.mOptions.strokeType) {
                    this.needsRedraw();
                }
            }
        }

        /**
         * The stroke color of this shape.
         *
         * @type {String}
         */

    }, {
        key: 'strokeColor',
        get: function get() {
            return this.mOptions.strokeColor;
        }

        /**
         * Sets the stroke color of this shape.
         *
         * @param {String} value - The new color.
         */
        ,
        set: function set(value) {
            if (value !== this.mOptions.strokeColor) {
                this.mOptions.strokeColor = value;
                if (this.mOptions.strokeType && this.mOptions.stroke > 0) {
                    this.needsRedraw();
                }
            }
        }

        /**
         * The stroke type of this shape.
         *
         * @type {Symbol|null}
         */

    }, {
        key: 'strokeType',
        get: function get() {
            return this.mOptions.strokeType;
        }

        /**
         * Sets the stroke type of this shape
         *
         * @param {Symbol|null} value - The new stroke type.
         */
        ,
        set: function set(value) {
            if (value !== this.mOptions.strokeType) {
                this.mOptions.strokeType = value;
                if (this.mOptions.stroke > 0) {
                    this.needsRedraw();
                }
            }
        }

        /**
         * If the stroke is enabled, the line cap type for this shape.
         *
         * @type {String}
         */

    }, {
        key: 'lineCapType',
        get: function get() {
            return this.mOptions.lineCapType;
        }

        /**
         * Sets the line cap type of this shape.
         *
         * @param {String} value - The new line cap type.
         */
        ,
        set: function set(value) {
            if (value !== this.mOptions.lineCapType) {
                this.mOptions.lineCapType = value;
                if (this.mOptions.strokeType && this.mOptions.stroke > 0) {
                    this.needsRedraw();
                }
            }
        }

        /**
         * Should the path of this shape always be closed.
         *
         * @type {Boolean}
         */

    }, {
        key: 'closePath',
        get: function get() {
            return this.mOptions.closePath;
        }

        /**
         * Defines if the path of this shape should always be closed.
         *
         * @param {Boolean} value - The new flag.
         */
        ,
        set: function set(value) {
            if (value !== this.mOptions.closePath) {
                this.mOptions.closePath = value;
                this.needsRedraw();
            }
        }
    }]);

    return Primitive;
}(__WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Primitive;

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var Events = {
  INPUT_POINTER_BEGAN: 'Input::Pointer::Began',
  INPUT_POINTER_MOVED: 'Input::Pointer::Moved',
  INPUT_POINTER_ENDED: 'Input::Pointer::Ended',
  INPUT_POINTER_CANCELLED: 'Input::Pointer::Cancelled',

  INPUT_MOUSE_SCROLL_UP: 'Input::Mouse::ScrollUp',
  INPUT_MOUSE_SCROLL_DOWN: 'Input::Mouse::ScrollDown'
};

/* harmony default export */ __webpack_exports__["a"] = Events;

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PointerEvent_js__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Events_js__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__graphics_Canvas__ = __webpack_require__(53);
/* unused harmony export InputManager */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */






var InputManagerInstances = new Map();

/**
 * Class used to manage input events. Includes utility functions to associate an InoutManager to a canvas by its reviContext.
 *
 * @class InputManager
 */
var InputManager = function (_IBindable) {
    _inherits(InputManager, _IBindable);

    _createClass(InputManager, null, [{
        key: 'registerContext',

        /**
         * Registers a revi context and binds a new InputManager to it.
         *
         * @method registerContext
         * @param {Symbol} context - The revi context of the canvas.
         * @static
         */
        value: function registerContext(context) {
            if (InputManagerInstances.has(context)) {
                throw new Error('The context is already registered.');
            }

            var canvas = __WEBPACK_IMPORTED_MODULE_3__graphics_Canvas__["a" /* default */].getCanvasForContext(context);
            if (!canvas) {
                throw new Error('No canvas is registered for the provided context');
            }

            InputManagerInstances.set(context, new InputManager(canvas));
        }

        /**
         * Unregisters a revi context and destroys the InputManager instance associated with it.
         *
         * @method unregisterContext
         * @param {Symbol} context - The revi context of the canvas.
         * @static
         */

    }, {
        key: 'unregisterContext',
        value: function unregisterContext(context) {
            var instance = InputManagerInstances.get(context);
            if (instance) {
                InputManagerInstances.delete(context);
                instance.release();
            } else {
                throw new Error('The context was never registered.');
            }
        }

        /**
         * Finds the InputManager linked to the provided context and returns it or null if not found.
         *
         * @method instanceForContext
         * @param {Symbol} context - The revi context to look for.
         * @returns {InputManager|null}
         * @static
         */

    }, {
        key: 'instanceForContext',
        value: function instanceForContext(context) {
            return InputManagerInstances.get(context) || null;
        }

        /**
         * @param {Canvas} canvas - The revi canvas this InputManager will be bound to.
         * @constructor
         */

    }]);

    function InputManager(canvas) {
        _classCallCheck(this, InputManager);

        var _this = _possibleConstructorReturn(this, (InputManager.__proto__ || Object.getPrototypeOf(InputManager)).call(this));

        _this.mCanvas = canvas;
        _this.mElement = _this.mCanvas.mCanvas;

        _this.mPointerDown = false;
        _this.mTouchTrackingID = -1;
        _this.mAllowsMultiplePointers = false;
        _this.mEnabled = true;

        _this.mLineHeight = 16; /* -.- */
        _this.mPageHeight = _this.mCanvas.size.height;

        _this.mBoundMouseHandler = _this._mouseHandler.bind(_this);
        _this.mElement.addEventListener('mousedown', _this.mBoundMouseHandler, false);
        _this.mElement.addEventListener('mouseup', _this.mBoundMouseHandler, false);
        _this.mElement.addEventListener('mouseover', _this.mBoundMouseHandler, false);
        _this.mElement.addEventListener('mouseout', _this.mBoundMouseHandler, false);
        _this.mElement.addEventListener('mousemove', _this.mBoundMouseHandler, false);

        _this.mBoundTouchHandler = _this._touchHandler.bind(_this);
        _this.mElement.addEventListener('touchstart', _this.mBoundTouchHandler, false);
        _this.mElement.addEventListener('touchmove', _this.mBoundTouchHandler, false);
        _this.mElement.addEventListener('touchend', _this.mBoundTouchHandler, false);
        _this.mElement.addEventListener('touchenter', _this.mBoundTouchHandler, false);
        _this.mElement.addEventListener('touchleave', _this.mBoundTouchHandler, false);
        _this.mElement.addEventListener('touchcancel', _this.mBoundTouchHandler, false);

        _this.mBoundWheelHandler = _this._wheelHandler.bind(_this);
        _this.mElement.addEventListener('wheel', _this.mBoundWheelHandler);
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(InputManager, [{
        key: 'destroy',
        value: function destroy() {
            this.mElement.removeEventListener('mousedown', this.mBoundMouseHandler, false);
            this.mElement.removeEventListener('mouseup', this.mBoundMouseHandler, false);
            this.mElement.removeEventListener('mouseover', this.mBoundMouseHandler, false);
            this.mElement.removeEventListener('mouseout', this.mBoundMouseHandler, false);
            this.mElement.removeEventListener('mousemove', this.mBoundMouseHandler, false);

            this.mElement.removeEventListener('touchstart', this.mBoundTouchHandler, false);
            this.mElement.removeEventListener('touchmove', this.mBoundTouchHandler, false);
            this.mElement.removeEventListener('touchend', this.mBoundTouchHandler, false);
            this.mElement.removeEventListener('touchenter', this.mBoundTouchHandler, false);
            this.mElement.removeEventListener('touchleave', this.mBoundTouchHandler, false);
            this.mElement.removeEventListener('touchcancel', this.mBoundTouchHandler, false);

            this.mElement.removeEventListener('wheel', this.mBoundWheelHandler);

            delete this.mCanvas;
            delete this.mElement;
            delete this.mPointerDown;
            delete this.mTouchTrackingID;
            delete this.mAllowsMultiplePointers;
            delete this.mEnabled;
            delete this.mLineHeight;
            delete this.mPageHeight;
            delete this.mBoundMouseHandler;
            delete this.mBoundTouchHandler;
            delete this.mBoundWheelHandler;

            _get(InputManager.prototype.__proto__ || Object.getPrototypeOf(InputManager.prototype), 'destroy', this).call(this);
        }

        /**
         * Is this InputManager enabled.
         *
         * @type {Boolean}
         */

    }, {
        key: '_mouseHandler',


        /**
         * Handles mouse inputs events.
         *
         * @method _mouseHandler
         * @param {InputEvent} inputEvent - The event to handle.
         * @private
         */
        value: function _mouseHandler(inputEvent) {
            inputEvent.preventDefault();
            inputEvent.stopPropagation();

            var eventType = null;
            switch (inputEvent.type) {
                case 'mousedown':
                    if (this.enabled) {
                        this.mPointerDown = true;
                        eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_POINTER_BEGAN;
                    }
                    break;

                case 'mousemove':
                    eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_POINTER_MOVED;
                    break;

                case 'mouseup':
                    this.mPointerDown = false;
                    eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_POINTER_ENDED;
                    break;

                case 'mouseout':
                    if (this.mPointerDown) {
                        this.mPointerDown = false;
                        eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_POINTER_CANCELLED;
                    }
                    break;

                case 'mouseover':
                default:
                    break;
            }

            if (eventType) {
                var rect = this.mElement.getBoundingClientRect();
                var x = inputEvent.clientX - rect.left;
                var y = inputEvent.clientY - rect.top;
                var pointerEvent = __WEBPACK_IMPORTED_MODULE_1__PointerEvent_js__["a" /* default */].instance(eventType, x, y, 123456789, Date.now());
                this.emit(eventType, this, pointerEvent);
            }
        }

        /**
         * Handles touch input events.
         *
         * @method _touchHandler
         * @param {InputEvent} inputEvent - The event to handle.
         * @private
         */

    }, {
        key: '_touchHandler',
        value: function _touchHandler(inputEvent) {
            inputEvent.preventDefault();

            var shouldResetTouchID = false;
            var eventType = null;
            switch (inputEvent.type) {
                case 'touchstart':
                    if (this.enabled) {
                        eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_POINTER_BEGAN;
                    }
                    break;

                case 'touchmove':
                    eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_POINTER_MOVED;
                    break;

                case 'touchend':
                    shouldResetTouchID = true;
                    eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_POINTER_ENDED;
                    break;

                case 'touchleave':
                case 'touchcancel':
                    shouldResetTouchID = true;
                    eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_POINTER_CANCELLED;
                    break;

                case 'touchenter':
                default:
                    break;
            }

            if (eventType) {
                var touches = inputEvent.changedTouches;
                var touchesLength = touches.length;
                for (var i = 0; i < touchesLength; ++i) {
                    var touch = touches[i];
                    var touchID = touch.identifier;
                    if (this.mAllowsMultiplePointers || this.mTouchTrackingID === -1 || touchID === this.mTouchTrackingID) {
                        this.mTouchTrackingID = touchID;

                        var rect = this.mElement.getBoundingClientRect();
                        var x = inputEvent.clientX - rect.left;
                        var y = inputEvent.clientY - rect.top;

                        var pointerEvent = __WEBPACK_IMPORTED_MODULE_1__PointerEvent_js__["a" /* default */].instance(eventType, x, y, touch.identifier, Date.now());
                        this.emit(eventType, this, pointerEvent);

                        if (shouldResetTouchID) {
                            this.mTouchTrackingID = -1;
                        }
                    }
                }
            }
        }

        /**
         * Handles scroll wheel events.
         *
         * @method _wheelHandler
         * @param {WheelEvent} wheelEvent - The event to handle.
         * @private
         */

    }, {
        key: '_wheelHandler',
        value: function _wheelHandler(wheelEvent) {
            if (wheelEvent.deltaY !== 0) {
                if (this.enabled) {
                    wheelEvent.preventDefault();

                    var eventType = null;
                    if (wheelEvent.deltaY > 0) {
                        eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_MOUSE_SCROLL_UP;
                    } else if (wheelEvent.deltaY < 0) {
                        eventType = __WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].INPUT_MOUSE_SCROLL_DOWN;
                    }

                    if (eventType) {
                        var x = wheelEvent.layerX;
                        var y = wheelEvent.layerY;

                        var delta = Math.abs(wheelEvent.deltaY);
                        if (wheelEvent.deltaMode === 1) {
                            /* per-line scrolling */
                            delta *= this.mLineHeight;
                        } else if (wheelEvent.deltaMode === 2) {
                            /* per-page scrolling */
                            delta *= this.mPageHeight;
                        }

                        this.emit(eventType, this, delta, x, y);
                    }
                }
            }
        }
    }, {
        key: 'enabled',
        get: function get() {
            return this.mEnabled;
        }

        /**
         * Sets if this InputManager is enabled.
         *
         * @param {Boolean} value - The new value.
         */
        ,
        set: function set(value) {
            if (value !== this.mEnabled) {
                this.mEnabled = value;
            }
        }
    }]);

    return InputManager;
}(__WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = InputManager;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(18)
  , toLength  = __webpack_require__(9)
  , toIndex   = __webpack_require__(45);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global            = __webpack_require__(2)
  , $export           = __webpack_require__(0)
  , redefine          = __webpack_require__(16)
  , redefineAll       = __webpack_require__(43)
  , meta              = __webpack_require__(35)
  , forOf             = __webpack_require__(49)
  , anInstance        = __webpack_require__(38)
  , isObject          = __webpack_require__(4)
  , fails             = __webpack_require__(3)
  , $iterDetect       = __webpack_require__(69)
  , setToStringTag    = __webpack_require__(51)
  , inheritIfRequired = __webpack_require__(85);

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a){
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance             = new C
      // early implementations not supports chaining
      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      , BUGGY_ZERO = !IS_WEAK && fails(function(){
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C()
          , index     = 5;
        while(index--)$instance[ADDER](index, index);
        return !$instance.has(-0);
      });
    if(!ACCEPT_ITERABLES){ 
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base, target, C);
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide     = __webpack_require__(15)
  , redefine = __webpack_require__(16)
  , fails    = __webpack_require__(3)
  , defined  = __webpack_require__(22)
  , wks      = __webpack_require__(5);

module.exports = function(KEY, length, exec){
  var SYMBOL   = wks(KEY)
    , fns      = exec(defined, SYMBOL, ''[KEY])
    , strfn    = fns[0]
    , rxfn     = fns[1];
  if(fails(function(){
    var O = {};
    O[SYMBOL] = function(){ return 7; };
    return ''[KEY](O) != 7;
  })){
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function(string, arg){ return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function(string){ return rxfn.call(string, this); }
    );
  }
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(1);
module.exports = function(){
  var that   = anObject(this)
    , result = '';
  if(that.global)     result += 'g';
  if(that.ignoreCase) result += 'i';
  if(that.multiline)  result += 'm';
  if(that.unicode)    result += 'u';
  if(that.sticky)     result += 'y';
  return result;
};

/***/ }),
/* 67 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(4)
  , cof      = __webpack_require__(21)
  , MATCH    = __webpack_require__(5)('match');
module.exports = function(it){
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR     = __webpack_require__(5)('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

// Forced replacement prototype accessors methods
module.exports = __webpack_require__(39)|| !__webpack_require__(3)(function(){
  var K = Math.random();
  // In FF throws only define methods
  __defineSetter__.call(null, K, function(){ /* empty */});
  delete __webpack_require__(2)[K];
});

/***/ }),
/* 71 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2)
  , hide   = __webpack_require__(15)
  , uid    = __webpack_require__(46)
  , TYPED  = uid('typed_array')
  , VIEW   = uid('view')
  , ABV    = !!(global.ArrayBuffer && global.DataView)
  , CONSTR = ABV
  , i = 0, l = 9, Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while(i < l){
  if(Typed = global[TypedArrayConstructors[i++]]){
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV:    ABV,
  CONSTR: CONSTR,
  TYPED:  TYPED,
  VIEW:   VIEW
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Glyph encoding



var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

/**
 * This is the encoding used for fonts created from scratch.
 * It loops through all glyphs and finds the appropriate unicode value.
 * Since it's linear time, other encodings will be faster.
 * @exports opentype.DefaultEncoding
 * @class
 * @constructor
 * @param {opentype.Font}
 */
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function(c) {
    var code = c.charCodeAt(0);
    var glyphs = this.font.glyphs;
    if (glyphs) {
        for (var i = 0; i < glyphs.length; i += 1) {
            var glyph = glyphs.get(i);
            for (var j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    } else {
        return null;
    }
};

/**
 * @exports opentype.CmapEncoding
 * @class
 * @constructor
 * @param {Object} cmap - a object with the cmap encoded data
 */
function CmapEncoding(cmap) {
    this.cmap = cmap;
}

/**
 * @param  {string} c - the character
 * @return {number} The glyph index.
 */
CmapEncoding.prototype.charToGlyphIndex = function(c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

/**
 * @exports opentype.CffEncoding
 * @class
 * @constructor
 * @param {string} encoding - The encoding
 * @param {Array} charset - The charcater set.
 */
function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

/**
 * @param  {string} s - The character
 * @return {number} The index.
 */
CffEncoding.prototype.charToGlyphIndex = function(s) {
    var code = s.charCodeAt(0);
    var charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

/**
 * @exports opentype.GlyphNames
 * @class
 * @constructor
 * @param {Object} post
 */
function GlyphNames(post) {
    var i;
    switch (post.version) {
        case 1:
            this.names = exports.standardNames.slice();
            break;
        case 2:
            this.names = new Array(post.numberOfGlyphs);
            for (i = 0; i < post.numberOfGlyphs; i++) {
                if (post.glyphNameIndex[i] < exports.standardNames.length) {
                    this.names[i] = exports.standardNames[post.glyphNameIndex[i]];
                } else {
                    this.names[i] = post.names[post.glyphNameIndex[i] - exports.standardNames.length];
                }
            }

            break;
        case 2.5:
            this.names = new Array(post.numberOfGlyphs);
            for (i = 0; i < post.numberOfGlyphs; i++) {
                this.names[i] = exports.standardNames[i + post.glyphNameIndex[i]];
            }

            break;
        case 3:
            this.names = [];
            break;
    }
}

/**
 * Gets the index of a glyph by name.
 * @param  {string} name - The glyph name
 * @return {number} The index
 */
GlyphNames.prototype.nameToGlyphIndex = function(name) {
    return this.names.indexOf(name);
};

/**
 * @param  {number} gid
 * @return {string}
 */
GlyphNames.prototype.glyphIndexToName = function(gid) {
    return this.names[gid];
};

/**
 * @alias opentype.addGlyphNames
 * @param {opentype.Font}
 */
function addGlyphNames(font) {
    var glyph;
    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
    var charCodes = Object.keys(glyphIndexMap);

    for (var i = 0; i < charCodes.length; i += 1) {
        var c = charCodes[i];
        var glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs.get(glyphIndex);
        glyph.addUnicode(parseInt(c));
    }

    for (i = 0; i < font.glyphs.length; i += 1) {
        glyph = font.glyphs.get(i);
        if (font.cffEncoding) {
            glyph.name = font.cffEncoding.charset[i];
        } else if (font.glyphNames.names) {
            glyph.name = font.glyphNames.glyphIndexToName(i);
        }
    }
}

exports.cffStandardStrings = cffStandardStrings;
exports.cffStandardEncoding = cffStandardEncoding;
exports.cffExpertEncoding = cffExpertEncoding;
exports.standardNames = standardNames;
exports.DefaultEncoding = DefaultEncoding;
exports.CmapEncoding = CmapEncoding;
exports.CffEncoding = CffEncoding;
exports.GlyphNames = GlyphNames;
exports.addGlyphNames = addGlyphNames;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

/* global WeakMap */



var check = __webpack_require__(11);

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

/**
 * @exports opentype.decode
 * @class
 */
var decode = {};
/**
 * @exports opentype.encode
 * @class
 */
var encode = {};
/**
 * @exports opentype.sizeOf
 * @class
 */
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function() {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

/**
 * Convert an 8-bit unsigned integer to a list of 1 byte.
 * @param {number}
 * @returns {Array}
 */
encode.BYTE = function(v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};
/**
 * @constant
 * @type {number}
 */
sizeOf.BYTE = constant(1);

/**
 * Convert a 8-bit signed integer to a list of 1 byte.
 * @param {string}
 * @returns {Array}
 */
encode.CHAR = function(v) {
    return [v.charCodeAt(0)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.CHAR = constant(1);

/**
 * Convert an ASCII string to a list of bytes.
 * @param {string}
 * @returns {Array}
 */
encode.CHARARRAY = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b[i] = v.charCodeAt(i);
    }

    return b;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARARRAY = function(v) {
    return v.length;
};

/**
 * Convert a 16-bit unsigned integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.USHORT = function(v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.USHORT = constant(2);

/**
 * Convert a 16-bit signed integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.SHORT = function(v) {
    // Two's complement
    if (v >= LIMIT16) {
        v = -(2 * LIMIT16 - v);
    }

    return [(v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.SHORT = constant(2);

/**
 * Convert a 24-bit unsigned integer to a list of 3 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.UINT24 = function(v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.UINT24 = constant(3);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.ULONG = function(v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.ULONG = constant(4);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.LONG = function(v) {
    // Two's complement
    if (v >= LIMIT32) {
        v = -(2 * LIMIT32 - v);
    }

    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;

/**
 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
 * @param {number}
 * @returns {Array}
 */
encode.LONGDATETIME = function(v) {
    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONGDATETIME = constant(8);

/**
 * Convert a 4-char tag to a list of 4 bytes.
 * @param {string}
 * @returns {Array}
 */
encode.TAG = function(v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
/**
 * Convert a numeric operand or charstring number to a variable-size list of bytes.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER = function(v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.NUMBER = function(v) {
    return encode.NUMBER(v).length;
};

/**
 * Convert a signed number between -32768 and +32767 to a three-byte value.
 * This ensures we always use three bytes, but is not the most compact format.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER16 = function(v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER16 = constant(3);

/**
 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
 * This is useful if you want to be sure you always use four bytes,
 * at the expense of wasting a few bytes for smaller numbers.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER32 = function(v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER32 = constant(5);

/**
 * @param {number}
 * @returns {Array}
 */
encode.REAL = function(v) {
    var value = v.toString();

    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
    // This code converts it back to a number without the epsilon.
    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
    if (m) {
        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(v * epsilon) / epsilon).toString();
    }

    var nibbles = '';
    var i;
    var ii;
    for (i = 0, ii = value.length; i < ii; i += 1) {
        var c = value[i];
        if (c === 'e') {
            nibbles += value[++i] === '-' ? 'c' : 'b';
        } else if (c === '.') {
            nibbles += 'a';
        } else if (c === '-') {
            nibbles += 'e';
        } else {
            nibbles += c;
        }
    }

    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
    var out = [30];
    for (i = 0, ii = nibbles.length; i < ii; i += 2) {
        out.push(parseInt(nibbles.substr(i, 2), 16));
    }

    return out;
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.REAL = function(v) {
    return encode.REAL(v).length;
};

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF8 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes;
    for (var j = 0; j < numChars; j++, offset += 1) {
        codePoints[j] = data.getUint8(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF16 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes / 2;
    for (var j = 0; j < numChars; j++, offset += 2) {
        codePoints[j] = data.getUint16(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * Convert a JavaScript string to UTF16-BE.
 * @param {string}
 * @returns {Array}
 */
encode.UTF16 = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        var codepoint = v.charCodeAt(i);
        b[b.length] = (codepoint >> 8) & 0xFF;
        b[b.length] = codepoint & 0xFF;
    }

    return b;
};

/**
 * @param {string}
 * @returns {number}
 */
sizeOf.UTF16 = function(v) {
    return v.length * 2;
};

// Data for converting old eight-bit Macintosh encodings to Unicode.
// This representation is optimized for decoding; encoding is slower
// and needs more memory. The assumption is that all opentype.js users
// want to open fonts, but saving a font will be comperatively rare
// so it can be more expensive. Keyed by IANA character set name.
//
// Python script for generating these strings:
//
//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
//     print(s.encode('utf-8'))
/**
 * @private
 */
var eightBitMacEncodings = {
    'x-mac-croatian':  // Python: 'mac_croatian'
        'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +
        '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',
    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
        'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +
        'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',
    'x-mac-gaelic':
        // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
        'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +
        'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',
    'x-mac-greek':  // Python: 'mac_greek'
        'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +
        'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\u00AD',
    'x-mac-icelandic':  // Python: 'mac_iceland'
        'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
        '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
    'x-mac-inuit':
        // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
        'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +
        'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',
    'x-mac-ce':  // Python: 'mac_latin2'
        'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +
        'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',
    macintosh:  // Python: 'mac_roman'
        'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
        '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
    'x-mac-romanian':  // Python: 'mac_romanian'
        'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +
        '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
    'x-mac-turkish':  // Python: 'mac_turkish'
        'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
        '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'
};

/**
 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
 * string, or 'undefined' if the encoding is unsupported. For example, we do
 * not support Chinese, Japanese or Korean because these would need large
 * mapping tables.
 * @param {DataView} dataView
 * @param {number} offset
 * @param {number} dataLength
 * @param {string} encoding
 * @returns {string}
 */
decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
    var table = eightBitMacEncodings[encoding];
    if (table === undefined) {
        return undefined;
    }

    var result = '';
    for (var i = 0; i < dataLength; i++) {
        var c = dataView.getUint8(offset + i);
        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c <= 0x7F) {
            result += String.fromCharCode(c);
        } else {
            result += table[c & 0x7F];
        }
    }

    return result;
};

// Helper function for encode.MACSTRING. Returns a dictionary for mapping
// Unicode character codes to their 8-bit MacOS equivalent. This table
// is not exactly a super cheap data structure, but we do not care because
// encoding Macintosh strings is only rarely needed in typical applications.
var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
var macEncodingCacheKeys;
var getMacEncodingTable = function(encoding) {
    // Since we use encoding as a cache key for WeakMap, it has to be
    // a String object and not a literal. And at least on NodeJS 2.10.1,
    // WeakMap requires that the same String instance is passed for cache hits.
    if (!macEncodingCacheKeys) {
        macEncodingCacheKeys = {};
        for (var e in eightBitMacEncodings) {
            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
            macEncodingCacheKeys[e] = new String(e);
        }
    }

    var cacheKey = macEncodingCacheKeys[encoding];
    if (cacheKey === undefined) {
        return undefined;
    }

    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
    // since garbage collection may run at any time, it could also kick in
    // between the calls to cache.has() and cache.get(). In that case,
    // we would return 'undefined' even though we do support the encoding.
    if (macEncodingTableCache) {
        var cachedTable = macEncodingTableCache.get(cacheKey);
        if (cachedTable !== undefined) {
            return cachedTable;
        }
    }

    var decodingTable = eightBitMacEncodings[encoding];
    if (decodingTable === undefined) {
        return undefined;
    }

    var encodingTable = {};
    for (var i = 0; i < decodingTable.length; i++) {
        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
    }

    if (macEncodingTableCache) {
        macEncodingTableCache.set(cacheKey, encodingTable);
    }

    return encodingTable;
};

/**
 * Encodes an old-style Macintosh string. Returns a byte array upon success.
 * If the requested encoding is unsupported, or if the input string contains
 * a character that cannot be expressed in the encoding, the function returns
 * 'undefined'.
 * @param {string} str
 * @param {string} encoding
 * @returns {Array}
 */
encode.MACSTRING = function(str, encoding) {
    var table = getMacEncodingTable(encoding);
    if (table === undefined) {
        return undefined;
    }

    var result = [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);

        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c >= 0x80) {
            c = table[c];
            if (c === undefined) {
                // str contains a Unicode character that cannot be encoded
                // in the requested encoding.
                return undefined;
            }
        }
        result[i] = c;
        // result.push(c);
    }

    return result;
};

/**
 * @param {string} str
 * @param {string} encoding
 * @returns {number}
 */
sizeOf.MACSTRING = function(str, encoding) {
    var b = encode.MACSTRING(str, encoding);
    if (b !== undefined) {
        return b.length;
    } else {
        return 0;
    }
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
/**
 * @param {Array} l
 * @returns {Array}
 */
encode.INDEX = function(l) {
    var i;
    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
    //    i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offets, then again to encode the offsets using the fitting data type.
    var offset = 1; // First offset is always 1.
    var offsets = [offset];
    var data = [];
    for (i = 0; i < l.length; i += 1) {
        var v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    var encodedOffsets = [];
    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (i = 0; i < offsets.length; i += 1) {
        var encodedOffset = offsetEncoder(offsets[i]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }

    return Array.prototype.concat(encode.Card16(l.length),
                           encode.OffSize(offSize),
                           encodedOffsets,
                           data);
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.INDEX = function(v) {
    return encode.INDEX(v).length;
};

/**
 * Convert an object to a CFF DICT structure.
 * The keys should be numeric.
 * The values should be objects containing name / type / value.
 * @param {Object} m
 * @returns {Array}
 */
encode.DICT = function(m) {
    var d = [];
    var keys = Object.keys(m);
    var length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.DICT = function(m) {
    return encode.DICT(m).length;
};

/**
 * @param {number}
 * @returns {Array}
 */
encode.OPERATOR = function(v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

/**
 * @param {Array} v
 * @param {string}
 * @returns {Array}
 */
encode.OPERAND = function(v, type) {
    var d = [];
    if (Array.isArray(type)) {
        for (var i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else if (type === 'number') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'real') {
            d = d.concat(encode.REAL(v));
        } else {
            throw new Error('Unknown operand type ' + type);
            // FIXME Add support for booleans
        }
    }

    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

// memoize charstring encoding using WeakMap if available
var wmm = typeof WeakMap === 'function' && new WeakMap();

/**
 * Convert a list of CharString operations to bytes.
 * @param {Array}
 * @returns {Array}
 */
encode.CHARSTRING = function(ops) {
    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
    if (wmm) {
        var cachedValue = wmm.get(ops);
        if (cachedValue !== undefined) {
            return cachedValue;
        }
    }

    var d = [];
    var length = ops.length;

    for (var i = 0; i < length; i += 1) {
        var op = ops[i];
        d = d.concat(encode[op.type](op.value));
    }

    if (wmm) {
        wmm.set(ops, d);
    }

    return d;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARSTRING = function(ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

/**
 * Convert an object containing name / type / value to bytes.
 * @param {Object}
 * @returns {Array}
 */
encode.OBJECT = function(v) {
    var encodingFunction = encode[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.OBJECT = function(v) {
    var sizeOfFunction = sizeOf[v.type];
    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
    return sizeOfFunction(v.value);
};

/**
 * Convert a table object to bytes.
 * A table contains a list of fields containing the metadata (name, type and default value).
 * The table itself has the field values set as attributes.
 * @param {opentype.Table}
 * @returns {Array}
 */
encode.TABLE = function(table) {
    var d = [];
    var length = table.fields.length;
    var subtables = [];
    var subtableOffsets = [];
    var i;

    for (i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        var bytes = encodingFunction(value);

        if (field.type === 'TABLE') {
            subtableOffsets.push(d.length);
            d = d.concat([0, 0]);
            subtables.push(bytes);
        } else {
            d = d.concat(bytes);
        }
    }

    for (i = 0; i < subtables.length; i += 1) {
        var o = subtableOffsets[i];
        var offset = d.length;
        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
        d[o] = offset >> 8;
        d[o + 1] = offset & 0xff;
        d = d.concat(subtables[i]);
    }

    return d;
};

/**
 * @param {opentype.Table}
 * @returns {number}
 */
sizeOf.TABLE = function(table) {
    var numBytes = 0;
    var length = table.fields.length;

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var sizeOfFunction = sizeOf[field.type];
        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        numBytes += sizeOfFunction(value);

        // Subtables take 2 more bytes for offsets.
        if (field.type === 'TABLE') {
            numBytes += 2;
        }
    }

    return numBytes;
};

encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;

// Merge in a list of bytes.
encode.LITERAL = function(v) {
    return v;
};

sizeOf.LITERAL = function(v) {
    return v.length;
};

exports.decode = decode;
exports.encode = encode;
exports.sizeOf = sizeOf;


/***/ }),
/* 76 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Primitive_js__ = __webpack_require__(60);
/* unused harmony export Circle */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



var circleRadians = Math.PI * 2;

/**
 * Draws a circle.
 */
var Circle = function (_Primitive) {
    _inherits(Circle, _Primitive);

    _createClass(Circle, null, [{
        key: 'circleRadians',

        /**
         * The radians needed to draw a circle. 360deg or PI * 2
         * @type {Number}
         */
        get: function get() {
            return circleRadians;
        }

        /**
         * @param {Number} radius - The radius of this circle.
         * @param {Object=} options - The rendering options for this object.
         * @constructor
         */

    }]);

    function Circle(radius, options) {
        _classCallCheck(this, Circle);

        var _this = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, options));

        _this.mRadius = radius;
        _this.size.set(radius * 2, radius * 2);
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Circle, [{
        key: 'destroy',
        value: function destroy() {
            delete this.mRadius;
            _get(Circle.prototype.__proto__ || Object.getPrototypeOf(Circle.prototype), 'destroy', this).call(this);
        }

        /**
         * @type {Number}
         */

    }, {
        key: '_renderPath',


        /**
         * Renders the path of this shape to the context.
         *
         * @method _renderPath
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {Object} options - The rendering options for this shape.
         * @private
         */
        value: function _renderPath(context, options) {
            var radius = this.mRadius;
            if (options.strokeType) {
                if (options.strokeType === Circle.STROKE_INNER) {
                    radius -= options.stroke * 0.5;
                } else if (options.strokeType === Circle.STROKE_OUTER) {
                    radius += options.stroke * 0.5;
                }
            }

            radius = Math.max(radius, 0);

            context.beginPath();
            context.arc(this.mRadius, this.mRadius, radius, 0, circleRadians, false);
            context.closePath();
        }
    }, {
        key: 'radius',
        get: function get() {
            return this.mRadius;
        }

        /**
         * @param {Number} value - The new radius of this circle.
         */
        ,
        set: function set(value) {
            if (value !== this.mRadius) {
                this.mRadius = value;
                this.size.set(this.mRadius * 2, this.mRadius * 2);
                this.needsRedraw();
            }
        }
    }]);

    return Circle;
}(__WEBPACK_IMPORTED_MODULE_0__Primitive_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Circle;

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IObject_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_AssetCache_js__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_opentype_js_src_opentype_js__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_opentype_js_src_opentype_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_opentype_js_src_opentype_js__);
/* unused harmony export FontManager */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */





/**
 * Variable to hold the shared instance of the FontManager.
 *
 * @type {FontManager}
 */
var fontManagerSharedInstance = null;

/**
 * Class used to load and unload font files.
 *
 * @class FontManager
 */
var FontManager = function (_IObject) {
    _inherits(FontManager, _IObject);

    _createClass(FontManager, null, [{
        key: 'sharedInstance',

        /**
         * Returns a shared instance of the FontManager. Useful to make the FontManager behave as a singleton.
         *
         * @method sharedInstance
         * @returns {FontManager}
         * @static
         */
        value: function sharedInstance() {
            if (!fontManagerSharedInstance) {
                fontManagerSharedInstance = new FontManager();
            }
            return fontManagerSharedInstance;
        }

        /**
         * @constructor
         */

    }]);

    function FontManager() {
        _classCallCheck(this, FontManager);

        var _this = _possibleConstructorReturn(this, (FontManager.__proto__ || Object.getPrototypeOf(FontManager)).call(this));

        _this.mFontCache = {};
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(FontManager, [{
        key: 'destroy',
        value: function destroy() {
            var _this2 = this;

            var fontKeys = Object.keys(this.mFontCache);
            fontKeys.forEach(function (key) {
                return delete _this2.mFontCache[key];
            });

            delete this.mFontCache;

            _get(FontManager.prototype.__proto__ || Object.getPrototypeOf(FontManager.prototype), 'destroy', this).call(this);
        }

        /**
         * The underlying cache object used by this FontManager.
         *
         * @type {{}}
         */

    }, {
        key: 'loadFont',


        /**
         * Loads a font from the provided URL and saves it to the cache. If the optional `fontKey` parameter is passed, the
         * specified key is used to save the font to the cache, the URL is used as key otherwise.
         *
         * @method loadFont
         * @param {String} url - The URL from which the font should be loaded from.
         * @param {String=} fontKey - The key to be used to save the font into the cache.
         * @returns {Promise}
         */
        value: function loadFont(url) {
            var _this3 = this;

            var fontKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            var key = fontKey === null ? url : fontKey;
            var loadedFont = this.mFontCache[key];
            if (loadedFont) {
                return Promise.resolve(loadedFont);
            }

            if (!__WEBPACK_IMPORTED_MODULE_1__core_AssetCache_js__["a" /* default */].isURL(url)) {
                loadedFont = this.loadFontB64(key, url);
                if (loadedFont) {
                    return Promise.resolve(loadedFont);
                }
            }

            return __WEBPACK_IMPORTED_MODULE_1__core_AssetCache_js__["a" /* default */].loadArrayBuffer(url).then(function (buffer) {
                var loaded = __WEBPACK_IMPORTED_MODULE_2_opentype_js_src_opentype_js__["parse"](buffer);
                _this3.mFontCache[fontKey] = loaded;
                return Promise.resolve(loaded);
            }, function (reason) {
                return Promise.reject(reason);
            });
        }

        /**
         * Loads a font from the provided Base64 encoded `data` and saves it in the cache using the specified `fontKey`.
         *
         * @method loadFontB64
         * @param {String} fontKey - The key to be used to save the font into the cache.
         * @param {String} data - Base64 encoded font data.
         * @returns {Font}
         */

    }, {
        key: 'loadFontB64',
        value: function loadFontB64(fontKey, data) {
            var loadedFont = this.mFontCache[fontKey];
            if (loadedFont) {
                return loadedFont;
            }

            try {
                var binaryString = window.atob(data);
                var len = binaryString.length;
                var arrayBuffer = new ArrayBuffer(len);
                var bytes = new Uint8Array(arrayBuffer);
                for (var i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                loadedFont = __WEBPACK_IMPORTED_MODULE_2_opentype_js_src_opentype_js__["parse"](arrayBuffer);
                this.mFontCache[fontKey] = loadedFont;

                return loadedFont;
            } catch (e) {
                return null;
            }
        }
    }, {
        key: 'fontCache',
        get: function get() {
            return this.mFontCache;
        }
    }]);

    return FontManager;
}(__WEBPACK_IMPORTED_MODULE_0__core_IObject_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = FontManager;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(10)
  , toIndex  = __webpack_require__(45)
  , toLength = __webpack_require__(9);
module.exports = function fill(value /*, start = 0, end = @length */){
  var O      = toObject(this)
    , length = toLength(O.length)
    , aLen   = arguments.length
    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
    , end    = aLen > 2 ? arguments[2] : undefined
    , endPos = end === undefined ? length : toIndex(end, length);
  while(endPos > index)O[index++] = value;
  return O;
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(7)
  , createDesc      = __webpack_require__(36);

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4)
  , document = __webpack_require__(2).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 82 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(5)('match');
module.exports = function(KEY){
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch(e){
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch(f){ /* empty */ }
  } return true;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2).document && document.documentElement;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var isObject       = __webpack_require__(4)
  , setPrototypeOf = __webpack_require__(93).set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators  = __webpack_require__(50)
  , ITERATOR   = __webpack_require__(5)('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(21);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create         = __webpack_require__(40)
  , descriptor     = __webpack_require__(36)
  , setToStringTag = __webpack_require__(51)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(15)(IteratorPrototype, __webpack_require__(5)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY        = __webpack_require__(39)
  , $export        = __webpack_require__(0)
  , redefine       = __webpack_require__(16)
  , hide           = __webpack_require__(15)
  , has            = __webpack_require__(12)
  , Iterators      = __webpack_require__(50)
  , $iterCreate    = __webpack_require__(88)
  , setToStringTag = __webpack_require__(51)
  , getPrototypeOf = __webpack_require__(20)
  , ITERATOR       = __webpack_require__(5)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 90 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),
/* 91 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(2)
  , macrotask = __webpack_require__(100).set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = __webpack_require__(21)(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(4)
  , anObject = __webpack_require__(1);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(29)(Function.call, __webpack_require__(19).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(72)('keys')
  , uid    = __webpack_require__(46);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = __webpack_require__(1)
  , aFunction = __webpack_require__(14)
  , SPECIES   = __webpack_require__(5)('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(37)
  , defined   = __webpack_require__(22);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(68)
  , defined  = __webpack_require__(22);

module.exports = function(that, searchString, NAME){
  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(37)
  , defined   = __webpack_require__(22);

module.exports = function repeat(count){
  var str = String(defined(this))
    , res = ''
    , n   = toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var ctx                = __webpack_require__(29)
  , invoke             = __webpack_require__(67)
  , html               = __webpack_require__(84)
  , cel                = __webpack_require__(81)
  , global             = __webpack_require__(2)
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(__webpack_require__(21)(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global         = __webpack_require__(2)
  , DESCRIPTORS    = __webpack_require__(6)
  , LIBRARY        = __webpack_require__(39)
  , $typed         = __webpack_require__(73)
  , hide           = __webpack_require__(15)
  , redefineAll    = __webpack_require__(43)
  , fails          = __webpack_require__(3)
  , anInstance     = __webpack_require__(38)
  , toInteger      = __webpack_require__(37)
  , toLength       = __webpack_require__(9)
  , gOPN           = __webpack_require__(41).f
  , dP             = __webpack_require__(7).f
  , arrayFill      = __webpack_require__(79)
  , setToStringTag = __webpack_require__(51)
  , ARRAY_BUFFER   = 'ArrayBuffer'
  , DATA_VIEW      = 'DataView'
  , PROTOTYPE      = 'prototype'
  , WRONG_LENGTH   = 'Wrong length!'
  , WRONG_INDEX    = 'Wrong index!'
  , $ArrayBuffer   = global[ARRAY_BUFFER]
  , $DataView      = global[DATA_VIEW]
  , Math           = global.Math
  , RangeError     = global.RangeError
  , Infinity       = global.Infinity
  , BaseBuffer     = $ArrayBuffer
  , abs            = Math.abs
  , pow            = Math.pow
  , floor          = Math.floor
  , log            = Math.log
  , LN2            = Math.LN2
  , BUFFER         = 'buffer'
  , BYTE_LENGTH    = 'byteLength'
  , BYTE_OFFSET    = 'byteOffset'
  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function(value, mLen, nBytes){
  var buffer = Array(nBytes)
    , eLen   = nBytes * 8 - mLen - 1
    , eMax   = (1 << eLen) - 1
    , eBias  = eMax >> 1
    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
    , i      = 0
    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
    , e, m, c;
  value = abs(value)
  if(value != value || value === Infinity){
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if(value * (c = pow(2, -e)) < 1){
      e--;
      c *= 2;
    }
    if(e + eBias >= 1){
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if(value * c >= 2){
      e++;
      c /= 2;
    }
    if(e + eBias >= eMax){
      m = 0;
      e = eMax;
    } else if(e + eBias >= 1){
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
};
var unpackIEEE754 = function(buffer, mLen, nBytes){
  var eLen  = nBytes * 8 - mLen - 1
    , eMax  = (1 << eLen) - 1
    , eBias = eMax >> 1
    , nBits = eLen - 7
    , i     = nBytes - 1
    , s     = buffer[i--]
    , e     = s & 127
    , m;
  s >>= 7;
  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if(e === 0){
    e = 1 - eBias;
  } else if(e === eMax){
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
};

var unpackI32 = function(bytes){
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
};
var packI8 = function(it){
  return [it & 0xff];
};
var packI16 = function(it){
  return [it & 0xff, it >> 8 & 0xff];
};
var packI32 = function(it){
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
};
var packF64 = function(it){
  return packIEEE754(it, 52, 8);
};
var packF32 = function(it){
  return packIEEE754(it, 23, 4);
};

var addGetter = function(C, key, internal){
  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
};

var get = function(view, bytes, index, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
};
var set = function(view, bytes, index, conversion, value, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = conversion(+value);
  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
};

var validateArrayBufferArguments = function(that, length){
  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
  var numberLength = +length
    , byteLength   = toLength(numberLength);
  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
  return byteLength;
};

if(!$typed.ABV){
  $ArrayBuffer = function ArrayBuffer(length){
    var byteLength = validateArrayBufferArguments(this, length);
    this._b       = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength){
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH]
      , offset       = toInteger(byteOffset);
    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if(DESCRIPTORS){
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset){
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset){
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if(!fails(function(){
    new $ArrayBuffer;     // eslint-disable-line no-new
  }) || !fails(function(){
    new $ArrayBuffer(.5); // eslint-disable-line no-new
  })){
    $ArrayBuffer = function ArrayBuffer(length){
      return new BaseBuffer(validateArrayBufferArguments(this, length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
    };
    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2))
    , $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(2)
  , core           = __webpack_require__(28)
  , LIBRARY        = __webpack_require__(39)
  , wksExt         = __webpack_require__(145)
  , defineProperty = __webpack_require__(7).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(55)
  , ITERATOR  = __webpack_require__(5)('iterator')
  , Iterators = __webpack_require__(50);
module.exports = __webpack_require__(28).getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(48)
  , step             = __webpack_require__(133)
  , Iterators        = __webpack_require__(50)
  , toIObject        = __webpack_require__(18);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(89)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The GlyphSet object



var _glyph = __webpack_require__(151);

// Define a property on the glyph that depends on the path being loaded.
function defineDependentProperty(glyph, externalName, internalName) {
    Object.defineProperty(glyph, externalName, {
        get: function() {
            // Request the path property to make sure the path is loaded.
            glyph.path; // jshint ignore:line
            return glyph[internalName];
        },
        set: function(newValue) {
            glyph[internalName] = newValue;
        },
        enumerable: true,
        configurable: true
    });
}

/**
 * A GlyphSet represents all glyphs available in the font, but modelled using
 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
 * necessary, to keep the memory footprint down.
 * @exports opentype.GlyphSet
 * @class
 * @param {opentype.Font}
 * @param {Array}
 */
function GlyphSet(font, glyphs) {
    this.font = font;
    this.glyphs = {};
    if (Array.isArray(glyphs)) {
        for (var i = 0; i < glyphs.length; i++) {
            this.glyphs[i] = glyphs[i];
        }
    }

    this.length = (glyphs && glyphs.length) || 0;
}

/**
 * @param  {number} index
 * @return {opentype.Glyph}
 */
GlyphSet.prototype.get = function(index) {
    if (typeof this.glyphs[index] === 'function') {
        this.glyphs[index] = this.glyphs[index]();
    }

    return this.glyphs[index];
};

/**
 * @param  {number} index
 * @param  {Object}
 */
GlyphSet.prototype.push = function(index, loader) {
    this.glyphs[index] = loader;
    this.length++;
};

/**
 * @alias opentype.glyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @return {opentype.Glyph}
 */
function glyphLoader(font, index) {
    return new _glyph.Glyph({index: index, font: font});
}

/**
 * Generate a stub glyph that can be filled with all metadata *except*
 * the "points" and "path" properties, which must be loaded only once
 * the glyph's path is actually requested for text shaping.
 * @alias opentype.ttfGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseGlyph
 * @param  {Object} data
 * @param  {number} position
 * @param  {Function} buildPath
 * @return {opentype.Glyph}
 */
function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
    return function() {
        var glyph = new _glyph.Glyph({index: index, font: font});

        glyph.path = function() {
            parseGlyph(glyph, data, position);
            var path = buildPath(font.glyphs, glyph);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        defineDependentProperty(glyph, 'xMin', '_xMin');
        defineDependentProperty(glyph, 'xMax', '_xMax');
        defineDependentProperty(glyph, 'yMin', '_yMin');
        defineDependentProperty(glyph, 'yMax', '_yMax');

        return glyph;
    };
}
/**
 * @alias opentype.cffGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseCFFCharstring
 * @param  {string} charstring
 * @return {opentype.Glyph}
 */
function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
    return function() {
        var glyph = new _glyph.Glyph({index: index, font: font});

        glyph.path = function() {
            var path = parseCFFCharstring(font, glyph, charstring);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        return glyph;
    };
}

exports.GlyphSet = GlyphSet;
exports.glyphLoader = glyphLoader;
exports.ttfGlyphLoader = ttfGlyphLoader;
exports.cffGlyphLoader = cffGlyphLoader;


/***/ }),
/* 106 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 107 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var LayoutEvents = {
  LAYOUT_ZOOM_IN_CLICKED: 'Layout::ZoomControls::ZoomIn',
  LAYOUT_ZOOM_OUT_CLICKED: 'Layout::ZoomControls::ZoomOut',
  LAYOUT_AUTO_ZOOM_CLICKED: 'Layout::ZoomControls::AutoZoom'
};

/* harmony default export */ __webpack_exports__["a"] = LayoutEvents;

/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var Events = {
  PERSONA_CLICKED: 'PERSONA::CLICKED' };

/* harmony default export */ __webpack_exports__["a"] = Events;

/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__IObject_js__ = __webpack_require__(32);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/**
 * Simple substitute for Storage, useful when to save objects rather than only strings.
 *
 * @class AssetCacheStorage
 */

var AssetCacheStorage = function (_IObject) {
    _inherits(AssetCacheStorage, _IObject);

    /**
     * @constructor
     */
    function AssetCacheStorage() {
        _classCallCheck(this, AssetCacheStorage);

        var _this = _possibleConstructorReturn(this, (AssetCacheStorage.__proto__ || Object.getPrototypeOf(AssetCacheStorage)).call(this));

        _this.mData = {};
        _this.mKeys = [];
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(AssetCacheStorage, [{
        key: 'destroy',
        value: function destroy() {
            this.clear();

            delete this.mData;
            delete this.mKeys;

            _get(AssetCacheStorage.prototype.__proto__ || Object.getPrototypeOf(AssetCacheStorage.prototype), 'destroy', this).call(this);
        }

        /**
         * The length read-only property of the AssetCacheStorage interface returns an integer representing the number of
         * data items stored in the AssetCacheStorage object.
         *
         * @type {Number}
         */

    }, {
        key: 'clear',


        /**
         * The clear() method of the AssetCacheStorage interface, when invoked, will empty all keys out of the storage.
         */
        value: function clear() {
            var _this2 = this;

            this.mKeys.forEach(function (key) {
                delete _this2.mData[key];
            });
            this.mKeys.length = 0;
        }

        /**
         * The key() method of the AssetCacheStorage interface, when passed a number n, returns the name of the nth key in
         * the storage. The order of keys is user-agent defined, so you should not rely on it.
         *
         * @method key
         * @param {Number} key - An integer representing the number of the key you want to get the name of. This is a zero-based index.
         * @returns {String}
         */

    }, {
        key: 'key',
        value: function key(_key) {
            if (_key < this.mKeys.length) {
                return this.mKeys[_key];
            }
            return null;
        }

        /**
         * The getItem() method of the AssetCacheStorage interface, when passed a key name, will return that key's value.
         *
         * @method getItem
         * @param {String} keyName - A DOMString containing the name of the key you want to retrieve the value of.
         * @returns {*}
         */

    }, {
        key: 'getItem',
        value: function getItem(keyName) {
            var i = this.mKeys.indexOf(keyName);
            if (i >= 0) {
                return this.mData[keyName];
            }
            return null;
        }

        /**
         * The removeItem() method of the AssetCacheStorage interface, when passed a key name, will remove that key from the storage.
         *
         * @method removeItem
         * @param {String} keyName - A DOMString containing the name of the key you want to remove.
         */

    }, {
        key: 'removeItem',
        value: function removeItem(keyName) {
            var i = this.mKeys.indexOf(keyName);
            if (i >= 0) {
                delete this.mData[keyName];
                this.mKeys.splice(i, 1);
            }
        }

        /**
         * The setItem() method of the AssetCacheStorage interface, when passed a key name and value, will add that key to
         * the storage, or update that key's value if it already exists.
         *
         * @param {String} keyName - A DOMString containing the name of the key you want to create/update.
         * @param {*} keyValue - An object containing the value you want to give the key you are creating/updating.
         */

    }, {
        key: 'setItem',
        value: function setItem(keyName, keyValue) {
            var i = this.mKeys.indexOf(keyName);
            if (i < 0) {
                this.mKeys.push(keyName);
            }
            this.mData[keyName] = keyValue;
        }
    }, {
        key: 'length',
        get: function get() {
            return this.mKeys.length;
        }
    }]);

    return AssetCacheStorage;
}(__WEBPACK_IMPORTED_MODULE_0__IObject_js__["a" /* default */]);

/**
 * Regular expression used to detect if strings are URLs.
 *
 * @type {RegExp}
 */


var URLPattern = new RegExp('^(https?)://[^\s/$.?#].[^\s]*', 'i');

/**
 * Class to load and hold assets in the cache, specially useful when loading things within power bi's own loader which
 * bypasses the browser cache (probably by adding parameters to the end of the URL. Something like a request to load
 * `image.png` become a request to load `https://powerbi.com/load/?url=image.png&id=somethingUnique&timestamp=time`.
 *
 * @class AssetCache
 */

var AssetCache = function (_IObject2) {
    _inherits(AssetCache, _IObject2);

    /**
     * @constructor
     */
    function AssetCache() {
        _classCallCheck(this, AssetCache);

        var _this3 = _possibleConstructorReturn(this, (AssetCache.__proto__ || Object.getPrototypeOf(AssetCache)).call(this));

        _this3.mStorage = new AssetCacheStorage();
        return _this3;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     * NOTE: Instances of this class cannot be destroyed.
     *
     * @method destroy
     */


    _createClass(AssetCache, [{
        key: 'destroy',
        value: function destroy() {
            throw new Error('This instance cannot be destroyed.');
        }

        /**
         * Loads an image from the provided URL and saves it to the cache.
         *
         * @method loadImage
         * @param {String} url - The URL from which the image should be loaded.
         * @returns {Promise}
         */

    }, {
        key: 'loadImage',
        value: function loadImage(url) {
            var _this4 = this;

            var loaded = this.mStorage.getItem(url);
            if (loaded) {
                return Promise.resolve(loaded);
            }

            var image = new Image();
            var promise = new Promise(function (resolve) {
                image.addEventListener('load', function () {
                    _this4.mStorage.setItem(url, image);
                    resolve(image);
                }, true);
            });

            this.mStorage.setItem(url, promise);
            image.src = url;

            return promise;
        }

        /**
         * Loads an Array Buffer from the provided URL and saves it to the cache.
         *
         * @method loadArrayBuffer
         * @param {String} url - The URL from which the buffer should be loaded.
         * @returns {Promise}
         */

    }, {
        key: 'loadArrayBuffer',
        value: function loadArrayBuffer(url) {
            var _this5 = this;

            var loaded = this.mStorage.getItem(url);
            if (loaded) {
                return Promise.resolve(loaded);
            }

            var request = new XMLHttpRequest();
            request.open('get', url, true);
            request.responseType = 'arraybuffer';

            var promise = new Promise(function (resolve, reject) {
                request.onload = function () {
                    if (request.status !== 200) {
                        reject('Array Buffer (' + url + ') could not be loaded: ' + request.statusText);
                    }

                    _this5.mStorage.setItem(url, request.response);
                    resolve(request.response);
                };
            });

            this.mStorage.setItem(url, promise);
            request.send();

            return promise;
        }

        /**
         * Tests if a string of text is a URL.
         *
         * @method isURL
         * @param {String} text - The text to test.
         * @returns {Boolean}
         */

    }, {
        key: 'isURL',
        value: function isURL(text) {
            return URLPattern.test(text);
        }
    }]);

    return AssetCache;
}(__WEBPACK_IMPORTED_MODULE_0__IObject_js__["a" /* default */]);

/**
 * Don't you love yourself a nice hack?
 * A a hack a day keeps the architect away.
 */
/* find if the session storage is available */


var storage = null;
try {
    sessionStorage.setItem('__ESSEX_STORAGE_CHECK__', Boolean(sessionStorage.getItem('__ESSEX_STORAGE_CHECK__')) || true);
    storage = sessionStorage;
} catch (e) {}
/* session storage not available */


/* if the storage is available try to find a registered asset cache, or register a new one */
var cache = null;
if (storage) {
    var varName = storage.getItem('__ESSEX_ASSET_CACHE_VAR_NAME__');
    if (varName && window[varName] instanceof AssetCache) {
        cache = window[varName];
    } else {
        cache = new AssetCache();
        var varNameBase = '__ESSEX_SHARED_ASSET_CACHE__';
        varName = varNameBase;
        var i = 0;
        while (window.hasOwnProperty(varName)) {
            varName = varNameBase + i++;
        }
        storage.setItem('__ESSEX_ASSET_CACHE_VAR_NAME__', varName);
        window[varName] = cache;
    }
} else {
    cache = new AssetCache();
}

/* harmony default export */ __webpack_exports__["a"] = cache;

/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate, process) {var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Interface class to create task queues.
 */
var ITaskQueue = function () {
    /**
     * Creates a "double buffered" queue pool.
     *
     * @constructor
     */
    function ITaskQueue() {
        _classCallCheck(this, ITaskQueue);

        this.mQueuePool = [[], []];
        this.mQueuePoolIndex = 0;
        this.mTickCallback = this.tick.bind(this);
    }

    /**
     * Destroys the task queues.
     *
     * @method destroy
     */


    _createClass(ITaskQueue, [{
        key: 'destroy',
        value: function destroy() {
            this.mQueuePool[0].length = 0;
            this.mQueuePool[1].length = 0;
            this.mQueuePool.length = 0;
        }

        /**
         * Adds a task to the queue and schedules a queue drain.
         *
         * @method enqueue
         * @param {Function} task - the task to enqueue.
         */

    }, {
        key: 'enqueue',
        value: function enqueue(task) {
            this.mQueuePool[this.mQueuePoolIndex].push(task);
            this.scheduleDrain();
        }

        /**
         * Handles the queue drain as during the scheduled tick. If an exception is thrown, it schedules a queue drain for the next tick.
         *
         * @method tick
         */

    }, {
        key: 'tick',
        value: function tick() {
            var queue = this.mQueuePool[this.mQueuePoolIndex];
            var task = null;
            this.mQueuePoolIndex = ++this.mQueuePoolIndex % 2;

            while (queue.length) {
                task = queue.shift();
                try {
                    task();
                } catch (e) {
                    var activeQueue = this.mQueuePool[this.mQueuePoolIndex];
                    this.mQueuePoolIndex = ++this.mQueuePoolIndex % 2;

                    queue.push.apply(queue, _toConsumableArray(activeQueue));
                    activeQueue.length = 0;

                    this.scheduleDrain();
                    throw e;
                }
            }
        }

        /**
         * Schedules a queue drain based on the underlying system.
         * This method must be overridden by inheriting classes.
         *
         * @method scheduleDrain
         */

    }, {
        key: 'scheduleDrain',
        value: function scheduleDrain() {
            throw new Error('Not Implemented.');
        }
    }]);

    return ITaskQueue;
}();

/**
 * Task queue based on MutationObservers.
 */


var ObserverTaskQueue = function (_ITaskQueue) {
    _inherits(ObserverTaskQueue, _ITaskQueue);

    /**
     * Creates and initializes a mutation observer based on the provided ObserverClass.
     *
     * @constructor
     * @param {constructor} ObserverClass - Constructor of the observer class to use.
     */
    function ObserverTaskQueue(ObserverClass) {
        _classCallCheck(this, ObserverTaskQueue);

        var _this = _possibleConstructorReturn(this, (ObserverTaskQueue.__proto__ || Object.getPrototypeOf(ObserverTaskQueue)).call(this));

        _this.mTextNode = document.createTextNode('');
        _this.mTextNodeData = 0;
        _this.mObserver = new ObserverClass(_this.mTickCallback);
        _this.mDrainQueued = false;

        _this.mObserver.observe(_this.mTextNode, { characterData: true });
        return _this;
    }

    /**
     * Disconnects the observer object.
     *
     * @method destroy
     */


    _createClass(ObserverTaskQueue, [{
        key: 'destroy',
        value: function destroy() {
            this.mObserver.disconnect();
            _get(ObserverTaskQueue.prototype.__proto__ || Object.getPrototypeOf(ObserverTaskQueue.prototype), 'destroy', this).call(this);
        }

        /**
         * Switches the drain flag and calls the super method.
         *
         * @method tick
         */

    }, {
        key: 'tick',
        value: function tick() {
            this.mDrainQueued = false;
            _get(ObserverTaskQueue.prototype.__proto__ || Object.getPrototypeOf(ObserverTaskQueue.prototype), 'tick', this).call(this);
        }

        /**
         * Schedules a queue drain.
         *
         * @method scheduleDrain
         */

    }, {
        key: 'scheduleDrain',
        value: function scheduleDrain() {
            if (!this.mDrainQueued) {
                this.mDrainQueued = true;
                this.mTextNodeData = ++this.mTextNodeData % 2;
                this.mTextNode.data = this.mTextNodeData;
            }
        }
    }]);

    return ObserverTaskQueue;
}(ITaskQueue);

/**
 * Class to create a task queue based on the `setImmediate` method
 */


var ImmediateTaskQueue = function (_ITaskQueue2) {
    _inherits(ImmediateTaskQueue, _ITaskQueue2);

    /**
     * @constructor
     */
    function ImmediateTaskQueue() {
        _classCallCheck(this, ImmediateTaskQueue);

        var _this2 = _possibleConstructorReturn(this, (ImmediateTaskQueue.__proto__ || Object.getPrototypeOf(ImmediateTaskQueue)).call(this));

        _this2.mImmediateHandle = null;
        return _this2;
    }

    /**
     * If set, invalidates the scheduled queue drain.
     *
     * @method destroy
     */


    _createClass(ImmediateTaskQueue, [{
        key: 'destroy',
        value: function destroy() {
            if (this.mImmediateHandle !== null) {
                clearImmediate(this.mImmediateHandle);
                this.mImmediateHandle = null;
            }
            _get(ImmediateTaskQueue.prototype.__proto__ || Object.getPrototypeOf(ImmediateTaskQueue.prototype), 'destroy', this).call(this);
        }

        /**
         * Switches the drain flag and calls the super method.
         *
         * @method tick
         */

    }, {
        key: 'tick',
        value: function tick() {
            this.mImmediateHandle = null;
            _get(ImmediateTaskQueue.prototype.__proto__ || Object.getPrototypeOf(ImmediateTaskQueue.prototype), 'tick', this).call(this);
        }

        /**
         * Schedules a queue drain.
         *
         * @method scheduleDrain
         */

    }, {
        key: 'scheduleDrain',
        value: function scheduleDrain() {
            if (this.mImmediateHandle !== null) {
                this.mImmediateHandle = setImmediate(this.mTickCallback);
            }
        }
    }]);

    return ImmediateTaskQueue;
}(ITaskQueue);

/**
 * Class to create a task queue based on the `setTimeout` method
 */


var TimeoutTaskQueue = function (_ITaskQueue3) {
    _inherits(TimeoutTaskQueue, _ITaskQueue3);

    /**
     * @constructor
     */
    function TimeoutTaskQueue() {
        _classCallCheck(this, TimeoutTaskQueue);

        var _this3 = _possibleConstructorReturn(this, (TimeoutTaskQueue.__proto__ || Object.getPrototypeOf(TimeoutTaskQueue)).call(this));

        _this3.mTimeoutHandle = null;
        return _this3;
    }

    /**
     * If set, invalidates the scheduled queue drain.
     *
     * @method destroy
     */


    _createClass(TimeoutTaskQueue, [{
        key: 'destroy',
        value: function destroy() {
            if (this.mTimeoutHandle !== null) {
                clearTimeout(this.mTimeoutHandle);
                this.mTimeoutHandle = null;
            }
            _get(TimeoutTaskQueue.prototype.__proto__ || Object.getPrototypeOf(TimeoutTaskQueue.prototype), 'destroy', this).call(this);
        }

        /**
         * Switches the drain flag and calls the super method.
         *
         * @method tick
         */

    }, {
        key: 'tick',
        value: function tick() {
            this.mTimeoutHandle = null;
            _get(TimeoutTaskQueue.prototype.__proto__ || Object.getPrototypeOf(TimeoutTaskQueue.prototype), 'tick', this).call(this);
        }

        /**
         * Schedules a queue drain.
         *
         * @method scheduleDrain
         */

    }, {
        key: 'scheduleDrain',
        value: function scheduleDrain() {
            if (this.mTimeoutHandle !== null) {
                this.mTimeoutHandle = setTimeout(this.mTickCallback, 0);
            }
        }
    }]);

    return TimeoutTaskQueue;
}(ITaskQueue);

/**
 * Exports a single function that uses the most viable implementation of the `nextTick` functionality or a function that
 * throws an error if no viable implementation is found.
 *
 * @export
 */


/* harmony default export */ __webpack_exports__["a"] = (function () {
    /* Node.js */
    if ((typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && process && typeof process.nextTick === 'function') {
        return process.nextTick;
    }

    var taskQueue = null;

    /* MutationObserver */
    if ((typeof document === 'undefined' ? 'undefined' : _typeof(document)) === 'object' && document) {
        if (typeof MutationObserver === 'function') {
            taskQueue = new ObserverTaskQueue(MutationObserver);
        } else if (typeof window.WebKitMutationObserver === 'function') {
            taskQueue = new ObserverTaskQueue(window.WebKitMutationObserver);
        }
    }

    /* fallback */
    if (!taskQueue) {
        if (typeof setImmediate === 'function') {
            taskQueue = new ImmediateTaskQueue();
        } else if (typeof setTimeout === 'function' || (typeof setTimeout === 'undefined' ? 'undefined' : _typeof(setTimeout)) === 'object') {
            taskQueue = new TimeoutTaskQueue();
        }
    }

    /* if a task queue was created, return a function wrapping it */
    if (taskQueue) {
        return function (task) {
            taskQueue.enqueue(task);
        };
    }

    /* if no viable implementation is found, throw an error every time `nextTick` is called */
    return function () {
        throw new Error('nextTick cannot be implemented on this system.');
    };
})();
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(166).clearImmediate, __webpack_require__(166).setImmediate, __webpack_require__(106)))

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Node_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Events_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__ = __webpack_require__(33);
/* unused harmony export CachedNode */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */





/**
 * Creates a node that uses an offscreen buffer to render its content, significantly improving rendering speed.
 * The content is only redrawn when there's a pixel change.
 *
 * @class CachedNode
 */
var CachedNode = function (_Node) {
    _inherits(CachedNode, _Node);

    /**
     * Creates an instance of CachedNode.
     * Since a backing buffer is used, the size of this node needs to be known at all times.
     *
     * @constructor
     * @param {Number|String} width - The width of this node.
     * @param {Number|String} height - The height of this node.
     */
    function CachedNode(width, height) {
        _classCallCheck(this, CachedNode);

        var _this = _possibleConstructorReturn(this, (CachedNode.__proto__ || Object.getPrototypeOf(CachedNode)).call(this, width, height));

        _this.mOffscreenCanvas = document.createElement('canvas');
        _this.mOffscreenContext = _this.mOffscreenCanvas.getContext('2d');
        _this.mDirty = false;

        _this.size.on(__WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this.size.safeBind(_this._handleSizeChanged, _this));
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(CachedNode, [{
        key: 'destroy',
        value: function destroy() {
            this.size.off(__WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this._handleSizeChanged, this);

            delete this.mOffscreenCanvas;
            delete this.mOffscreenContext;
            delete this.mDirty;

            _get(CachedNode.prototype.__proto__ || Object.getPrototypeOf(CachedNode.prototype), 'destroy', this).call(this);
        }

        /**
         * The device scale used to render this node's internal buffer.
         *
         * @type {Number}
         */

    }, {
        key: 'onEnter',


        /**
         * Called every time the object is added to the currently running scene graph.
         *
         * @method onEnter
         * @param {Symbol} reviContext - A unique symbol that identifies the rendering context of this object.
         */
        value: function onEnter(reviContext) {
            this.on(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GRAPHICS_NODE_NEEDS_REDRAW, this.safeBind(this._handleNeedsRedraw, this));
            this.mDirty = true;
            _get(CachedNode.prototype.__proto__ || Object.getPrototypeOf(CachedNode.prototype), 'onEnter', this).call(this, reviContext);
        }

        /**
         * Called when this objects is removed from the scene graph.
         *
         * @method onExit
         */

    }, {
        key: 'onExit',
        value: function onExit() {
            this.off(__WEBPACK_IMPORTED_MODULE_1__Events_js__["a" /* default */].GRAPHICS_NODE_NEEDS_REDRAW, this._handleNeedsRedraw, this);
            _get(CachedNode.prototype.__proto__ || Object.getPrototypeOf(CachedNode.prototype), 'onExit', this).call(this);
        }

        /**
         * Called every tick, drawing operations should be performed here.
         *
         * @method draw
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when drawing.
         */

    }, {
        key: 'draw',
        value: function draw(context) {
            var _this2 = this;

            for (var _len = arguments.length, varArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                varArgs[_key - 1] = arguments[_key];
            }

            if (this.mDirty) {
                this.mDirty = false;
                this.mOffscreenCanvas.width = this.pixelSize.width * this.deviceScale * this.globalScale;
                this.mOffscreenCanvas.height = this.pixelSize.height * this.deviceScale * this.globalScale;
                this.mOffscreenContext.setTransform(1, 0, 0, 1, 0, 0);
                this.mOffscreenContext.clearRect(0, 0, this.mOffscreenCanvas.width, this.mOffscreenCanvas.height);
                this.mOffscreenContext.scale(this.deviceScale * this.globalScale, this.deviceScale * this.globalScale);
                this.updateCache.apply(this, [this.mOffscreenContext, context].concat(varArgs));
                this.mChildren.forEach(function (child) {
                    child._pushTransform(_this2.mOffscreenContext);
                    child.draw.apply(child, [_this2.mOffscreenContext].concat(varArgs));
                    child._popTransform(_this2.mOffscreenContext);
                });
            }
            this.drawCache.apply(this, [this.mOffscreenCanvas, context].concat(varArgs));
        }

        /**
         * Called every time the cache needs to be updated, local drawing operations should be performed here.
         *
         * @method updateCache
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {CanvasRenderingContext2D} parentContext - The canvas contex to which this cached node is being drawn to.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when drawing.
         */

    }, {
        key: 'updateCache',
        value: function updateCache() /* context, parentContext, ...varArgs */{}
        /* override */


        /**
         * Called every time the cache needs to be drawn onto another context.
         *
         * @method drawCache
         * @param {HTMLCanvasElement} localCanvas - The local canvas that holds the pixel buffer to draw.
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when drawing.
         */

    }, {
        key: 'drawCache',
        value: function drawCache(localCanvas, context /* , ...varArgs */) {
            context.drawImage(localCanvas, 0, 0, this.pixelSize.width, this.pixelSize.height);
        }

        /**
         * When this node needs to be redrawn, this method is called and detects if the internal cache should be updated as well.
         *
         * @method _handleNeedsRedraw
         * @param {IBindable} sender - The instance that originally triggered this event.
         * @param {Symbol} reason - The reason why a redraw is needed, as described in the Node.REDRAW_* constants.
         * @param {Symbol|null} type - The type of update performed for the redraw to be needed, as described in the Node.MATRIX_UPDATE_* constants.
         * @private
         */

    }, {
        key: '_handleNeedsRedraw',
        value: function _handleNeedsRedraw(sender, reason) {
            var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            if (sender !== this || reason === __WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */].REDRAW_EXTERNAL_REQUEST || reason === __WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */].REDRAW_CHILD_ADDED || reason === __WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */].REDRAW_CHILD_REMOVED) {
                this.mDirty = true;
            } else if (reason === __WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */].REDRAW_TRANSFORMATION_CHANGE) {
                if (type === __WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */].MATRIX_UPDATE_SCALE || type === __WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */].MATRIX_UPDATE_SIZE || type === __WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */].MATRIX_UPDATE_PARENT_REQUEST) {
                    this.mDirty = true;
                }
            }
        }

        /**
         * When this node's size is modified, this method is called and also changes the size of the internal buffer.
         *
         * @method _handleSizeChanged
         * @param {*} sender - The instance that originally triggered this event.
         * @private
         */

    }, {
        key: '_handleSizeChanged',
        value: function _handleSizeChanged(sender) {
            if (sender === this.size) {
                this.mOffscreenCanvas.width = this.pixelSize.width * this.deviceScale * this.globalScale;
                this.mOffscreenCanvas.height = this.pixelSize.height * this.deviceScale * this.globalScale;
                if (this.running) {
                    this.mDirty = true;
                    this.needsRedraw();
                }
            }
        }
    }, {
        key: 'deviceScale',
        get: function get() {
            return _get(CachedNode.prototype.__proto__ || Object.getPrototypeOf(CachedNode.prototype), 'deviceScale', this);
        }

        /**
         * Sets the device scale used to render this node's internal buffer.
         *
         * @param {Number} value - The new device scale.
         */
        ,
        set: function set(value) {
            if (value !== this.deviceScale) {
                this.mDirty = true;
                this.needsRedraw();
            }
            _set(CachedNode.prototype.__proto__ || Object.getPrototypeOf(CachedNode.prototype), 'deviceScale', value, this);
        }

        /**
         * The global scale of this node.
         *
         * @type {Number}
         */

    }, {
        key: 'globalScale',
        get: function get() {
            return _get(CachedNode.prototype.__proto__ || Object.getPrototypeOf(CachedNode.prototype), 'globalScale', this);
        }

        /**
         * Sets the global scale of this node and its children. Usually this property should not be set manually.
         *
         * @param {Number} value - the new global scale of the node.
         */
        ,
        set: function set(value) {
            if (value !== this.globalScale) {
                this.mDirty = true;
                this.needsRedraw();
            }
            _set(CachedNode.prototype.__proto__ || Object.getPrototypeOf(CachedNode.prototype), 'globalScale', value, this);
        }
    }]);

    return CachedNode;
}(__WEBPACK_IMPORTED_MODULE_0__Node_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = CachedNode;

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Polyline_js__ = __webpack_require__(185);
/* unused harmony export Line */
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/**
 * Class used to draw a line from point A to point B.
 *
 * @class Line
 */
var Line = function (_Polyline) {
  _inherits(Line, _Polyline);

  /**
   * @param {Point} from - The point from which this line will be drawn.
   * @param {Point} to - The point to which this line will be drawn.
   * @param {Object} options - The rendering options for this object.
   */
  function Line(from, to, options) {
    _classCallCheck(this, Line);

    return _possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this, options, from, to));
  }

  return Line;
}(__WEBPACK_IMPORTED_MODULE_0__Polyline_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Line;

/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Primitive_js__ = __webpack_require__(60);
/* unused harmony export Rectangle */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/**
 * Utility class to draw a rectangle.
 *
 * @class Rectangle
 */
var Rectangle = function (_Primitive) {
    _inherits(Rectangle, _Primitive);

    /**
     * @param {Number|String} width - The width of the rectangle.
     * @param {Number|String} height - The height of the rectangle.
     * @param {Object=} options - An object containing the options to draw this primitive.
     * @constructor
     */
    function Rectangle(width, height, options) {
        _classCallCheck(this, Rectangle);

        var _this = _possibleConstructorReturn(this, (Rectangle.__proto__ || Object.getPrototypeOf(Rectangle)).call(this, options));

        _this.size.set(width, height);
        return _this;
    }

    /**
     * Renders the path of this shape to the context.
     *
     * @method _renderPath
     * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
     * @param {Object} options - The rendering options for this shape.
     * @private
     */


    _createClass(Rectangle, [{
        key: '_renderPath',
        value: function _renderPath(context, options) {
            var offset = 0;
            if (options.strokeType) {
                if (options.strokeType === Rectangle.STROKE_INNER) {
                    offset -= options.stroke * 0.5;
                } else if (options.strokeType === Rectangle.STROKE_OUTER) {
                    offset += options.stroke * 0.5;
                }
            }

            context.beginPath();
            context.rect(-offset, -offset, this.pixelSize.width + offset * 2, this.pixelSize.height + offset * 2);
            context.closePath();
        }
    }]);

    return Rectangle;
}(__WEBPACK_IMPORTED_MODULE_0__Primitive_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Rectangle;

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IObject_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__graphics_Canvas_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__graphics_Events_js__ = __webpack_require__(54);
/* unused harmony export Scheduler */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */





var __INSTANCES__ = new Map();

/**
 * Plugin used to schedule functions, equivalent to `setInterval` and `setTimeout` but this class makes sure that the
 * scheduled function timers are in sync with the rendering engine.
 *
 * @class Scheduler
 */
var Scheduler = function (_IObject) {
    _inherits(Scheduler, _IObject);

    _createClass(Scheduler, null, [{
        key: 'registerContext',

        /**
         * Registers a revi context and binds a new InputManager to it.
         *
         * @method registerContext
         * @param {Symbol} context - The revi context of the canvas.
         * @static
         */
        value: function registerContext(context) {
            if (__INSTANCES__.has(context)) {
                throw new Error('The context is already registered.');
            }

            var canvas = __WEBPACK_IMPORTED_MODULE_1__graphics_Canvas_js__["a" /* default */].getCanvasForContext(context);
            if (!canvas) {
                throw new Error('No canvas is registered for the provided context');
            }

            __INSTANCES__.set(context, new Scheduler(canvas));
        }

        /**
         * Unregisters a revi context and destroys the InputManager instance associated with it.
         *
         * @method unregisterContext
         * @param {Symbol} context - The revi context of the canvas.
         * @static
         */

    }, {
        key: 'unregisterContext',
        value: function unregisterContext(context) {
            var instance = __INSTANCES__.get(context);
            if (instance) {
                __INSTANCES__.delete(context);
                instance.release();
            } else {
                throw new Error('The context was never registered.');
            }
        }

        /**
         * Finds the InputManager linked to the provided context and returns it or null if not found.
         *
         * @method instanceForContext
         * @param {Symbol} context - The revi context to look for.
         * @returns {InputManager|null}
         * @static
         */

    }, {
        key: 'instanceForContext',
        value: function instanceForContext(context) {
            return __INSTANCES__.get(context) || null;
        }

        /**
         * @param {Canvas} canvas - The canvas to which the scheduled functions should be synced to.
         * @constructor
         */

    }]);

    function Scheduler(canvas) {
        _classCallCheck(this, Scheduler);

        var _this = _possibleConstructorReturn(this, (Scheduler.__proto__ || Object.getPrototypeOf(Scheduler)).call(this));

        _this.mCurrentTimer = 0;
        _this.mCanvas = canvas;
        _this.mMethods = [];
        _this.mMethodsScheduled = 0;
        _this.mTimeout = null;
        _this.mTimeoutStartTime = 0;
        _this.mTimeoutHandler = _this._handleTimeout.bind(_this);

        _this.mCanvas.on(__WEBPACK_IMPORTED_MODULE_2__graphics_Events_js__["a" /* default */].GRAPHICS_CANVAS_IDLE_STATE_CHANGED, _this.mCanvas.safeBind(_this._handleIdleStateChange, _this));
        _this.mCanvas.on(__WEBPACK_IMPORTED_MODULE_2__graphics_Events_js__["a" /* default */].GRAPHICS_CANVAS_PRE_UPDATE, _this.mCanvas.safeBind(_this._handleCanvasUpdate, _this));
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Scheduler, [{
        key: 'destroy',
        value: function destroy() {
            _get(Scheduler.prototype.__proto__ || Object.getPrototypeOf(Scheduler.prototype), 'destroy', this).call(this);
        }

        /**
         * Schedules a function to be called once after the specified delay. Returns a unique identifier that can be used to
         * cancel the scheduled function before it fires.
         *
         * @method scheduleTimeout
         * @param {Function} func - The function to call.
         * @param {Number} delay - The delay after which the function will be called.
         * @returns {Number}
         */

    }, {
        key: 'scheduleTimeout',
        value: function scheduleTimeout(func) {
            var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            return this._scheduleFunction(func, delay, false);
        }

        /**
         * Schedules a function to be repeatedly called at the specified interval. Returns a unique identifier that can be
         * used to cancel the scheduled function.
         *
         * @method scheduleInterval
         * @param {Function} func - The function to call.
         * @param {Number} interval - The time interval at which the function will be called.
         * @returns {Number}
         */

    }, {
        key: 'scheduleInterval',
        value: function scheduleInterval(func, interval) {
            return this._scheduleFunction(func, interval, true);
        }

        /**
         * Cancels the function scheduled with the specified id.
         *
         * @method cancel
         * @param {Number} id - The id of the function to cancel.
         */

    }, {
        key: 'cancel',
        value: function cancel(id) {
            var index = this.mMethods.findIndex(function (method) {
                return method.id === id;
            });
            if (index !== -1) {
                this.mMethods.splice(index, 1);

                var idle = this.mCanvas.idle;
                if (idle && this.mTimeout !== null) {
                    clearTimeout(this.mTimeout);
                    this.mTimeout = null;
                    if (this.mMethods.length) {
                        this.mCurrentTimer += Date.now() - this.mTimeoutStartTime;
                        this._scheduleTimeout();
                    } else {
                        this.mCurrentTimer = 0;
                    }
                }
            }
        }

        /**
         * Utility method to schedule a function to be called after a delay. Returns a unique identifier for the scheduled function.
         *
         * @method _scheduleFunction
         * @param {Function} func - The function to schedule.
         * @param {Number} delay - The delay after which the function will fire.
         * @param {Boolean} repeats - Should this function be re-scheduled after it fires.
         * @param {Number=} id - The id used to schedule the function. Optional.
         * @returns {Number}
         * @private
         */

    }, {
        key: '_scheduleFunction',
        value: function _scheduleFunction(func, delay, repeats) {
            var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

            var idle = this.mCanvas.idle;
            if (idle && this.mTimeout !== null) {
                this.mCurrentTimer += Date.now() - this.mTimeoutStartTime;
            }

            var targetTime = delay + this.mCurrentTimer;
            var container = {
                func: func,
                delay: delay,
                targetTime: targetTime,
                repeats: repeats,
                id: id !== null ? id : this.mMethodsScheduled++
            };

            var methods = this.mMethods;
            if (!methods.length) {
                methods.push(container);
            } else {
                var min = 0;
                var max = methods.length - 1;
                var mid = 0;

                if (targetTime <= methods[max].targetTime) {
                    methods.push(container);
                } else if (targetTime >= methods[min].targetTime) {
                    methods.unshift(container);
                } else {
                    while (min < max && min + 1 !== max) {
                        mid = min + Math.floor((max - min) * 0.5);
                        if (targetTime < methods[mid].targetTime) {
                            min = mid;
                        } else {
                            max = mid;
                        }
                    }
                    methods.splice(max, 0, container);
                }
            }

            if (idle) {
                if (this.mTimeout !== null) {
                    clearTimeout(this.mTimeout);
                    this.mTimeout = null;
                }
                this._scheduleTimeout();
            }

            return container.id;
        }

        /**
         * Schedules a timeout to be fired as soon as the next function in the queue should fire.
         *
         * @method _scheduleTimeout
         * @private
         */

    }, {
        key: '_scheduleTimeout',
        value: function _scheduleTimeout() {
            var nextTargetTime = this.mMethods[this.mMethods.length - 1].targetTime;
            this.mTimeout = setTimeout(this.mTimeoutHandler, nextTargetTime - this.mCurrentTimer);
            this.mTimeoutStartTime = Date.now();
        }

        /**
         * Handles changes of the idle state of the canvas linked to this scheduler.
         *
         * @method _handleIdleStateChange
         * @param {Canvas} sender - The canvas that triggered the event.
         * @param {Boolean} idle - Is the canvas idle.
         * @private
         */

    }, {
        key: '_handleIdleStateChange',
        value: function _handleIdleStateChange(sender, idle) {
            if (this.mMethods.length) {
                if (!idle && this.mTimeout !== null) {
                    clearTimeout(this.mTimeout);
                    this.mTimeout = null;
                    this.mCurrentTimer += Date.now() - this.mTimeoutStartTime;
                    this._executeFunctions();
                } else if (idle) {
                    this._scheduleTimeout();
                }
            }
        }

        /**
         * Handles the canvas update event.
         *
         * @method _handleCanvasUpdate
         * @param {Canvas} sender - The canvas that triggered the event.
         * @param {Number} delta - The amount of milliseconds since the last update.
         * @private
         */

    }, {
        key: '_handleCanvasUpdate',
        value: function _handleCanvasUpdate(sender, delta) {
            if (this.mMethods.length) {
                this.mCurrentTimer += Math.floor(delta);
                this._executeFunctions();
            }
        }

        /**
         * Handles a timeout scheduled by this scheduler.
         *
         * @method _handleTimeout
         * @private
         */

    }, {
        key: '_handleTimeout',
        value: function _handleTimeout() {
            this.mTimeout = null;
            var time = Date.now();
            this.mCurrentTimer += time - this.mTimeoutStartTime;
            this._executeFunctions();
            this.mCurrentTimer += Date.now() - time;
            if (this.mMethods.length) {
                this._scheduleTimeout();
            }
        }

        /**
         * Executes all timed out functions since the last time this function got called. Uses the internal timer variable to
         * calculate time outs.
         *
         * @method _executeFunctions
         * @private
         */

    }, {
        key: '_executeFunctions',
        value: function _executeFunctions() {
            var elapsedTime = this.mCurrentTimer;
            while (this.mMethods.length && this.mMethods[this.mMethods.length - 1].targetTime <= elapsedTime) {
                var container = this.mMethods.pop();
                container.func();
                if (container.repeats) {
                    this._scheduleFunction(container.func, container.delay, container.repeats, container.id);
                }
            }

            if (!this.mMethods.length) {
                this.mCurrentTimer = 0;
            }
        }
    }]);

    return Scheduler;
}(__WEBPACK_IMPORTED_MODULE_0__core_IObject_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Scheduler;

/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EasingTypes_js__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Events_js__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__graphics_Canvas_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__graphics_Events_js__ = __webpack_require__(54);
/* unused harmony export Easing */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */







var __CONTEXTS__ = new Map();

var EASING_OPTIONS_DEFAULTS = {
    type: __WEBPACK_IMPORTED_MODULE_1__EasingTypes_js__["a" /* default */].Linear,
    duration: 1000,
    startValue: 0,
    endValue: 1,
    amplitude: 1,
    period: 0.3,
    overshoot: 1.70158
};

/**
 * Simple easing class. Used as the base of more complex easing classes.
 *
 * @class Easing
 */
var Easing = function (_IBIndable) {
    _inherits(Easing, _IBIndable);

    _createClass(Easing, null, [{
        key: 'registerContext',

        /**
         * Registers a revi context and starts executing easing functions within it.
         *
         * @method registerContext
         * @param {Symbol} context - The revi context of the canvas.
         * @static
         */
        value: function registerContext(context) {
            if (__CONTEXTS__.has(context)) {
                throw new Error('The context is already registered.');
            }

            var canvas = __WEBPACK_IMPORTED_MODULE_3__graphics_Canvas_js__["a" /* default */].getCanvasForContext(context);
            if (!canvas) {
                throw new Error('No canvas is registered for the provided context');
            }

            __CONTEXTS__.set(context, new Set());

            canvas.on(__WEBPACK_IMPORTED_MODULE_4__graphics_Events_js__["a" /* default */].GRAPHICS_CANVAS_PRE_UPDATE, Easing.update);
        }

        /**
         * Unregisters a revi context and removes all easing functions from it.
         *
         * @method unregisterContext
         * @param {Symbol} context - The revi context of the canvas.
         * @static
         */

    }, {
        key: 'unregisterContext',
        value: function unregisterContext(context) {
            if (__CONTEXTS__.has(context)) {
                var easings = __CONTEXTS__.get(context);
                easings.clear();
                var canvas = __WEBPACK_IMPORTED_MODULE_3__graphics_Canvas_js__["a" /* default */].getCanvasForContext(context);
                if (canvas) {
                    canvas.off(__WEBPACK_IMPORTED_MODULE_4__graphics_Events_js__["a" /* default */].GRAPHICS_CANVAS_PRE_UPDATE, Easing.update);
                }

                __CONTEXTS__.delete(context);
            } else {
                throw new Error('The context was never registered.');
            }
        }

        /**
         * Schedules the specified easing to be updated during the next context update.
         *
         * @method scheduleEasing
         * @param {Symbol} context - The context to which the easing will be added.
         * @param {Easing} easing - Easing to add.
         * @returns {Boolean}
         * @static
         */

    }, {
        key: 'scheduleEasing',
        value: function scheduleEasing(context, easing) {
            if (__CONTEXTS__.has(context)) {
                var easings = __CONTEXTS__.get(context);
                if (!easings.has(easing)) {
                    easings.add(easing);
                    easing.retain();
                    return true;
                }
            }
            return false;
        }

        /**
         * Removes the specified easing from the provided context.
         *
         * @method removeEasing
         * @param {Symbol} context - the context from which the easing will be removed.
         * @param {Easing} easing - the easing to remove.
         * @returns {Boolean}
         * @static
         */

    }, {
        key: 'removeEasing',
        value: function removeEasing(context, easing) {
            if (__CONTEXTS__.has(context)) {
                var easings = __CONTEXTS__.get(context);
                if (easings.has(easing)) {
                    easings.delete(easing);
                    easing.autorelease();
                    return true;
                }
            }
            return false;
        }

        /**
         * Advances the easing functions attached to the specified canvas by delta time.
         *
         * @method update
         * @param {Canvas} canvas - The canvas to which the easing functions are attached.
         * @param {Number} delta - Delta time to advance the easing function by.
         */

    }, {
        key: 'update',
        value: function update(canvas, delta) {
            var instances = __CONTEXTS__.get(canvas.reviContext);
            instances.forEach(function (easing) {
                easing.update(delta);
            });
        }

        /**
         * @param {Symbol} context - The context this easing belongs to.
         * @param {Object} options - An object with options for this easing instance.
         * @constructor
         */

    }]);

    function Easing(context, options) {
        _classCallCheck(this, Easing);

        if (!__CONTEXTS__.has(context)) {
            throw new Error('You must register the easing plugin first by calling: Easing.registerContext(reviContext)');
        }

        var _this = _possibleConstructorReturn(this, (Easing.__proto__ || Object.getPrototypeOf(Easing)).call(this));

        _this.mContext = context;
        _this.mOptions = Object.assign({}, EASING_OPTIONS_DEFAULTS, options);
        _this.mElapsed = 0;
        _this.mProgress = 0;
        _this.mArguments = _this._buildArguments(_this.mOptions);
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Easing, [{
        key: 'destroy',
        value: function destroy() {
            if (__CONTEXTS__.has(this.mContext)) {
                var easings = __CONTEXTS__.get(this.mContext);
                easings.delete(this);
            }

            delete this.mContext;
            delete this.mOptions;
            delete this.mElapsed;
            delete this.mArguments;

            _get(Easing.prototype.__proto__ || Object.getPrototypeOf(Easing.prototype), 'destroy', this).call(this);
        }

        /**
         * The context of this easing object.
         *
         * @type {Symbol}
         */

    }, {
        key: 'start',


        /**
         * Starts updating this easing within its context.
         *
         * @method start
         */
        value: function start() {
            if (Easing.scheduleEasing(this.mContext, this)) {
                if (this.mElapsed === 0) {
                    this.emit(__WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].EASING_START, this);
                } else {
                    var _mOptions;

                    this.mProgress = (_mOptions = this.mOptions).type.apply(_mOptions, [this.mElapsed].concat(_toConsumableArray(this.mArguments)));
                    this.emit(__WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].EASING_CONTINUE, this, this.mProgress);
                }
            }
        }

        /**
         * Stops updating this easing within its context.
         *
         * @method stop
         */

    }, {
        key: 'stop',
        value: function stop() {
            if (Easing.removeEasing(this.mContext, this)) {
                this.emit(__WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].EASING_STOP, this, this.mProgress);
            }
        }

        /**
         * Resets this easing so it can be reused.
         *
         * @method reset.
         */

    }, {
        key: 'reset',
        value: function reset() {
            this.mProgress = 0;
            this.mElapsed = 0;
        }

        /**
         * Called every tick this easing needs to be updated.
         *
         * @method update
         * @param {Number} delta - The delta time since the last update.
         * @returns {Number}
         */

    }, {
        key: 'update',
        value: function update(delta) {
            if (this.mElapsed < this.mOptions.duration) {
                var _mOptions2;

                this.mElapsed = Math.min(this.mElapsed + delta, this.mOptions.duration);
                this.mProgress = (_mOptions2 = this.mOptions).type.apply(_mOptions2, [this.mElapsed].concat(_toConsumableArray(this.mArguments)));
                this._performUpdate(this.mProgress);
                if (this.mElapsed === this.mOptions.duration) {
                    Easing.removeEasing(this.mContext, this);
                    this.emit(__WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].EASING_END, this);
                }
                return this.mProgress;
            }
            return 1;
        }

        /**
         * Called every time the easing is updated and should perform any complex tasks assigned to this easing.
         *
         * @method _performUpdate
         * @param {Number} progress - The current progress of this easing, represents the result of the easing function configured.
         * @private
         */

    }, {
        key: '_performUpdate',
        value: function _performUpdate(progress) {
            var valueChange = this.mOptions.endValue - this.mOptions.startValue;
            this.emit(__WEBPACK_IMPORTED_MODULE_2__Events_js__["a" /* default */].EASING_UPDATE, this, progress, this.mOptions.startValue + valueChange * progress);
        }

        /**
         * Builds the arguments needed for the easing function configured.
         *
         * @method _buildArguments
         * @param {Object} options - This easing's options.
         * @returns {Array}
         * @private
         */

    }, {
        key: '_buildArguments',
        value: function _buildArguments(options) {
            var args = [];

            args.push(options.duration);
            args.push(0);
            args.push(1);

            if (options.type === __WEBPACK_IMPORTED_MODULE_1__EasingTypes_js__["a" /* default */].Elastic.EaseIn || options.type === __WEBPACK_IMPORTED_MODULE_1__EasingTypes_js__["a" /* default */].Elastic.EaseOut || options.type === __WEBPACK_IMPORTED_MODULE_1__EasingTypes_js__["a" /* default */].Elastic.EaseInOut) {
                args.push(options.amplitude);
                args.push(options.period);
            } else if (options.type === __WEBPACK_IMPORTED_MODULE_1__EasingTypes_js__["a" /* default */].Back.EaseIn || options.type === __WEBPACK_IMPORTED_MODULE_1__EasingTypes_js__["a" /* default */].Back.EaseOut || options.type === __WEBPACK_IMPORTED_MODULE_1__EasingTypes_js__["a" /* default */].Back.EaseInOut) {
                args.push(options.overshoot);
            }

            return args;
        }
    }, {
        key: 'context',
        get: function get() {
            return this.mContext;
        }

        /**
         * The time elapsed since this easing was started.
         *
         * @type {Number}
         */

    }, {
        key: 'elapsed',
        get: function get() {
            return this.mElapsed;
        }

        /**
         * The progress of this easing, reflects the easing type applied.
         *
         * @type {Number}
         */

    }, {
        key: 'progress',
        get: function get() {
            return this.mProgress;
        }
    }]);

    return Easing;
}(__WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Easing;

/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export EasingTypes */
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var PI_T_2 = 6.28318530717959; /* PI * 2 */

/** THIS METHODS ARE CRAFTED FOR PERFORMANCE, NOT TO BE PRETTY CODE :( **/
/* eslint-disable */

/**
 * Object containing the different easing types supported by revi's easing plugin.
 * NOTE: This functions don't really need a `start` and `change` parameters since the easing plugin always uses 0 and 1
 * respectively, but I left the arguments for reusability's sake. That being said a bit of performance can be squeezed
 * by removing the arguments from the implementation. Don't expecy huge gains though, unless easing is being heavily used
 * in the project.
 *
 * @type {Object}
 */
var EasingTypes = {
    Linear: function LinearEasing(time, duration, start, change) {
        return change * time / duration + start;
    },

    Quadratic: {
        EaseIn: function QuadraticEaseIn(time, duration, start, change) {
            time /= duration;
            return change * time * time + start;
        },

        EaseOut: function QuadraticEaseOut(time, duration, start, change) {
            time /= duration;
            return -change * time * (time - 2) + start;
        },

        EaseInOut: function quadraticEaseInOut(time, duration, start, change) {
            if ((time /= duration * 0.5) < 1) return change * 0.5 * time * time + start;
            --time;
            return -change * 0.5 * (time * (time - 2) - 1) + start;
        }
    },

    Cubic: {
        EaseIn: function CubicEaseIn(time, duration, start, change) {
            time /= duration;
            return change * time * time * time + start;
        },

        EaseOut: function CubicEaseOut(time, duration, start, change) {
            time /= duration;
            --time;
            return change * (time * time * time + 1) + start;
        },

        EaseInOut: function CubicEaseInOut(time, duration, start, change) {
            time /= duration / 2;
            if (time < 1) return change / 2 * time * time * time + start;
            time -= 2;
            return change / 2 * (time * time * time + 2) + start;
        }
    },

    Quartic: {
        EaseIn: function QuarticEaseIn(time, duration, start, change) {
            time /= duration;
            return change * time * time * time * time + start;
        },

        EaseOut: function QuarticEaseOut(time, duration, start, change) {
            time /= duration;
            --time;
            return -change * (time * time * time * time - 1) + start;
        },

        EaseInOut: function QuarticEaseInOut(time, duration, start, change) {
            time /= duration / 2;
            if (time < 1) return change / 2 * time * time * time * time + start;
            time -= 2;
            return -change / 2 * (time * time * time * time - 2) + start;
        }
    },

    Quintic: {
        EaseIn: function QuinticEaseIn(time, duration, start, change) {
            time /= duration;
            return change * time * time * time * time * time + start;
        },

        EaseOut: function QuinticEaseOut(time, duration, start, change) {
            time /= duration;
            --time;
            return change * (time * time * time * time * time + 1) + start;
        },

        EaseInOut: function QuinticEaseInOut(time, duration, start, change) {
            time /= duration / 2;
            if (time < 1) return change / 2 * time * time * time * time * time + start;
            time -= 2;
            return change / 2 * (time * time * time * time * time + 2) + start;
        }
    },

    Sinusoidal: {
        EaseIn: function SinusoidalEaseIn(time, duration, start, change) {
            return -change * Math.cos(time / duration * (Math.PI / 2)) + change + start;
        },

        EaseOut: function SinusoidalEaseOut(time, duration, start, change) {
            return change * Math.sin(time / duration * (Math.PI / 2)) + start;
        },

        EaseInOut: function SinusoidalEaseInOut(time, duration, start, change) {
            return -change / 2 * (Math.cos(Math.PI * time / duration) - 1) + start;
        }
    },

    Exponential: {
        EaseIn: function ExponentialEaseIn(time, duration, start, change) {
            return change * Math.pow(2.0, 10.0 * (time / duration - 1)) + start;
        },

        EaseOut: function ExponentialEaseOut(time, duration, start, change) {
            return change * (-Math.pow(2.0, -10.0 * time / duration) + 1.0) + start;
        },

        EaseInOut: function ExponentialEaseInOut(time, duration, start, change) {
            time /= duration / 2;
            if (time < 1) return change / 2 * Math.pow(2.0, 10.0 * (time - 1.0)) + start;
            --time;
            return change / 2 * (-Math.pow(2.0, -10.0 * time) + 2.0) + start;
        }
    },

    Circular: {
        EaseIn: function CircularEaseIn(time, duration, start, change) {
            time /= duration;
            return -change * (Math.sqrt(1 - time * time) - 1) + start;
        },

        EaseOut: function CircularEaseOut(time, duration, start, change) {
            time /= duration;
            --time;
            return change * Math.sqrt(1 - time * time) + start;
        },

        EaseInOut: function CircularEaseInOut(time, duration, start, change) {
            time /= duration / 2;
            if (time < 1) return -change / 2 * (Math.sqrt(1 - time * time) - 1) + start;
            time -= 2;
            return change / 2 * (Math.sqrt(1 - time * time) + 1) + start;
        }
    },

    Elastic: {
        EaseIn: function ElasticEaseIn(time, duration, start, change, amplitude, period) {
            var s = void 0;
            if (time === 0) return start;if ((time /= duration) === 1) return start + change;if (!period) period = duration * 0.3;
            if (!amplitude || change > 0 && amplitude < change || change < 0 && amplitude < -change) {
                amplitude = change;s = period / 4;
            } else s = period / PI_T_2 * Math.asin(change / amplitude);
            time -= 1;
            return -(amplitude * Math.pow(2, 10 * time) * Math.sin((time * duration - s) * PI_T_2 / period)) + start;
        },

        EaseOut: function ElasticEaseOut(time, duration, start, change, amplitude, period) {
            var s = void 0;
            if (time === 0) return start;if ((time /= duration) === 1) return start + change;if (!period) period = duration * 0.3;
            if (!amplitude || change > 0 && amplitude < change || change < 0 && amplitude < -change) {
                amplitude = change;s = period / 4;
            } else s = period / PI_T_2 * Math.asin(change / amplitude);
            return amplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s) * PI_T_2 / period) + change + start;
        },

        EaseInOut: function ElasticEaseInOut(time, duration, start, change, amplitude, period) {
            var s = void 0;
            if (time === 0) return start;if ((time /= duration * 0.5) === 2) return start + change;if (!period) period = duration * (0.3 * 1.5);
            if (!amplitude || change > 0 && amplitude < change || change < 0 && amplitude < -change) {
                amplitude = change;s = period / 4;
            } else s = period / PI_T_2 * Math.asin(change / amplitude);
            if (time < 1) {
                --time;
                return -0.5 * (amplitude * Math.pow(2, 10 * time) * Math.sin((time * duration - s) * PI_T_2 / period)) + start;
            }
            --time;
            return amplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s) * PI_T_2 / period) * 0.5 + change + start;
        }
    },

    Back: {
        EaseIn: function BackEaseIn(time, duration, start, change, overshoot) {
            time /= duration;
            return change * time * time * ((overshoot + 1) * time - overshoot) + start;
        },

        EaseOut: function BackEaseOut(time, durartion, start, change, overshoot) {
            time = time / durartion - 1;
            return change * (time * time * ((overshoot + 1) * time + overshoot) + 1) + start;
        },

        EaseInOut: function BackEaseInOut(time, duration, start, change, overshoot) {
            if ((time /= duration * 0.5) < 1) {
                overshoot *= 1.525;
                return change * 0.5 * (time * time * ((overshoot + 1) * time - overshoot)) + start;
            }
            overshoot *= 1.525;
            time -= 2;
            return change / 2 * (time * time * ((overshoot + 1) * time + overshoot) + 2) + start;
        }
    },

    Bounce: {
        EaseIn: function EaseIn(time, duration, start, change) {
            return change - EasingTypes.Bounce.EaseOut(duration - time, 0, change, duration) + start;
        },

        EaseOut: function EaseOut(time, duration, start, change) {
            if ((time /= duration) < 1 / 2.75) {
                return change * (7.5625 * time * time) + start;
            } else if (time < 2 / 2.75) {
                return change * (7.5625 * (time -= 1.5 / 2.75) * time + 0.75) + start;
            } else if (time < 2.5 / 2.75) {
                return change * (7.5625 * (time -= 2.25 / 2.75) * time + 0.9375) + start;
            } else {
                return change * (7.5625 * (time -= 2.625 / 2.75) * time + 0.984375) + start;
            }
        },

        EaseInOut: function EaseInOut(time, duration, start, change) {
            if (time < duration / 2) return EasingTypes.Bounce.EaseIn(time * 2, 0, change, duration) * 0.5 + start;
            return EasingTypes.Bounce.EaseOut(time * 2 - duration, 0, change, duration) * 0.5 + change * 0.5 + start;
        }
    }
};

/** THIS METHODS ARE CRAFTED FOR PERFORMANCE, NOT TO BE PRETTY CODE :( **/
/* eslint-enable */

/* harmony default export */ __webpack_exports__["a"] = EasingTypes;

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var Events = {
  EASING_UPDATE: 'Easing::Update',
  EASING_START: 'Easing::Start',
  EASING_CONTINUE: 'Easing::Continue',
  EASING_END: 'Easing::End',
  EASING_STOP: 'Easing::Stop'
};

/* harmony default export */ __webpack_exports__["a"] = Events;

/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var Events = {
  TEXT_LABEL_WILL_RENDER: 'Text::LabelWillRender',
  TEXT_LABEL_RENDERED: 'Text::LabelRendered'
};

/* harmony default export */ __webpack_exports__["a"] = Events;

/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__graphics_CachedNode_js__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__FontManager_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Events_js__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geometry_Size_js__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geometry_Point_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Line_js__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Word_js__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_opentype_js_src_opentype_js__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_opentype_js_src_opentype_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_opentype_js_src_opentype_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_nextTick_js__ = __webpack_require__(111);
/* unused harmony export Label */
var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */












/**
 * Text alignment types.
 *
 * @type {{LEFT: Symbol, CENTER: Symbol, RIGHT: Symbol}}
 */
var TEXT_ALIGNMENT = {
    'LEFT': Symbol('LEFT'),
    'CENTER': Symbol('CENTER'),
    'RIGHT': Symbol('RIGHT')
};
Object.freeze(TEXT_ALIGNMENT);

/**
 * Text truncating types.
 *
 * @type {{TRUNCATE: Symbol, AUTO_FIT: Symbol, ELLIPSES: Symbol}}
 */
var TEXT_TRUNCATING_MODE = {
    'TRUNCATE': Symbol('TRUNCATE'),
    'AUTO_FIT': Symbol('AUTO_FIT'),
    'ELLIPSES': Symbol('ELLIPSES')
};
Object.freeze(TEXT_TRUNCATING_MODE);

/**
 * Multi-line text types.
 *
 * @type {{AS_IS: Symbol, AUTO_LINES: Symbol, SINGLE_LINE: Symbol}}
 */
var TEXT_MULTI_LINE_MODE = {
    'AS_IS': Symbol('AS_IS'),
    'AUTO_LINES': Symbol('AUTO_LINES'),
    'SINGLE_LINE': Symbol('SINGLE_LINE')
};
Object.freeze(TEXT_MULTI_LINE_MODE);

/**
 * Text rendering backend.
 *
 * @type {{CANVAS: Symbol, SVG: Symbol, SVG_OPTIMIZE_SPEED: Symbol, SVG_CRISP_EDGES: Symbol, SVG_GEOMETRIC_PRECISION: Symbol}}
 */
var TEXT_RENDERING_BACKEND = {
    'CANVAS': Symbol('CANVAS'),
    'SVG': Symbol('SVG'),
    'SVG_OPTIMIZE_SPEED': Symbol('SVG_OPTIMIZE_SPEED'),
    'SVG_CRISP_EDGES': Symbol('SVG_CRISP_EDGES'),
    'SVG_GEOMETRIC_PRECISION': Symbol('SVG_GEOMETRIC_PRECISION')
};
Object.freeze(TEXT_RENDERING_BACKEND);

/**
 * Default label rendering types.
 *
 * @type {Object}
 */
var DefaultLabelOptions = {
    fontSize: 10,
    color: '#000000',
    alignment: TEXT_ALIGNMENT.LEFT,
    multiLineMode: TEXT_MULTI_LINE_MODE.AS_IS,
    truncateMode: TEXT_TRUNCATING_MODE.TRUNCATE,
    tracking: 0,
    autoSize: false,
    renderShadow: false,
    shadowColor: '#000000',
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowBlur: 5,
    renderingBackend: TEXT_RENDERING_BACKEND.CANVAS
};
Object.freeze(DefaultLabelOptions);

/**
 * Class that represents and renders text in its determined label space.
 */
var Label = function (_CachedNode) {
    _inherits(Label, _CachedNode);

    _createClass(Label, null, [{
        key: 'TEXT_ALIGNMENT',

        /**
         * Text alignment types.
         *
         * @type {{LEFT: Symbol, CENTER: Symbol, RIGHT: Symbol}}
         * @readonly
         */
        get: function get() {
            return TEXT_ALIGNMENT;
        }

        /**
         * Text truncating types.
         *
         * @type {{TRUNCATE: Symbol, AUTO_FIT: Symbol, ELLIPSES: Symbol}}
         * @readonly
         */

    }, {
        key: 'TEXT_TRUNCATING_MODE',
        get: function get() {
            return TEXT_TRUNCATING_MODE;
        }

        /**
         * Multi-line text types.
         *
         * @type {{AS_IS: Symbol, AUTO_LINES: Symbol, SINGLE_LINE: Symbol}}
         * @readonly
         */

    }, {
        key: 'TEXT_MULTI_LINE_MODE',
        get: function get() {
            return TEXT_MULTI_LINE_MODE;
        }

        /**
         * Text rendering backend.
         *
         * @type {{CANVAS: Symbol, SVG: Symbol, SVG_OPTIMIZE_SPEED: Symbol, SVG_CRISP_EDGES: Symbol, SVG_GEOMETRIC_PRECISION: Symbol}}
         */

    }, {
        key: 'TEXT_RENDERING_BACKEND',
        get: function get() {
            return TEXT_RENDERING_BACKEND;
        }

        /**
         * Returns a copy of the default rendering options for labels.
         *
         * @returns {Object}
         * @readonly
         */

    }, {
        key: 'DefaultLabelOptions',
        get: function get() {
            return Object.assign({}, DefaultLabelOptions);
        }

        /**
         * @param {Number} width - The max width of this label.
         * @param {Number} height - The max height of this label.
         * @param {String} text - The text to render on this label.
         * @param {String} fontKey - The key, in the font manager, of the font to use.
         * @param {String=} fontURL - The font to load, if it hasn't been loaded yet. URL or Base64.
         * @param {Object=} options - The rendering options for this label.
         * @constructor
         */

    }]);

    function Label(width, height, text, fontKey) {
        var fontURL = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

        _classCallCheck(this, Label);

        var _this = _possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).call(this, 0, 0));

        _this.mMaxSize = new __WEBPACK_IMPORTED_MODULE_4__geometry_Size_js__["a" /* default */](width, height);
        _this.mEffectsSize = new __WEBPACK_IMPORTED_MODULE_4__geometry_Size_js__["a" /* default */](width, height);
        _this.mEffectsOffset = new __WEBPACK_IMPORTED_MODULE_5__geometry_Point_js__["a" /* default */](0, 0);
        _this.mText = text;
        _this.mFont = null;
        _this.mOptions = Object.assign({}, DefaultLabelOptions, options);
        _this.mMinDeviceScale = 2;

        if (!_this.mOptions.autoSize) {
            _this.size.set(width, height);
        }
        _this.maxSize.on(__WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this.maxSize.safeBind(_this._handleMaxSizeChanged, _this));
        _this._loadFont(fontKey, fontURL);
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Label, [{
        key: 'destroy',
        value: function destroy() {
            this.maxSize.off(__WEBPACK_IMPORTED_MODULE_2__geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this._handleMaxSizeChanged, this);

            this.mMaxSize.release();
            this.mEffectsSize.release();
            this.mEffectsOffset.release();

            delete this.mMaxSize;
            delete this.mEffectsSize;
            delete this.mEffectsOffset;
            delete this.mText;
            delete this.mFont;
            delete this.mOptions;

            _get(Label.prototype.__proto__ || Object.getPrototypeOf(Label.prototype), 'destroy', this).call(this);
        }

        /**
         * The font used to render this label.
         *
         * @type {Font}
         * @readonly
         */

    }, {
        key: 'needsRedraw',


        /**
         * Notifies the rendering system that this node needs to be redrawn to properly display its updated state.
         *
         * @method needsRedraw
         */
        value: function needsRedraw() {
            this.emit(__WEBPACK_IMPORTED_MODULE_3__Events_js__["a" /* default */].TEXT_LABEL_WILL_RENDER, this);
            _get(Label.prototype.__proto__ || Object.getPrototypeOf(Label.prototype), 'needsRedraw', this).call(this);
        }

        /**
         * Called every time the cache needs to be updated, local drawing operations should be performed here.
         *
         * @method updateCache
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {CanvasRenderingContext2D} parentContext - The canvas context to which this cached node is being drawn to.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when drawing.
         */

    }, {
        key: 'updateCache',
        value: function updateCache(context, parentContext) {
            var _get2;

            if (this.mFont && this.mText) {
                var options = this.mOptions;
                var font = this.mFont;
                var fontSize = options.fontSize;
                var tracking = options.tracking;

                var hhea = font.tables.hhea;
                var fontScale = fontSize / font.unitsPerEm;
                var words = this._extractWords();
                var spaceWidth = font.charToGlyph(' ').advanceWidth + tracking;
                var lineHeight = hhea.ascender - hhea.descender;
                var lines = this._buildLines(lineHeight, fontScale, words, spaceWidth);

                var alignment = options.alignment;
                var left = TEXT_ALIGNMENT.LEFT;
                var center = TEXT_ALIGNMENT.CENTER;
                var right = TEXT_ALIGNMENT.RIGHT;
                var textPath = new __WEBPACK_IMPORTED_MODULE_8_opentype_js_src_opentype_js__["Path"]();
                var offsetX = 1;
                var offsetY = lines.length ? lines[0].minBaseline * fontScale : 1;

                textPath.fill = null;
                textPath.stroke = null;

                /* blah... */
                var computedWidth = Math.min(this.mMaxSize.width, lines.reduce(function (width, line) {
                    return Math.max(width, line.emWidth);
                }, 0) * fontScale);
                var width = options.autoSize ? computedWidth : this.mMaxSize.width;
                var canvasCenter = width * 0.5;

                lines.forEach(function (line) {
                    var lineWidth = line.emWidth * fontScale;

                    if (alignment === left) {
                        offsetX = line.offsetLeft * fontScale;
                    } else if (alignment === center) {
                        offsetX = canvasCenter - (line.emWidth - line.offsetLeft) * fontScale * 0.5;
                    } else if (alignment === right) {
                        offsetX = width - lineWidth;
                    }

                    line.addToPath(textPath, fontSize, fontScale, offsetX, offsetY);
                    offsetY += lineHeight * fontScale;
                });

                var bb = textPath.getBoundingBox();
                var bbWidth = bb.x2 - bb.x1;
                var bbHeight = bb.y2 - bb.y1;
                this.mBoundingBox.set(bb.x1, bb.y1, bbWidth, bbHeight);

                if (options.autoSize) {
                    this._autoSize(bbWidth + 2, bbHeight + 2, context, parentContext, options);
                }
                this._renderPath(textPath, context, options);
                this.emit(__WEBPACK_IMPORTED_MODULE_3__Events_js__["a" /* default */].TEXT_LABEL_RENDERED, this, context, parentContext);
            }

            for (var _len = arguments.length, varArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                varArgs[_key - 2] = arguments[_key];
            }

            (_get2 = _get(Label.prototype.__proto__ || Object.getPrototypeOf(Label.prototype), 'updateCache', this)).call.apply(_get2, [this, context].concat(varArgs));
        }

        /**
         * Called every time the cache needs to be drawn onto another context.
         *
         * @method drawCache
         * @param {HTMLCanvasElement} localCanvas - The local canvas that holds the pixel buffer to draw.
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when drawing.
         */

    }, {
        key: 'drawCache',
        value: function drawCache(localCanvas, context /* , ...varArgs */) {
            context.drawImage(localCanvas, -this.mEffectsOffset.x, -this.mEffectsOffset.y, this.mEffectsSize.width, this.mEffectsSize.height);
        }

        /**
         * When configured, autosizes this label to fit it's contents and effects.
         *
         * @method _autoSize
         * @param {Number} width - The new expected width of the label.
         * @param {Number} height - the expected height of the label.
         * @param {CanvasRenderingContext2D} context - The context where the label will be drawn.
         * @param {CanvasRenderingContext2D} parentContext - The canvas context to which this cached node is being drawn to.
         * @param {Object} options - The drawing options of this label.
         * @private
         */

    }, {
        key: '_autoSize',
        value: function _autoSize(width, height, context, parentContext, options) {
            /* resize the element */
            this._popTransform(parentContext);
            this.size.value1 = width;
            this.size.value2 = height;
            this._updateMatrix();
            this._pushTransform(parentContext);

            /* calculate the new canvas size */
            this.mEffectsSize.set(width, height);

            if (options.renderShadow) {
                this.mEffectsOffset.x = Math.max(options.shadowBlur - options.shadowOffsetX, 0);
                this.mEffectsSize.width += options.shadowBlur + Math.max(options.shadowBlur, Math.abs(options.shadowOffsetX));

                this.mEffectsOffset.y = Math.max(options.shadowBlur - options.shadowOffsetY, 0);
                this.mEffectsSize.height += options.shadowBlur + Math.max(options.shadowBlur, Math.abs(options.shadowOffsetY));
            } else {
                this.mEffectsOffset.set(0, 0);
            }

            this.mOffscreenCanvas.width = this.mEffectsSize.width * this.deviceScale * this.globalScale;
            this.mOffscreenCanvas.height = this.mEffectsSize.height * this.deviceScale * this.globalScale;

            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0, 0, this.mOffscreenCanvas.width, this.mOffscreenCanvas.height);
            context.scale(this.deviceScale * this.globalScale, this.deviceScale * this.globalScale);
            context.translate(this.mEffectsOffset.x, this.mEffectsOffset.y);
        }

        /**
         * Extracts the words from the given text, using the font and tracking provided.
         * NOTE: The returned array contains autoreleased `Word` instances. If the words will be saved for later use, call
         * `retain` on each one of them.
         *
         * @method _extractWords
         * @returns {Word[]}
         * @private
         */

    }, {
        key: '_extractWords',
        value: function _extractWords() {
            var font = this.mFont;
            var text = this.mText;
            var tracking = this.mOptions.tracking;
            var words = [];
            var char = void 0;
            var wordText = '';

            for (var i = 0, n = text.length; i < n; ++i) {
                char = text[i];
                if (char === ' ') {
                    if (wordText !== '') {
                        words.push(__WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].instance(wordText, font, tracking));
                        wordText = '';
                    }
                    words.push(__WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].SPACE_WORD);
                } else if (char === '\n' || char === '\r' || char === '\x03') {
                    if (wordText !== '') {
                        words.push(__WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].instance(wordText, font, tracking));
                        wordText = '';
                    }
                    words.push(__WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].LINE_BREAK_WORD);
                } else {
                    wordText += char;
                }
            }

            if (wordText !== '') {
                words.push(__WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].instance(wordText, font, tracking));
            }

            return words;
        }

        /**
         * Builds the text lines for this label using the options provided.
         *
         * @method _buildLines
         * @param {Number} lineHeight - The height, in ems, of a line of text.
         * @param {Number} scale - The desired font size scale.
         * @param {Word[]} words - An array of words to distribute in lines.
         * @param {Number} spaceWidth - The width, in ems, of a space character.
         * @returns {Line[]}
         * @private
         */

    }, {
        key: '_buildLines',
        value: function _buildLines(lineHeight, scale, words, spaceWidth) {
            var options = this.mOptions;
            if (options.truncateMode === TEXT_TRUNCATING_MODE.AUTO_FIT) {
                throw new Error('Truncating mode not implemented yet');
            }

            var width = this.mMaxSize.width;
            var height = this.mMaxSize.height;

            var lines = [];
            var asIsLineBreak = options.multiLineMode === TEXT_MULTI_LINE_MODE.AS_IS;
            var singleLine = options.multiLineMode === TEXT_MULTI_LINE_MODE.SINGLE_LINE;
            var addEllipses = options.truncateMode === TEXT_TRUNCATING_MODE.ELLIPSES;
            var targetEmWidth = width / scale;
            var targetEmHeight = height / scale;
            var emHeight = 0;
            var line = null;
            var word = null;
            var isLastLine = false;

            for (var i = 0, n = words.length; i < n; ++i) {
                if (!line) {
                    emHeight += lineHeight;
                    isLastLine = singleLine || emHeight + lineHeight > targetEmHeight;
                    line = __WEBPACK_IMPORTED_MODULE_6__Line_js__["a" /* default */].instance(spaceWidth);
                }

                word = words[i];
                if (word === __WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].LINE_BREAK_WORD && singleLine) {
                    word = __WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].SPACE_WORD;
                }

                if (word === __WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].LINE_BREAK_WORD || (!asIsLineBreak || isLastLine) && word !== __WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].SPACE_WORD && line.emWidth + word.emWidth > targetEmWidth) {
                    if (isLastLine) {
                        if (addEllipses) {
                            var periodGlyph = this.mFont.charToGlyph('.');
                            var ellipsesEmWidth = periodGlyph.advanceWidth * 3 + options.tracking * 2;
                            if (line.emWidth + ellipsesEmWidth < targetEmWidth) {
                                line.addWord(word);
                            }
                            line.addEllipses(targetEmWidth, this.mFont, options.tracking);
                        }
                        break;
                    } else {
                        line.trimBlankSpace();
                        lines.push(line);
                        line = null;
                        i = word === __WEBPACK_IMPORTED_MODULE_7__Word_js__["a" /* default */].LINE_BREAK_WORD ? i : i - 1;
                        continue;
                    }
                }

                line.addWord(word);
            }

            if (line) {
                line.trimBlankSpace();
                lines.push(line);
            }

            return lines;
        }

        /**
         * Loads a font from/into the font manager and triggers a re-render of this label when done.
         *
         * @method _loadfont
         * @param {String} fontKey - The key of the font in the font manager.
         * @param {String} fontURL - The URL or Base64 encoded string from which the font should be loaded.
         * @private
         */

    }, {
        key: '_loadFont',
        value: function _loadFont(fontKey, fontURL) {
            var _this2 = this;

            var fontManager = __WEBPACK_IMPORTED_MODULE_1__FontManager_js__["a" /* default */].sharedInstance();
            this.mFont = fontManager.fontCache[fontKey];
            if (this.mFont) {
                this.needsRedraw();
            } else {
                if (fontURL !== null) {
                    fontManager.loadFont(fontURL, fontKey).then(function (font) {
                        /* handle the case where the object could have been destroyed before the font was loaded */
                        if (_this2.retainCount > 0) {
                            _this2.mFont = font;
                            _this2.needsRedraw();
                        }
                    });
                } else {
                    throw new Error('The font ' + fontKey + ' has not been loaded loaded and a URL was not provided.');
                }
            }
        }

        /**
         * Renders the given text path into the specified context using the specified options.
         *
         * @method _renderPath
         * @param {Path} path - The path to render.
         * @param {CanvasRenderingContext2D} context - The context to which the text will be rendered.
         * @param {Object} options - The rendering options of this label.
         * @private
         */

    }, {
        key: '_renderPath',
        value: function _renderPath(path, context, options) {
            var _this3 = this;

            if (options.renderingBackend === TEXT_RENDERING_BACKEND.CANVAS) {
                path.draw(context);

                if (options.renderShadow) {
                    context.shadowColor = options.shadowColor;
                    context.shadowOffsetX = options.shadowOffsetX * this.deviceScale * this.globalScale;
                    context.shadowOffsetY = options.shadowOffsetY * this.deviceScale * this.globalScale;
                    context.shadowBlur = options.shadowBlur * this.deviceScale * this.globalScale;
                }

                context.fillStyle = options.color;
                context.fill();
            } else {
                var shapeRendering = 'auto';
                if (options.renderingBackend === TEXT_RENDERING_BACKEND.SVG_OPTIMIZE_SPEED) {
                    shapeRendering = 'optimizeSpeed';
                } else if (options.renderingBackend === TEXT_RENDERING_BACKEND.SVG_CRISP_EDGES) {
                    shapeRendering = 'crispEdges';
                } else if (options.renderingBackend === TEXT_RENDERING_BACKEND.SVG_GEOMETRIC_PRECISION) {
                    shapeRendering = 'geometricPrecision';
                }

                path.fill = 'white';

                var content = path.toSVG();
                var svgString = '<svg xmlns="http://www.w3.org/2000/svg"\n                                version="1.1"\n                                width="' + this.size.width * this.deviceScale * this.globalScale + '"\n                                height="' + this.size.height * this.deviceScale * this.globalScale + '"\n                                viewBox="0 0 ' + this.size.width + ' ' + this.size.height + '"\n                                shape-rendering="' + shapeRendering + '"\n                                >' + content + '</svg>';
                var image = new Image();
                image.src = 'data:image/svg+xml;base64,' + window.btoa(svgString);

                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__core_nextTick_js__["a" /* default */])(function () {
                    context.save();

                    context.drawImage(image, 0, 0, _this3.size.width, _this3.size.height);
                    context.globalCompositeOperation = 'source-in';
                    context.fillStyle = options.color;
                    context.fillRect(0, 0, _this3.size.width, _this3.size.height);

                    if (options.renderShadow) {
                        context.shadowColor = options.shadowColor;
                        context.shadowOffsetX = options.shadowOffsetX * _this3.deviceScale * _this3.globalScale;
                        context.shadowOffsetY = options.shadowOffsetY * _this3.deviceScale * _this3.globalScale;
                        context.shadowBlur = options.shadowBlur * _this3.deviceScale * _this3.globalScale;
                        context.globalCompositeOperation = 'destination-over';
                        context.drawImage(image, 0, 0, _this3.size.width, _this3.size.height);
                    }

                    context.restore();

                    _this3._needsRedraw(Label.REDRAW_CACHE_REFRESH);
                });
            }
        }

        /**
         * When this node's size is modified, this method is called and also changes the size of the internal buffer.
         *
         * @method _handleSizeChanged
         * @param {*} sender - The instance that originally triggered this event.
         * @param {Number} width - The new width of this node.
         * @param {Number} height - The new height of this node.
         * @private
         */

    }, {
        key: '_handleSizeChanged',
        value: function _handleSizeChanged(sender, width, height) {
            if (sender === this.size) {
                this.maxSize.set(width, height);
            }
            _get(Label.prototype.__proto__ || Object.getPrototypeOf(Label.prototype), '_handleSizeChanged', this).call(this, sender, width, height);
        }

        /**
         * When this label's max size is modified, this method is called and also changes the size of the internal buffer.
         *
         * @method _handleMaxSizeChanged
         * @param {*} sender - The instance that originally triggered this event.
         * @private
         */

    }, {
        key: '_handleMaxSizeChanged',
        value: function _handleMaxSizeChanged(sender) {
            if (sender === this.maxSize && this.running) {
                this.mDirty = true;
                this.needsRedraw();
            }
        }
    }, {
        key: 'font',
        get: function get() {
            return this.mFont;
        }

        /**
         * The font size used to render this label.
         *
         * @type {Number}
         */

    }, {
        key: 'fontSize',
        get: function get() {
            return this.mOptions.fontSize;
        }

        /**
         * Sets the font size used to render this label.
         *
         * @param {Number} value - The new font size.
         */
        ,
        set: function set(value) {
            if (value !== this.mOptions.fontSize) {
                this.mOptions.fontSize = value;
                this.needsRedraw();
            }
        }

        /**
         * The ascender of this label in pixels.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'ascender',
        get: function get() {
            return this.mFont.tables.hhea.ascender * (this.fontSize / this.mFont.unitsPerEm);
        }

        /**
         * The descender of this label in pixels.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'descender',
        get: function get() {
            return this.mFont.tables.hhea.descender * (this.fontSize / this.mFont.unitsPerEm);
        }

        /**
         * The tracking of this label.
         *
         * @returns {Number}
         * @readonly
         */

    }, {
        key: 'tracking',
        get: function get() {
            return this.mOptions.tracking;
        }

        /**
         * The maximum size of this label.
         *
         * @returns {Size}
         * @readonly
         */

    }, {
        key: 'maxSize',
        get: function get() {
            return this.mMaxSize;
        }

        /**
         * The device scale used to render this node's internal buffer.
         *
         * @type {Number}
         */

    }, {
        key: 'deviceScale',
        get: function get() {
            return _get(Label.prototype.__proto__ || Object.getPrototypeOf(Label.prototype), 'deviceScale', this);
        }

        /**
         * Sets the device scale used to render this node's internal buffer.
         *
         * @param {Number} value - The new device scale.
         */
        ,
        set: function set(value) {
            _set(Label.prototype.__proto__ || Object.getPrototypeOf(Label.prototype), 'deviceScale', Math.max(value, this.mMinDeviceScale), this); // force to render at the minimum device scale resolution to reduce anti-aliasing
        }

        /**
         * The text of this label.
         *
         * @type {String}
         */

    }, {
        key: 'text',
        get: function get() {
            return this.mText;
        }

        /**
         * Sets the text of this label.
         *
         * @param {String} value - The new
         */
        ,
        set: function set(value) {
            if (value !== this.mText) {
                this.mText = value;
                this.needsRedraw();
            }
        }
    }]);

    return Label;
}(__WEBPACK_IMPORTED_MODULE_0__graphics_CachedNode_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Label;

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IObject_js__ = __webpack_require__(32);
/* unused harmony export Word */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



var LINE_BREAK_WORD = Symbol('LINE_BREAK_WORD');
var SPACE_WORD = Symbol('SPACE_WORD');

/**
 * Class that represents a word of text.
 *
 * @class Word
 */
var Word = function (_IObject) {
    _inherits(Word, _IObject);

    _createClass(Word, null, [{
        key: 'wordWithEllipses',


        /**
         * Creates a new word using the given `word` as a base with added ellipses to the end, this function replaces the
         * last characters of the word so it fits within the specified `maxEmWidth`.
         *
         * @method wordWithEllipses
         * @param {Word} word - The word to use as a base.
         * @param {Number} maxEmWidth - The maximum width, in ems, that this word can take, including the ellipses.
         * @returns {Word}
         */
        value: function wordWithEllipses(word, maxEmWidth) {
            var ellipsesWord = Word.instance('...', word.mFont, word.mTracking);
            var ellipsesWidth = ellipsesWord.emWidth;
            var offsets = word.offsets;
            var i = void 0;
            for (i = offsets.length - 1; i >= 0 && offsets[i] + ellipsesWidth > maxEmWidth; --i) {
                // empty
            }
            var wordText = word.mText.substr(0, i) + '...';
            return Word.instance(wordText, word.mFont, word.mTracking);
        }

        /**
         * @param {String} text - The text of this word.
         * @param {Font} font - The font to use to render this word.
         * @param {Number} tracking - The tracking for the characters in this word.
         * @constructor
         */

    }, {
        key: 'LINE_BREAK_WORD',

        /**
         * The internal type used to recognize line breaks.
         *
         * @type {Symbol}
         * @readonly
         */
        get: function get() {
            return LINE_BREAK_WORD;
        }

        /**
         * The internal type used to recognize spaces.
         *
         * @type {Symbol}
         * @readonly
         */

    }, {
        key: 'SPACE_WORD',
        get: function get() {
            return SPACE_WORD;
        }
    }]);

    function Word() {
        var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var tracking = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        _classCallCheck(this, Word);

        var _this = _possibleConstructorReturn(this, (Word.__proto__ || Object.getPrototypeOf(Word)).call(this));

        _this.mGlyphs = null;
        _this.mOffsets = [];
        _this.mEmWidth = 0;
        _this.mEmHeight = 0;
        _this.mAscending = 0;
        _this.mDescending = 0;
        _this.mTracking = tracking;
        _this.mOffsetLeft = 0;
        _this.mText = text;
        _this.mFont = font;
        _this.mOffsetLeft = 0;

        _this._calculateMetrics();
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Word, [{
        key: 'destroy',
        value: function destroy() {
            if (this.mGlyphs) {
                this.mGlyphs.length = 0;
            }
            this.mOffsets.length = 0;

            delete this.mGlyphs;
            delete this.mOffsets;
            delete this.mEmWidth;
            delete this.mEmHeight;
            delete this.mAscending;
            delete this.mDescending;
            delete this.mOffsetLeft;
            delete this.mText;
            delete this.mFont;
            delete this.mOffsetLeft;

            _get(Word.prototype.__proto__ || Object.getPrototypeOf(Word.prototype), 'destroy', this).call(this);
        }

        /**
         * An array of glyphs representing the characters of this word.
         * @type {null|Glyph[]}
         * @readonly
         */

    }, {
        key: 'addToPath',


        /**
         * Adds this word to the given path for rendering and returns the width of the rendered word.
         *
         * @method addToPath
         * @param {Path} path - The OpenType path to which this word will be added.
         * @param {Number} size - The desired font size for this word.
         * @param {Number} scale - The scale of this font size.
         * @param {Number} x - The x coordinate for this word.
         * @param {Number} y - The y coordinate for this word.
         * @returns {Number}
         */
        value: function addToPath(path, size, scale) {
            var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

            var offsets = this.mOffsets;
            this.mGlyphs.forEach(function (glyph, i) {
                var glyphPath = glyph.getPath(x + offsets[i] * scale, y, size);
                path.extend(glyphPath);
            });

            return this.mEmWidth * scale;
        }

        /**
         * Calculates the metrics of this word.
         *
         * @method _calculateMetrics
         * @private
         */

    }, {
        key: '_calculateMetrics',
        value: function _calculateMetrics() {
            var _this2 = this;

            if (this.mFont && this.mText) {
                var offsets = this.mOffsets;
                var tracking = this.mTracking;
                var height = null;
                var ascending = null;
                var descending = null;
                var offset = 0;
                var glyphMetrics = void 0;

                this.mOffsets.length = 0;
                this.mGlyphs = this.mFont.stringToGlyphs(this.mText);
                this.mGlyphs.forEach(function (glyph, i) {
                    offsets.push(offset);
                    glyphMetrics = glyph.getMetrics();
                    if (glyph.advanceWidth) {
                        offset += glyph.advanceWidth;
                        offset += tracking;
                    }

                    if (ascending === null || glyphMetrics.yMax > ascending) {
                        ascending = glyphMetrics.yMax;
                    }

                    if (descending === null || glyphMetrics.yMin < descending) {
                        descending = glyphMetrics.yMin;
                    }

                    if (height === null || ascending - descending > height) {
                        height = ascending - descending;
                    }

                    if (i === 0) {
                        _this2.mOffsetLeft = -glyphMetrics.xMin;
                    }
                });

                this.mEmWidth = offset;
                this.mEmHeight = height;
                this.mAscending = ascending;
                this.mDescending = descending;
            }
        }
    }, {
        key: 'glyphs',
        get: function get() {
            return this.mGlyphs;
        }

        /**
         * An array with the offsets of each charatecr in this word.
         *
         * @type {Array}
         * @readonly
         */

    }, {
        key: 'offsets',
        get: function get() {
            return this.mOffsets;
        }

        /**
         * The total width, in ems, of this word.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'emWidth',
        get: function get() {
            return this.mEmWidth;
        }

        /**
         * The total height, in ems, of this word.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'emHeight',
        get: function get() {
            return this.mEmHeight;
        }

        /**
         * The max ascending distance of this word.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'ascending',
        get: function get() {
            return this.mAscending;
        }

        /**
         * The max descending distance of this word.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'descending',
        get: function get() {
            return this.mDescending;
        }

        /**
         * The left side offset for this word.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'offsetLeft',
        get: function get() {
            return this.mOffsetLeft;
        }
    }]);

    return Word;
}(__WEBPACK_IMPORTED_MODULE_0__core_IObject_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Word;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(21);
module.exports = function(it, msg){
  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
  return +it;
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(10)
  , toIndex  = __webpack_require__(45)
  , toLength = __webpack_require__(9);

module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
  var O     = toObject(this)
    , len   = toLength(O.length)
    , to    = toIndex(target, len)
    , from  = toIndex(start, len)
    , end   = arguments.length > 2 ? arguments[2] : undefined
    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
    , inc   = 1;
  if(from < to && to < from + count){
    inc  = -1;
    from += count - 1;
    to   += count - 1;
  }
  while(count-- > 0){
    if(from in O)O[to] = O[from];
    else delete O[to];
    to   += inc;
    from += inc;
  } return O;
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(49);

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(14)
  , toObject  = __webpack_require__(10)
  , IObject   = __webpack_require__(56)
  , toLength  = __webpack_require__(9);

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction  = __webpack_require__(14)
  , isObject   = __webpack_require__(4)
  , invoke     = __webpack_require__(67)
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP          = __webpack_require__(7).f
  , create      = __webpack_require__(40)
  , redefineAll = __webpack_require__(43)
  , ctx         = __webpack_require__(29)
  , anInstance  = __webpack_require__(38)
  , defined     = __webpack_require__(22)
  , forOf       = __webpack_require__(49)
  , $iterDefine = __webpack_require__(89)
  , step        = __webpack_require__(133)
  , setSpecies  = __webpack_require__(44)
  , DESCRIPTORS = __webpack_require__(6)
  , fastKey     = __webpack_require__(35).fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(55)
  , from    = __webpack_require__(124);
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll       = __webpack_require__(43)
  , getWeak           = __webpack_require__(35).getWeak
  , anObject          = __webpack_require__(1)
  , isObject          = __webpack_require__(4)
  , anInstance        = __webpack_require__(38)
  , forOf             = __webpack_require__(49)
  , createArrayMethod = __webpack_require__(24)
  , $has              = __webpack_require__(12)
  , arrayFind         = createArrayMethod(5)
  , arrayFindIndex    = createArrayMethod(6)
  , id                = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that){
  return that._l || (that._l = new UncaughtFrozenStore);
};
var UncaughtFrozenStore = function(){
  this.a = [];
};
var findUncaughtFrozen = function(store, key){
  return arrayFind(store.a, function(it){
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key){
    var entry = findUncaughtFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value){
    var entry = findUncaughtFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = arrayFindIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var data = getWeak(anObject(key), true);
    if(data === true)uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(6) && !__webpack_require__(3)(function(){
  return Object.defineProperty(__webpack_require__(81)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(4)
  , floor    = Math.floor;
module.exports = function isInteger(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(1);
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ }),
/* 134 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x){
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = __webpack_require__(42)
  , gOPS     = __webpack_require__(71)
  , pIE      = __webpack_require__(57)
  , toObject = __webpack_require__(10)
  , IObject  = __webpack_require__(56)
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(3)(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(7)
  , anObject = __webpack_require__(1)
  , getKeys  = __webpack_require__(42);

module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(18)
  , gOPN      = __webpack_require__(41).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(12)
  , toIObject    = __webpack_require__(18)
  , arrayIndexOf = __webpack_require__(63)(false)
  , IE_PROTO     = __webpack_require__(94)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(42)
  , toIObject = __webpack_require__(18)
  , isEnum    = __webpack_require__(57).f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN     = __webpack_require__(41)
  , gOPS     = __webpack_require__(71)
  , anObject = __webpack_require__(1)
  , Reflect  = __webpack_require__(2).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
  var keys       = gOPN.f(anObject(it))
    , getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(2).parseFloat
  , $trim       = __webpack_require__(52).trim;

module.exports = 1 / $parseFloat(__webpack_require__(99) + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim(String(str), 3)
    , result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(2).parseInt
  , $trim     = __webpack_require__(52).trim
  , ws        = __webpack_require__(99)
  , hex       = /^[\-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(9)
  , repeat   = __webpack_require__(98)
  , defined  = __webpack_require__(22);

module.exports = function(that, maxLength, fillString, left){
  var S            = String(defined(that))
    , stringLength = S.length
    , fillStr      = fillString === undefined ? ' ' : String(fillString)
    , intMaxLength = toLength(maxLength);
  if(intMaxLength <= stringLength || fillStr == '')return S;
  var fillLen = intMaxLength - stringLength
    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(5);

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(127);

// 23.1 Map Objects
module.exports = __webpack_require__(64)('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if(__webpack_require__(6) && /./g.flags != 'g')__webpack_require__(7).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(66)
});

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(127);

// 23.2 Set Objects
module.exports = __webpack_require__(64)('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each         = __webpack_require__(24)(0)
  , redefine     = __webpack_require__(16)
  , meta         = __webpack_require__(35)
  , assign       = __webpack_require__(135)
  , weak         = __webpack_require__(129)
  , isObject     = __webpack_require__(4)
  , getWeak      = meta.getWeak
  , isExtensible = Object.isExtensible
  , uncaughtFrozenStore = weak.ufstore
  , tmp          = {}
  , InternalMap;

var wrapper = function(get){
  return function WeakMap(){
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      var data = getWeak(key);
      if(data === true)return uncaughtFrozenStore(this).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(64)('WeakMap', wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  InternalMap = weak.getConstructor(wrapper);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    redefine(proto, key, function(a, b){
      // store frozen objects on internal weakmap shim
      if(isObject(a) && !isExtensible(a)){
        if(!this._f)this._f = new InternalMap;
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The Bounding Box object



function derive(v0, v1, v2, v3, t) {
    return Math.pow(1 - t, 3) * v0 +
        3 * Math.pow(1 - t, 2) * t * v1 +
        3 * (1 - t) * Math.pow(t, 2) * v2 +
        Math.pow(t, 3) * v3;
}
/**
 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
 * It is used to calculate the bounding box of a glyph or text path.
 *
 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
 *
 * @exports opentype.BoundingBox
 * @class
 * @constructor
 */
function BoundingBox() {
    this.x1 = Number.NaN;
    this.y1 = Number.NaN;
    this.x2 = Number.NaN;
    this.y2 = Number.NaN;
}

/**
 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
 */
BoundingBox.prototype.isEmpty = function() {
    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};

/**
 * Add the point to the bounding box.
 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
 * @param {number} x - The X coordinate of the point.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addPoint = function(x, y) {
    if (typeof x === 'number') {
        if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x;
            this.x2 = x;
        }
        if (x < this.x1) {
            this.x1 = x;
        }
        if (x > this.x2) {
            this.x2 = x;
        }
    }
    if (typeof y === 'number') {
        if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y;
            this.y2 = y;
        }
        if (y < this.y1) {
            this.y1 = y;
        }
        if (y > this.y2) {
            this.y2 = y;
        }
    }
};

/**
 * Add a X coordinate to the bounding box.
 * This extends the bounding box to include the X coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} x - The X coordinate of the point.
 */
BoundingBox.prototype.addX = function(x) {
    this.addPoint(x, null);
};

/**
 * Add a Y coordinate to the bounding box.
 * This extends the bounding box to include the Y coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addY = function(y) {
    this.addPoint(null, y);
};

/**
 * Add a Bézier curve to the bounding box.
 * This extends the bounding box to include the entire Bézier.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the first control point.
 * @param {number} y1 - The Y coordinate of the first control point.
 * @param {number} x2 - The X coordinate of the second control point.
 * @param {number} y2 - The Y coordinate of the second control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
    // and https://github.com/icons8/svg-path-bounding-box

    var p0 = [x0, y0];
    var p1 = [x1, y1];
    var p2 = [x2, y2];
    var p3 = [x, y];

    this.addPoint(x0, y0);
    this.addPoint(x, y);

    for (var i = 0; i <= 1; i++) {
        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        var c = 3 * p1[i] - 3 * p0[i];

        if (a === 0) {
            if (b === 0) continue;
            var t = -c / b;
            if (0 < t && t < 1) {
                if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t));
                if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t));
            }
            continue;
        }

        var b2ac = Math.pow(b, 2) - 4 * c * a;
        if (b2ac < 0) continue;
        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
        if (0 < t1 && t1 < 1) {
            if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1));
            if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1));
        }
        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
        if (0 < t2 && t2 < 1) {
            if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2));
            if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2));
        }
    }
};

/**
 * Add a quadratic curve to the bounding box.
 * This extends the bounding box to include the entire quadratic curve.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the control point.
 * @param {number} y1 - The Y coordinate of the control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
    var cp1x = x0 + 2 / 3 * (x1 - x0);
    var cp1y = y0 + 2 / 3 * (y1 - y0);
    var cp2x = cp1x + 1 / 3 * (x - x0);
    var cp2y = cp1y + 1 / 3 * (y - y0);
    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};

exports.BoundingBox = BoundingBox;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The Glyph object



var check = __webpack_require__(11);
var draw = __webpack_require__(375);
var path = __webpack_require__(58);

function getPathDefinition(glyph, path) {
    var _path = path || { commands: [] };
    return {
        configurable: true,

        get: function() {
            if (typeof _path === 'function') {
                _path = _path();
            }

            return _path;
        },

        set: function(p) {
            _path = p;
        }
    };
}
/**
 * @typedef GlyphOptions
 * @type Object
 * @property {string} [name] - The glyph name
 * @property {number} [unicode]
 * @property {Array} [unicodes]
 * @property {number} [xMin]
 * @property {number} [yMin]
 * @property {number} [xMax]
 * @property {number} [yMax]
 * @property {number} [advanceWidth]
 */

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
/**
 * @exports opentype.Glyph
 * @class
 * @param {GlyphOptions}
 * @constructor
 */
function Glyph(options) {
    // By putting all the code on a prototype function (which is only declared once)
    // we reduce the memory requirements for larger fonts by some 2%
    this.bindConstructorValues(options);
}

/**
 * @param  {GlyphOptions}
 */
Glyph.prototype.bindConstructorValues = function(options) {
    this.index = options.index || 0;

    // These three values cannnot be deferred for memory optimization:
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

    // But by binding these values only when necessary, we reduce can
    // the memory requirements by almost 3% for larger fonts.
    if (options.xMin) {
        this.xMin = options.xMin;
    }

    if (options.yMin) {
        this.yMin = options.yMin;
    }

    if (options.xMax) {
        this.xMax = options.xMax;
    }

    if (options.yMax) {
        this.yMax = options.yMax;
    }

    if (options.advanceWidth) {
        this.advanceWidth = options.advanceWidth;
    }

    // The path for a glyph is the most memory intensive, and is bound as a value
    // with a getter/setter to ensure we actually do path parsing only once the
    // path is actually needed by anything.
    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
};

/**
 * @param {number}
 */
Glyph.prototype.addUnicode = function(unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }

    this.unicodes.push(unicode);
};

/**
 * Calculate the minimum bounding box for this glyph.
 * @return {opentype.BoundingBox}
 */
Glyph.prototype.getBoundingBox = function() {
    return this.path.getBoundingBox();
};

/**
 * Convert the glyph to a Path we can draw on a drawing context.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to strech the glyph.
 * @return {opentype.Path}
 */
Glyph.prototype.getPath = function(x, y, fontSize, options) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    options = options !== undefined ? options : {xScale: 1.0, yScale: 1.0};
    fontSize = fontSize !== undefined ? fontSize : 72;
    var scale = 1 / this.path.unitsPerEm * fontSize;
    var xScale = options.xScale * scale;
    var yScale = options.yScale * scale;

    var p = new path.Path();
    var commands = this.path.commands;
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }

    return p;
};

/**
 * Split the glyph into contours.
 * This function is here for backwards compatibility, and to
 * provide raw access to the TrueType glyph outlines.
 * @return {Array}
 */
Glyph.prototype.getContours = function() {
    if (this.points === undefined) {
        return [];
    }

    var contours = [];
    var currentContour = [];
    for (var i = 0; i < this.points.length; i += 1) {
        var pt = this.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

/**
 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
 * @return {Object}
 */
Glyph.prototype.getMetrics = function() {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }

        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }

        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }

    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: this.leftSideBearing
    };

    if (!isFinite(metrics.xMin)) {
        metrics.xMin = 0;
    }

    if (!isFinite(metrics.xMax)) {
        metrics.xMax = this.advanceWidth;
    }

    if (!isFinite(metrics.yMin)) {
        metrics.yMin = 0;
    }

    if (!isFinite(metrics.yMax)) {
        metrics.yMax = 0;
    }

    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

/**
 * Draw the glyph on the given context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to strech the glyph.
 */
Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
    this.getPath(x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of the glyph.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {

    function drawCircles(l, x, y, scale) {
        var PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (var j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
        }

        ctx.closePath();
        ctx.fill();
    }

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    var scale = 1 / this.path.unitsPerEm * fontSize;

    var blueCircles = [];
    var redCircles = [];
    var path = this.path;
    for (var i = 0; i < path.commands.length; i += 1) {
        var cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }

        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }

        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

/**
 * Draw lines indicating important font measurements.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.path.unitsPerEm * fontSize;
    ctx.lineWidth = 1;

    // Draw the origin
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -10000, x, 10000);
    draw.line(ctx, -10000, y, 10000, y);

    // This code is here due to memory optimization: by not using
    // defaults in the constructor, we save a notable amount of memory.
    var xMin = this.xMin || 0;
    var yMin = this.yMin || 0;
    var xMax = this.xMax || 0;
    var yMax = this.yMax || 0;
    var advanceWidth = this.advanceWidth || 0;

    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

    // Draw the advance width
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
};

exports.Glyph = Glyph;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2015 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global DataView, Uint8Array, XMLHttpRequest  */



var inflate = __webpack_require__(387);

var encoding = __webpack_require__(74);
var _font = __webpack_require__(376);
var glyph = __webpack_require__(151);
var parse = __webpack_require__(8);
var bbox = __webpack_require__(150);
var path = __webpack_require__(58);
var util = __webpack_require__(165);

var cmap = __webpack_require__(154);
var cff = __webpack_require__(153);
var fvar = __webpack_require__(379);
var glyf = __webpack_require__(380);
var gpos = __webpack_require__(381);
var gsub = __webpack_require__(155);
var head = __webpack_require__(156);
var hhea = __webpack_require__(157);
var hmtx = __webpack_require__(158);
var kern = __webpack_require__(382);
var ltag = __webpack_require__(159);
var loca = __webpack_require__(383);
var maxp = __webpack_require__(160);
var _name = __webpack_require__(162);
var os2 = __webpack_require__(163);
var post = __webpack_require__(164);
var meta = __webpack_require__(161);

/**
 * The opentype library.
 * @namespace opentype
 */

// File loaders /////////////////////////////////////////////////////////
/**
 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} path - The path of the file
 * @param  {Function} callback - The function to call when the font load completes
 */
function loadFromFile(path, callback) {
    var fs = __webpack_require__(107);
    fs.readFile(path, function(err, buffer) {
        if (err) {
            return callback(err.message);
        }

        callback(null, util.nodeBufferToArrayBuffer(buffer));
    });
}
/**
 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} url - The URL of the font file.
 * @param  {Function} callback - The function to call when the font load completes
 */
function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function() {
        if (request.status !== 200) {
            return callback('Font could not be loaded: ' + request.statusText);
        }

        return callback(null, request.response);
    };

    request.send();
}

// Table Directory Entries //////////////////////////////////////////////
/**
 * Parses OpenType table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */
function parseOpenTypeTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 12;
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var checksum = parse.getULong(data, p + 4);
        var offset = parse.getULong(data, p + 8);
        var length = parse.getULong(data, p + 12);
        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
        p += 16;
    }

    return tableEntries;
}

/**
 * Parses WOFF table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */
function parseWOFFTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 44; // offset to the first table directory entry.
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var offset = parse.getULong(data, p + 4);
        var compLength = parse.getULong(data, p + 8);
        var origLength = parse.getULong(data, p + 12);
        var compression;
        if (compLength < origLength) {
            compression = 'WOFF';
        } else {
            compression = false;
        }

        tableEntries.push({tag: tag, offset: offset, compression: compression,
            compressedLength: compLength, originalLength: origLength});
        p += 20;
    }

    return tableEntries;
}

/**
 * @typedef TableData
 * @type Object
 * @property {DataView} data - The DataView
 * @property {number} offset - The data offset.
 */

/**
 * @param  {DataView}
 * @param  {Object}
 * @return {TableData}
 */
function uncompressTable(data, tableEntry) {
    if (tableEntry.compression === 'WOFF') {
        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
        var outBuffer = new Uint8Array(tableEntry.originalLength);
        inflate(inBuffer, outBuffer);
        if (outBuffer.byteLength !== tableEntry.originalLength) {
            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
        }

        var view = new DataView(outBuffer.buffer, 0);
        return {data: view, offset: 0};
    } else {
        return {data: data, offset: tableEntry.offset};
    }
}

// Public API ///////////////////////////////////////////////////////////

/**
 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
 * Throws an error if the font could not be parsed.
 * @param  {ArrayBuffer}
 * @return {opentype.Font}
 */
function parseBuffer(buffer) {
    var indexToLocFormat;
    var ltagTable;

    // Since the constructor can also be called to create new fonts from scratch, we indicate this
    // should be an empty font that we'll fill with our own data.
    var font = new _font.Font({empty: true});

    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.
    var data = new DataView(buffer, 0);
    var numTables;
    var tableEntries = [];
    var signature = parse.getTag(data, 0);
    if (signature === String.fromCharCode(0, 1, 0, 0)) {
        font.outlinesFormat = 'truetype';
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'OTTO') {
        font.outlinesFormat = 'cff';
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'wOFF') {
        var flavor = parse.getTag(data, 4);
        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
            font.outlinesFormat = 'truetype';
        } else if (flavor === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType flavor ' + signature);
        }

        numTables = parse.getUShort(data, 12);
        tableEntries = parseWOFFTableEntries(data, numTables);
    } else {
        throw new Error('Unsupported OpenType signature ' + signature);
    }

    var cffTableEntry;
    var fvarTableEntry;
    var glyfTableEntry;
    var gposTableEntry;
    var gsubTableEntry;
    var hmtxTableEntry;
    var kernTableEntry;
    var locaTableEntry;
    var nameTableEntry;
    var metaTableEntry;

    for (var i = 0; i < numTables; i += 1) {
        var tableEntry = tableEntries[i];
        var table;
        switch (tableEntry.tag) {
            case 'cmap':
                table = uncompressTable(data, tableEntry);
                font.tables.cmap = cmap.parse(table.data, table.offset);
                font.encoding = new encoding.CmapEncoding(font.tables.cmap);
                break;
            case 'fvar':
                fvarTableEntry = tableEntry;
                break;
            case 'head':
                table = uncompressTable(data, tableEntry);
                font.tables.head = head.parse(table.data, table.offset);
                font.unitsPerEm = font.tables.head.unitsPerEm;
                indexToLocFormat = font.tables.head.indexToLocFormat;
                break;
            case 'hhea':
                table = uncompressTable(data, tableEntry);
                font.tables.hhea = hhea.parse(table.data, table.offset);
                font.ascender = font.tables.hhea.ascender;
                font.descender = font.tables.hhea.descender;
                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                break;
            case 'hmtx':
                hmtxTableEntry = tableEntry;
                break;
            case 'ltag':
                table = uncompressTable(data, tableEntry);
                ltagTable = ltag.parse(table.data, table.offset);
                break;
            case 'maxp':
                table = uncompressTable(data, tableEntry);
                font.tables.maxp = maxp.parse(table.data, table.offset);
                font.numGlyphs = font.tables.maxp.numGlyphs;
                break;
            case 'name':
                nameTableEntry = tableEntry;
                break;
            case 'OS/2':
                table = uncompressTable(data, tableEntry);
                font.tables.os2 = os2.parse(table.data, table.offset);
                break;
            case 'post':
                table = uncompressTable(data, tableEntry);
                font.tables.post = post.parse(table.data, table.offset);
                font.glyphNames = new encoding.GlyphNames(font.tables.post);
                break;
            case 'glyf':
                glyfTableEntry = tableEntry;
                break;
            case 'loca':
                locaTableEntry = tableEntry;
                break;
            case 'CFF ':
                cffTableEntry = tableEntry;
                break;
            case 'kern':
                kernTableEntry = tableEntry;
                break;
            case 'GPOS':
                gposTableEntry = tableEntry;
                break;
            case 'GSUB':
                gsubTableEntry = tableEntry;
                break;
            case 'meta':
                metaTableEntry = tableEntry;
                break;
        }
    }

    var nameTable = uncompressTable(data, nameTableEntry);
    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
    font.names = font.tables.name;

    if (glyfTableEntry && locaTableEntry) {
        var shortVersion = indexToLocFormat === 0;
        var locaTable = uncompressTable(data, locaTableEntry);
        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
        var glyfTable = uncompressTable(data, glyfTableEntry);
        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
    } else if (cffTableEntry) {
        var cffTable = uncompressTable(data, cffTableEntry);
        cff.parse(cffTable.data, cffTable.offset, font);
    } else {
        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
    }

    var hmtxTable = uncompressTable(data, hmtxTableEntry);
    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
    encoding.addGlyphNames(font);

    if (kernTableEntry) {
        var kernTable = uncompressTable(data, kernTableEntry);
        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
    } else {
        font.kerningPairs = {};
    }

    if (gposTableEntry) {
        var gposTable = uncompressTable(data, gposTableEntry);
        gpos.parse(gposTable.data, gposTable.offset, font);
    }

    if (gsubTableEntry) {
        var gsubTable = uncompressTable(data, gsubTableEntry);
        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
    }

    if (fvarTableEntry) {
        var fvarTable = uncompressTable(data, fvarTableEntry);
        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
    }

    if (metaTableEntry) {
        var metaTable = uncompressTable(data, metaTableEntry);
        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
        font.metas = font.tables.meta;
    }

    return font;
}

/**
 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
 * with two arguments `(err, font)`. The `err` will be null on success,
 * the `font` is a Font object.
 * We use the node.js callback convention so that
 * opentype.js can integrate with frameworks like async.js.
 * @alias opentype.load
 * @param  {string} url - The URL of the font to load.
 * @param  {Function} callback - The callback.
 */
function load(url, callback) {
    var isNode = typeof window === 'undefined';
    var loadFn = isNode ? loadFromFile : loadFromUrl;
    loadFn(url, function(err, arrayBuffer) {
        if (err) {
            return callback(err);
        }
        var font;
        try {
            font = parseBuffer(arrayBuffer);
        } catch (e) {
            return callback(e, null);
        }
        return callback(null, font);
    });
}

/**
 * Synchronously load the font from a URL or file.
 * When done, returns the font object or throws an error.
 * @alias opentype.loadSync
 * @param  {string} url - The URL of the font to load.
 * @return {opentype.Font}
 */
function loadSync(url) {
    var fs = __webpack_require__(107);
    var buffer = fs.readFileSync(url);
    return parseBuffer(util.nodeBufferToArrayBuffer(buffer));
}

exports._parse = parse;
exports.Font = _font.Font;
exports.Glyph = glyph.Glyph;
exports.Path = path.Path;
exports.BoundingBox = bbox.BoundingBox;
exports.parse = parseBuffer;
exports.load = load;
exports.loadSync = loadSync;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf



var encoding = __webpack_require__(74);
var glyphset = __webpack_require__(105);
var parse = __webpack_require__(8);
var path = __webpack_require__(58);
var table = __webpack_require__(13);

// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }

        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }

        return true;
    } else {
        return false;
    }
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    //var i, objectOffset, endOffset;
    var offsets = [];
    var objects = [];
    var count = parse.getCard16(data, start);
    var i;
    var objectOffset;
    var endOffset;
    if (count !== 0) {
        var offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        var pos = start + 3;
        for (i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }

        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }

    for (i = 0; i < offsets.length - 1; i += 1) {
        var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }

        objects.push(value);
    }

    return {objects: objects, startOffset: start, endOffset: endOffset};
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s = '';
    var eof = 15;
    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        var b = parser.parseByte();
        var n1 = b >> 4;
        var n2 = b & 15;

        if (n1 === eof) {
            break;
        }

        s += lookup[n1];

        if (n2 === eof) {
            break;
        }

        s += lookup[n2];
    }

    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1;
    var b2;
    var b3;
    var b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }

    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }

    if (b0 === 30) {
        return parseFloatOperand(parser);
    }

    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }

    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }

    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }

    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o = {};
    for (var i = 0; i < entries.length; i += 1) {
        var key = entries[i][0];
        var values = entries[i][1];
        var value;
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }

        if (o.hasOwnProperty(key)) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }

        o[key] = value;
    }

    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    start = start !== undefined ? start : 0;
    var parser = new parse.Parser(data, start);
    var entries = [];
    var operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        var op = parser.parseByte();

        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }

            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }

    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = encoding.cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }

    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var newDict = {};

    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (var i = 0; i < meta.length; i += 1) {
        var m = meta[i];
        var value = dict[m.op];
        if (value === undefined) {
            value = m.value !== undefined ? m.value : null;
        }

        if (m.type === 'SID') {
            value = getCFFString(strings, value);
        }

        newDict[m.name] = value;
    }

    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse.getCard8(data, start);
    header.formatMinor = parse.getCard8(data, start + 1);
    header.size = parse.getCard8(data, start + 2);
    header.offsetSize = parse.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {name: 'fontMatrix', op: 1207, type: ['real', 'real', 'real', 'real', 'real', 'real'], value: [0.001, 0, 0, 0.001, 0, 0]},
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]}
];

var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var i;
    var sid;
    var count;
    var parser = new parse.Parser(data, start);

    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    var charset = ['.notdef'];

    var format = parser.parseCard8();
    if (format === 0) {
        for (i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var i;
    var code;
    var enc = {};
    var parser = new parse.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        var nCodes = parser.parseCard8();
        for (i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        var nRanges = parser.parseCard8();
        code = 1;
        for (i = 0; i < nRanges; i += 1) {
            var first = parser.parseCard8();
            var nLeft = parser.parseCard8();
            for (var j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }

    return new encoding.CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(font, glyph, code) {
    var c1x;
    var c1y;
    var c2x;
    var c2y;
    var p = new path.Path();
    var stack = [];
    var nStems = 0;
    var haveWidth = false;
    var width = font.defaultWidthX;
    var open = false;
    var x = 0;
    var y = 0;

    function newContour(x, y) {
        if (open) {
            p.closePath();
        }

        p.moveTo(x, y);
        open = true;
    }

    function parseStems() {
        var hasWidthArg;

        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + font.nominalWidthX;
        }

        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse(code) {
        var b1;
        var b2;
        var b3;
        var b4;
        var codeIndex;
        var subrCode;
        var jpx;
        var jpy;
        var c3x;
        var c3y;
        var c4x;
        var c4y;

        var i = 0;
        while (i < code.length) {
            var v = code[i];
            i += 1;
            switch (v) {
                case 1: // hstem
                    parseStems();
                    break;
                case 3: // vstem
                    parseStems();
                    break;
                case 4: // vmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + font.nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    newContour(x, y);
                    break;
                case 5: // rlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 6: // hlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 7: // vlineto
                    while (stack.length > 0) {
                        y += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        x += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 8: // rrcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 10: // callsubr
                    codeIndex = stack.pop() + font.subrsBias;
                    subrCode = font.subrs[codeIndex];
                    if (subrCode) {
                        parse(subrCode);
                    }

                    break;
                case 11: // return
                    return;
                case 12: // flex operators
                    v = code[i];
                    i += 1;
                    switch (v) {
                        case 35: // flex
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y + stack.shift();    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = jpy + stack.shift();    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            x = c4x + stack.shift();      // dx6
                            y = c4y + stack.shift();      // dy6
                            stack.shift();                // flex depth
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 34: // hflex
                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y;                      // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y;                    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = c2y;                    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = y;                      // dy5
                            x = c4x + stack.shift();      // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 36: // hflex1
                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y;                    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = c2y;                    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            x = c4x + stack.shift();      // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 37: // flex1
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y + stack.shift();    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = jpy + stack.shift();    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                                x = c4x + stack.shift();
                            } else {
                                y = c4y + stack.shift();
                            }

                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        default:
                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
                            stack.length = 0;
                    }
                    break;
                case 14: // endchar
                    if (stack.length > 0 && !haveWidth) {
                        width = stack.shift() + font.nominalWidthX;
                        haveWidth = true;
                    }

                    if (open) {
                        p.closePath();
                        open = false;
                    }

                    break;
                case 18: // hstemhm
                    parseStems();
                    break;
                case 19: // hintmask
                case 20: // cntrmask
                    parseStems();
                    i += (nStems + 7) >> 3;
                    break;
                case 21: // rmoveto
                    if (stack.length > 2 && !haveWidth) {
                        width = stack.shift() + font.nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 22: // hmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + font.nominalWidthX;
                        haveWidth = true;
                    }

                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 23: // vstemhm
                    parseStems();
                    break;
                case 24: // rcurveline
                    while (stack.length > 2) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                    break;
                case 25: // rlinecurve
                    while (stack.length > 6) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    break;
                case 26: // vvcurveto
                    if (stack.length % 2) {
                        x += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x;
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 27: // hhcurveto
                    if (stack.length % 2) {
                        y += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y;
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 28: // shortint
                    b1 = code[i];
                    b2 = code[i + 1];
                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                    i += 2;
                    break;
                case 29: // callgsubr
                    codeIndex = stack.pop() + font.gsubrsBias;
                    subrCode = font.gsubrs[codeIndex];
                    if (subrCode) {
                        parse(subrCode);
                    }

                    break;
                case 30: // vhcurveto
                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 31: // hvcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                default:
                    if (v < 32) {
                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
                    } else if (v < 247) {
                        stack.push(v - 139);
                    } else if (v < 251) {
                        b1 = code[i];
                        i += 1;
                        stack.push((v - 247) * 256 + b1 + 108);
                    } else if (v < 255) {
                        b1 = code[i];
                        i += 1;
                        stack.push(-(v - 251) * 256 - b1 - 108);
                    } else {
                        b1 = code[i];
                        b2 = code[i + 1];
                        b3 = code[i + 2];
                        b4 = code[i + 3];
                        i += 4;
                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                    }
            }
        }
    }

    parse(code);

    glyph.advanceWidth = width;
    return p;
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }

    return bias;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    font.tables.cff = {};
    var header = parseCFFHeader(data, start);
    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);
    var topDict = parseCFFTopDict(topDictData, stringIndex.objects);
    font.tables.cff.topDict = topDict;

    var privateDictOffset = start + topDict['private'][1];
    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict['private'][0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        var subrOffset = privateDictOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) { // Standard encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) { // Expert encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }

    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = new glyphset.GlyphSet(font);
    for (var i = 0; i < font.nGlyphs; i += 1) {
        var charString = charStringsIndex.objects[i];
        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
    }
}

// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var sid;

    // Is the string in the CFF standard strings?
    var i = encoding.cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }

    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + encoding.cffStandardStrings.length;
    } else {
        sid = encoding.cffStandardStrings.length + strings.length;
        strings.push(s);
    }

    return sid;
}

function makeHeader() {
    return new table.Record('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}

function makeNameIndex(fontNames) {
    var t = new table.Record('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }

    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {};
    for (var i = 0; i < meta.length; i += 1) {
        var entry = meta[i];
        var value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }

            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }

    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new table.Record('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new table.Record('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}

function makeStringIndex(strings) {
    var t = new table.Record('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }

    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new table.Record('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}

function makeCharsets(glyphNames, strings) {
    var t = new table.Record('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }

    return t;
}

function glyphToOps(glyph) {
    var ops = [];
    var path = glyph.path;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    var x = 0;
    var y = 0;
    for (var i = 0; i < path.commands.length; i += 1) {
        var dx;
        var dy;
        var cmd = path.commands[i];
        if (cmd.type === 'Q') {
            // CFF only supports bézier curves, so convert the quad to a bézier.
            var _13 = 1 / 3;
            var _23 = 2 / 3;

            // We're going to create a new command so we don't change the original path.
            cmd = {
                type: 'C',
                x: cmd.x,
                y: cmd.y,
                x1: _13 * x + _23 * cmd.x1,
                y1: _13 * y + _23 * cmd.y1,
                x2: _13 * cmd.x + _23 * cmd.x1,
                y2: _13 * cmd.y + _23 * cmd.y1
            };
        }

        if (cmd.type === 'M') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'L') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'C') {
            var dx1 = Math.round(cmd.x1 - x);
            var dy1 = Math.round(cmd.y1 - y);
            var dx2 = Math.round(cmd.x2 - cmd.x1);
            var dy2 = Math.round(cmd.y2 - cmd.y1);
            dx = Math.round(cmd.x - cmd.x2);
            dy = Math.round(cmd.y - cmd.y2);
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        }

        // Contours are closed automatically.

    }

    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new table.Record('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);

    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }

    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new table.Record('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'RECORD'},
        {name: 'nameIndex', type: 'RECORD'},
        {name: 'topDictIndex', type: 'RECORD'},
        {name: 'stringIndex', type: 'RECORD'},
        {name: 'globalSubrIndex', type: 'RECORD'},
        {name: 'charsets', type: 'RECORD'},
        {name: 'charStringsIndex', type: 'RECORD'},
        {name: 'privateDict', type: 'RECORD'}
    ]);

    var fontScale = 1 / options.unitsPerEm;
    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        fontBBox: options.fontBBox || [0, 0, 0, 0],
        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];
    var glyph;

    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyph = glyphs.get(i);
        glyphNames.push(glyph.name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    t.privateDict = makePrivateDict(privateAttrs, strings);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;

    // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.encoding = 0;
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

exports.parse = parseCFFTable;
exports.make = makeCFFTable;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm



var check = __webpack_require__(11);
var parse = __webpack_require__(8);
var table = __webpack_require__(13);

function parseCmapTableFormat12(cmap, p) {
    var i;

    //Skip reserved.
    p.parseUShort();

    // Length in bytes of the sub-tables.
    cmap.length = p.parseULong();
    cmap.language = p.parseULong();

    var groupCount;
    cmap.groupCount = groupCount = p.parseULong();
    cmap.glyphIndexMap = {};

    for (i = 0; i < groupCount; i += 1) {
        var startCharCode = p.parseULong();
        var endCharCode = p.parseULong();
        var startGlyphId = p.parseULong();

        for (var c = startCharCode; c <= endCharCode; c += 1) {
            cmap.glyphIndexMap[c] = startGlyphId;
            startGlyphId++;
        }
    }
}

function parseCmapTableFormat4(cmap, p, data, start, offset) {
    var i;

    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();

    // segCount is stored x 2.
    var segCount;
    cmap.segCount = segCount = p.parseUShort() >> 1;

    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};
    var endCountParser = new parse.Parser(data, start + offset + 14);
    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
    var glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (i = 0; i < segCount - 1; i += 1) {
        var glyphIndex;
        var endCount = endCountParser.parseUShort();
        var startCount = startCountParser.parseUShort();
        var idDelta = idDeltaParser.parseShort();
        var idRangeOffset = idRangeOffsetParser.parseUShort();
        for (var c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;

                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }

            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
}

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4 and 12.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var i;
    var cmap = {};
    cmap.version = parse.getUShort(data, start);
    check.argument(cmap.version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numTables = parse.getUShort(data, start + 2);
    var offset = -1;
    for (i = cmap.numTables - 1; i >= 0; i -= 1) {
        var platformId = parse.getUShort(data, start + 4 + (i * 8));
        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) {
            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }

    if (offset === -1) {
        // There is no cmap table in the font that we support, so return null.
        // This font will be marked as unsupported.
        return null;
    }

    var p = new parse.Parser(data, start + offset);
    cmap.format = p.parseUShort();

    if (cmap.format === 12) {
        parseCmapTableFormat12(cmap, p);
    } else if (cmap.format === 4) {
        parseCmapTableFormat4(cmap, p, data, start, offset);
    } else {
        throw new Error('Only format 4 and 12 cmap tables are supported.');
    }

    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

function makeCmapTable(glyphs) {
    var i;
    var t = new table.Table('cmap', [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: 1},
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: 12},
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);

    t.segments = [];
    for (i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        for (var j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }

        t.segments = t.segments.sort(function(a, b) {
            return a.start - b.start;
        });
    }

    addTerminatorSegment(t);

    var segCount;
    segCount = t.segments.length;
    t.segCountX2 = segCount * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

    // Set up parallel segment arrays.
    var endCounts = [];
    var startCounts = [];
    var idDeltas = [];
    var idRangeOffsets = [];
    var glyphIds = [];

    for (i = 0; i < segCount; i += 1) {
        var segment = t.segments[i];
        endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
        startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
        idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
        if (segment.glyphId !== undefined) {
            glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
        }
    }

    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.length = 14 + // Subtable header
        endCounts.length * 2 +
        2 + // reservedPad
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;

    return t;
}

exports.parse = parseCmapTable;
exports.make = makeCmapTable;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `GSUB` table contains ligatures, among other things.
// https://www.microsoft.com/typography/OTSPEC/gsub.htm



var check = __webpack_require__(11);
var Parser = __webpack_require__(8).Parser;
var subtableParsers = new Array(9);         // subtableParsers[0] is unused
var table = __webpack_require__(13);

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
subtableParsers[1] = function parseLookup1() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            deltaGlyphId: this.parseUShort()
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            substitute: this.parseOffset16List()
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
subtableParsers[2] = function parseLookup2() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        sequences: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
subtableParsers[3] = function parseLookup3() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        alternateSets: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
subtableParsers[4] = function parseLookup4() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        ligatureSets: this.parseListOfLists(function() {
            return {
                ligGlyph: this.parseUShort(),
                components: this.parseUShortList(this.parseUShort() - 1)
            };
        })
    };
};

var lookupRecordDesc = {
    sequenceIndex: Parser.uShort,
    lookupListIndex: Parser.uShort
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
subtableParsers[5] = function parseLookup5() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();

    if (substFormat === 1) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            ruleSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    input: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            classDef: this.parsePointer(Parser.classDef),
            classSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    classes: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        var glyphCount = this.parseUShort();
        var substCount = this.parseUShort();
        return {
            substFormat: substFormat,
            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
subtableParsers[6] = function parseLookup6() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            chainRuleSets: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            backtrackClassDef: this.parsePointer(Parser.classDef),
            inputClassDef: this.parsePointer(Parser.classDef),
            lookaheadClassDef: this.parsePointer(Parser.classDef),
            chainClassSet: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        return {
            substFormat: 3,
            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
subtableParsers[7] = function parseLookup7() {
    // Extension Substitution subtable
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
    var extensionLookupType = this.parseUShort();
    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
    return {
        substFormat: 1,
        lookupType: extensionLookupType,
        extension: subtableParsers[extensionLookupType].call(extensionParser)
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
subtableParsers[8] = function parseLookup8() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        substitutes: this.parseUShortList()
    };
};

// https://www.microsoft.com/typography/OTSPEC/gsub.htm
function parseGsubTable(data, start) {
    start = start || 0;
    var p = new Parser(data, start);
    var tableVersion = p.parseVersion();
    check.argument(tableVersion === 1, 'Unsupported GSUB table version.');
    return {
        version: tableVersion,
        scripts: p.parseScriptList(),
        features: p.parseFeatureList(),
        lookups: p.parseLookupList(subtableParsers)
    };
}

// GSUB Writing //////////////////////////////////////////////
var subtableMakers = new Array(9);

subtableMakers[1] = function makeLookup1(subtable) {
    if (subtable.substFormat === 1) {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 1},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
        ]);
    } else {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 2},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
        ].concat(table.ushortList('substitute', subtable.substitute)));
    }
    check.fail('Lookup type 1 substFormat must be 1 or 2.');
};

subtableMakers[3] = function makeLookup3(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
    })));
};

subtableMakers[4] = function makeLookup4(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
            return new table.Table('ligatureTable',
                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
            );
        }));
    })));
};

function makeGsubTable(gsub) {
    return new table.Table('GSUB', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
    ]);
}

exports.parse = parseGsubTable;
exports.make = makeGsubTable;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm



var check = __webpack_require__(11);
var parse = __webpack_require__(8);
var table = __webpack_require__(13);

// Parse the header `head` table
function parseHeadTable(data, start) {
    var head = {};
    var p = new parse.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();
    head.glyphDataFormat = p.parseShort();
    return head;
}

function makeHeadTable(options) {
    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
    var createdTimestamp = timestamp;

    if (options.createdTimestamp) {
        createdTimestamp = options.createdTimestamp + 2082844800;
    }

    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}

exports.parse = parseHeadTable;
exports.make = makeHeadTable;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm



var parse = __webpack_require__(8);
var table = __webpack_require__(13);

// Parse the horizontal header `hhea` table
function parseHheaTable(data, start) {
    var hhea = {};
    var p = new parse.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseHheaTable;
exports.make = makeHheaTable;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm



var parse = __webpack_require__(8);
var table = __webpack_require__(13);

// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var advanceWidth;
    var leftSideBearing;
    var p = new parse.Parser(data, start);
    for (var i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }

        var glyph = glyphs.get(i);
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }

    return t;
}

exports.parse = parseHmtxTable;
exports.make = makeHmtxTable;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `ltag` table stores IETF BCP-47 language tags. It allows supporting
// languages for which TrueType does not assign a numeric code.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6ltag.html
// http://www.w3.org/International/articles/language-tags/
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry



var check = __webpack_require__(11);
var parse = __webpack_require__(8);
var table = __webpack_require__(13);

function makeLtagTable(tags) {
    var result = new table.Table('ltag', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'numTags', type: 'ULONG', value: tags.length}
    ]);

    var stringPool = '';
    var stringPoolOffset = 12 + tags.length * 4;
    for (var i = 0; i < tags.length; ++i) {
        var pos = stringPool.indexOf(tags[i]);
        if (pos < 0) {
            pos = stringPool.length;
            stringPool += tags[i];
        }

        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
    }

    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
    return result;
}

function parseLtagTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
    // The 'ltag' specification does not define any flags; skip the field.
    p.skip('uLong', 1);
    var numTags = p.parseULong();

    var tags = [];
    for (var i = 0; i < numTags; i++) {
        var tag = '';
        var offset = start + p.parseUShort();
        var length = p.parseUShort();
        for (var j = offset; j < offset + length; ++j) {
            tag += String.fromCharCode(data.getInt8(j));
        }

        tags.push(tag);
    }

    return tags;
}

exports.make = makeLtagTable;
exports.parse = parseLtagTable;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm



var parse = __webpack_require__(8);
var table = __webpack_require__(13);

// Parse the maximum profile `maxp` table.
function parseMaxpTable(data, start) {
    var maxp = {};
    var p = new parse.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }

    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}

exports.parse = parseMaxpTable;
exports.make = makeMaxpTable;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm



var types = __webpack_require__(75);
var decode = types.decode;
var check = __webpack_require__(11);
var parse = __webpack_require__(8);
var table = __webpack_require__(13);

// Parse the metadata `meta` table.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
function parseMetaTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported META table version.');
    p.parseULong(); // flags - currently unused and set to 0
    p.parseULong(); // tableOffset
    var numDataMaps = p.parseULong();

    var tags = {};
    for (var i = 0; i < numDataMaps; i++) {
        var tag = p.parseTag();
        var dataOffset = p.parseULong();
        var dataLength = p.parseULong();
        var text = decode.UTF8(data, start + dataOffset, dataLength);

        tags[tag] = text;
    }
    return tags;
}

function makeMetaTable(tags) {
    var numTags = Object.keys(tags).length;
    var stringPool = '';
    var stringPoolOffset = 16 + numTags * 12;

    var result = new table.Table('meta', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
        {name: 'numTags', type: 'ULONG', value: numTags}
    ]);

    for (var tag in tags) {
        var pos = stringPool.length;
        stringPool += tags[tag];

        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
    }

    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

    return result;
}

exports.parse = parseMetaTable;
exports.make = makeMetaTable;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm



var types = __webpack_require__(75);
var decode = types.decode;
var encode = types.encode;
var parse = __webpack_require__(8);
var table = __webpack_require__(13);

// NameIDs for the name table.
var nameTableNames = [
    'copyright',              // 0
    'fontFamily',             // 1
    'fontSubfamily',          // 2
    'uniqueID',               // 3
    'fullName',               // 4
    'version',                // 5
    'postScriptName',         // 6
    'trademark',              // 7
    'manufacturer',           // 8
    'designer',               // 9
    'description',            // 10
    'manufacturerURL',        // 11
    'designerURL',            // 12
    'license',                // 13
    'licenseURL',             // 14
    'reserved',               // 15
    'preferredFamily',        // 16
    'preferredSubfamily',     // 17
    'compatibleFullName',     // 18
    'sampleText',             // 19
    'postScriptFindFontName', // 20
    'wwsFamily',              // 21
    'wwsSubfamily'            // 22
];

var macLanguages = {
    0: 'en',
    1: 'fr',
    2: 'de',
    3: 'it',
    4: 'nl',
    5: 'sv',
    6: 'es',
    7: 'da',
    8: 'pt',
    9: 'no',
    10: 'he',
    11: 'ja',
    12: 'ar',
    13: 'fi',
    14: 'el',
    15: 'is',
    16: 'mt',
    17: 'tr',
    18: 'hr',
    19: 'zh-Hant',
    20: 'ur',
    21: 'hi',
    22: 'th',
    23: 'ko',
    24: 'lt',
    25: 'pl',
    26: 'hu',
    27: 'es',
    28: 'lv',
    29: 'se',
    30: 'fo',
    31: 'fa',
    32: 'ru',
    33: 'zh',
    34: 'nl-BE',
    35: 'ga',
    36: 'sq',
    37: 'ro',
    38: 'cz',
    39: 'sk',
    40: 'si',
    41: 'yi',
    42: 'sr',
    43: 'mk',
    44: 'bg',
    45: 'uk',
    46: 'be',
    47: 'uz',
    48: 'kk',
    49: 'az-Cyrl',
    50: 'az-Arab',
    51: 'hy',
    52: 'ka',
    53: 'mo',
    54: 'ky',
    55: 'tg',
    56: 'tk',
    57: 'mn-CN',
    58: 'mn',
    59: 'ps',
    60: 'ks',
    61: 'ku',
    62: 'sd',
    63: 'bo',
    64: 'ne',
    65: 'sa',
    66: 'mr',
    67: 'bn',
    68: 'as',
    69: 'gu',
    70: 'pa',
    71: 'or',
    72: 'ml',
    73: 'kn',
    74: 'ta',
    75: 'te',
    76: 'si',
    77: 'my',
    78: 'km',
    79: 'lo',
    80: 'vi',
    81: 'id',
    82: 'tl',
    83: 'ms',
    84: 'ms-Arab',
    85: 'am',
    86: 'ti',
    87: 'om',
    88: 'so',
    89: 'sw',
    90: 'rw',
    91: 'rn',
    92: 'ny',
    93: 'mg',
    94: 'eo',
    128: 'cy',
    129: 'eu',
    130: 'ca',
    131: 'la',
    132: 'qu',
    133: 'gn',
    134: 'ay',
    135: 'tt',
    136: 'ug',
    137: 'dz',
    138: 'jv',
    139: 'su',
    140: 'gl',
    141: 'af',
    142: 'br',
    143: 'iu',
    144: 'gd',
    145: 'gv',
    146: 'ga',
    147: 'to',
    148: 'el-polyton',
    149: 'kl',
    150: 'az',
    151: 'nn'
};

// MacOS language ID → MacOS script ID
//
// Note that the script ID is not sufficient to determine what encoding
// to use in TrueType files. For some languages, MacOS used a modification
// of a mainstream script. For example, an Icelandic name would be stored
// with smRoman in the TrueType naming table, but the actual encoding
// is a special Icelandic version of the normal Macintosh Roman encoding.
// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
// Syllables but MacOS had run out of available script codes, so this was
// done as a (pretty radical) "modification" of Ethiopic.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageToScript = {
    0: 0,  // langEnglish → smRoman
    1: 0,  // langFrench → smRoman
    2: 0,  // langGerman → smRoman
    3: 0,  // langItalian → smRoman
    4: 0,  // langDutch → smRoman
    5: 0,  // langSwedish → smRoman
    6: 0,  // langSpanish → smRoman
    7: 0,  // langDanish → smRoman
    8: 0,  // langPortuguese → smRoman
    9: 0,  // langNorwegian → smRoman
    10: 5,  // langHebrew → smHebrew
    11: 1,  // langJapanese → smJapanese
    12: 4,  // langArabic → smArabic
    13: 0,  // langFinnish → smRoman
    14: 6,  // langGreek → smGreek
    15: 0,  // langIcelandic → smRoman (modified)
    16: 0,  // langMaltese → smRoman
    17: 0,  // langTurkish → smRoman (modified)
    18: 0,  // langCroatian → smRoman (modified)
    19: 2,  // langTradChinese → smTradChinese
    20: 4,  // langUrdu → smArabic
    21: 9,  // langHindi → smDevanagari
    22: 21,  // langThai → smThai
    23: 3,  // langKorean → smKorean
    24: 29,  // langLithuanian → smCentralEuroRoman
    25: 29,  // langPolish → smCentralEuroRoman
    26: 29,  // langHungarian → smCentralEuroRoman
    27: 29,  // langEstonian → smCentralEuroRoman
    28: 29,  // langLatvian → smCentralEuroRoman
    29: 0,  // langSami → smRoman
    30: 0,  // langFaroese → smRoman (modified)
    31: 4,  // langFarsi → smArabic (modified)
    32: 7,  // langRussian → smCyrillic
    33: 25,  // langSimpChinese → smSimpChinese
    34: 0,  // langFlemish → smRoman
    35: 0,  // langIrishGaelic → smRoman (modified)
    36: 0,  // langAlbanian → smRoman
    37: 0,  // langRomanian → smRoman (modified)
    38: 29,  // langCzech → smCentralEuroRoman
    39: 29,  // langSlovak → smCentralEuroRoman
    40: 0,  // langSlovenian → smRoman (modified)
    41: 5,  // langYiddish → smHebrew
    42: 7,  // langSerbian → smCyrillic
    43: 7,  // langMacedonian → smCyrillic
    44: 7,  // langBulgarian → smCyrillic
    45: 7,  // langUkrainian → smCyrillic (modified)
    46: 7,  // langByelorussian → smCyrillic
    47: 7,  // langUzbek → smCyrillic
    48: 7,  // langKazakh → smCyrillic
    49: 7,  // langAzerbaijani → smCyrillic
    50: 4,  // langAzerbaijanAr → smArabic
    51: 24,  // langArmenian → smArmenian
    52: 23,  // langGeorgian → smGeorgian
    53: 7,  // langMoldavian → smCyrillic
    54: 7,  // langKirghiz → smCyrillic
    55: 7,  // langTajiki → smCyrillic
    56: 7,  // langTurkmen → smCyrillic
    57: 27,  // langMongolian → smMongolian
    58: 7,  // langMongolianCyr → smCyrillic
    59: 4,  // langPashto → smArabic
    60: 4,  // langKurdish → smArabic
    61: 4,  // langKashmiri → smArabic
    62: 4,  // langSindhi → smArabic
    63: 26,  // langTibetan → smTibetan
    64: 9,  // langNepali → smDevanagari
    65: 9,  // langSanskrit → smDevanagari
    66: 9,  // langMarathi → smDevanagari
    67: 13,  // langBengali → smBengali
    68: 13,  // langAssamese → smBengali
    69: 11,  // langGujarati → smGujarati
    70: 10,  // langPunjabi → smGurmukhi
    71: 12,  // langOriya → smOriya
    72: 17,  // langMalayalam → smMalayalam
    73: 16,  // langKannada → smKannada
    74: 14,  // langTamil → smTamil
    75: 15,  // langTelugu → smTelugu
    76: 18,  // langSinhalese → smSinhalese
    77: 19,  // langBurmese → smBurmese
    78: 20,  // langKhmer → smKhmer
    79: 22,  // langLao → smLao
    80: 30,  // langVietnamese → smVietnamese
    81: 0,  // langIndonesian → smRoman
    82: 0,  // langTagalog → smRoman
    83: 0,  // langMalayRoman → smRoman
    84: 4,  // langMalayArabic → smArabic
    85: 28,  // langAmharic → smEthiopic
    86: 28,  // langTigrinya → smEthiopic
    87: 28,  // langOromo → smEthiopic
    88: 0,  // langSomali → smRoman
    89: 0,  // langSwahili → smRoman
    90: 0,  // langKinyarwanda → smRoman
    91: 0,  // langRundi → smRoman
    92: 0,  // langNyanja → smRoman
    93: 0,  // langMalagasy → smRoman
    94: 0,  // langEsperanto → smRoman
    128: 0,  // langWelsh → smRoman (modified)
    129: 0,  // langBasque → smRoman
    130: 0,  // langCatalan → smRoman
    131: 0,  // langLatin → smRoman
    132: 0,  // langQuechua → smRoman
    133: 0,  // langGuarani → smRoman
    134: 0,  // langAymara → smRoman
    135: 7,  // langTatar → smCyrillic
    136: 4,  // langUighur → smArabic
    137: 26,  // langDzongkha → smTibetan
    138: 0,  // langJavaneseRom → smRoman
    139: 0,  // langSundaneseRom → smRoman
    140: 0,  // langGalician → smRoman
    141: 0,  // langAfrikaans → smRoman
    142: 0,  // langBreton → smRoman (modified)
    143: 28,  // langInuktitut → smEthiopic (modified)
    144: 0,  // langScottishGaelic → smRoman (modified)
    145: 0,  // langManxGaelic → smRoman (modified)
    146: 0,  // langIrishGaelicScript → smRoman (modified)
    147: 0,  // langTongan → smRoman
    148: 6,  // langGreekAncient → smRoman
    149: 0,  // langGreenlandic → smRoman
    150: 0,  // langAzerbaijanRoman → smRoman
    151: 0   // langNynorsk → smRoman
};

// While Microsoft indicates a region/country for all its language
// IDs, we omit the region code if it's equal to the "most likely
// region subtag" according to Unicode CLDR. For scripts, we omit
// the subtag if it is equal to the Suppress-Script entry in the
// IANA language subtag registry for IETF BCP 47.
//
// For example, Microsoft states that its language code 0x041A is
// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
// and not 'hr-HR' because Croatia is the default country for Croatian,
// according to Unicode CLDR. As another example, Microsoft states
// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
// for the Croatian language, according to IANA.
//
// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
var windowsLanguages = {
    0x0436: 'af',
    0x041C: 'sq',
    0x0484: 'gsw',
    0x045E: 'am',
    0x1401: 'ar-DZ',
    0x3C01: 'ar-BH',
    0x0C01: 'ar',
    0x0801: 'ar-IQ',
    0x2C01: 'ar-JO',
    0x3401: 'ar-KW',
    0x3001: 'ar-LB',
    0x1001: 'ar-LY',
    0x1801: 'ary',
    0x2001: 'ar-OM',
    0x4001: 'ar-QA',
    0x0401: 'ar-SA',
    0x2801: 'ar-SY',
    0x1C01: 'aeb',
    0x3801: 'ar-AE',
    0x2401: 'ar-YE',
    0x042B: 'hy',
    0x044D: 'as',
    0x082C: 'az-Cyrl',
    0x042C: 'az',
    0x046D: 'ba',
    0x042D: 'eu',
    0x0423: 'be',
    0x0845: 'bn',
    0x0445: 'bn-IN',
    0x201A: 'bs-Cyrl',
    0x141A: 'bs',
    0x047E: 'br',
    0x0402: 'bg',
    0x0403: 'ca',
    0x0C04: 'zh-HK',
    0x1404: 'zh-MO',
    0x0804: 'zh',
    0x1004: 'zh-SG',
    0x0404: 'zh-TW',
    0x0483: 'co',
    0x041A: 'hr',
    0x101A: 'hr-BA',
    0x0405: 'cs',
    0x0406: 'da',
    0x048C: 'prs',
    0x0465: 'dv',
    0x0813: 'nl-BE',
    0x0413: 'nl',
    0x0C09: 'en-AU',
    0x2809: 'en-BZ',
    0x1009: 'en-CA',
    0x2409: 'en-029',
    0x4009: 'en-IN',
    0x1809: 'en-IE',
    0x2009: 'en-JM',
    0x4409: 'en-MY',
    0x1409: 'en-NZ',
    0x3409: 'en-PH',
    0x4809: 'en-SG',
    0x1C09: 'en-ZA',
    0x2C09: 'en-TT',
    0x0809: 'en-GB',
    0x0409: 'en',
    0x3009: 'en-ZW',
    0x0425: 'et',
    0x0438: 'fo',
    0x0464: 'fil',
    0x040B: 'fi',
    0x080C: 'fr-BE',
    0x0C0C: 'fr-CA',
    0x040C: 'fr',
    0x140C: 'fr-LU',
    0x180C: 'fr-MC',
    0x100C: 'fr-CH',
    0x0462: 'fy',
    0x0456: 'gl',
    0x0437: 'ka',
    0x0C07: 'de-AT',
    0x0407: 'de',
    0x1407: 'de-LI',
    0x1007: 'de-LU',
    0x0807: 'de-CH',
    0x0408: 'el',
    0x046F: 'kl',
    0x0447: 'gu',
    0x0468: 'ha',
    0x040D: 'he',
    0x0439: 'hi',
    0x040E: 'hu',
    0x040F: 'is',
    0x0470: 'ig',
    0x0421: 'id',
    0x045D: 'iu',
    0x085D: 'iu-Latn',
    0x083C: 'ga',
    0x0434: 'xh',
    0x0435: 'zu',
    0x0410: 'it',
    0x0810: 'it-CH',
    0x0411: 'ja',
    0x044B: 'kn',
    0x043F: 'kk',
    0x0453: 'km',
    0x0486: 'quc',
    0x0487: 'rw',
    0x0441: 'sw',
    0x0457: 'kok',
    0x0412: 'ko',
    0x0440: 'ky',
    0x0454: 'lo',
    0x0426: 'lv',
    0x0427: 'lt',
    0x082E: 'dsb',
    0x046E: 'lb',
    0x042F: 'mk',
    0x083E: 'ms-BN',
    0x043E: 'ms',
    0x044C: 'ml',
    0x043A: 'mt',
    0x0481: 'mi',
    0x047A: 'arn',
    0x044E: 'mr',
    0x047C: 'moh',
    0x0450: 'mn',
    0x0850: 'mn-CN',
    0x0461: 'ne',
    0x0414: 'nb',
    0x0814: 'nn',
    0x0482: 'oc',
    0x0448: 'or',
    0x0463: 'ps',
    0x0415: 'pl',
    0x0416: 'pt',
    0x0816: 'pt-PT',
    0x0446: 'pa',
    0x046B: 'qu-BO',
    0x086B: 'qu-EC',
    0x0C6B: 'qu',
    0x0418: 'ro',
    0x0417: 'rm',
    0x0419: 'ru',
    0x243B: 'smn',
    0x103B: 'smj-NO',
    0x143B: 'smj',
    0x0C3B: 'se-FI',
    0x043B: 'se',
    0x083B: 'se-SE',
    0x203B: 'sms',
    0x183B: 'sma-NO',
    0x1C3B: 'sms',
    0x044F: 'sa',
    0x1C1A: 'sr-Cyrl-BA',
    0x0C1A: 'sr',
    0x181A: 'sr-Latn-BA',
    0x081A: 'sr-Latn',
    0x046C: 'nso',
    0x0432: 'tn',
    0x045B: 'si',
    0x041B: 'sk',
    0x0424: 'sl',
    0x2C0A: 'es-AR',
    0x400A: 'es-BO',
    0x340A: 'es-CL',
    0x240A: 'es-CO',
    0x140A: 'es-CR',
    0x1C0A: 'es-DO',
    0x300A: 'es-EC',
    0x440A: 'es-SV',
    0x100A: 'es-GT',
    0x480A: 'es-HN',
    0x080A: 'es-MX',
    0x4C0A: 'es-NI',
    0x180A: 'es-PA',
    0x3C0A: 'es-PY',
    0x280A: 'es-PE',
    0x500A: 'es-PR',

    // Microsoft has defined two different language codes for
    // “Spanish with modern sorting” and “Spanish with traditional
    // sorting”. This makes sense for collation APIs, and it would be
    // possible to express this in BCP 47 language tags via Unicode
    // extensions (eg., es-u-co-trad is Spanish with traditional
    // sorting). However, for storing names in fonts, the distinction
    // does not make sense, so we give “es” in both cases.
    0x0C0A: 'es',
    0x040A: 'es',

    0x540A: 'es-US',
    0x380A: 'es-UY',
    0x200A: 'es-VE',
    0x081D: 'sv-FI',
    0x041D: 'sv',
    0x045A: 'syr',
    0x0428: 'tg',
    0x085F: 'tzm',
    0x0449: 'ta',
    0x0444: 'tt',
    0x044A: 'te',
    0x041E: 'th',
    0x0451: 'bo',
    0x041F: 'tr',
    0x0442: 'tk',
    0x0480: 'ug',
    0x0422: 'uk',
    0x042E: 'hsb',
    0x0420: 'ur',
    0x0843: 'uz-Cyrl',
    0x0443: 'uz',
    0x042A: 'vi',
    0x0452: 'cy',
    0x0488: 'wo',
    0x0485: 'sah',
    0x0478: 'ii',
    0x046A: 'yo'
};

// Returns a IETF BCP 47 language code, for example 'zh-Hant'
// for 'Chinese in the traditional script'.
function getLanguageCode(platformID, languageID, ltag) {
    switch (platformID) {
        case 0:  // Unicode
            if (languageID === 0xFFFF) {
                return 'und';
            } else if (ltag) {
                return ltag[languageID];
            }

            break;

        case 1:  // Macintosh
            return macLanguages[languageID];

        case 3:  // Windows
            return windowsLanguages[languageID];
    }

    return undefined;
}

var utf16 = 'utf-16';

// MacOS script ID → encoding. This table stores the default case,
// which can be overridden by macLanguageEncodings.
var macScriptEncodings = {
    0: 'macintosh',           // smRoman
    1: 'x-mac-japanese',      // smJapanese
    2: 'x-mac-chinesetrad',   // smTradChinese
    3: 'x-mac-korean',        // smKorean
    6: 'x-mac-greek',         // smGreek
    7: 'x-mac-cyrillic',      // smCyrillic
    9: 'x-mac-devanagai',     // smDevanagari
    10: 'x-mac-gurmukhi',     // smGurmukhi
    11: 'x-mac-gujarati',     // smGujarati
    12: 'x-mac-oriya',        // smOriya
    13: 'x-mac-bengali',      // smBengali
    14: 'x-mac-tamil',        // smTamil
    15: 'x-mac-telugu',       // smTelugu
    16: 'x-mac-kannada',      // smKannada
    17: 'x-mac-malayalam',    // smMalayalam
    18: 'x-mac-sinhalese',    // smSinhalese
    19: 'x-mac-burmese',      // smBurmese
    20: 'x-mac-khmer',        // smKhmer
    21: 'x-mac-thai',         // smThai
    22: 'x-mac-lao',          // smLao
    23: 'x-mac-georgian',     // smGeorgian
    24: 'x-mac-armenian',     // smArmenian
    25: 'x-mac-chinesesimp',  // smSimpChinese
    26: 'x-mac-tibetan',      // smTibetan
    27: 'x-mac-mongolian',    // smMongolian
    28: 'x-mac-ethiopic',     // smEthiopic
    29: 'x-mac-ce',           // smCentralEuroRoman
    30: 'x-mac-vietnamese',   // smVietnamese
    31: 'x-mac-extarabic'     // smExtArabic
};

// MacOS language ID → encoding. This table stores the exceptional
// cases, which override macScriptEncodings. For writing MacOS naming
// tables, we need to emit a MacOS script ID. Therefore, we cannot
// merge macScriptEncodings into macLanguageEncodings.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageEncodings = {
    15: 'x-mac-icelandic',    // langIcelandic
    17: 'x-mac-turkish',      // langTurkish
    18: 'x-mac-croatian',     // langCroatian
    24: 'x-mac-ce',           // langLithuanian
    25: 'x-mac-ce',           // langPolish
    26: 'x-mac-ce',           // langHungarian
    27: 'x-mac-ce',           // langEstonian
    28: 'x-mac-ce',           // langLatvian
    30: 'x-mac-icelandic',    // langFaroese
    37: 'x-mac-romanian',     // langRomanian
    38: 'x-mac-ce',           // langCzech
    39: 'x-mac-ce',           // langSlovak
    40: 'x-mac-ce',           // langSlovenian
    143: 'x-mac-inuit',       // langInuktitut
    146: 'x-mac-gaelic'       // langIrishGaelicScript
};

function getEncoding(platformID, encodingID, languageID) {
    switch (platformID) {
        case 0:  // Unicode
            return utf16;

        case 1:  // Apple Macintosh
            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

        case 3:  // Microsoft Windows
            if (encodingID === 1 || encodingID === 10) {
                return utf16;
            }

            break;
    }

    return undefined;
}

// Parse the naming `name` table.
// FIXME: Format 1 additional fields are not supported yet.
// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
function parseNameTable(data, start, ltag) {
    var name = {};
    var p = new parse.Parser(data, start);
    var format = p.parseUShort();
    var count = p.parseUShort();
    var stringOffset = p.offset + p.parseUShort();
    for (var i = 0; i < count; i++) {
        var platformID = p.parseUShort();
        var encodingID = p.parseUShort();
        var languageID = p.parseUShort();
        var nameID = p.parseUShort();
        var property = nameTableNames[nameID] || nameID;
        var byteLength = p.parseUShort();
        var offset = p.parseUShort();
        var language = getLanguageCode(platformID, languageID, ltag);
        var encoding = getEncoding(platformID, encodingID, languageID);
        if (encoding !== undefined && language !== undefined) {
            var text;
            if (encoding === utf16) {
                text = decode.UTF16(data, stringOffset + offset, byteLength);
            } else {
                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
            }

            if (text) {
                var translations = name[property];
                if (translations === undefined) {
                    translations = name[property] = {};
                }

                translations[language] = text;
            }
        }
    }

    var langTagCount = 0;
    if (format === 1) {
        // FIXME: Also handle Microsoft's 'name' table 1.
        langTagCount = p.parseUShort();
    }

    return name;
}

// {23: 'foo'} → {'foo': 23}
// ['bar', 'baz'] → {'bar': 0, 'baz': 1}
function reverseDict(dict) {
    var result = {};
    for (var key in dict) {
        result[dict[key]] = parseInt(key);
    }

    return result;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Record('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}

// Finds the position of needle in haystack, or -1 if not there.
// Like String.indexOf(), but for arrays.
function findSubArray(needle, haystack) {
    var needleLength = needle.length;
    var limit = haystack.length - needleLength + 1;

    loop:
    for (var pos = 0; pos < limit; pos++) {
        for (; pos < limit; pos++) {
            for (var k = 0; k < needleLength; k++) {
                if (haystack[pos + k] !== needle[k]) {
                    continue loop;
                }
            }

            return pos;
        }
    }

    return -1;
}

function addStringToPool(s, pool) {
    var offset = findSubArray(s, pool);
    if (offset < 0) {
        offset = pool.length;
        for (var i = 0, len = s.length; i < len; ++i) {
            pool.push(s[i]);
        }

    }

    return offset;
}

function makeNameTable(names, ltag) {
    var nameID;
    var nameIDs = [];

    var namesWithNumericKeys = {};
    var nameTableIds = reverseDict(nameTableNames);
    for (var key in names) {
        var id = nameTableIds[key];
        if (id === undefined) {
            id = key;
        }

        nameID = parseInt(id);

        if (isNaN(nameID)) {
            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
        }

        namesWithNumericKeys[nameID] = names[key];
        nameIDs.push(nameID);
    }

    var macLanguageIds = reverseDict(macLanguages);
    var windowsLanguageIds = reverseDict(windowsLanguages);

    var nameRecords = [];
    var stringPool = [];

    for (var i = 0; i < nameIDs.length; i++) {
        nameID = nameIDs[i];
        var translations = namesWithNumericKeys[nameID];
        for (var lang in translations) {
            var text = translations[lang];

            // For MacOS, we try to emit the name in the form that was introduced
            // in the initial version of the TrueType spec (in the late 1980s).
            // However, this can fail for various reasons: the requested BCP 47
            // language code might not have an old-style Mac equivalent;
            // we might not have a codec for the needed character encoding;
            // or the name might contain characters that cannot be expressed
            // in the old-style Macintosh encoding. In case of failure, we emit
            // the name in a more modern fashion (Unicode encoding with BCP 47
            // language tags) that is recognized by MacOS 10.5, released in 2009.
            // If fonts were only read by operating systems, we could simply
            // emit all names in the modern form; this would be much easier.
            // However, there are many applications and libraries that read
            // 'name' tables directly, and these will usually only recognize
            // the ancient form (silently skipping the unrecognized names).
            var macPlatform = 1;  // Macintosh
            var macLanguage = macLanguageIds[lang];
            var macScript = macLanguageToScript[macLanguage];
            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
            var macName = encode.MACSTRING(text, macEncoding);
            if (macName === undefined) {
                macPlatform = 0;  // Unicode
                macLanguage = ltag.indexOf(lang);
                if (macLanguage < 0) {
                    macLanguage = ltag.length;
                    ltag.push(lang);
                }

                macScript = 4;  // Unicode 2.0 and later
                macName = encode.UTF16(text);
            }

            var macNameOffset = addStringToPool(macName, stringPool);
            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
                                            nameID, macName.length, macNameOffset));

            var winLanguage = windowsLanguageIds[lang];
            if (winLanguage !== undefined) {
                var winName = encode.UTF16(text);
                var winNameOffset = addStringToPool(winName, stringPool);
                nameRecords.push(makeNameRecord(3, 1, winLanguage,
                                                nameID, winName.length, winNameOffset));
            }
        }
    }

    nameRecords.sort(function(a, b) {
        return ((a.platformID - b.platformID) ||
                (a.encodingID - b.encodingID) ||
                (a.languageID - b.languageID) ||
                (a.nameID - b.nameID));
    });

    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: nameRecords.length},
        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
    ]);

    for (var r = 0; r < nameRecords.length; r++) {
        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
    }

    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
    return t;
}

exports.parse = parseNameTable;
exports.make = makeNameTable;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm



var parse = __webpack_require__(8);
var table = __webpack_require__(13);

var unicodeRanges = [
    {begin: 0x0000, end: 0x007F}, // Basic Latin
    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
    {begin: 0x2C80, end: 0x2CFF}, // Coptic
    {begin: 0x0400, end: 0x04FF}, // Cyrillic
    {begin: 0x0530, end: 0x058F}, // Armenian
    {begin: 0x0590, end: 0x05FF}, // Hebrew
    {begin: 0xA500, end: 0xA63F}, // Vai
    {begin: 0x0600, end: 0x06FF}, // Arabic
    {begin: 0x07C0, end: 0x07FF}, // NKo
    {begin: 0x0900, end: 0x097F}, // Devanagari
    {begin: 0x0980, end: 0x09FF}, // Bengali
    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
    {begin: 0x0B00, end: 0x0B7F}, // Oriya
    {begin: 0x0B80, end: 0x0BFF}, // Tamil
    {begin: 0x0C00, end: 0x0C7F}, // Telugu
    {begin: 0x0C80, end: 0x0CFF}, // Kannada
    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
    {begin: 0x0E00, end: 0x0E7F}, // Thai
    {begin: 0x0E80, end: 0x0EFF}, // Lao
    {begin: 0x10A0, end: 0x10FF}, // Georgian
    {begin: 0x1B00, end: 0x1B7F}, // Balinese
    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
    {begin: 0x2000, end: 0x206F}, // General Punctuation
    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
    {begin: 0x2150, end: 0x218F}, // Number Forms
    {begin: 0x2190, end: 0x21FF}, // Arrows
    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
    {begin: 0x2400, end: 0x243F}, // Control Pictures
    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
    {begin: 0x2500, end: 0x257F}, // Box Drawing
    {begin: 0x2580, end: 0x259F}, // Block Elements
    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
    {begin: 0x2700, end: 0x27BF}, // Dingbats
    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
    {begin: 0x3040, end: 0x309F}, // Hiragana
    {begin: 0x30A0, end: 0x30FF}, // Katakana
    {begin: 0x3100, end: 0x312F}, // Bopomofo
    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
    {begin: 0xA840, end: 0xA87F}, // Phags-pa
    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
    {begin: 0x10900, end: 0x1091F}, // Phoenicia
    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
    {begin: 0xFFF0, end: 0xFFFF}, // Specials
    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
    {begin: 0x0700, end: 0x074F}, // Syriac
    {begin: 0x0780, end: 0x07BF}, // Thaana
    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
    {begin: 0x1000, end: 0x109F}, // Myanmar
    {begin: 0x1200, end: 0x137F}, // Ethiopic
    {begin: 0x13A0, end: 0x13FF}, // Cherokee
    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
    {begin: 0x1680, end: 0x169F}, // Ogham
    {begin: 0x16A0, end: 0x16FF}, // Runic
    {begin: 0x1780, end: 0x17FF}, // Khmer
    {begin: 0x1800, end: 0x18AF}, // Mongolian
    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
    {begin: 0x1700, end: 0x171F}, // Tagalog
    {begin: 0x10300, end: 0x1032F}, // Old Italic
    {begin: 0x10330, end: 0x1034F}, // Gothic
    {begin: 0x10400, end: 0x1044F}, // Deseret
    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
    {begin: 0xE0000, end: 0xE007F}, // Tags
    {begin: 0x1900, end: 0x194F}, // Limbu
    {begin: 0x1950, end: 0x197F}, // Tai Le
    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
    {begin: 0x1A00, end: 0x1A1F}, // Buginese
    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
    {begin: 0x10380, end: 0x1039F}, // Ugaritic
    {begin: 0x103A0, end: 0x103DF}, // Old Persian
    {begin: 0x10450, end: 0x1047F}, // Shavian
    {begin: 0x10480, end: 0x104AF}, // Osmanya
    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
    {begin: 0x12000, end: 0x123FF}, // Cuneiform
    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
    {begin: 0xA900, end: 0xA92F}, // Kayah Li
    {begin: 0xA930, end: 0xA95F}, // Rejang
    {begin: 0xAA00, end: 0xAA5F}, // Cham
    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
    {begin: 0x102A0, end: 0x102DF}, // Carian
    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
];

function getUnicodeRange(unicode) {
    for (var i = 0; i < unicodeRanges.length; i += 1) {
        var range = unicodeRanges[i];
        if (unicode >= range.begin && unicode < range.end) {
            return i;
        }
    }

    return -1;
}

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {};
    var p = new parse.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }

    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }

    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }

    return os2;
}

function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}

exports.unicodeRanges = unicodeRanges;
exports.getUnicodeRange = getUnicodeRange;
exports.parse = parseOS2Table;
exports.make = makeOS2Table;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm



var encoding = __webpack_require__(74);
var parse = __webpack_require__(8);
var table = __webpack_require__(13);

// Parse the PostScript `post` table
function parsePostTable(data, start) {
    var post = {};
    var p = new parse.Parser(data, start);
    var i;
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
        case 1:
            post.names = encoding.standardNames.slice();
            break;
        case 2:
            post.numberOfGlyphs = p.parseUShort();
            post.glyphNameIndex = new Array(post.numberOfGlyphs);
            for (i = 0; i < post.numberOfGlyphs; i++) {
                post.glyphNameIndex[i] = p.parseUShort();
            }

            post.names = [];
            for (i = 0; i < post.numberOfGlyphs; i++) {
                if (post.glyphNameIndex[i] >= encoding.standardNames.length) {
                    var nameLength = p.parseChar();
                    post.names.push(p.parseString(nameLength));
                }
            }

            break;
        case 2.5:
            post.numberOfGlyphs = p.parseUShort();
            post.offset = new Array(post.numberOfGlyphs);
            for (i = 0; i < post.numberOfGlyphs; i++) {
                post.offset[i] = p.parseChar();
            }

            break;
    }
    return post;
}

function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}

exports.parse = parsePostTable;
exports.make = makePostTable;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.isBrowser = function() {
    return typeof window !== 'undefined';
};

exports.isNode = function() {
    return typeof window === 'undefined';
};

exports.nodeBufferToArrayBuffer = function(buffer) {
    var ab = new ArrayBuffer(buffer.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        view[i] = buffer[i];
    }

    return ab;
};

exports.arrayBufferToNodeBuffer = function(ab) {
    var buffer = new Buffer(ab.byteLength);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
    }

    return buffer;
};

exports.checkArgument = function(expression, message) {
    if (!expression) {
        throw message;
    }
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(191).Buffer))

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(386);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__revi_core_IObject_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__revi_graphics_Canvas_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layout_Viewport_js__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__persona_Persona_js__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__persona_Events_js__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__revi_plugins_input_InputManager_js__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__revi_plugins_easing_Easing_js__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__revi_plugins_Scheduler_js__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__config_General_js__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__config_Persona_js__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__config_Layout_js__ = __webpack_require__(170);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Personas", function() { return Personas; });
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */















var Personas = function (_IObject) {
    _inherits(Personas, _IObject);

    function Personas(element) {
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Personas);

        var _this = _possibleConstructorReturn(this, (Personas.__proto__ || Object.getPrototypeOf(Personas)).call(this));

        _this.mConfig = {
            general: Object.assign({}, __WEBPACK_IMPORTED_MODULE_8__config_General_js__["a" /* default */], config.general),
            persona: Object.assign({}, __WEBPACK_IMPORTED_MODULE_9__config_Persona_js__["a" /* default */], config.persona),
            layout: Object.assign({}, __WEBPACK_IMPORTED_MODULE_10__config_Layout_js__["a" /* default */], config.layout)
        };

        _this.mCanvas = new __WEBPACK_IMPORTED_MODULE_1__revi_graphics_Canvas_js__["a" /* default */](element, _this.mConfig.general.initialDeviceScale);

        _this.mElement = element;
        _this.mViewport = new __WEBPACK_IMPORTED_MODULE_2__layout_Viewport_js__["a" /* default */](_this.mCanvas.size.width, _this.mCanvas.size.height, _this.mConfig.layout);
        _this.mSizeDomain = _this.mConfig.general.personaMaxRadius - _this.mConfig.general.personaMinRadius;

        __WEBPACK_IMPORTED_MODULE_5__revi_plugins_input_InputManager_js__["a" /* default */].registerContext(_this.mCanvas.reviContext);
        __WEBPACK_IMPORTED_MODULE_6__revi_plugins_easing_Easing_js__["a" /* default */].registerContext(_this.mCanvas.reviContext);
        __WEBPACK_IMPORTED_MODULE_7__revi_plugins_Scheduler_js__["a" /* default */].registerContext(_this.mCanvas.reviContext);

        _this.mCanvas.addChild(_this.mViewport);
        return _this;
    }

    _createClass(Personas, [{
        key: 'destroy',
        value: function destroy() {
            __WEBPACK_IMPORTED_MODULE_5__revi_plugins_input_InputManager_js__["a" /* default */].unregisterContext(this.mCanvas.reviContext);
            _get(Personas.prototype.__proto__ || Object.getPrototypeOf(Personas.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'loadData',
        value: function loadData(data) {
            var _this2 = this;

            this.mData = data;
            var totalRadius = 0;
            data.personas.forEach(function (personaData) {
                var persona = new __WEBPACK_IMPORTED_MODULE_3__persona_Persona_js__["a" /* default */](_this2.mConfig.general.personaMinRadius + personaData.scalingFactor * _this2.mSizeDomain, personaData, _this2.mConfig.persona);
                totalRadius += persona.safeRadius + 20;
                persona.position.set(totalRadius, 200);
                totalRadius += persona.safeRadius;
                persona.on(__WEBPACK_IMPORTED_MODULE_4__persona_Events_js__["a" /* default */].PERSONA_CLICKED, function (sender) {
                    sender.selected = !sender.selected;
                });
                _this2.mViewport.addChild(persona);
            });
        }
    }]);

    return Personas;
}(__WEBPACK_IMPORTED_MODULE_0__revi_core_IObject_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["default"] = Personas;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(372);

__webpack_require__(385);

__webpack_require__(192);

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(76)))

/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var GeneralConfig = {
  initialDeviceScale: 0,

  personaMinRadius: 65,
  personaMaxRadius: 250
};

/* harmony default export */ __webpack_exports__["a"] = GeneralConfig;

/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export LayoutConfig */
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var LayoutConfig = {
  zoomControlsPosition: 'top-right', // available options: 'top-left', 'top-right', 'bottom-left', 'bottom-right'
  zoomControlsPadding: 10,
  zoomControlsButtonSize: 24,
  zoomControlsBackgroundColor: '#ffffff',
  zoomControlsBorderSize: 1,
  zoomControlsBorderColor: '#cccccc',
  zoomControlsFontSize: 16,
  zoomControlsFontColor: '#222222',
  zoomControlsFontShadow: false,
  zoomControlsFontShadowColor: '#000000',
  zoomControlsFontShadowBlur: 2,
  zoomControlsFontShadowOffsetX: 0,
  zoomControlsFontShadowOffsetY: 0,

  viewportDragThreshold: 8,
  viewportMaxZoomMultiplier: 2,
  viewportMinZoomMultiplier: 0.3,
  viewportZoomScrollMultiplier: 0.001,
  viewportDelayedRedraw: true,
  viewportDelayedRedrawTime: 50
};

/* harmony default export */ __webpack_exports__["a"] = LayoutConfig;

/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var PersonaConfig = {
    backgroundColor: '#333333',
    radiusOverlap: 1, // used to grow/shrink the radius/thickness of circles and strokes to mitigate artifacts created by canvas' anti-aliasing.

    selectedBorder: 4,
    selectedBorderColor: '#2ab3e4',

    unselectedBorder: 2,
    unselectedBorderColor: '#CEC3B8',

    gaugeThickness: 8,
    gaugeBackgroundColor: '#F6F1EE',
    gaugePadding: 1,
    gaugeMarkerThickness: 2,
    gaugeMarkerSpill: 5,
    gaugeMarkerColor: '#2f2f2f',
    gaugeBarPadding: 3,
    gaugeBarCaps: 'butt',

    avatarBorder: 2,
    avatarBorderColor: '#FFFFFF',
    avatarSubImagePosition: 0.7,

    labelWidthSpill: 10,
    labelScaleFontSizes: true,
    labelScaleBasePersonaRadius: 125,
    labelVerticalPosition: '50%',
    labelCountDisplayMode: 'totalCount', // Available: 'none', 'propertyCount', 'totalCount', 'propertyCount/totalCount'
    labelPropertyCountIndex: 0,
    labelNameAndCountsPadding: 4,
    labelMinFontSize: 12,
    labelMaxFontSize: 40,

    labelNameFont: 'default',
    labelNameFontSize: 18,
    labelNameMaxLines: 2,
    labelNameColor: '#FFFFFF',
    labelNameBackgroundColor: 'rgba(33,33,33,0.7)',
    labelNameBackgroundPadding: 6,
    labelNameShadow: false,
    labelNameShadowColor: '#000000',
    labelNameShadowBlur: 2,
    labelNameShadowOffsetX: 0,
    labelNameShadowOffsetY: 0,

    labelCountFont: 'default',
    labelCountFontSize: 30,
    labelCountColor: '#FFFFFF',
    labelCountShadow: true,
    labelCountShadowColor: '#000000',
    labelCountShadowBlur: 4,
    labelCountShadowOffsetX: 0,
    labelCountShadowOffsetY: 0,

    labelTotalCountFont: 'default',
    labelTotalCountFontSize: 16,
    labelTotalCountColor: '#FFFFFF',
    labelTotalCountShadow: true,
    labelTotalCountShadowColor: '#000000',
    labelTotalCountShadowBlur: 4,
    labelTotalCountShadowOffsetX: 0,
    labelTotalCountShadowOffsetY: 0
};

/* harmony default export */ __webpack_exports__["a"] = PersonaConfig;

/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Arial */
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var Arial = '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';

/* harmony default export */ __webpack_exports__["a"] = Arial;

/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Oswald700 */
/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var Oswald700 = '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';

/* harmony default export */ __webpack_exports__["a"] = Oswald700;

/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__revi_plugins_input_InputManager_js__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__revi_plugins_easing_Easing_js__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__revi_plugins_easing_EasingTypes_js__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__revi_plugins_easing_Events_js__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__revi_graphics_Canvas_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__revi_plugins_Scheduler_js__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ZoomControl_js__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__revi_geometry_Events_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Events_js__ = __webpack_require__(108);
/* unused harmony export Viewport */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */













/**
 * Class to manage the area where objects are displayed. Implements pan and zoom.
 *
 * @class Viewport
 */
var Viewport = function (_Node) {
    _inherits(Viewport, _Node);

    /**
     * @param {Number} width - The width of the viewport.
     * @param {Number} height - The height of the viewport.
     * @param {Object} config - The layout configuration of this Personas instance.
     * @constructor
     */
    function Viewport(width, height, config) {
        _classCallCheck(this, Viewport);

        var _this = _possibleConstructorReturn(this, (Viewport.__proto__ || Object.getPrototypeOf(Viewport)).call(this, width, height));

        _this.mConfig = config;
        _this.mDragging = false;
        _this.mUpdateScale = null;
        _this.mTrackingMoveThreshold = Math.pow(_this.mConfig.viewportDragThreshold, 2);
        _this.mZoomScrollMultiplier = _this.mConfig.viewportZoomScrollMultiplier;
        _this.mDelayedUpdateScale = _this.mConfig.viewportDelayedRedraw;
        _this.mDelayedUpdateScaleTime = _this.mConfig.viewportDelayedRedrawTime;
        _this.mScheduler = null;
        _this.mContent = new __WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__["a" /* default */](width, height);
        _this.mZoomControls = new __WEBPACK_IMPORTED_MODULE_8__ZoomControl_js__["a" /* default */](_this.mConfig);

        _this.mContent.anchor.set(0, 0);

        _get(Viewport.prototype.__proto__ || Object.getPrototypeOf(Viewport.prototype), 'addChildAt', _this).call(_this, _this.mContent, 0);
        _get(Viewport.prototype.__proto__ || Object.getPrototypeOf(Viewport.prototype), 'addChildAt', _this).call(_this, _this.mZoomControls, 1);

        _this.anchor.set(0, 0);
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Viewport, [{
        key: 'destroy',
        value: function destroy() {
            this.mContent.release();
            this.mZoomControls.release();

            while (this.mChildren.length) {
                _get(Viewport.prototype.__proto__ || Object.getPrototypeOf(Viewport.prototype), 'removeChildAt', this).call(this, this.mChildren.length - 1);
            }

            delete this.mConfig;
            delete this.mDragging;
            delete this.mUpdateScale;
            delete this.mTrackingMoveThreshold;
            delete this.mZoomScrollMultiplier;
            delete this.mScheduler;
            delete this.mContent;
            delete this.mZoomControls;

            _get(Viewport.prototype.__proto__ || Object.getPrototypeOf(Viewport.prototype), 'destroy', this).call(this);
        }

        /**
         * Called every time the object is added to the currently running scene graph.
         *
         * @method onEnter
         * @param {Symbol} reviContext - A unique symbol that identifies the rendering context of this object.
         */

    }, {
        key: 'onEnter',
        value: function onEnter(reviContext) {
            var inputManager = __WEBPACK_IMPORTED_MODULE_1__revi_plugins_input_InputManager_js__["a" /* default */].instanceForContext(reviContext);
            inputManager.on(__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_BEGAN, inputManager.safeBind(this._handlePointerBegan, this));
            inputManager.on(__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_MOVED, inputManager.safeBind(this._handlePointerMoved, this));
            inputManager.on([__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_ENDED, __WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_CANCELLED], inputManager.safeBind(this._handlePointerEnded, this));
            inputManager.on(__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_MOUSE_SCROLL_UP, inputManager.safeBind(this._handleScrollUp, this));
            inputManager.on(__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_MOUSE_SCROLL_DOWN, inputManager.safeBind(this._handleScrollDown, this));

            this.mScheduler = __WEBPACK_IMPORTED_MODULE_7__revi_plugins_Scheduler_js__["a" /* default */].instanceForContext(reviContext);
            this._positionZoomControls(this.pixelSize.width, this.pixelSize.height);

            this.pixelSize.on(__WEBPACK_IMPORTED_MODULE_9__revi_geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this.pixelSize.safeBind(this._handlePixelSizeChanged, this));
            this.mZoomControls.on(__WEBPACK_IMPORTED_MODULE_10__Events_js__["a" /* default */].LAYOUT_ZOOM_IN_CLICKED, this.mZoomControls.safeBind(this.zoomIn, this, true));
            this.mZoomControls.on(__WEBPACK_IMPORTED_MODULE_10__Events_js__["a" /* default */].LAYOUT_ZOOM_OUT_CLICKED, this.mZoomControls.safeBind(this.zoomOut, this, true));
            this.mZoomControls.on(__WEBPACK_IMPORTED_MODULE_10__Events_js__["a" /* default */].LAYOUT_AUTO_ZOOM_CLICKED, this.mZoomControls.safeBind(this.autoZoom, this, this.mContent, true));

            _get(Viewport.prototype.__proto__ || Object.getPrototypeOf(Viewport.prototype), 'onEnter', this).call(this, reviContext);
        }

        /**
         * Called when this objects is removed from the scene graph.
         *
         * @method onExit
         */

    }, {
        key: 'onExit',
        value: function onExit() {
            var inputManager = __WEBPACK_IMPORTED_MODULE_1__revi_plugins_input_InputManager_js__["a" /* default */].instanceForContext(this.reviContext);
            inputManager.off(__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_BEGAN, this._handlePointerBegan, this);
            inputManager.off(__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_MOVED, this._handlePointerMoved, this);
            inputManager.off([__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_ENDED, __WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_CANCELLED], this._handlePointerEnded, this);
            inputManager.off(__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_MOUSE_SCROLL_UP, this._handleScrollUp, this);
            inputManager.off(__WEBPACK_IMPORTED_MODULE_2__revi_plugins_input_Events_js__["a" /* default */].INPUT_MOUSE_SCROLL_DOWN, this._handleScrollDown, this);

            this.mScheduler = null;

            this.pixelSize.off(__WEBPACK_IMPORTED_MODULE_9__revi_geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this._handlePixelSizeChanged, this);

            _get(Viewport.prototype.__proto__ || Object.getPrototypeOf(Viewport.prototype), 'onExit', this).call(this);
        }

        /**
         * Adds a child node to this object.
         *
         * @method addChild
         * @param {Node} child - The node to add as a child.
         * @returns {Node}
         */

    }, {
        key: 'addChild',
        value: function addChild(child) {
            return this.mContent.addChild(child);
        }

        /**
         * Adds a new node as a children to this node at the specified position.
         *
         * @method addChildAt
         * @param {Node} child - The node to add as a child.
         * @param {Number} index - The index at which the node will be added.
         * @returns {Node}
         */

    }, {
        key: 'addChildAt',
        value: function addChildAt(child, index) {
            return this.mContent.addChildAt(child, index);
        }

        /**
         * Removes the specified node from this node's children list.
         *
         * @method removeChild
         * @param {Node} child - The node to remove.
         * @returns {Node}
         */

    }, {
        key: 'removeChild',
        value: function removeChild(child) {
            return this.mContent.removeChild(child);
        }

        /**
         * Removes the child node at the specified index.
         *
         * @method removeChildAt
         * @param {Number} index - The index of this child to remove.
         * @returns {Node}
         */

    }, {
        key: 'removeChildAt',
        value: function removeChildAt(index) {
            return this.mContent.removeChildAt(index);
        }

        /**
         * Removes all the children of from this node.
         *
         * @method removeChildren
         */

    }, {
        key: 'removeChildren',
        value: function removeChildren() {
            this.mContent.removeChildren();
        }

        /**
         * Zooms this viewport by the desired amount using the origin as the center point for the zoom.
         * NOTE: This method respects the maximum and minimum zoom levels configured in the constructor.
         *
         * @method zoom
         * @param {number} amount - The scale to apply where 1 means 100%
         * @param {Number} x - The x coordinate from which the zoom will be applied.
         * @param {Number} y - The y coordinate from which the zoom will be applied.
         * @param {boolean=} animated - Should the zoom be animated
         * @param {boolean=} useActualAmount - If true, will zoom to amount, otherwise zooms to current scale plus amount
         * @return {Easing|null}
         */

    }, {
        key: 'zoom',
        value: function zoom(amount, x, y) {
            var _this2 = this;

            var animated = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var useActualAmount = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

            var localPoint = this.mContent.globalToLocalCoords(x, y);
            var oldScale = this.mContent.scale;

            var newScale = void 0;
            if (useActualAmount) {
                newScale = amount;
            } else {
                newScale = oldScale + amount;
            }

            /* check against min/max scale */
            newScale = Math.max(Math.min(newScale, this.mConfig.viewportMaxZoomMultiplier), this.mConfig.viewportMinZoomMultiplier);

            if (newScale === oldScale) {
                return null;
            }

            var scaleDifference = newScale - oldScale;

            if (animated && this.reviContext) {
                var startX = this.mContent.position.x;
                var startY = this.mContent.position.y;
                var startScale = oldScale;
                var zoomEasing = __WEBPACK_IMPORTED_MODULE_3__revi_plugins_easing_Easing_js__["a" /* default */].instance(this.reviContext, {
                    type: __WEBPACK_IMPORTED_MODULE_4__revi_plugins_easing_EasingTypes_js__["a" /* default */].Quadratic.EaseInOut,
                    duration: 300
                });

                localPoint.retain();
                zoomEasing.on(__WEBPACK_IMPORTED_MODULE_5__revi_plugins_easing_Events_js__["a" /* default */].EASING_UPDATE, function (sender, progress) {
                    _this2.mContent.position.set(startX - localPoint.x * scaleDifference * progress, startY - localPoint.y * scaleDifference * progress);
                    _this2.mContent.scale = startScale + scaleDifference * progress;

                    if (!_this2.mDelayedUpdateScale) {
                        _this2.mParent.updateGlobalScale();
                    }
                });

                zoomEasing.on(__WEBPACK_IMPORTED_MODULE_5__revi_plugins_easing_Events_js__["a" /* default */].EASING_END, function () {
                    localPoint.release();
                    if (_this2.mDelayedUpdateScale) {
                        _this2.mParent.updateGlobalScale();
                    }
                });

                zoomEasing.start();
                this.needsRedraw();

                return zoomEasing;
            }

            this.mContent.position.set(this.mContent.position.x - localPoint.x * scaleDifference, this.mContent.position.y - localPoint.y * scaleDifference);
            this.mContent.scale = newScale;

            if (this.mDelayedUpdateScale) {
                if (this.mScheduler) {
                    if (this.mUpdateScale !== null) {
                        this.mScheduler.cancel(this.mUpdateScale);
                        this.mUpdateScale = null;
                    }

                    this.mUpdateScale = this.mScheduler.scheduleTimeout(function () {
                        _this2.mParent.updateGlobalScale();
                        _this2.mUpdateScale = null;
                    }, this.mDelayedUpdateScaleTime);
                } else {
                    if (this.mUpdateScale !== null) {
                        clearTimeout(this.mUpdateScale);
                        this.mUpdateScale = null;
                    }

                    this.mUpdateScale = setTimeout(function () {
                        _this2.mParent.updateGlobalScale();
                        _this2.mUpdateScale = null;
                    }, this.mDelayedUpdateScaleTime);
                }
            } else {
                this.mParent.updateGlobalScale();
            }

            this.needsRedraw();
            return null;
        }

        /**
         * Automatically zooms this viewport to the bounding box of the given object.
         *
         * @method autoZoom
         * @param {Node} object - An object, childed to this viewport, to fin in the viewport.
         * @param {Boolean} animated - Should the zooming be animated.
         */

    }, {
        key: 'autoZoom',
        value: function autoZoom(object, animated) {
            var _this3 = this;

            if (this.reviContext) {
                var canvas = __WEBPACK_IMPORTED_MODULE_6__revi_graphics_Canvas_js__["a" /* default */].getCanvasForContext(this.reviContext);
                var bb = object.boundingBox;
                var globalTL = object.localToGlobalPoint(bb.v1);
                var globalBR = object.localToGlobalPoint(bb.v4);
                var globalWidth = globalBR.x - globalTL.x;
                var globalHeight = globalBR.y - globalTL.y;
                var centerX = globalTL.x + globalWidth * 0.5;
                var centerY = globalTL.y + globalHeight * 0.5;
                var centerPosition = this.globalToLocalCoords(centerX, centerY);
                var targetPosition = this.globalToLocalCoords(canvas.pixelSize.width * 0.5, canvas.pixelSize.height * 0.5);

                var scale = Math.min(canvas.pixelSize.width / globalWidth, canvas.pixelSize.height / globalHeight);
                var easing = this.zoom(scale * this.mContent.scale, centerX, centerY, animated, true);
                if (easing) {
                    var startX = this.mContent.pixelPosition.x;
                    var startY = this.mContent.pixelPosition.y;
                    var targetX = targetPosition.x + (startX - centerPosition.x) * scale;
                    var targetY = targetPosition.y + (startY - centerPosition.y) * scale;
                    var changeX = targetX - startX;
                    var changeY = targetY - startY;

                    easing.on(__WEBPACK_IMPORTED_MODULE_5__revi_plugins_easing_Events_js__["a" /* default */].EASING_UPDATE, function (sender, progress) {
                        _this3.mContent.position.set(startX + changeX * progress, startY + changeY * progress);
                    });
                } else {
                    this.mContent.position.set(this.mContent.position.x + targetPosition.x - centerPosition.x, this.mContent.position.y + targetPosition.y - centerPosition.y);
                }
            }
        }

        /**
         * Zooms in by the configured zoom step.
         *
         * @method zoomIn
         * @param {Boolean} animated - Should the zooming be animated.
         */

    }, {
        key: 'zoomIn',
        value: function zoomIn(animated) {
            this.zoom(this.mContent.scale * 0.3, this.pixelSize.width * 0.5, this.pixelSize.height * 0.5, animated);
        }

        /**
         * Zooms out by the configured zoom step.
         *
         * @method zoomOut
         * @param {Boolean} animated - Should the zooming be animated.
         */

    }, {
        key: 'zoomOut',
        value: function zoomOut(animated) {
            this.zoom(-this.mContent.scale * 0.3, this.pixelSize.width * 0.5, this.pixelSize.height * 0.5, animated);
        }

        /**
         * Handles the pointer began input event.
         *
         * @method _handlePointerBegan
         * @param {*} sender - The sender of the event.
         * @param {PointerEvent} event - Object containing the event's description.
         * @private
         */

    }, {
        key: '_handlePointerBegan',
        value: function _handlePointerBegan(sender, event) {
            this.mDragging = false;
            this.mTrackingPointer = null;
            if (this.mTrackingPoint) {
                this.mTrackingPoint.release();
                this.mTrackingPoint = null;
            }

            this.mTrackingPointer = event.identifier;
            this.mTrackingPoint = event.point.retain();
        }

        /**
         * Handles the pointer moved event.
         *
         * @method _handlePointerMoved
         * @param {*} sender - The sender of the event.
         * @param {PointerEvent} event - Object containing the event's description.
         * @private
         */

    }, {
        key: '_handlePointerMoved',
        value: function _handlePointerMoved(sender, event) {
            if (event.identifier === this.mTrackingPointer) {
                var point = event.point;
                var distanceSQ = Math.pow(point.x - this.mTrackingPoint.x, 2) + Math.pow(point.y - this.mTrackingPoint.y, 2);
                if (!this.mDragging && distanceSQ > this.mTrackingMoveThreshold) {
                    this.mDragging = true;
                }

                if (this.mDragging) {
                    var xOff = point.x - this.mTrackingPoint.x;
                    var yOff = point.y - this.mTrackingPoint.y;
                    this.mContent.position.set(this.mContent.position.x + xOff, this.mContent.position.y + yOff);
                    this.mTrackingPoint.release();
                    this.mTrackingPoint = point.retain();
                }
            }
        }

        /**
         * Handles the pointer moved input event.
         *
         * @method _handlePointerEnded
         * @param {*} sender - The sender of the event.
         * @param {PointerEvent} event - Object containing the event's description.
         * @private
         */

    }, {
        key: '_handlePointerEnded',
        value: function _handlePointerEnded(sender, event) {
            if (event.identifier === this.mTrackingPointer) {
                this.mDragging = false;
                this.mTrackingPointer = null;
                if (this.mTrackingPoint) {
                    this.mTrackingPoint.release();
                    this.mTrackingPoint = null;
                }
            }
        }

        /**
         * Handles the scroll up input event.
         *
         * @method _handleScrollUp
         * @param {*} sender - The sender of the event.
         * @param {Number} delta - The amount scrolled.
         * @param {Number} x - The x position of the pointer when the event was triggered.
         * @param {Number} y - The y position of the pointer when the event was triggered.
         * @private
         */

    }, {
        key: '_handleScrollUp',
        value: function _handleScrollUp(sender, delta, x, y) {
            var zoomAmount = delta * this.mZoomScrollMultiplier;
            this.zoom(this.mContent.scale - zoomAmount, x, y, false, true);
        }

        /**
         * Handles the scroll down input event.
         *
         * @method _handleScrollDown
         * @param {*} sender - The sender of the event.
         * @param {Number} delta - The amount scrolled.
         * @param {Number} x - The x position of the pointer when the event was triggered.
         * @param {Number} y - The y position of the pointer when the event was triggered.
         * @private
         */

    }, {
        key: '_handleScrollDown',
        value: function _handleScrollDown(sender, delta, x, y) {
            var zoomAmount = delta * this.mZoomScrollMultiplier;
            this.zoom(this.mContent.scale + zoomAmount, x, y, false, true);
        }

        /**
         * Position the zoom controls at the desired configured position.
         *
         * @method _positionZoomControls
         * @param {Number} width - The width of the container where the zoom controls will be positioned.
         * @param {Number} height - The height of the container where the zoom controls will be positioned.
         * @private
         */

    }, {
        key: '_positionZoomControls',
        value: function _positionZoomControls(width, height) {
            var padding = this.mConfig.zoomControlsPadding;
            switch (this.mConfig.zoomControlsPosition) {
                case 'top-left':
                    this.mZoomControls.anchor.set(0, 0);
                    this.mZoomControls.position.set(padding, padding);
                    break;

                case 'bottom-left':
                    this.mZoomControls.anchor.set(0, '100%');
                    this.mZoomControls.position.set(padding, height - padding);
                    break;

                case 'bottom-right':
                    this.mZoomControls.anchor.set('100%', '100%');
                    this.mZoomControls.position.set(width - padding, height - padding);
                    break;

                case 'top-right':
                default:
                    this.mZoomControls.anchor.set('100%', 0);
                    this.mZoomControls.position.set(width - padding, padding);
                    break;
            }
        }

        /**
         * Handles pixel size changes.
         *
         * @method _handlePixelSizeChanged
         * @param {Size} sender - The object that generated the event.
         * @param {Number} width - The new width.
         * @param {Number} height - the new height.
         * @private
         */

    }, {
        key: '_handlePixelSizeChanged',
        value: function _handlePixelSizeChanged(sender, width, height) {
            if (sender === this.pixelSize) {
                this._positionZoomControls(width, height);
            }
        }
    }]);

    return Viewport;
}(__WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Viewport;

/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__revi_text_FontAwesome_js__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__revi_text_FontManager_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__revi_graphics_primitives_Rectangle_js__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__revi_graphics_primitives_Line_js__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__revi_geometry_Point_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__revi_plugins_input_InputManager_js__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__revi_plugins_input_Events_js__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Events_js__ = __webpack_require__(108);
/* unused harmony export ZoomControl */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */












var FONT_AWESOME_KEY = 'FontAwesome';

var ZoomControl = function (_Node) {
    _inherits(ZoomControl, _Node);

    function ZoomControl(config) {
        _classCallCheck(this, ZoomControl);

        var _this = _possibleConstructorReturn(this, (ZoomControl.__proto__ || Object.getPrototypeOf(ZoomControl)).call(this, config.zoomControlsButtonSize, config.zoomControlsButtonSize * 3 + config.zoomControlsBorderSize * 2));

        _this.mConfig = config;

        var background = __WEBPACK_IMPORTED_MODULE_4__revi_graphics_primitives_Rectangle_js__["a" /* default */].instance(_this.size.width, _this.size.height, {
            fillEnabled: true,
            fillColor: _this.mConfig.zoomControlsBackgroundColor,
            stroke: _this.mConfig.zoomControlsBorderSize,
            strokeColor: _this.mConfig.zoomControlsBorderColor,
            strokeType: __WEBPACK_IMPORTED_MODULE_4__revi_graphics_primitives_Rectangle_js__["a" /* default */].STROKE_OUTER
        });
        background.anchor.set(0, 0);
        _this.addChild(background);

        var separatorOffset = Math.min(2, _this.mConfig.zoomControlsBorderSize);
        var separator01 = __WEBPACK_IMPORTED_MODULE_5__revi_graphics_primitives_Line_js__["a" /* default */].instance(__WEBPACK_IMPORTED_MODULE_6__revi_geometry_Point_js__["a" /* default */].instance(-separatorOffset, 0), __WEBPACK_IMPORTED_MODULE_6__revi_geometry_Point_js__["a" /* default */].instance(_this.size.width + separatorOffset, 0), {
            stroke: _this.mConfig.zoomControlsBorderSize,
            strokeColor: _this.mConfig.zoomControlsBorderColor,
            strokeType: __WEBPACK_IMPORTED_MODULE_4__revi_graphics_primitives_Rectangle_js__["a" /* default */].STROKE_MIDDLE
        });
        separator01.position.set(0, _this.size.height / 3);
        _this.addChild(separator01);

        var separator02 = __WEBPACK_IMPORTED_MODULE_5__revi_graphics_primitives_Line_js__["a" /* default */].instance(__WEBPACK_IMPORTED_MODULE_6__revi_geometry_Point_js__["a" /* default */].instance(-separatorOffset, 0), __WEBPACK_IMPORTED_MODULE_6__revi_geometry_Point_js__["a" /* default */].instance(_this.size.width + separatorOffset, 0), {
            stroke: _this.mConfig.zoomControlsBorderSize,
            strokeColor: _this.mConfig.zoomControlsBorderColor,
            strokeType: __WEBPACK_IMPORTED_MODULE_4__revi_graphics_primitives_Rectangle_js__["a" /* default */].STROKE_MIDDLE
        });
        separator02.position.set(0, _this.size.height / 3 * 2);
        _this.addChild(separator02);

        __WEBPACK_IMPORTED_MODULE_3__revi_text_FontManager_js__["a" /* default */].sharedInstance().loadFont(__WEBPACK_IMPORTED_MODULE_2__revi_text_FontAwesome_js__["a" /* default */], FONT_AWESOME_KEY).then(_this._handleFontAwesomeLoaded.bind(_this));
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(ZoomControl, [{
        key: 'destroy',
        value: function destroy() {
            delete this.mConfig;

            _get(ZoomControl.prototype.__proto__ || Object.getPrototypeOf(ZoomControl.prototype), 'destroy', this).call(this);
        }

        /**
         * Called every time the object is added to the currently running scene graph.
         *
         * @method onEnter
         * @param {Symbol} reviContext - A unique symbol that identifies the rendering context of this object.
         */

    }, {
        key: 'onEnter',
        value: function onEnter(reviContext) {
            var inputManager = __WEBPACK_IMPORTED_MODULE_7__revi_plugins_input_InputManager_js__["a" /* default */].instanceForContext(reviContext);
            inputManager.on(__WEBPACK_IMPORTED_MODULE_8__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_BEGAN, inputManager.safeBind(this._handlePointerBegan, this));
            inputManager.on(__WEBPACK_IMPORTED_MODULE_8__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_MOVED, inputManager.safeBind(this._handlePointerMoved, this));
            inputManager.on([__WEBPACK_IMPORTED_MODULE_8__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_ENDED, __WEBPACK_IMPORTED_MODULE_8__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_CANCELLED], inputManager.safeBind(this._handlePointerEnded, this));
            _get(ZoomControl.prototype.__proto__ || Object.getPrototypeOf(ZoomControl.prototype), 'onEnter', this).call(this, reviContext);
        }

        /**
         * Called when this objects is removed from the scene graph.
         *
         * @method onExit
         */

    }, {
        key: 'onExit',
        value: function onExit() {
            var inputManager = __WEBPACK_IMPORTED_MODULE_7__revi_plugins_input_InputManager_js__["a" /* default */].instanceForContext(this.reviContext);
            inputManager.off(__WEBPACK_IMPORTED_MODULE_8__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_BEGAN, this._handlePointerBegan, this);
            inputManager.off(__WEBPACK_IMPORTED_MODULE_8__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_MOVED, this._handlePointerMoved, this);
            inputManager.off([__WEBPACK_IMPORTED_MODULE_8__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_ENDED, __WEBPACK_IMPORTED_MODULE_8__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_CANCELLED], this._handlePointerEnded, this);
            _get(ZoomControl.prototype.__proto__ || Object.getPrototypeOf(ZoomControl.prototype), 'onExit', this).call(this);
        }

        /**
         * Called when font awesome is loaded.
         *
         * @method _handleFontAwesomeLoaded
         * @private
         */

    }, {
        key: '_handleFontAwesomeLoaded',
        value: function _handleFontAwesomeLoaded() {
            var buttonSize = this.mConfig.zoomControlsButtonSize;

            var plus = __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].instance(buttonSize, buttonSize, '\uF067', FONT_AWESOME_KEY, null, {
                color: 'black',
                fontSize: this.mConfig.zoomControlsFontSize,
                alignment: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_ALIGNMENT.CENTER,
                truncateMode: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_TRUNCATING_MODE.ELLIPSES,
                multiLineMode: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_MULTI_LINE_MODE.AUTO_LINES,
                renderingBackend: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_RENDERING_BACKEND.CANVAS,
                autoSize: true
            });
            plus.position.set(buttonSize * 0.5, buttonSize * 0.5);
            this.addChild(plus);

            var home = __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].instance(buttonSize, buttonSize, '\uF066', FONT_AWESOME_KEY, null, {
                color: 'black',
                fontSize: this.mConfig.zoomControlsFontSize,
                alignment: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_ALIGNMENT.CENTER,
                truncateMode: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_TRUNCATING_MODE.ELLIPSES,
                multiLineMode: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_MULTI_LINE_MODE.AUTO_LINES,
                renderingBackend: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_RENDERING_BACKEND.CANVAS,
                autoSize: true
            });
            home.position.set(buttonSize * 0.5, this.size.height * 0.5);
            this.addChild(home);

            var minus = __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].instance(buttonSize, buttonSize, '\uF068', FONT_AWESOME_KEY, null, {
                color: 'black',
                fontSize: this.mConfig.zoomControlsFontSize,
                alignment: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_ALIGNMENT.CENTER,
                truncateMode: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_TRUNCATING_MODE.ELLIPSES,
                multiLineMode: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_MULTI_LINE_MODE.AUTO_LINES,
                renderingBackend: __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_RENDERING_BACKEND.CANVAS,
                autoSize: true
            });
            minus.position.set(buttonSize * 0.5, this.size.height - buttonSize * 0.5);
            this.addChild(minus);
        }
    }, {
        key: '_handlePointerBegan',
        value: function _handlePointerBegan(sender, event) {
            var point = event.point;
            var localPoint = this.globalToLocalPoint(point);

            this.mTrackingPointer = null;
            if (localPoint.x >= 0 && localPoint.x <= this.pixelSize.width && localPoint.y >= 0 && localPoint.y <= this.pixelSize.height) {
                this.mTrackingPointer = event.identifier;
            }
        }
    }, {
        key: '_handlePointerMoved',
        value: function _handlePointerMoved(sender, event) {
            var point = event.point;
            var localPoint = this.globalToLocalPoint(point);
            if (event.identifier === this.mTrackingPointer) {
                if (localPoint.x < 0 || localPoint.x > this.pixelSize.width || localPoint.y < 0 || localPoint.y > this.pixelSize.height) {
                    this.mTrackingPointer = null;
                }
            }
        }
    }, {
        key: '_handlePointerEnded',
        value: function _handlePointerEnded(sender, event) {
            var point = event.point;
            var localPoint = this.globalToLocalPoint(point);
            if (event.identifier === this.mTrackingPointer) {
                this.mTrackingPointer = null;

                if (localPoint.x >= 0 && localPoint.x <= this.pixelSize.width && localPoint.y >= 0 && localPoint.y <= this.pixelSize.height) {
                    if (localPoint.y < this.pixelSize.height / 3) {
                        this.emit(__WEBPACK_IMPORTED_MODULE_9__Events_js__["a" /* default */].LAYOUT_ZOOM_IN_CLICKED, this);
                    } else if (localPoint.y < this.pixelSize.height / 3 * 2) {
                        this.emit(__WEBPACK_IMPORTED_MODULE_9__Events_js__["a" /* default */].LAYOUT_AUTO_ZOOM_CLICKED, this);
                    } else {
                        this.emit(__WEBPACK_IMPORTED_MODULE_9__Events_js__["a" /* default */].LAYOUT_ZOOM_OUT_CLICKED, this);
                    }
                }
            }
        }
    }]);

    return ZoomControl;
}(__WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = ZoomControl;

/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__revi_graphics_primitives_Circle_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__revi_core_AssetCache_js__ = __webpack_require__(110);
/* unused harmony export Avatar */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */





/**
 * Class to draw a Persona's avatar (images).
 *
 * @class Avatar
 */
var Avatar = function (_Node) {
    _inherits(Avatar, _Node);

    /**
     * @param {Number} radius - The radius of this avatar.
     * @param {String[]|null} imageURLs - An array containing the URLs of the images to display in this avatar.
     * @param {Object} config - Configuration object.
     * @constructor
     */
    function Avatar(radius, imageURLs, config) {
        _classCallCheck(this, Avatar);

        var _this = _possibleConstructorReturn(this, (Avatar.__proto__ || Object.getPrototypeOf(Avatar)).call(this));

        _this.mRadius = Math.max(radius, 0);
        _this.mConfig = config;
        _this.mImages = [];

        _this.size.set(_this.mRadius * 2, _this.mRadius * 2);

        _this.mBorder = new __WEBPACK_IMPORTED_MODULE_1__revi_graphics_primitives_Circle_js__["a" /* default */](_this.mRadius, {
            fillEnabled: false,
            strokeType: __WEBPACK_IMPORTED_MODULE_1__revi_graphics_primitives_Circle_js__["a" /* default */].STROKE_INNER,
            stroke: _this.mConfig.avatarBorder,
            strokeColor: _this.mConfig.avatarBorderColor
        });
        _this.mBorder.position.set('50%', '50%');
        _this.addChild(_this.mBorder);

        if (imageURLs) {
            _this._loadImages(imageURLs);
        }
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Avatar, [{
        key: 'destroy',
        value: function destroy() {
            this.mBorder.release();
            this.mImages.length = 0;

            delete this.mRadius;
            delete this.mConfig;
            delete this.mImages;
            delete this.mBorder;

            _get(Avatar.prototype.__proto__ || Object.getPrototypeOf(Avatar.prototype), 'destroy', this).call(this);
        }

        /**
         * The radius of this avatar.
         *
         * @type {Number}
         */

    }, {
        key: 'draw',


        /**
         * Called every tick, drawing operations should be performed here.
         *
         * @method draw
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when drawing.
         */
        value: function draw(context) {
            var _get2;

            var images = this.mImages.filter(function (image) {
                return Boolean(image);
            });
            if (images.length) {
                var imageRadius = Math.max(this.mRadius - this.mConfig.avatarBorder + Math.min(this.mConfig.avatarBorder, this.mConfig.radiusOverlap), 0);
                context.save();
                context.beginPath();
                context.arc(this.mRadius, this.mRadius, imageRadius, 0, __WEBPACK_IMPORTED_MODULE_1__revi_graphics_primitives_Circle_js__["a" /* default */].circleRadians, false);
                context.closePath();
                context.clip();

                var mainImageHeight = images.length > 1 ? this.size.height * this.mConfig.avatarSubImagePosition : this.size.height;
                this._drawImage(images[0], context, 0, 0, this.size.width, mainImageHeight);

                var subImageY = this.size.height * this.mConfig.avatarSubImagePosition;
                var subImageWidth = this.size.width / (images.length - 1);
                var subImageHeight = this.size.height * (1.0 - this.mConfig.avatarSubImagePosition);
                for (var i = 1; i < images.length; ++i) {
                    this._drawImage(images[i], context, subImageWidth * (i - 1), subImageY, subImageWidth, subImageHeight);
                }

                context.restore();
            }

            for (var _len = arguments.length, varArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                varArgs[_key - 1] = arguments[_key];
            }

            (_get2 = _get(Avatar.prototype.__proto__ || Object.getPrototypeOf(Avatar.prototype), 'draw', this)).call.apply(_get2, [this, context].concat(varArgs));
        }

        /**
         * Updates the images contained in this avatar.
         *
         * @method updateImages
         * @param {Array} imageURLs - An array containing the URLs of the images to render.
         */

    }, {
        key: 'updateImages',
        value: function updateImages(imageURLs) {
            if (imageURLs && imageURLs.length !== this.mImages.length) {
                this.mImages.length = 0;
                if (imageURLs.length) {
                    this._loadImages(imageURLs);
                } else {
                    this.needsRedraw();
                }
            } else if (!imageURLs && this.mImages.length) {
                this.mImages.length = 0;
                this.needsRedraw();
            }
        }

        /**
         * Draws an image in the specified context, within the specified rect.
         *
         * @method _drawImage
         * @param {Image} image - The image to draw.
         * @param {CanvasRenderingContext2D} context - The context where the image will be rendered.
         * @param {Number} x - X coordinate, within the context, where the image should be drawn.
         * @param {Number} y - Y coordinate, within the context, where the image should be drawn.
         * @param {Number} width - The width of the rect where the image must be drawn.
         * @param {Number} height - The height of the rect where the image must be drawn.
         * @private
         */

    }, {
        key: '_drawImage',
        value: function _drawImage(image, context, x, y, width, height) {
            var scale = Math.min(image.width / width, image.height / height);
            var scaledWidth = width * scale;
            var scaledHeight = height * scale;
            context.drawImage(image, (image.width - scaledWidth) * 0.5, (image.height - scaledHeight) * 0.5, scaledWidth, scaledHeight, x, y, width, height);
        }

        /**
         * Loads an array of image URLs and schedules a redraw every time one finishes loading.
         *
         * @method _loadImage
         * @param {String[]} imageURLs - An array os trings representing the URLs of the images to load.
         * @private
         */

    }, {
        key: '_loadImages',
        value: function _loadImages(imageURLs) {
            var _this2 = this;

            imageURLs.forEach(function (imageURL, i) {
                __WEBPACK_IMPORTED_MODULE_2__revi_core_AssetCache_js__["a" /* default */].loadImage(imageURL).then(function (image) {
                    /* handle the case where the object could have been destroyed at this point */
                    if (_this2.retainCount > 0) {
                        _this2.mImages[i] = image;
                        _this2.needsRedraw();
                    }
                });
            });
        }
    }, {
        key: 'radius',
        get: function get() {
            return this.mRadius;
        }

        /**
         * Sets the radius of this avatar.
         *
         * @param {Number} value - The new radius.
         */
        ,
        set: function set(value) {
            if (value !== this.mRadius) {
                this.mRadius = value;
                this.size.set(this.mRadius * 2, this.mRadius * 2);

                this.mBorder.radius = this.mRadius;
                this.mBorder.position.set(this.size.width * 0.5, this.size.height * 0.5);

                this.needsRedraw();
            }
        }
    }]);

    return Avatar;
}(__WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Avatar;

/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__GaugeBar_js__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__revi_graphics_primitives_Circle_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__revi_graphics_primitives_Line_js__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__revi_geometry_Point_js__ = __webpack_require__(27);
/* unused harmony export Gauge */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */







/**
 * Class to draw the circular gauges on a Persona.
 *
 * @class Gauge
 */
var Gauge = function (_Node) {
    _inherits(Gauge, _Node);

    /**
     * @param {Number} radius - The radius of the gauge.
     * @param {Object} config - Configuration object.
     * @constructor
     */
    function Gauge(radius, config) {
        _classCallCheck(this, Gauge);

        var _this = _possibleConstructorReturn(this, (Gauge.__proto__ || Object.getPrototypeOf(Gauge)).call(this));

        _this.mRadius = Math.max(radius, 0);
        _this.mConfig = config;
        _this.mBars = [];
        _this.mBackground = null;
        _this.mMarker = null;
        _this.mMarkerSpill = _this.mConfig.gaugeMarkerSpill;
        _this.mBarRadius = Math.max(_this.mRadius - _this.mConfig.gaugePadding, 0);

        _this.size.set(_this.mRadius * 2, _this.mRadius * 2);

        _this.mBackground = new __WEBPACK_IMPORTED_MODULE_2__revi_graphics_primitives_Circle_js__["a" /* default */](_this.mRadius, {
            fillEnabled: false,
            strokeType: __WEBPACK_IMPORTED_MODULE_2__revi_graphics_primitives_Circle_js__["a" /* default */].STROKE_INNER,
            stroke: config.gaugeThickness + _this.mConfig.radiusOverlap,
            strokeColor: config.gaugeBackgroundColor
        });
        _this.mBackground.position.set('50%', '50%');
        _this.addChild(_this.mBackground);

        if (_this.mConfig.gaugeMarkerThickness > 0) {
            _this.mMarker = new __WEBPACK_IMPORTED_MODULE_3__revi_graphics_primitives_Line_js__["a" /* default */](__WEBPACK_IMPORTED_MODULE_4__revi_geometry_Point_js__["a" /* default */].instance('50%', -_this.mMarkerSpill), __WEBPACK_IMPORTED_MODULE_4__revi_geometry_Point_js__["a" /* default */].instance('50%', config.gaugeThickness + config.radiusOverlap), {
                fillEnabled: false,
                strokeType: __WEBPACK_IMPORTED_MODULE_3__revi_graphics_primitives_Line_js__["a" /* default */].STROKE_MIDDLE,
                strokeColor: config.gaugeMarkerColor,
                stroke: config.gaugeMarkerThickness
            });
            _this.addChild(_this.mMarker);
        }
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Gauge, [{
        key: 'destroy',
        value: function destroy() {
            this.mBackground.release();
            this.mBars.forEach(function (bar) {
                return bar.release();
            });
            this.mBars.length = 0;

            if (this.mMarker) {
                this.mMarker.release();
            }

            delete this.mRadius;
            delete this.mConfig;
            delete this.mBars;
            delete this.mBackground;
            delete this.mMarker;
            delete this.mBarRadius;

            _get(Gauge.prototype.__proto__ || Object.getPrototypeOf(Gauge.prototype), 'destroy', this).call(this);
        }

        /**
         * The radius of this circular gauge.
         *
         * @type {Number}
         */

    }, {
        key: 'update',


        /**
         * Called every tick, before this object is drawn.
         *
         * @method update
         * @param {Number} delta - The delta time since the last update.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when updating.
         */
        value: function update(delta) {
            var _get2,
                _this2 = this;

            for (var _len = arguments.length, varArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                varArgs[_key - 1] = arguments[_key];
            }

            (_get2 = _get(Gauge.prototype.__proto__ || Object.getPrototypeOf(Gauge.prototype), 'update', this)).call.apply(_get2, [this, delta].concat(varArgs));
            var offset = 0;
            this.mBars.forEach(function (bar) {
                bar.offset = offset;
                offset += bar.progress;
                bar.position.set(_this2.mBackground.size.width * 0.5, _this2.mBackground.size.height * 0.5);
            });
        }

        /**
         * Adds a stacked bar to this gauge tha represents the specified progress.
         *
         * @method addBar
         * @param {Number} progress - A number between 0 and 1 that represents the progress of this bar.
         * @param {String} color - The color of this bar.
         */

    }, {
        key: 'addBar',
        value: function addBar(progress, color) {
            var offset = this.mBars.reduce(function (acc, bar) {
                return acc + bar.progress;
            }, 0);
            var bar = new __WEBPACK_IMPORTED_MODULE_1__GaugeBar_js__["a" /* default */](this.mBarRadius, offset, progress, color, this.mConfig);
            bar.position.set(this.mBackground.size.width * 0.5, this.mBackground.size.height * 0.5);
            this.mBackground.addChild(bar);
            this.mBars.push(bar);
        }
    }, {
        key: 'radius',
        get: function get() {
            return this.mRadius;
        }

        /**
         * Sets the radius of this circular gauge.
         *
         * @param {Number} value - The new radius.
         */
        ,
        set: function set(value) {
            var _this3 = this;

            if (value !== this.mRadius) {
                this.mRadius = Math.max(value, 0);
                this.mBarRadius = Math.max(this.mRadius - this.mConfig.gaugePadding, 0);
                this.size.set(this.mRadius * 2, this.mRadius * 2);

                this.mBackground.radius = this.mRadius;

                this.mBarRadius = Math.max(this.mRadius - this.mConfig.gaugePadding, 0);
                this.mBars.forEach(function (bar) {
                    bar.radius = _this3.mBarRadius;
                });

                this.needsRedraw();
            }
        }
    }]);

    return Gauge;
}(__WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Gauge;

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__revi_graphics_primitives_SemiCircle_js__ = __webpack_require__(186);
/* unused harmony export GaugeBar */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



var doublePI = Math.PI * 2;

/**
 * This class draws a bar inside a circular gauge.
 *
 * @class GaugeBar
 */
var GaugeBar = function (_SemiCircle) {
    _inherits(GaugeBar, _SemiCircle);

    /**
     * @param {Number} radius - The radius of the gauge this bar belongs to.
     * @param {Number} offset - A number between 0 and 1 that represents where in the gauge this bar will be drawn.
     * @param {Number} progress - A number between 0 and 1 that represents the progress of this bar.
     * @param {String} color - The color to use when drawns the bar.
     * @param {Object} config - Configuration object.
     * @constructor
     */
    function GaugeBar(radius, offset, progress, color, config) {
        _classCallCheck(this, GaugeBar);

        var radPadding = config.gaugeBarPadding / radius * 0.5;

        var _this = _possibleConstructorReturn(this, (GaugeBar.__proto__ || Object.getPrototypeOf(GaugeBar)).call(this, radius, offset * doublePI + radPadding, Math.max(progress * doublePI - radPadding * 2, 0), {
            fillEnabled: false,
            strokeType: __WEBPACK_IMPORTED_MODULE_0__revi_graphics_primitives_SemiCircle_js__["a" /* default */].STROKE_INNER,
            stroke: config.gaugeThickness - config.gaugePadding * 2,
            strokeColor: color,
            lineCapType: config.gaugeBarCaps
        }));

        _this.mConfig = config;
        _this.mRadPadding = radPadding;
        _this.mOffsetPercentage = offset;
        _this.mProgressPercentage = progress;
        return _this;
    }

    /**
     * The radius of this circular bar.
     *
     * @type {Number}
     */


    _createClass(GaugeBar, [{
        key: 'radius',
        get: function get() {
            return _get(GaugeBar.prototype.__proto__ || Object.getPrototypeOf(GaugeBar.prototype), 'radius', this);
        }

        /**
         * Sets the radius of this circular bar.
         *
         * @param {Number} value - The new radius.
         */
        ,
        set: function set(value) {
            if (value !== _get(GaugeBar.prototype.__proto__ || Object.getPrototypeOf(GaugeBar.prototype), 'radius', this)) {
                _set(GaugeBar.prototype.__proto__ || Object.getPrototypeOf(GaugeBar.prototype), 'radius', value, this);
                this.mRadPadding = this.mConfig.gaugeBarPadding / value * 0.5;
                this.offset = this.offset;
                this.progress = this.progress;
            }
        }

        /**
         * This bar's offset.
         *
         * @type {Number}
         */

    }, {
        key: 'offset',
        get: function get() {
            return this.mOffsetPercentage;
        }

        /**
         * Sets the bar's offset.
         *
         * @param {Number} value - The new offset.
         */
        ,
        set: function set(value) {
            this.mOffsetPercentage = value;
            _set(GaugeBar.prototype.__proto__ || Object.getPrototypeOf(GaugeBar.prototype), 'offset', this.mOffsetPercentage * doublePI + this.mRadPadding, this);
        }

        /**
         * This bar's progress.
         *
         * @type {Number}
         */

    }, {
        key: 'progress',
        get: function get() {
            return this.mProgressPercentage;
        }

        /**
         * Sets this bar's progress.
         *
         * @param {Number} value - The new progress.
         */
        ,
        set: function set(value) {
            this.mProgressPercentage = value;
            _set(GaugeBar.prototype.__proto__ || Object.getPrototypeOf(GaugeBar.prototype), 'angle', Math.max(this.mProgressPercentage * doublePI - this.mRadPadding * 2, 0), this);
        }

        /**
         * This bar's color.
         *
         * @type {String}
         */

    }, {
        key: 'color',
        get: function get() {
            return this.strokeColor;
        }

        /**
         * Sets the bar's color.
         *
         * @param {String} value - The new color.
         */
        ,
        set: function set(value) {
            this.strokeColor = value;
        }
    }]);

    return GaugeBar;
}(__WEBPACK_IMPORTED_MODULE_0__revi_graphics_primitives_SemiCircle_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = GaugeBar;

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__revi_text_Events_js__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__revi_geometry_Events_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__revi_text_FontManager_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config_fonts_Arial_js__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__config_fonts_Oswald700_js__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__revi_graphics_primitives_Rectangle_js__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__revi_geometry_Size_js__ = __webpack_require__(59);
/* unused harmony export Label */
var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */











var PERSONA_FONTS = {
    NAME: Symbol('PERSONA_NAME_FONT'),
    COUNT: Symbol('PERSONA_COUNT_FONT'),
    TOTAL_COUNT: Symbol('PERSONA_TOTAL_COUNT_FONT')
};

/**
 * Creates and renders a persona's label. Includes the persona name, count and total count.
 *
 * @class Label
 */
var Label = function (_Node) {
    _inherits(Label, _Node);

    _createClass(Label, null, [{
        key: 'PERSONA_NAME_FONT',

        /**
         * The key used to load the name font.
         *
         * @type {Symbol}
         * @readonly
         */
        get: function get() {
            return PERSONA_FONTS.NAME;
        }

        /**
         * The key used to load the count font.
         *
         * @type {Symbol}
         * @readonly
         */

    }, {
        key: 'PERSONA_COUNT_FONT',
        get: function get() {
            return PERSONA_FONTS.COUNT;
        }

        /**
         * The key used to load the total count font.
         *
         * @type {Symbol}
         * @readonly
         */

    }, {
        key: 'PERSONA_TOTAL_COUNT_FONT',
        get: function get() {
            return PERSONA_FONTS.TOTAL_COUNT;
        }

        /**
         *
         * @param {String} name - the name of this persona.
         * @param {String|Number|null} count - The count of this persona or null if it should not be rendered.
         * @param {String|Number|null} totalCount - The total count of this persona or null if it should not be rendered.
         * @param {Number} width - The width within which the label should fit.
         * @param {Number} height - The height within which the label should fit.
         * @param {Object} config - The label's configuration.
         * @constructor
         */

    }]);

    function Label(name, count, totalCount, width, height, config) {
        _classCallCheck(this, Label);

        var _this = _possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).call(this));

        _this.mMaxSize = new __WEBPACK_IMPORTED_MODULE_8__revi_geometry_Size_js__["a" /* default */](width, height);
        _this.mName = name;
        _this.mCount = count;
        _this.mTotalCount = totalCount;
        _this.mConfig = config;
        _this.mFontSizeScale = _this.mConfig.labelScaleFontSizes ? _this.maxSize.height / (_this.mConfig.labelScaleBasePersonaRadius * 2) : 1;
        _this.mBiggestFontSize = Math.max(_this.mConfig.labelNameFontSize, _this.mConfig.labelCountFontSize, _this.mConfig.labelTotalCountFontSize);
        _this.mSmallestFontSize = Math.min(_this.mConfig.labelNameFontSize, _this.mConfig.labelCountFontSize, _this.mConfig.labelTotalCountFontSize);

        _this.mNameLabel = null;
        _this.mCountLabel = null;
        _this.mTotalCountLabel = null;

        _this.mNameBack = new __WEBPACK_IMPORTED_MODULE_7__revi_graphics_primitives_Rectangle_js__["a" /* default */](0, 0, {
            fillEnabled: true,
            fillColor: config.labelNameBackgroundColor
        });

        _this.maxSize.on(__WEBPACK_IMPORTED_MODULE_3__revi_geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this.maxSize.safeBind(_this._handleMaxSizeChanged, _this));

        var nameFont = _this.mConfig.labelNameFont === 'default' ? __WEBPACK_IMPORTED_MODULE_5__config_fonts_Arial_js__["a" /* default */] : _this.mConfig.labelNameFont;
        __WEBPACK_IMPORTED_MODULE_4__revi_text_FontManager_js__["a" /* default */].sharedInstance().loadFont(nameFont, PERSONA_FONTS.NAME).then(_this._handleNameFontLoaded.bind(_this));

        if (_this.mCount !== null) {
            var countFont = _this.mConfig.labelCountFont === 'default' ? __WEBPACK_IMPORTED_MODULE_6__config_fonts_Oswald700_js__["a" /* default */] : _this.mConfig.labelCountFont;
            __WEBPACK_IMPORTED_MODULE_4__revi_text_FontManager_js__["a" /* default */].sharedInstance().loadFont(countFont, PERSONA_FONTS.COUNT).then(_this._handleCountFontLoaded.bind(_this));
        }

        if (_this.mTotalCount !== null) {
            var totalCountFont = _this.mConfig.labelTotalCountFont === 'default' ? __WEBPACK_IMPORTED_MODULE_5__config_fonts_Arial_js__["a" /* default */] : _this.mConfig.labelTotalCountFont;
            __WEBPACK_IMPORTED_MODULE_4__revi_text_FontManager_js__["a" /* default */].sharedInstance().loadFont(totalCountFont, PERSONA_FONTS.TOTAL_COUNT).then(_this._handleTotalCountFontLoaded.bind(_this));
        }
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Label, [{
        key: 'destroy',
        value: function destroy() {
            this.maxSize.off(__WEBPACK_IMPORTED_MODULE_3__revi_geometry_Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this._handleMaxSizeChanged, this);

            this.mMaxSize.release();
            this.mNameBack.release();
            if (this.mNameLabel) {
                this.mNameLabel.release();
            }
            if (this.mCountLabel) {
                this.mCountLabel.release();
            }
            if (this.mTotalCountLabel) {
                this.mTotalCountLabel.release();
            }

            delete this.mName;
            delete this.mCount;
            delete this.mTotalCount;
            delete this.mConfig;
            delete this.mFontSizeScale;
            delete this.mBiggestFontSize;
            delete this.mSmallestFontSize;
            delete this.mNameLabel;
            delete this.mCountLabel;
            delete this.mTotalCountLabel;
            delete this.mNameBack;

            _get(Label.prototype.__proto__ || Object.getPrototypeOf(Label.prototype), 'destroy', this).call(this);
        }

        /**
         * The maximum size of this label.
         *
         * @type {Size}
         */

    }, {
        key: 'updateText',


        /**
         * Updates the text of this label as specified.
         *
         * @method updateText
         * @param {String|null} name - The new name to display or null if no change is needed.
         * @param {String|null} count - The new count to display or null if no count should be displayed.
         * @param {String|null} totalCount - The new total count to display or null if no total count should be displayed.
         */
        value: function updateText() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var totalCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            if (name !== null && name !== this.mName) {
                this.mName = name;
                this.mNameLabel.text = this.mName.toString();
            }

            if (count !== null && count !== this.mCount) {
                this.mCount = count;
                if (!this.mCountLabel) {
                    var countFont = this.mConfig.labelCountFont === 'default' ? __WEBPACK_IMPORTED_MODULE_6__config_fonts_Oswald700_js__["a" /* default */] : this.mConfig.labelCountFont;
                    __WEBPACK_IMPORTED_MODULE_4__revi_text_FontManager_js__["a" /* default */].sharedInstance().loadFont(countFont, PERSONA_FONTS.COUNT).then(this._handleCountFontLoaded.bind(this));
                } else {
                    this.mCountLabel.text = this.mCount.toString();
                }
            } else if (count === null && this.mCountLabel) {
                this.mCountLabel.parent.removeChild(this.mCountLabel);
                this.mCountLabel.release();
                this.mCountLabel = null;
            }

            if (totalCount !== null && totalCount !== this.mTotalCount) {
                this.mTotalCount = totalCount;
                if (!this.mTotalCountLabel) {
                    var totalCountFont = this.mConfig.labelTotalCountFont === 'default' ? __WEBPACK_IMPORTED_MODULE_5__config_fonts_Arial_js__["a" /* default */] : this.mConfig.labelTotalCountFont;
                    __WEBPACK_IMPORTED_MODULE_4__revi_text_FontManager_js__["a" /* default */].sharedInstance().loadFont(totalCountFont, PERSONA_FONTS.TOTAL_COUNT).then(this._handleTotalCountFontLoaded.bind(this));
                } else {
                    this.mTotalCountLabel.text = this.mTotalCount.toString();
                }
            } else if (totalCount === null && this.mTotalCountLabel) {
                this.mTotalCountLabel.parent.removeChild(this.mTotalCountLabel);
                this.mTotalCountLabel.release();
                this.mTotalCountLabel = null;
            }
        }

        /**
         * Called when the font for the name label is loaded.
         *
         * @method _handleNameFontLoaded
         * @param {Font} font - The loaded font.
         * @private
         */

    }, {
        key: '_handleNameFontLoaded',
        value: function _handleNameFontLoaded(font) {
            var _this2 = this;

            /* handle the case where the object could have been destroyed at this point */
            if (this.retainCount > 0) {
                var padding = this.mConfig.labelNameBackgroundPadding;
                var fontScale = this._getFontSize(this.mSmallestFontSize) / this.mSmallestFontSize;
                this.mNameLabel = this._createLabel(this.mName.toString(), this.maxSize.width, this.mConfig.labelNameMaxLines, padding * fontScale, font, PERSONA_FONTS.NAME, {
                    color: this.mConfig.labelNameColor,
                    fontSize: this._getFontSize(this.mConfig.labelNameFontSize),
                    renderShadow: this.mConfig.labelNameShadow,
                    shadowColor: this.mConfig.labelNameShadowColor,
                    shadowBlur: this.mConfig.labelNameShadowBlur,
                    shadowOffsetX: this.mConfig.labelNameShadowOffsetX,
                    shadowOffsetY: this.mConfig.labelNameShadowOffsetY
                });

                this.mNameLabel.on(__WEBPACK_IMPORTED_MODULE_2__revi_text_Events_js__["a" /* default */].TEXT_LABEL_RENDERED, function () {
                    var scale = _this2._getFontSize(_this2.mSmallestFontSize) / _this2.mSmallestFontSize;
                    var scaledPadding = padding * scale;
                    _this2._positionLabels();
                    _this2.mNameBack.anchor.set('50%', 0);
                    _this2.mNameBack.position.set('50%', _this2.mNameLabel.position.y - scaledPadding);
                    _this2.mNameBack.size.set(_this2.mNameLabel.boundingBox.width + scaledPadding * 2, _this2.mNameLabel.boundingBox.height + scaledPadding * 2);
                });

                this.mNameLabel.on(__WEBPACK_IMPORTED_MODULE_2__revi_text_Events_js__["a" /* default */].TEXT_LABEL_WILL_RENDER, function () {
                    _this2.scale = 1;
                });

                this.addChild(this.mNameBack);
                this.addChild(this.mNameLabel);
            }
        }

        /**
         * Called when the font for the count label is loaded.
         *
         * @method _handleCountFontLoaded
         * @param {Font} font - The loaded font.
         * @private
         */

    }, {
        key: '_handleCountFontLoaded',
        value: function _handleCountFontLoaded(font) {
            var _this3 = this;

            /* handle the case where the object could have been destroyed at this point */
            if (this.retainCount > 0 && this.mCount !== null) {
                var labelWidth = this.mTotalCount === null ? this.maxSize.width : this.maxSize.width * 0.5;
                this.mCountLabel = this._createLabel(this.mCount.toString(), labelWidth, 1, 0, font, PERSONA_FONTS.COUNT, {
                    color: this.mConfig.labelCountColor,
                    fontSize: this._getFontSize(this.mConfig.labelCountFontSize),
                    renderShadow: this.mConfig.labelCountShadow,
                    shadowColor: this.mConfig.labelCountShadowColor,
                    shadowBlur: this.mConfig.labelCountShadowBlur,
                    shadowOffsetX: this.mConfig.labelCountShadowOffsetX,
                    shadowOffsetY: this.mConfig.labelCountShadowOffsetY
                });

                this.mCountLabel.on(__WEBPACK_IMPORTED_MODULE_2__revi_text_Events_js__["a" /* default */].TEXT_LABEL_RENDERED, function () {
                    return _this3._positionLabels();
                });
                this.mCountLabel.on(__WEBPACK_IMPORTED_MODULE_2__revi_text_Events_js__["a" /* default */].TEXT_LABEL_WILL_RENDER, function () {
                    _this3.scale = 1;
                });

                this.addChild(this.mCountLabel);
            }
        }

        /**
         * Called when the font for the total count label is loaded.
         *
         * @method _handleCountFontLoaded
         * @param {Font} font - The loaded font.
         * @private
         */

    }, {
        key: '_handleTotalCountFontLoaded',
        value: function _handleTotalCountFontLoaded(font) {
            var _this4 = this;

            /* handle the case where the object could have been destroyed at this point */
            if (this.retainCount > 0 && this.mTotalCount !== null) {
                var labelWidth = this.mCount === null ? this.maxSize.width : this.maxSize.width * 0.5;
                this.mTotalCountLabel = this._createLabel('/' + this.mTotalCount, labelWidth, 1, 0, font, PERSONA_FONTS.TOTAL_COUNT, {
                    color: this.mConfig.labelTotalCountColor,
                    fontSize: this._getFontSize(this.mConfig.labelTotalCountFontSize),
                    renderShadow: this.mConfig.labelTotalCountShadow,
                    shadowColor: this.mConfig.labelTotalCountShadowColor,
                    shadowBlur: this.mConfig.labelTotalCountShadowBlur,
                    shadowOffsetX: this.mConfig.labelTotalCountShadowOffsetX,
                    shadowOffsetY: this.mConfig.labelTotalCountShadowOffsetY
                });

                this.mTotalCountLabel.on(__WEBPACK_IMPORTED_MODULE_2__revi_text_Events_js__["a" /* default */].TEXT_LABEL_RENDERED, function () {
                    return _this4._positionLabels();
                });
                this.mTotalCountLabel.on(__WEBPACK_IMPORTED_MODULE_2__revi_text_Events_js__["a" /* default */].TEXT_LABEL_WILL_RENDER, function () {
                    _this4.scale = 1;
                });

                this.addChild(this.mTotalCountLabel);
            }
        }

        /**
         * When this label's max size is modified, this method is called.
         *
         * @method _handleMaxSizeChanged
         * @param {*} sender - The instance that originally triggered this event.
         * @param {Number} width - The new width of the label.
         * @private
         */

    }, {
        key: '_handleMaxSizeChanged',
        value: function _handleMaxSizeChanged(sender, width) {
            if (sender === this.mMaxSize) {
                this.mFontSizeScale = this.mConfig.labelScaleFontSizes ? this.maxSize.height / (this.mConfig.labelScaleBasePersonaRadius * 2) : 1;
                if (this.mNameLabel) {
                    // this.mNameLabel.off(TextEvents.TEXT_LABEL_RENDERED);
                    this._updateLabel(this.mNameLabel, width, this.mConfig.labelNameMaxLines, this.mConfig.labelNameBackgroundPadding, this.mConfig.labelNameFontSize);
                }

                if (this.mCountLabel) {
                    // this.mCountLabel.off(TextEvents.TEXT_LABEL_RENDERED);
                    var labelWidth = this.mTotalCount === null ? width : width * 0.5;
                    this._updateLabel(this.mCountLabel, labelWidth, 1, 0, this.mConfig.labelCountFontSize);
                }

                if (this.mTotalCountLabel) {
                    // this.mTotalCountLabel.off(TextEvents.TEXT_LABEL_RENDERED);
                    var _labelWidth = this.mCount === null ? width : width * 0.5;
                    this._updateLabel(this.mTotalCountLabel, _labelWidth, 1, 0, this.mConfig.labelTotalCountFontSize);
                }
            }
        }

        /**
         * Gets the scaled font size.
         *
         * @method _getFontSize
         * @param {Number} fontSize - The original font size to scale.
         * @returns {Number}
         * @private
         */

    }, {
        key: '_getFontSize',
        value: function _getFontSize(fontSize) {
            var minFontSize = void 0;

            if (this.mBiggestFontSize * this.mFontSizeScale > this.mConfig.labelMaxFontSize) {
                minFontSize = Math.max(this.mConfig.labelMaxFontSize * (this.mSmallestFontSize / this.mBiggestFontSize), this.mConfig.labelMinFontSize);
            } else {
                minFontSize = Math.max(this.mSmallestFontSize * this.mFontSizeScale, this.mConfig.labelMinFontSize);
            }

            return Math.min(fontSize / this.mSmallestFontSize * minFontSize, this.mConfig.labelMaxFontSize);
        }

        /**
         * Creates a label using the specified details.
         *
         * @method _createLabel
         * @param {String} text - The text for the label.
         * @param {Number} maxWidth - The maximum width of the label to create.
         * @param {Number} maxLines - The maximum number of text lines for the label.
         * @param {Number} padding - The padding left around the label.
         * @param {Font} font - The font to be used for the label.
         * @param {String} fontKey - The key used in the font manager to load the font.
         * @param {Object} options - The rendering options for the label.
         * @returns {Label}
         * @private
         */

    }, {
        key: '_createLabel',
        value: function _createLabel(text, maxWidth, maxLines, padding, font, fontKey, options) {
            var hhea = font.tables.hhea;
            var fontScale = options.fontSize / font.unitsPerEm;
            var lineHeight = (hhea.ascender - hhea.descender) * fontScale;
            var labelWidth = Math.max(maxWidth - padding * 2, 0);
            var labelHeight = Math.max(Math.min(lineHeight * maxLines, this.mMaxSize.height - padding * 2), 0);

            options.alignment = __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_ALIGNMENT.CENTER;
            options.truncateMode = __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_TRUNCATING_MODE.ELLIPSES;
            options.multiLineMode = __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_MULTI_LINE_MODE.AUTO_LINES;
            options.renderingBackend = __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */].TEXT_RENDERING_BACKEND.CANVAS;
            options.autoSize = true;

            var label = new __WEBPACK_IMPORTED_MODULE_1__revi_text_Label_js__["a" /* default */](labelWidth, labelHeight, text, fontKey, null, options);

            return label;
        }

        /**
         * Updates the specified label.
         *
         * @param {Label} label - the label to update.
         * @param {Number} maxWidth - The new max width of the label.
         * @param {Number} maxLines - The new max number of lines of text for the label.
         * @param {Number} padding - The padding around the text.
         * @param {Number} fontSize - The font size for the label.
         * @private
         */

    }, {
        key: '_updateLabel',
        value: function _updateLabel(label, maxWidth, maxLines, padding, fontSize) {
            var font = label.font;
            var scaledFontSize = this._getFontSize(fontSize);
            var hhea = font.tables.hhea;
            var fontScale = scaledFontSize / font.unitsPerEm;
            var lineHeight = (hhea.ascender - hhea.descender) * fontScale;
            var labelWidth = Math.max(maxWidth - padding * 2, 0);
            var labelHeight = Math.max(Math.min(lineHeight * maxLines, this.mMaxSize.height - padding * 2), 0);
            label.fontSize = scaledFontSize;
            label.maxSize.set(labelWidth, labelHeight);
        }

        /**
         * Positions the loaded labels within this persona label.
         *
         * @method _positionLabels
         * @private
         */

    }, {
        key: '_positionLabels',
        value: function _positionLabels() {
            var totalHeight = 0;

            if (this.mNameLabel) {
                var fontScale = this._getFontSize(this.mSmallestFontSize) / this.mSmallestFontSize;
                var padding = this.mConfig.labelNameBackgroundPadding * fontScale;
                this.mNameLabel.anchor.set('50%', 0);
                this.mNameLabel.position.set('50%', padding);
                totalHeight += this.mNameLabel.size.height + padding * 2 + this.mConfig.labelNameAndCountsPadding * fontScale;
            }

            if (this.mCountLabel && this.mTotalCountLabel) {
                totalHeight += Math.max(this.mCountLabel.size.height, this.mTotalCountLabel.size.height);

                this.mCountLabel.anchor.set('100%', '100%');
                this.mTotalCountLabel.anchor.set(0, '100%');

                this.mCountLabel.position.set('50%', totalHeight);
                this.mTotalCountLabel.position.set('50%', totalHeight + this.mCountLabel.descender - this.mTotalCountLabel.descender);
            } else if (this.mCountLabel) {
                totalHeight += this.mCountLabel.size.height;
                this.mCountLabel.anchor.set('50%', '100%');
                this.mCountLabel.position.set('50%', totalHeight);
            } else if (this.mTotalCountLabel) {
                totalHeight += this.mTotalCountLabel.size.height;
                this.mTotalCountLabel.anchor.set('50%', '100%');
                this.mTotalCountLabel.position.set('50%', totalHeight);
            }

            this.size.height = totalHeight;
        }
    }, {
        key: 'maxSize',
        get: function get() {
            return this.mMaxSize;
        }
    }]);

    return Label;
}(__WEBPACK_IMPORTED_MODULE_0__revi_graphics_Node_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Label;

/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__revi_graphics_CachedNode_js__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__revi_graphics_primitives_Circle_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Gauge_js__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Avatar_js__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Label_js__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__revi_plugins_input_InputManager_js__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__revi_plugins_input_Events_js__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Events_js__ = __webpack_require__(109);
/* unused harmony export Persona */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */










/**
 * Class that represents a Persona in the visualization.
 *
 * @class Persona
 */
var Persona = function (_CachedNode) {
    _inherits(Persona, _CachedNode);

    /**
     * @param {Number} radius - The radius of this persona.
     * @param {Object} data - The data this persona will represent.
     * @param {Object} config - Rendering configuration.
     * @constructor
     */
    function Persona(radius, data, config) {
        _classCallCheck(this, Persona);

        var size = Math.max(radius * 2, 0);
        var sizeWithBorder = Math.ceil(size + Math.max(config.selectedBorder, config.unselectedBorder) * 2);
        var labelWidth = size + Math.ceil(config.labelWidthSpill * 2);
        var personaWidth = Math.max(labelWidth, sizeWithBorder);
        var personaHeight = Math.max(sizeWithBorder, size + config.gaugeMarkerSpill * 2);

        var _this = _possibleConstructorReturn(this, (Persona.__proto__ || Object.getPrototypeOf(Persona)).call(this, personaWidth, personaHeight));

        _this.mConfig = config;
        _this.mRadius = Math.max(radius, 0);
        _this.mID = data.id;
        _this.mSelected = data.selected || false;
        _this.mTrackingPointer = null;
        _this.mTrackingPoint = null;
        _this.mTrackingMoveThreshold = Math.pow(8, 2);

        /* background */
        var backgroundRadius = Math.max(_this.mRadius - _this.mConfig.radiusOverlap, 0);
        var backgroundStroke = _this.mSelected ? _this.mConfig.selectedBorder : _this.mConfig.unselectedBorder + _this.mConfig.radiusOverlap;
        var backgroundStrokeColor = _this.mSelected ? _this.mConfig.selectedBorderColor : _this.mConfig.unselectedBorderColor;
        _this.mBackground = new __WEBPACK_IMPORTED_MODULE_1__revi_graphics_primitives_Circle_js__["a" /* default */](backgroundRadius, {
            fillEnabled: true,
            fillColor: _this.mConfig.backgroundColor,
            stroke: backgroundStroke,
            strokeColor: backgroundStrokeColor,
            strokeType: __WEBPACK_IMPORTED_MODULE_1__revi_graphics_primitives_Circle_js__["a" /* default */].STROKE_OUTER
        });
        _this.mBackground.position.set('50%', '50%');
        _this.addChild(_this.mBackground);

        /* gauge */
        _this.mGauge = new __WEBPACK_IMPORTED_MODULE_2__Gauge_js__["a" /* default */](_this.mRadius, _this.mConfig);
        _this.mGauge.position.set('50%', '50%');
        _this.addChild(_this.mGauge);
        data.properties.forEach(function (property) {
            return _this.mGauge.addBar(property.count / data.totalCount, property.color);
        });

        /* avatar */
        var avatarRadius = Math.max(_this.mRadius - _this.mConfig.gaugeThickness, 0);
        _this.mAvatar = new __WEBPACK_IMPORTED_MODULE_3__Avatar_js__["a" /* default */](avatarRadius, data.images, _this.mConfig);
        _this.mAvatar.position.set('50%', '50%');
        _this.addChild(_this.mAvatar);

        /* label */
        var countLabel = null;
        var totalCountLabel = null;
        if (_this.mConfig.labelCountDisplayMode === 'propertyCount/totalCount') {
            countLabel = data.properties[_this.mConfig.labelPropertyCountIndex].count;
            totalCountLabel = data.totalCount;
        } else if (_this.mConfig.labelCountDisplayMode === 'propertyCount') {
            countLabel = data.properties[_this.mConfig.labelPropertyCountIndex].count;
        } else if (_this.mConfig.labelCountDisplayMode === 'totalCount') {
            countLabel = data.totalCount;
        }

        _this.mLabel = new __WEBPACK_IMPORTED_MODULE_4__Label_js__["a" /* default */](data.label, countLabel, totalCountLabel, labelWidth, _this.size.height, _this.mConfig);
        _this.mLabel.anchor.set('50%', _this.mConfig.labelVerticalPosition);
        _this.mLabel.position.set('50%', _this.mConfig.labelVerticalPosition);
        _this.addChild(_this.mLabel);
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Persona, [{
        key: 'destroy',
        value: function destroy() {
            this.mBackground.release();
            this.mGauge.release();
            this.mAvatar.release();
            this.mLabel.release();

            if (this.mTrackingPoint) {
                this.mTrackingPoint.release();
                this.mTrackingPoint = null;
            }

            delete this.mConfig;
            delete this.mRadius;
            delete this.mID;
            delete this.mSelected;
            delete this.mTrackingPointer;
            delete this.mTrackingPoint;
            delete this.mTrackingMoveThreshold;
            delete this.mBackground;
            delete this.mGauge;
            delete this.mAvatar;
            delete this.mLabel;

            _get(Persona.prototype.__proto__ || Object.getPrototypeOf(Persona.prototype), 'destroy', this).call(this);
        }

        /**
         * The ID assigned to this persona through the data.
         *
         * @type {*}
         */

    }, {
        key: 'onEnter',


        /**
         * Called every time the object is added to the currently running scene graph.
         *
         * @method onEnter
         * @param {Symbol} reviContext - A unique symbol that identifies the rendering context of this object.
         */
        value: function onEnter(reviContext) {
            var inputManager = __WEBPACK_IMPORTED_MODULE_5__revi_plugins_input_InputManager_js__["a" /* default */].instanceForContext(reviContext);
            inputManager.on(__WEBPACK_IMPORTED_MODULE_6__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_BEGAN, inputManager.safeBind(this._handlePointerBegan, this));
            inputManager.on(__WEBPACK_IMPORTED_MODULE_6__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_MOVED, inputManager.safeBind(this._handlePointerMoved, this));
            inputManager.on([__WEBPACK_IMPORTED_MODULE_6__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_ENDED, __WEBPACK_IMPORTED_MODULE_6__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_CANCELLED], inputManager.safeBind(this._handlePointerEnded, this));
            _get(Persona.prototype.__proto__ || Object.getPrototypeOf(Persona.prototype), 'onEnter', this).call(this, reviContext);
        }

        /**
         * Called when this objects is removed from the scene graph.
         *
         * @method onExit
         */

    }, {
        key: 'onExit',
        value: function onExit() {
            var inputManager = __WEBPACK_IMPORTED_MODULE_5__revi_plugins_input_InputManager_js__["a" /* default */].instanceForContext(this.reviContext);
            inputManager.off(__WEBPACK_IMPORTED_MODULE_6__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_BEGAN, this._handlePointerBegan, this);
            inputManager.off(__WEBPACK_IMPORTED_MODULE_6__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_MOVED, this._handlePointerMoved, this);
            inputManager.off([__WEBPACK_IMPORTED_MODULE_6__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_ENDED, __WEBPACK_IMPORTED_MODULE_6__revi_plugins_input_Events_js__["a" /* default */].INPUT_POINTER_CANCELLED], this._handlePointerEnded, this);
            _get(Persona.prototype.__proto__ || Object.getPrototypeOf(Persona.prototype), 'onExit', this).call(this);
        }

        /**
         * Called every tick, drawing operations should be performed here.
         *
         * @method draw
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {...*} varArgs - Optional parameters to be passed to the node's children when drawing.
         */

    }, {
        key: 'draw',
        value: function draw(context) {
            var _this2 = this;

            for (var _len = arguments.length, varArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                varArgs[_key - 1] = arguments[_key];
            }

            if (this.mDirty) {
                this.mDirty = false;
                this.mOffscreenCanvas.width = this.size.width * this.deviceScale * this.globalScale;
                this.mOffscreenCanvas.height = this.size.height * this.deviceScale * this.globalScale;
                this.mOffscreenContext.setTransform(1, 0, 0, 1, 0, 0);
                this.mOffscreenContext.clearRect(0, 0, this.mOffscreenCanvas.width, this.mOffscreenCanvas.height);
                this.mOffscreenContext.scale(this.deviceScale, this.deviceScale);
                this.mOffscreenContext.translate(this.size.width * this.globalScale * 0.5 - this.size.width * 0.5, this.size.height * this.globalScale * 0.5 - this.size.height * 0.5);
                this.updateCache.apply(this, [this.mOffscreenContext, context].concat(varArgs));
                this.mChildren.forEach(function (child) {
                    child._pushTransform(_this2.mOffscreenContext);
                    child.draw.apply(child, [_this2.mOffscreenContext].concat(varArgs));
                    child._popTransform(_this2.mOffscreenContext);
                });
            }
            this.drawCache.apply(this, [this.mOffscreenCanvas, context].concat(varArgs));
        }

        /**
         * Updates this persona with the data provided.
         *
         * @method updateData
         * @param {Object} data - the data used to update this persona.
         */

    }, {
        key: 'updateData',
        value: function updateData(data) {
            var countLabel = null;
            var totalCountLabel = null;
            if (this.mConfig.labelCountDisplayMode === 'propertyCount/totalCount') {
                countLabel = data.properties[this.mConfig.labelPropertyCountIndex].count;
                totalCountLabel = data.totalCount;
            } else if (this.mConfig.labelCountDisplayMode === 'propertyCount') {
                countLabel = data.properties[this.mConfig.labelPropertyCountIndex].count;
            } else if (this.mConfig.labelCountDisplayMode === 'totalCount') {
                countLabel = data.totalCount;
            }
            this.mLabel.updateText(data.label, countLabel, totalCountLabel);

            this.mAvatar.updateImages(data.images);

            /* update gauges here */
        }

        /**
         * Handles the pointer began input event.
         *
         * @method _handlePointerBegan
         * @param {*} sender - The sender of the event.
         * @param {PointerEvent} event - Object containing the event's description.
         * @private
         */

    }, {
        key: '_handlePointerBegan',
        value: function _handlePointerBegan(sender, event) {
            var localPoint = this.globalToLocalPoint(event.point);
            var distanceSQ = Math.pow(localPoint.x - this.size.width * 0.5, 2) + Math.pow(localPoint.y - this.size.height * 0.5, 2);

            this.mTrackingPointer = null;
            if (this.mTrackingPoint) {
                this.mTrackingPoint.release();
                this.mTrackingPoint = null;
            }

            if (distanceSQ < this.radius * this.radius) {
                this.mTrackingPointer = event.identifier;
                this.mTrackingPoint = event.point.retain();
            }
        }

        /**
         * Handles the pointer moved event.
         *
         * @method _handlePointerMoved
         * @param {*} sender - The sender of the event.
         * @param {PointerEvent} event - Object containing the event's description.
         * @private
         */

    }, {
        key: '_handlePointerMoved',
        value: function _handlePointerMoved(sender, event) {
            if (event.identifier === this.mTrackingPointer) {
                var point = event.point;
                var distanceSQ = Math.pow(point.x - this.mTrackingPoint.x, 2) + Math.pow(point.y - this.mTrackingPoint.y, 2);
                if (distanceSQ > this.mTrackingMoveThreshold) {
                    this.mTrackingPointer = null;
                    if (this.mTrackingPoint) {
                        this.mTrackingPoint.release();
                        this.mTrackingPoint = null;
                    }
                }
            }
        }

        /**
         * Handles the pointer moved input event.
         *
         * @method _handlePointerEnded
         * @param {*} sender - The sender of the event.
         * @param {PointerEvent} event - Object containing the event's description.
         * @private
         */

    }, {
        key: '_handlePointerEnded',
        value: function _handlePointerEnded(sender, event) {
            if (event.identifier === this.mTrackingPointer) {
                var localPoint = this.globalToLocalPoint(event.point);
                var distanceSQ = Math.pow(localPoint.x - this.size.width * 0.5, 2) + Math.pow(localPoint.y - this.size.height * 0.5, 2);

                this.mTrackingPointer = null;
                if (this.mTrackingPoint) {
                    this.mTrackingPoint.release();
                    this.mTrackingPoint = null;
                }

                if (distanceSQ < this.radius * this.radius) {
                    this.emit(__WEBPACK_IMPORTED_MODULE_7__Events_js__["a" /* default */].PERSONA_CLICKED, this, event.position, localPoint);
                }
            }
        }
    }, {
        key: 'id',
        get: function get() {
            return this.mID;
        }

        /**
         * The radius that encloses all elements of this persona.
         *
         * @type {Number}
         */

    }, {
        key: 'safeRadius',
        get: function get() {
            return Math.max(this.size.width, this.size.height) * 0.5;
        }

        /**
         * The configured radius of this persona.
         *
         * @type {Number}
         */

    }, {
        key: 'radius',
        get: function get() {
            return this.mRadius;
        }

        /**
         * Sets the radius of this persona.
         *
         * @param {Number} value - The new radius.
         */
        ,
        set: function set(value) {
            if (value !== this.mRadius) {
                this.mRadius = Math.max(value, 0);

                var scale = this.mGlobalScale * this.mScale;
                var radius = this.mRadius * scale;
                var size = this.mRadius * 2;
                var sizeWithBorder = Math.ceil(size + Math.max(this.mConfig.selectedBorder, this.mConfig.unselectedBorder) * 2 / scale);
                var labelWidth = size + Math.ceil(this.mConfig.labelWidthSpill * 2 / scale);
                var personaWidth = Math.max(labelWidth, sizeWithBorder);
                var personaHeight = Math.max(sizeWithBorder, size + this.mConfig.gaugeMarkerSpill * 2 / scale);
                this.size.set(personaWidth, personaHeight);

                this.mBackground.radius = Math.max(radius - this.mConfig.radiusOverlap, 0);
                this.mGauge.radius = radius;
                this.mAvatar.radius = Math.max(radius - this.mConfig.gaugeThickness, 0);
                this.mLabel.maxSize.set(radius * 2 + Math.ceil(this.mConfig.labelWidthSpill * 2), this.size.height * scale);

                this.needsRedraw();
            }
        }

        /**
         * Is this persona selected.
         *
         * @type {Boolean}
         */

    }, {
        key: 'selected',
        get: function get() {
            return this.mSelected;
        }

        /**
         * Sets the selection state of this persona.
         *
         * @param {Boolean} value - The new selection state.
         */
        ,
        set: function set(value) {
            if (value !== this.mSelected) {
                this.mSelected = value;
                this.mBackground.stroke = (this.mSelected ? this.mConfig.selectedBorder : this.mConfig.unselectedBorder) + this.mConfig.radiusOverlap;
                this.mBackground.strokeColor = this.mSelected ? this.mConfig.selectedBorderColor : this.mConfig.unselectedBorderColor;
            }
        }

        /**
         * The aggregated scale of this node and all its ancestors.
         *
         * @type {Number}
         */

    }, {
        key: 'globalScale',
        get: function get() {
            return _get(Persona.prototype.__proto__ || Object.getPrototypeOf(Persona.prototype), 'globalScale', this);
        }

        /**
         * Sets the global scale of this node and its children. Usually this property should not be set manually.
         *
         * @param {Number} value - the new global scale of the node.
         */
        ,
        set: function set(value) {
            if (value !== this.globalScale) {
                this.mDirty = true;
                this.needsRedraw();
            }
            this.mGlobalScale = value;

            /* HACK!!! */
            var radius = this.mRadius;
            this.mRadius += 5;
            this.radius = radius;
        }
    }]);

    return Persona;
}(__WEBPACK_IMPORTED_MODULE_0__revi_graphics_CachedNode_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Persona;

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__IBindable_js__ = __webpack_require__(47);
/* unused harmony export Tuple */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/**
 * Utility class used to save an arbitrary number of values in an object.
 *
 * @class tuple
 */
var Tuple = function (_IBindable) {
    _inherits(Tuple, _IBindable);

    /**
     * Constructs an instance of a Tuple with its values as the passed arguments. Each value is added to the object with
     * the notation `value1` ... `value[n]`.
     *
     * @param {...*} varArgs - The values to add this object as properties.
     */
    function Tuple() /* varArgs */{
        var _this$mValues;

        _classCallCheck(this, Tuple);

        var _this = _possibleConstructorReturn(this, (Tuple.__proto__ || Object.getPrototypeOf(Tuple)).call(this));

        _this.mFrozen = 0;
        _this.mValues = [];

        (_this$mValues = _this.mValues).push.apply(_this$mValues, arguments);
        _this.mValues.forEach(function (ignored, i) {
            Object.defineProperty(_this, 'value' + (i + 1), {
                get: function get() {
                    return _this._getValueAtIndex(i);
                },
                set: function set(value) {
                    if (_this.mFrozen > 0) {
                        throw new Error('This instance cannot be modified as its values are frozen. Try unfreezing them first.');
                    }
                    _this._setValueAtIndex(i, value);
                }
            });
        });
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Tuple, [{
        key: 'destroy',
        value: function destroy() {
            this.mValues.length = 0;
            delete this.mValues;
            _get(Tuple.prototype.__proto__ || Object.getPrototypeOf(Tuple.prototype), 'destroy', this).call(this);
        }

        /**
         * Freezes the values of this tuple. If a value is modified while froze, the setter throws an error.
         * NOTE: The freezing mechanism is implemented as a stack, meaning that to unfreeze the values `unfreezeValues` has
         * to be called the same number of times as `freezeValues`.
         *
         * @method freezeValues
         */

    }, {
        key: 'freezeValues',
        value: function freezeValues() {
            ++this.mFrozen;
        }

        /**
         * Unfreezes the values of this tuple.
         * NOTE: The freezing mechanism is implemented as a stack, meaning that to unfreeze the values `unfreezeValues` has
         * to be called the same number of times as `freezeValues`.
         *
         * @methos unfreezeValues
         */

    }, {
        key: 'unfreezeValues',
        value: function unfreezeValues() {
            if (!this.mFrozen) {
                throw new Error('Values are not frozen. Are you missing a freeze?');
            }
            --this.mFrozen;
        }

        /**
         * Gets the value at the given index of this tuple.
         *
         * @method _getValueAtIndex
         * @param {Number} index - The index of the value to retieve.
         * @returns {*}
         * @private
         */

    }, {
        key: '_getValueAtIndex',
        value: function _getValueAtIndex(index) {
            return this.mValues[index];
        }

        /**
         * Sets the value at the given index of this tuple.
         * NOTE: This method bypasses the value freezing mechanism of this tuple.
         *
         * @method _setValueAtIndex
         * @param {Number} index - The index of the value to set.
         * @param {*} value - The new value.
         * @private
         */

    }, {
        key: '_setValueAtIndex',
        value: function _setValueAtIndex(index, value) {
            this.mValues[index] = value;
        }
    }]);

    return Tuple;
}(__WEBPACK_IMPORTED_MODULE_0__IBindable_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Tuple;

/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Rect_js__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Point_js__ = __webpack_require__(27);
/* unused harmony export BoundingBox */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */




/**
 * Utility class that represents a bounding box in 2D space.
 *
 * @class BoundingBox
 */
var BoundingBox = function (_Rect) {
  _inherits(BoundingBox, _Rect);

  /**
   * @constructor
   * @param {Number=} x - X coordinate of the bounding box's origin.
   * @param {Number=} y - Y coordinate of the bounding box's origin.
   * @param {Number=} width - The bounding box's width.
   * @param {Number=} height - The bounding box's height.
   */
  function BoundingBox(x, y, width, height) {
    _classCallCheck(this, BoundingBox);

    var _this = _possibleConstructorReturn(this, (BoundingBox.__proto__ || Object.getPrototypeOf(BoundingBox)).call(this, x, y, width, height));

    _this.mVertex01 = new __WEBPACK_IMPORTED_MODULE_1__Point_js__["a" /* default */](x, y);
    _this.mVertex02 = new __WEBPACK_IMPORTED_MODULE_1__Point_js__["a" /* default */](x, y + height);
    _this.mVertex03 = new __WEBPACK_IMPORTED_MODULE_1__Point_js__["a" /* default */](x + width, y);
    _this.mVertex04 = new __WEBPACK_IMPORTED_MODULE_1__Point_js__["a" /* default */](x + width, y + height);
    return _this;
  }

  /**
   * Destroys this object. Called automatically when the reference count of this object reaches zero.
   *
   * @method destroy
   */


  _createClass(BoundingBox, [{
    key: 'destroy',
    value: function destroy() {
      this.mVertex01.release();
      this.mVertex02.release();
      this.mVertex03.release();
      this.mVertex04.release();

      delete this.mVertex01;
      delete this.mVertex02;
      delete this.mVertex03;
      delete this.mVertex04;
      delete this.mForwardEvent;

      _get(BoundingBox.prototype.__proto__ || Object.getPrototypeOf(BoundingBox.prototype), 'destroy', this).call(this);
    }

    /**
     * The first vertex; when untransformed, the top-left corner of the bounding box.
     *
     * @type {Point}
     * @readonly
     */

  }, {
    key: 'set',


    /**
     * Sets the x and y coordinates of this bounding box's origin as well as its width and height.
     *
     * @method set
     * @param {Number} x - X coordinate of the origin.
     * @param {Number} y - Y coordinate of the origin.
     * @param {Number} width - The new width.
     * @param {Number} height - The new height.
     */
    value: function set(x, y, width, height) {
      this.mOrigin.value1 = x;
      this.mOrigin.value2 = y;
      this.mSize.value1 = width;
      this.mSize.value2 = height;

      this.mVertex01.set(x, y);
      this.mVertex02.set(x, y + height);
      this.mVertex03.set(x + width, y);
      this.mVertex04.set(x + width, y + height);

      this.mForwardEvent();
    }

    /**
     * Sets the bounding box's origin, width, and height using the provided bounding box as reference.
     *
     * @method setFromBoundingBox
     * @param {BoundingBox} boundingBox - The boundingBox to use as reference.
     */

  }, {
    key: 'setFromBoundingBox',
    value: function setFromBoundingBox(boundingBox) {
      this.mOrigin.value1 = boundingBox.x;
      this.mOrigin.value2 = boundingBox.y;
      this.mSize.value1 = boundingBox.width;
      this.mSize.value2 = boundingBox.height;

      this.mVertex01.setFromPoint(boundingBox.v1);
      this.mVertex02.setFromPoint(boundingBox.v2);
      this.mVertex03.setFromPoint(boundingBox.v3);
      this.mVertex04.setFromPoint(boundingBox.v4);

      this.mForwardEvent();
    }

    /**
     * Expands this bounding box to include the given x, y point
     * @param {number} x x coordinate to include in this bounding box
     * @param {number} y y coordinate to include in this bounding box
     */

  }, {
    key: 'include',
    value: function include(x, y) {
      var minX = Math.min(this.v1.x, x);
      var minY = Math.min(this.v1.y, y);
      var maxX = Math.max(this.v4.x, x);
      var maxY = Math.max(this.v4.y, y);
      this.set(minX, minY, maxX - minX, maxY - minY);
    }

    /**
     * Expands this bounding box to include the given bounding box
     * @param {BoundingBox} boundingBox bounding box to include in this bounding box
     */

  }, {
    key: 'union',
    value: function union(boundingBox) {
      var minX = Math.min(this.v1.x, boundingBox.v1.x);
      var minY = Math.min(this.v1.y, boundingBox.v1.y);
      var maxX = Math.max(this.v4.x, boundingBox.v4.x);
      var maxY = Math.max(this.v4.y, boundingBox.v4.y);
      this.set(minX, minY, maxX - minX, maxY - minY);
    }
  }, {
    key: 'v1',
    get: function get() {
      return this.mVertex01;
    }

    /**
     * The second vertex; when untransformed, the top-right corner of the bounding box.
     *
     * @type {Point}
     * @readonly
     */

  }, {
    key: 'v2',
    get: function get() {
      return this.mVertex02;
    }

    /**
     * The third vertex; when untransformed, the bottom-left corner of the bounding box.
     *
     * @type {Point}
     * @readonly
     */

  }, {
    key: 'v3',
    get: function get() {
      return this.mVertex03;
    }

    /**
     * The fourth vertex; when untransformed, the bottom-right corner of the bounding box.
     *
     * @type {Point}
     * @readonly
     */

  }, {
    key: 'v4',
    get: function get() {
      return this.mVertex04;
    }
  }]);

  return BoundingBox;
}(__WEBPACK_IMPORTED_MODULE_0__Rect_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = BoundingBox;

/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__ = __webpack_require__(47);
/* unused harmony export Matrix */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/**
 * 2D transformation matrix object initialized with identity matrix.
 *
 * The matrix can synchronize a canvas context by supplying the context
 * as an argument, or later apply current absolute transform to an
 * existing context.
 *
 * All values are handled as floating point values.
 *
 * @class Matrix
 */
var Matrix = function (_IBindable) {
  _inherits(Matrix, _IBindable);

  /**
   * @constructor Matrix
   */
  function Matrix() {
    _classCallCheck(this, Matrix);

    var _this = _possibleConstructorReturn(this, (Matrix.__proto__ || Object.getPrototypeOf(Matrix)).call(this));

    _this.mA = 1;
    _this.mB = 0;
    _this.mC = 0;
    _this.mD = 1;
    _this.mE = 0;
    _this.mF = 0;
    return _this;
  }

  /**
   * Destroys this object. Called automatically when the reference count of this object reaches zero.
   *
   * @method destroy
   */


  _createClass(Matrix, [{
    key: 'destroy',
    value: function destroy() {
      delete this.mA;
      delete this.mB;
      delete this.mC;
      delete this.mD;
      delete this.mE;
      delete this.mF;
      _get(Matrix.prototype.__proto__ || Object.getPrototypeOf(Matrix.prototype), 'destroy', this).call(this);
    }

    /**
     * Get an inverse matrix of current matrix. The method returns a new
     * matrix with values you need to use to get to an identity matrix.
     * Context from parent matrix is not applied to the returned matrix.
     *
     * @type {Matrix}
     * @returns {Matrix}
     */

  }, {
    key: 'reset',


    /**
     * Short-hand to reset current matrix to an identity matrix.
     *
     * @method reset
     * @returns {Matrix}
     */
    value: function reset() {
      this.mA = this.mD = 1;
      this.mB = this.mC = this.mE = this.mF = 0;
      return this;
    }

    /**
     * Translate current matrix accumulative.
     *
     * @method translate
     * @param {number} tx - translation for x
     * @param {number} ty - translation for y
     * @returns {Matrix}
     */

  }, {
    key: 'translate',
    value: function translate(tx, ty) {
      this.transform(1, 0, 0, 1, tx, ty);
      return this;
    }

    /**
     * Rotates current matrix accumulative by angle.
     *
     * @methos rotate
     * @param {number} angle - angle in radians
     * @returns {Matrix}
     */

  }, {
    key: 'rotate',
    value: function rotate(angle) {
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      this.transform(cos, sin, -sin, cos, 0, 0);
      return this;
    }

    /**
     * Scales current matrix accumulative.
     * @param {number} sx - scale factor x (1 does nothing)
     * @param {number} sy - scale factor y (1 does nothing)
     * @returns {Matrix}
     */

  }, {
    key: 'scale',
    value: function scale(sx, sy) {
      this.transform(sx, 0, 0, sy, 0, 0);
      return this;
    }

    /**
     * Flips the horizontal values.
     *
     * @method flipX
     * @returns {Matrix}
     */

  }, {
    key: 'flipX',
    value: function flipX() {
      this.transform(-1, 0, 0, 1, 0, 0);
      return this;
    }

    /**
     * Flips the vertical values.
     *
     * @method flipY
     * @returns {Matrix}
     */

  }, {
    key: 'flipY',
    value: function flipY() {
      this.transform(1, 0, 0, -1, 0, 0);
      return this;
    }

    /**
     * Set current matrix to new absolute matrix.
     *
     * @method set
     * @param {number} a - scale x
     * @param {number} b - skew y
     * @param {number} c - skew x
     * @param {number} d - scale y
     * @param {number} e - translate x
     * @param {number} f - translate y
     * @returns {Matrix}
     */

  }, {
    key: 'set',
    value: function set(a, b, c, d, e, f) {
      this.mA = a;
      this.mB = b;
      this.mC = c;
      this.mD = d;
      this.mE = e;
      this.mF = f;
      return this;
    }

    /**
     * Sets the current matrix to a new absolute matrix using the provided matrix as reference.
     *
     * @method setFromMatrix
     * @param {Matrix} matrix - the matrix to use as reference.
     * @returns {Matrix}
     */

  }, {
    key: 'setFromMatrix',
    value: function setFromMatrix(matrix) {
      this.mA = matrix.mA;
      this.mB = matrix.mB;
      this.mC = matrix.mC;
      this.mD = matrix.mD;
      this.mE = matrix.mE;
      this.mF = matrix.mF;
      return this;
    }

    /**
     * Multiplies current matrix with new matrix values.
     *
     * @method transform
     * @param {number} a2 - scale x
     * @param {number} b2 - skew y
     * @param {number} c2 - skew x
     * @param {number} d2 - scale y
     * @param {number} e2 - translate x
     * @param {number} f2 - translate y
     * @returns {Matrix}
     */

  }, {
    key: 'transform',
    value: function transform(a2, b2, c2, d2, e2, f2) {
      var a1 = this.mA;
      var b1 = this.mB;
      var c1 = this.mC;
      var d1 = this.mD;
      var e1 = this.mE;
      var f1 = this.mF;

      /* matrix order (canvas compatible):
       * ace
       * bdf
       * 001
       */
      this.mA = a1 * a2 + c1 * b2;
      this.mB = b1 * a2 + d1 * b2;
      this.mC = a1 * c2 + c1 * d2;
      this.mD = b1 * c2 + d1 * d2;
      this.mE = a1 * e2 + c1 * f2 + e1;
      this.mF = b1 * e2 + d1 * f2 + f1;

      return this;
    }

    /**
     * Multiplies the current matrix by the matrix provided.
     *
     * @method multiply
     * @param {Matrix} matrix - The matrix to multiply by.
     * @returns {Matrix}
     */

  }, {
    key: 'multiply',
    value: function multiply(matrix) {
      return this.transform(matrix.mA, matrix.mB, matrix.mC, matrix.mD, matrix.mE, matrix.mF);
    }

    /**
     * Interpolate this matrix with another and produce a new matrix.
     * t is a value in the range [0.0, 1.0] where 0 is this instance and
     * 1 is equal to the second matrix. The t value is not constrained.
     *
     * Context from parent matrix is not applied to the returned matrix.
     *
     * @method interpolate
     * @param {Matrix} matrix - the matrix to interpolate with.
     * @param {number} t - interpolation [0.0, 1.0]
     * @returns {Matrix} - new instance with the interpolated result
     */

  }, {
    key: 'interpolate',
    value: function interpolate(matrix, t) {
      var m = new Matrix().autorelease();

      m.mA = this.mA + (matrix.mA - this.mA) * t;
      m.mB = this.mB + (matrix.mB - this.mB) * t;
      m.mC = this.mC + (matrix.mC - this.mC) * t;
      m.mD = this.mD + (matrix.mD - this.mD) * t;
      m.mE = this.mE + (matrix.mE - this.mE) * t;
      m.mF = this.mF + (matrix.mF - this.mF) * t;

      return m;
    }

    /**
     * Apply current matrix to x and y point.
     * Returns the point object.
     *
     * @method applyToPoint
     * @param {Point} point - The point to which the transformation will be applied.
     * @returns {Point} The transformed point object.
     */

  }, {
    key: 'applyToPoint',
    value: function applyToPoint(point) {
      var x = point.x;
      var y = point.y;
      point.set(x * this.mA + y * this.mC + this.mE, x * this.mB + y * this.mD + this.mF);
      return point;
    }

    /**
     * Inversely applies the current matrix to the provided point. Useful to convert between coordinate systems.
     * Returns the point object.
     *
     * @method applyToPointInverse
     * @param {Point} point - The point to transform.
     * @returns {Point}
     */

  }, {
    key: 'applyToPointInverse',
    value: function applyToPointInverse(point) {
      var x = point.x;
      var y = point.y;
      var det = 1 / (this.mA * this.mD - this.mB * this.mC);

      point.set(this.mD * det * x + -this.mC * det * y + (this.mF * this.mC - this.mE * this.mD) * det, this.mA * det * y + -this.mB * det * x + (-this.mF * this.mA + this.mE * this.mB) * det);

      return point;
    }

    /**
     * Apply the current matrix to the specified boundingBox.
     * This applies the transformation to the bounding box's vertices and computes the axis aligned bounding box.
     * Returns the boundingBox object.
     *
     * @method applyToBoundingBox
     * @param {BoundingBox} boundingBox - The boundingBox to which the transformation will be applied.
     * @returns {BoundingBox} The transformed boundingBox.
     */

  }, {
    key: 'applyToBoundingBox',
    value: function applyToBoundingBox(boundingBox) {
      this.applyToPoint(boundingBox.v1);
      this.applyToPoint(boundingBox.v2);
      this.applyToPoint(boundingBox.v3);
      this.applyToPoint(boundingBox.v4);

      var xMin = Math.min(boundingBox.v1.x, boundingBox.v2.x, boundingBox.v3.x, boundingBox.v4.x);
      var xMax = Math.max(boundingBox.v1.x, boundingBox.v2.x, boundingBox.v3.x, boundingBox.v4.x);
      var yMin = Math.min(boundingBox.v1.y, boundingBox.v2.y, boundingBox.v3.y, boundingBox.v4.y);
      var yMax = Math.max(boundingBox.v1.y, boundingBox.v2.y, boundingBox.v3.y, boundingBox.v4.y);

      boundingBox.origin.set(xMin, yMin);
      boundingBox.size.set(xMax - xMin, yMax - yMin);

      return boundingBox;
    }

    /**
     * Apply to any canvas 2D context object. This does not affect the
     * context that optionally was referenced in constructor unless it is
     * the same context.
     *
     * @method applyToContext
     * @param {CanvasRenderingContext2D} context - The context the transformation is applied to.
     * @returns {Matrix}
     */

  }, {
    key: 'applyToContext',
    value: function applyToContext(context) {
      context.transform(this.mA, this.mB, this.mC, this.mD, this.mE, this.mF);
      return this;
    }

    /**
     * Returns true if matrix is an identity matrix (no transforms applied).
     *
     * @method isIdentity
     * @returns {boolean} True if identity (not transformed)
     */

  }, {
    key: 'isIdentity',
    value: function isIdentity() {
      return this._isEqual(this.mA, 1) && this._isEqual(this.mB, 0) && this._isEqual(this.mC, 0) && this._isEqual(this.mD, 1) && this._isEqual(this.mE, 0) && this._isEqual(this.mF, 0);
    }

    /**
     * Compares current matrix with another matrix. Returns true if equal
     * (within epsilon tolerance).
     *
     * @method isEqual
     * @param {Matrix} matrix - matrix to compare this matrix with
     * @returns {boolean}
     */

  }, {
    key: 'isEqual',
    value: function isEqual(matrix) {
      return this._isEqual(this.mA, matrix.mA) && this._isEqual(this.mB, matrix.mB) && this._isEqual(this.mC, matrix.mC) && this._isEqual(this.mD, matrix.mD) && this._isEqual(this.mE, matrix.mE) && this._isEqual(this.mF, matrix.mF);
    }

    /**
     * Compares floating point values with some tolerance (epsilon)
     *
     * @method _isEqual
     * @param {number} f1 - float 1
     * @param {number} f2 - float 2
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_isEqual',
    value: function _isEqual(f1, f2) {
      return Math.abs(f1 - f2) < 1e-14;
    }
  }, {
    key: 'inverse',
    get: function get() {
      var a = this.mA;
      var b = this.mB;
      var c = this.mC;
      var d = this.mD;
      var e = this.mE;
      var f = this.mF;
      var dt = a * d - b * c;
      var m = new Matrix().autorelease();

      m.mA = d / dt;
      m.mB = -b / dt;
      m.mC = -c / dt;
      m.mD = a / dt;
      m.mE = (c * f - d * e) / dt;
      m.mF = -(a * f - b * e) / dt;

      return m;
    }
  }]);

  return Matrix;
}(__WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Matrix;

/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Point_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Size_js__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Events_js__ = __webpack_require__(33);
/* unused harmony export Rect */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */






/**
 * Utility class that represents a bounding box in 2D space.
 *
 * @class BoundingBox
 */
var Rect = function (_IBindable) {
  _inherits(Rect, _IBindable);

  /**
   * @constructor
   * @param {Number=} x - X coordinate of the bounding box's origin.
   * @param {Number=} y - Y coordinate of the bounding box's origin.
   * @param {Number=} width - The bounding box's width.
   * @param {Number=} height - The bounding box's height.
   */
  function Rect(x, y, width, height) {
    _classCallCheck(this, Rect);

    var _this = _possibleConstructorReturn(this, (Rect.__proto__ || Object.getPrototypeOf(Rect)).call(this));

    _this.mOrigin = new __WEBPACK_IMPORTED_MODULE_1__Point_js__["a" /* default */](x, y);
    _this.mSize = new __WEBPACK_IMPORTED_MODULE_2__Size_js__["a" /* default */](width, height);

    _this.mForwardEvent = function () {
      return _this.emit(__WEBPACK_IMPORTED_MODULE_3__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this, _this.x, _this.y, _this.width, _this.height);
    };
    _this.mOrigin.on(__WEBPACK_IMPORTED_MODULE_3__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this.mForwardEvent);
    _this.mSize.on(__WEBPACK_IMPORTED_MODULE_3__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, _this.mForwardEvent);
    return _this;
  }

  /**
   * @method destroy
   */


  _createClass(Rect, [{
    key: 'destroy',
    value: function destroy() {
      this.mOrigin.off(__WEBPACK_IMPORTED_MODULE_3__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this.mForwardEvent);
      this.mSize.off(__WEBPACK_IMPORTED_MODULE_3__Events_js__["a" /* default */].GEOMETRY_VALUE_CHANGED, this.mForwardEvent);

      this.mOrigin.release();
      this.mSize.release();

      delete this.mOrigin;
      delete this.mSize;
      delete this.mForwardEvent;

      _get(Rect.prototype.__proto__ || Object.getPrototypeOf(Rect.prototype), 'destroy', this).call(this);
    }

    /**
     * The point at which the axis aligned bounding box's origin is at.
     *
     * @type {Point}
     * @readonly
     */

  }, {
    key: 'set',


    /**
     * Sets the x and y coordinates of this bounding box's origin as well as its width and height.
     *
     * @method set
     * @param {Number} x - X coordinate of the origin.
     * @param {Number} y - Y coordinate of the origin.
     * @param {Number} width - The new width.
     * @param {Number} height - The new height.
     */
    value: function set(x, y, width, height) {
      this.mOrigin.value1 = x;
      this.mOrigin.value2 = y;
      this.mSize.value1 = width;
      this.mSize.value2 = height;

      this.mForwardEvent();
    }

    /**
     * Sets the rects origin and size by copying the values of the supplied rect.
     *
     * @method setFromRect
     * @param {Rect} rect - the rect from which the new values will be copied from.
     */

  }, {
    key: 'setFromRect',
    value: function setFromRect(rect) {
      this.mOrigin.value1 = rect.x;
      this.mOrigin.value2 = rect.y;
      this.mSize.value1 = rect.width;
      this.mSize.value2 = rect.height;

      this.mForwardEvent();
    }
  }, {
    key: 'origin',
    get: function get() {
      return this.mOrigin;
    }

    /**
     * The size of this bounding box.
     * @type {Size}
     * @readonly
     */

  }, {
    key: 'size',
    get: function get() {
      return this.mSize;
    }

    /**
     * X coordinate of the axis aligned bounding box's origin.
     * @type {Number}
     */

  }, {
    key: 'x',
    get: function get() {
      return this.mOrigin.x;
    }

    /**
     * X coordinate of the axis aligned bounding box's origin.
     * @param {Number} value - The new value of the property.
     */
    ,
    set: function set(value) {
      this.mOrigin.x = value;
    }

    /**
     * Y coordinate of the axis aligned bounding box's origin.
     * @type {Number}
     */

  }, {
    key: 'y',
    get: function get() {
      return this.mOrigin.y;
    }

    /**
     * Y coordinate of the axis aligned bounding box's origin.
     * @param {Number} value - The new value of the property.
     */
    ,
    set: function set(value) {
      this.mOrigin.y = value;
    }

    /**
     * The bounding box's width.
     * @type {Number}
     */

  }, {
    key: 'width',
    get: function get() {
      return this.mSize.width;
    }

    /**
     * Sets the bounding box's width.
     * @param {Number} value - The new value of the property.
     */
    ,
    set: function set(value) {
      this.mSize.width = value;
    }

    /**
     * The bounding box's height.
     * @type {Number}
     */

  }, {
    key: 'height',
    get: function get() {
      return this.mSize.height;
    }

    /**
     * Sets the bounding box's height.
     * @param {Number} value - The new value of the property.
     */
    ,
    set: function set(value) {
      this.mSize.height = value;
    }
  }]);

  return Rect;
}(__WEBPACK_IMPORTED_MODULE_0__core_IBindable_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Rect;

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Primitive_js__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geometry_Point_js__ = __webpack_require__(27);
/* unused harmony export Polyline */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */




/**
 * Class to draw a line going through multiple vertices. This is the base class of all the other primitives that are
 * rendered based on vertices.
 *
 * @class Polyline
 */
var Polyline = function (_Primitive) {
    _inherits(Polyline, _Primitive);

    /**
     * @param {Object} options - The rendering options for this object.
     * @param {...Point} vertices - The vertices of this line.
     * @constructor
     */
    function Polyline(options) {
        _classCallCheck(this, Polyline);

        var _this = _possibleConstructorReturn(this, (Polyline.__proto__ || Object.getPrototypeOf(Polyline)).call(this, options));

        _this.mVertices = [];

        for (var _len = arguments.length, vertices = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            vertices[_key - 1] = arguments[_key];
        }

        var vertexArray = vertices[0] instanceof Array ? vertices[0] : vertices;
        vertexArray.forEach(function (point) {
            return _this.mVertices.push(__WEBPACK_IMPORTED_MODULE_1__geometry_Point_js__["a" /* default */].fromPoint(point));
        });
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Polyline, [{
        key: 'destroy',
        value: function destroy() {
            this.mVertices.forEach(function (point) {
                return point.release();
            });
            this.mVertices.length = 0;
            delete this.mVertices;
            _get(Polyline.prototype.__proto__ || Object.getPrototypeOf(Polyline.prototype), 'destroy', this).call(this);
        }

        /**
         * Renders the path of this shape to the context.
         *
         * @method _renderPath
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {Object} options - The rendering options for this shape.
         * @private
         */

    }, {
        key: '_renderPath',
        value: function _renderPath(context, options) {
            if (this.mVertices.length) {
                context.beginPath();
                var vertex = this._getVertexInPixels(this.mVertices[0]);
                context.moveTo(vertex.x, vertex.y);
                for (var i = 1, n = this.mVertices.length; i < n; ++i) {
                    vertex = this._getVertexInPixels(this.mVertices[i]);
                    context.lineTo(vertex.x, vertex.y);
                }
                if (options.closePath) {
                    context.closePath();
                }
            }
        }

        /**
         * Applies the fill, stroke, etc. as described in the provided `options` object.
         *
         * @method _applyRenderOptions
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {Object} options - The rendering options for this shape.
         * @private
         */

    }, {
        key: '_applyRenderOptions',
        value: function _applyRenderOptions(context, options) {
            if (options.strokeType && options.stroke > 0) {
                context.lineCap = options.lineCapType;
                context.strokeStyle = options.strokeColor;
                if (options.strokeType === Polyline.STROKE_INNER) {
                    if (options.fillEnabled) {
                        context.fillStyle = options.fillColor;
                        context.fill();
                    }
                    context.lineWidth = options.stroke * 2;
                    context.save();
                    context.clip();
                    context.stroke();
                    context.restore();
                } else if (options.strokeType === Polyline.STROKE_OUTER) {
                    context.lineWidth = options.stroke * 2;
                    context.stroke();
                    if (options.fillEnabled) {
                        context.fillStyle = options.fillColor;
                        context.fill();
                    }
                } else {
                    if (options.fillEnabled) {
                        context.fillStyle = options.fillColor;
                        context.fill();
                    }
                    context.lineWidth = options.stroke;
                    context.stroke();
                }
            } else if (options.fillEnabled) {
                context.fillStyle = options.fillColor;
                context.fill();
            }
        }
    }, {
        key: '_getVertexInPixels',
        value: function _getVertexInPixels(vertex) {
            var x = this.parent && vertex.xUnits === __WEBPACK_IMPORTED_MODULE_1__geometry_Point_js__["a" /* default */].UNIT_TYPE_PERCENTAGE ? this.parent.pixelSize.width * vertex.x : vertex.x;
            var y = this.parent && vertex.yUnits === __WEBPACK_IMPORTED_MODULE_1__geometry_Point_js__["a" /* default */].UNIT_TYPE_PERCENTAGE ? this.parent.pixelSize.height * vertex.y : vertex.y;
            return __WEBPACK_IMPORTED_MODULE_1__geometry_Point_js__["a" /* default */].instance(x, y);
        }
    }]);

    return Polyline;
}(__WEBPACK_IMPORTED_MODULE_0__Primitive_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Polyline;

/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Primitive_js__ = __webpack_require__(60);
/* unused harmony export SemiCircle */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



/**
 * Initial offset of the semi-circle so it starts drawing from the top of the circle.
 *
 * @type {Number}
 */
var INITIAL_OFFSET = Math.PI * -0.5;

/**
 * Class used to draw a section of a circle using the provided options.
 *
 * @class SemiCircle
 */
var SemiCircle = function (_Primitive) {
    _inherits(SemiCircle, _Primitive);

    /**
     * @param {Number} radius - The radius of the circle this class will be drawing a section of.
     * @param {Number} offset - The offset, in radians, from which the section should start drawing.
     * @param {Number} angle - The angle length, in radians, of the section to draw.
     * @param {Object} options - The rendering options for this object.
     * @constructor
     */
    function SemiCircle(radius, offset, angle, options) {
        _classCallCheck(this, SemiCircle);

        var _this = _possibleConstructorReturn(this, (SemiCircle.__proto__ || Object.getPrototypeOf(SemiCircle)).call(this, options));

        _this.mRadius = radius;
        _this.mOffset = offset;
        _this.mAngle = angle;
        _this.size.set(radius * 2, radius * 2);
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(SemiCircle, [{
        key: 'destroy',
        value: function destroy() {
            delete this.mRadius;
            delete this.mOffset;
            delete this.mAngle;

            _get(SemiCircle.prototype.__proto__ || Object.getPrototypeOf(SemiCircle.prototype), 'destroy', this).call(this);
        }

        /**
         * The radius of the circle this class will be drawing a section of.
         *
         * @type {Number}
         */

    }, {
        key: '_renderPath',


        /**
         * Renders the path of this shape to the context.
         *
         * @method _renderPath
         * @param {CanvasRenderingContext2D} context - The canvas context in which the drawing operations will be performed.
         * @param {Object} options - The rendering options for this shape.
         * @private
         */
        value: function _renderPath(context, options) {
            var radius = this.mRadius;
            if (options.strokeType) {
                if (options.strokeType === SemiCircle.STROKE_INNER) {
                    radius -= options.stroke * 0.5;
                } else if (options.strokeType === SemiCircle.STROKE_OUTER) {
                    radius += options.stroke * 0.5;
                }
            }

            radius = Math.max(radius, 0);

            context.beginPath();
            context.arc(this.mRadius, this.mRadius, radius, INITIAL_OFFSET + this.mOffset, INITIAL_OFFSET + this.mOffset + this.mAngle, false);
            if (options.closePath) {
                context.closePath();
            }
        }
    }, {
        key: 'radius',
        get: function get() {
            return this.mRadius;
        }

        /**
         * @param {Number} value - The new radius of the circle this class will be drawing a section of.
         */
        ,
        set: function set(value) {
            if (value !== this.mRadius) {
                this.mRadius = value;
                this.size.set(this.mRadius * 2, this.mRadius * 2);
                this.needsRedraw();
            }
        }

        /**
         * The offset, in radians, from which the section should start drawing.
         *
         * @type {Number}
         */

    }, {
        key: 'offset',
        get: function get() {
            return this.mOffset;
        }

        /**
         * @param {Number} value - The new offset, in radians, from which the section should start drawing.
         */
        ,
        set: function set(value) {
            if (value !== this.mOffset) {
                this.mOffset = value;
                this.needsRedraw();
            }
        }

        /**
         * The angle length, in radians, of the section to draw.
         *
         * @type {Number}
         */

    }, {
        key: 'angle',
        get: function get() {
            return this.mAngle;
        }

        /**
         * @param {Number} value - The new angle length, in radians, of the section to draw.
         */
        ,
        set: function set(value) {
            if (value !== this.mAngle) {
                this.mAngle = value;
                this.needsRedraw();
            }
        }
    }]);

    return SemiCircle;
}(__WEBPACK_IMPORTED_MODULE_0__Primitive_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = SemiCircle;

/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IObject_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geometry_Point_js__ = __webpack_require__(27);
/* unused harmony export PointerEvent */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */




/**
 * Utility class used to describe a mouse or touch event.
 */
var PointerEvent = function (_IObject) {
  _inherits(PointerEvent, _IObject);

  /**
   * @param {String} type - The event type this pointer represents.
   * @param {Number} x - The X coordinate of the event.
   * @param {Number} y - The Y coordinate of the event.
   * @param {Number} identifier - A number identifying the mouse or touch which triggered this event.
   * @param {Number} timestamp - the timestamp of this event.
   */
  function PointerEvent(type, x, y, identifier, timestamp) {
    _classCallCheck(this, PointerEvent);

    var _this = _possibleConstructorReturn(this, (PointerEvent.__proto__ || Object.getPrototypeOf(PointerEvent)).call(this));

    _this.mType = type;
    _this.mPoint = new __WEBPACK_IMPORTED_MODULE_1__geometry_Point_js__["a" /* default */](x, y);
    _this.mIdentifier = identifier;
    _this.mTimestamp = timestamp;

    _this.mPoint.freezeValues();
    return _this;
  }

  /**
   * Destroys this object. Called automatically when the reference count of this object reaches zero.
   *
   * @method destroy
   */


  _createClass(PointerEvent, [{
    key: 'destroy',
    value: function destroy() {
      this.mPoint.unfreezeValues();
      this.mPoint.release();

      delete this.mType;
      delete this.mPoint;
      delete this.mIdentifier;
      delete this.mTimestamp;

      _get(PointerEvent.prototype.__proto__ || Object.getPrototypeOf(PointerEvent.prototype), 'destroy', this).call(this);
    }

    /**
     * The event type this pointer event represents.
     *
     * @type {String}
     */

  }, {
    key: 'type',
    get: function get() {
      return this.mType;
    }

    /**
     * The point where this event originated.
     *
     * @type {Point}
     */

  }, {
    key: 'point',
    get: function get() {
      return this.mPoint;
    }

    /**
     * The X coordinate of this event.
     *
     * @type {Number}
     */

  }, {
    key: 'x',
    get: function get() {
      return this.mPoint.x;
    }

    /**
     * The Y coordinate of this event.
     *
     * @type {Number}
     */

  }, {
    key: 'y',
    get: function get() {
      return this.mPoint.y;
    }

    /**
     * A number taht identifies the mouse or touch that triggered this event.
     *
     * @type {Number}
     */

  }, {
    key: 'identifier',
    get: function get() {
      return this.mIdentifier;
    }

    /**
     * The timestamp of this event.
     *
     * @type {Number}
     */

  }, {
    key: 'timestamp',
    get: function get() {
      return this.mTimestamp;
    }
  }]);

  return PointerEvent;
}(__WEBPACK_IMPORTED_MODULE_0__core_IObject_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = PointerEvent;

/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export FONT_AWESOME */

var FONT_AWESOME = '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';

/* harmony default export */ __webpack_exports__["a"] = FONT_AWESOME;

/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_IObject_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Word_js__ = __webpack_require__(121);
/* unused harmony export Line */
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 Uncharted Software Inc.
 * http://www.uncharted.software/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */




/**
 * Class that represents a line of text.
 *
 * @class Line
 */
var Line = function (_IObject) {
    _inherits(Line, _IObject);

    /**
     * @param {Number} spaceWidth - The width of a space in ems.
     * @constructor
     */
    function Line() {
        var spaceWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        _classCallCheck(this, Line);

        var _this = _possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this));

        _this.mWords = [];
        _this.mEmWidth = 0;
        _this.mEmHeight = 0;
        _this.mMinBaseline = 0;
        _this.mSpaceWidth = spaceWidth;
        return _this;
    }

    /**
     * Destroys this object. Called automatically when the reference count of this object reaches zero.
     *
     * @method destroy
     */


    _createClass(Line, [{
        key: 'destroy',
        value: function destroy() {
            this.mWords.length = 0;

            delete this.mWords;
            delete this.mEmWidth;
            delete this.mEmHeight;
            delete this.mMinBaseline;
            delete this.mSpaceWidth;

            _get(Line.prototype.__proto__ || Object.getPrototypeOf(Line.prototype), 'destroy', this).call(this);
        }

        /**
         * An array containing the words in this line.
         *
         * @type {Array}
         * @readonly
         */

    }, {
        key: 'addWord',


        /**
         * Adds the specified word to this line.
         *
         * @param {Word} word - The word to add.
         */
        value: function addWord(word) {
            this.mWords.push(word);

            if (word === __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].SPACE_WORD) {
                this.mEmWidth += this.mSpaceWidth;
            } else if (word !== __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].LINE_BREAK_WORD) {
                this.mEmWidth += word.emWidth;
                this.mEmHeight = Math.max(word.emHeight, this.mEmHeight);
                this.mMinBaseline = Math.max(word.ascending, this.mMinBaseline);
            }
        }

        /**
         * Adds ellipses to this line and makes sure it fits within the specified.
         *
         * @method addEllipses
         * @param {Number} targetEmWidth - The maximum width, in ems, this line should occupy.
         * @param {Font} font - The font to use to render this word.
         * @param {Number} tracking - The tracking for the characters in this word.
         */

    }, {
        key: 'addEllipses',
        value: function addEllipses(targetEmWidth, font, tracking) {
            var _this2 = this;

            var offset = 0;
            var word = null;

            for (var i = 0, n = this.mWords.length; i < n; ++i) {
                if (this.mWords[i] === __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].SPACE_WORD) {
                    offset += this.mSpaceWidth;
                } else if (this.mWords[i] !== __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].LINE_BREAK_WORD) {
                    word = this.mWords[i];
                    offset += word.emWidth;
                    if (offset > targetEmWidth) {
                        break;
                    }
                }
            }

            word = word || __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].instance('', font, tracking);

            var ellipsesWord = __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].wordWithEllipses(word, targetEmWidth - offset + word.emWidth);
            var oldWords = this.mWords.slice(0, this.mWords.indexOf(word));
            this._reset();
            oldWords.forEach(function (oldWord) {
                return _this2.addWord(oldWord);
            });
            this.addWord(ellipsesWord);
        }

        /**
         * Trims the blank space off this line.
         *
         * @method trimBlankSpace
         */

    }, {
        key: 'trimBlankSpace',
        value: function trimBlankSpace() {
            while (this.mWords.length && this.mWords[0] === __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].SPACE_WORD) {
                this.mWords.shift();
                this.mEmWidth -= this.mSpaceWidth;
            }

            while (this.mWords.length && this.mWords[this.mWords.length - 1] === __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].SPACE_WORD) {
                this.mWords.pop();
                this.mEmWidth -= this.mSpaceWidth;
            }
        }

        /**
         * Adds this line to the given path for rendering.
         *
         * @method addToPath
         * @param {Path} path - The OpenType path to which this word will be added.
         * @param {Number} fontSize - The desired font size for this line.
         * @param {Number} scale - The scale of this font size.
         * @param {Number} x - The x coordinate for this line.
         * @param {Number} y - The y coordinate for this line.
         */

    }, {
        key: 'addToPath',
        value: function addToPath(path, fontSize, scale) {
            var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

            var spaceWidth = this.mSpaceWidth * scale;
            var spaceWord = __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].SPACE_WORD;
            var lineBreakWord = __WEBPACK_IMPORTED_MODULE_1__Word_js__["a" /* default */].LINE_BREAK_WORD;
            var offsetX = x;
            var offsetY = y;
            this.mWords.forEach(function (word) {
                if (word === spaceWord) {
                    offsetX += spaceWidth;
                } else if (word !== lineBreakWord) {
                    offsetX += word.addToPath(path, fontSize, scale, offsetX, offsetY);
                }
            });
        }

        /**
         * Removes all the words in this line and resets its size.
         *
         * @method _reset
         * @private
         */

    }, {
        key: '_reset',
        value: function _reset() {
            this.mWords.length = 0;
            this.mEmWidth = 0;
            this.mEmHeight = 0;
            this.mMinBaseline = 0;
        }
    }, {
        key: 'words',
        get: function get() {
            return this.mWords;
        }

        /**
         * The total width of this line in ems.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'emWidth',
        get: function get() {
            return this.mEmWidth;
        }

        /**
         * The total height of this line in ems.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'emHeight',
        get: function get() {
            return this.mEmHeight;
        }

        /**
         * The minimum baseline of this line.
         *
         * @type {Number}
         * @readonly
         */

    }, {
        key: 'minBaseline',
        get: function get() {
            return this.mMinBaseline;
        }

        /**
         * The left offset of this line.
         *
         * @returns {Number}
         * @readonly
         */

    }, {
        key: 'offsetLeft',
        get: function get() {
            if (this.mWords.length) {
                return this.mWords[0].offsetLeft;
            }
            return 0;
        }

        /**
         * The width of a space, in ems, within this line.
         *
         * @returns {Number}
         * @readonly
         */

    }, {
        key: 'spaceWidth',
        get: function get() {
            return this.mSpaceWidth;
        }
    }]);

    return Line;
}(__WEBPACK_IMPORTED_MODULE_0__core_IObject_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = Line;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(190)
var ieee754 = __webpack_require__(373)
var isArray = __webpack_require__(374)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(76)))

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(201);
module.exports = __webpack_require__(28).RegExp.escape;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4)
  , isArray  = __webpack_require__(87)
  , SPECIES  = __webpack_require__(5)('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(193);

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject    = __webpack_require__(1)
  , toPrimitive = __webpack_require__(26)
  , NUMBER      = 'number';

module.exports = function(hint){
  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(42)
  , gOPS    = __webpack_require__(71)
  , pIE     = __webpack_require__(57);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(42)
  , toIObject = __webpack_require__(18);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var path      = __webpack_require__(199)
  , invoke    = __webpack_require__(67)
  , aFunction = __webpack_require__(14);
module.exports = function(/* ...pargs */){
  var fn     = aFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that = this
      , aLen = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !aLen)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(aLen > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);

/***/ }),
/* 200 */
/***/ (function(module, exports) {

module.exports = function(regExp, replace){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(it).replace(regExp, replacer);
  };
};

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(0)
  , $re     = __webpack_require__(200)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', {copyWithin: __webpack_require__(123)});

__webpack_require__(48)('copyWithin');

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $every  = __webpack_require__(24)(4);

$export($export.P + $export.F * !__webpack_require__(23)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */){
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', {fill: __webpack_require__(79)});

__webpack_require__(48)('fill');

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $filter = __webpack_require__(24)(2);

$export($export.P + $export.F * !__webpack_require__(23)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */){
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0)
  , $find   = __webpack_require__(24)(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(48)(KEY);

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0)
  , $find   = __webpack_require__(24)(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(48)(KEY);

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export  = __webpack_require__(0)
  , $forEach = __webpack_require__(24)(0)
  , STRICT   = __webpack_require__(23)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx            = __webpack_require__(29)
  , $export        = __webpack_require__(0)
  , toObject       = __webpack_require__(10)
  , call           = __webpack_require__(132)
  , isArrayIter    = __webpack_require__(86)
  , toLength       = __webpack_require__(9)
  , createProperty = __webpack_require__(80)
  , getIterFn      = __webpack_require__(103);

$export($export.S + $export.F * !__webpack_require__(69)(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export       = __webpack_require__(0)
  , $indexOf      = __webpack_require__(63)(false)
  , $native       = [].indexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(23)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', {isArray: __webpack_require__(87)});

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export   = __webpack_require__(0)
  , toIObject = __webpack_require__(18)
  , arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(56) != Object || !__webpack_require__(23)(arrayJoin)), 'Array', {
  join: function join(separator){
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export       = __webpack_require__(0)
  , toIObject     = __webpack_require__(18)
  , toInteger     = __webpack_require__(37)
  , toLength      = __webpack_require__(9)
  , $native       = [].lastIndexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(23)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
    // convert -0 to +0
    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
    var O      = toIObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
    if(index < 0)index = length + index;
    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
    return -1;
  }
});

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $map    = __webpack_require__(24)(1);

$export($export.P + $export.F * !__webpack_require__(23)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */){
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export        = __webpack_require__(0)
  , createProperty = __webpack_require__(80);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(3)(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , aLen   = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(aLen);
    while(aLen > index)createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $reduce = __webpack_require__(125);

$export($export.P + $export.F * !__webpack_require__(23)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $reduce = __webpack_require__(125);

$export($export.P + $export.F * !__webpack_require__(23)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export    = __webpack_require__(0)
  , html       = __webpack_require__(84)
  , cof        = __webpack_require__(21)
  , toIndex    = __webpack_require__(45)
  , toLength   = __webpack_require__(9)
  , arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(3)(function(){
  if(html)arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return arraySlice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $some   = __webpack_require__(24)(3);

$export($export.P + $export.F * !__webpack_require__(23)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */){
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export   = __webpack_require__(0)
  , aFunction = __webpack_require__(14)
  , toObject  = __webpack_require__(10)
  , fails     = __webpack_require__(3)
  , $sort     = [].sort
  , test      = [1, 2, 3];

$export($export.P + $export.F * (fails(function(){
  // IE8-
  test.sort(undefined);
}) || !fails(function(){
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(23)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn){
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(44)('Array');

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0)
  , fails   = __webpack_require__(3)
  , getTime = Date.prototype.getTime;

var lz = function(num){
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (fails(function(){
  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
}) || !fails(function(){
  new Date(NaN).toISOString();
})), 'Date', {
  toISOString: function toISOString(){
    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
    var d = this
      , y = d.getUTCFullYear()
      , m = d.getUTCMilliseconds()
      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  }
});

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export     = __webpack_require__(0)
  , toObject    = __webpack_require__(10)
  , toPrimitive = __webpack_require__(26);

$export($export.P + $export.F * __webpack_require__(3)(function(){
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
}), 'Date', {
  toJSON: function toJSON(key){
    var O  = toObject(this)
      , pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(5)('toPrimitive')
  , proto        = Date.prototype;

if(!(TO_PRIMITIVE in proto))__webpack_require__(15)(proto, TO_PRIMITIVE, __webpack_require__(195));

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto    = Date.prototype
  , INVALID_DATE = 'Invalid Date'
  , TO_STRING    = 'toString'
  , $toString    = DateProto[TO_STRING]
  , getTime      = DateProto.getTime;
if(new Date(NaN) + '' != INVALID_DATE){
  __webpack_require__(16)(DateProto, TO_STRING, function toString(){
    var value = getTime.call(this);
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', {bind: __webpack_require__(126)});

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject       = __webpack_require__(4)
  , getPrototypeOf = __webpack_require__(20)
  , HAS_INSTANCE   = __webpack_require__(5)('hasInstance')
  , FunctionProto  = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(7).f(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(typeof this != 'function' || !isObject(O))return false;
  if(!isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
  return false;
}});

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(7).f
  , createDesc = __webpack_require__(36)
  , has        = __webpack_require__(12)
  , FProto     = Function.prototype
  , nameRE     = /^\s*function ([^ (]*)/
  , NAME       = 'name';

var isExtensible = Object.isExtensible || function(){
  return true;
};

// 19.2.4.2 name
NAME in FProto || __webpack_require__(6) && dP(FProto, NAME, {
  configurable: true,
  get: function(){
    try {
      var that = this
        , name = ('' + that).match(nameRE)[1];
      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
      return name;
    } catch(e){
      return '';
    }
  }
});

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0)
  , log1p   = __webpack_require__(134)
  , sqrt    = Math.sqrt
  , $acosh  = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0)
  , $asinh  = Math.asinh;

function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0 
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0)
  , $atanh  = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0 
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0)
  , sign    = __webpack_require__(91);

$export($export.S, 'Math', {
  cbrt: function cbrt(x){
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0)
  , exp     = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0)
  , $expm1  = __webpack_require__(90);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export   = __webpack_require__(0)
  , sign      = __webpack_require__(91)
  , pow       = Math.pow
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);

var roundTiesToEven = function(n){
  return n + 1 / EPSILON - 1 / EPSILON;
};


$export($export.S, 'Math', {
  fround: function fround(x){
    var $abs  = Math.abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  }
});

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(0)
  , abs     = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , aLen = arguments.length
      , larg = 0
      , arg, div;
    while(i < aLen){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0)
  , $imul   = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(3)(function(){
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y){
    var UINT16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UINT16 & xn
      , yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {log1p: __webpack_require__(134)});

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {sign: __webpack_require__(91)});

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0)
  , expm1   = __webpack_require__(90)
  , exp     = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(3)(function(){
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x){
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0)
  , expm1   = __webpack_require__(90)
  , exp     = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global            = __webpack_require__(2)
  , has               = __webpack_require__(12)
  , cof               = __webpack_require__(21)
  , inheritIfRequired = __webpack_require__(85)
  , toPrimitive       = __webpack_require__(26)
  , fails             = __webpack_require__(3)
  , gOPN              = __webpack_require__(41).f
  , gOPD              = __webpack_require__(19).f
  , dP                = __webpack_require__(7).f
  , $trim             = __webpack_require__(52).trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(__webpack_require__(40)(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = __webpack_require__(6) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(16)(global, NUMBER, $Number);
}

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export   = __webpack_require__(0)
  , _isFinite = __webpack_require__(2).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {isInteger: __webpack_require__(131)});

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export   = __webpack_require__(0)
  , isInteger = __webpack_require__(131)
  , abs       = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var $export     = __webpack_require__(0)
  , $parseFloat = __webpack_require__(141);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

var $export   = __webpack_require__(0)
  , $parseInt = __webpack_require__(142);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export      = __webpack_require__(0)
  , toInteger    = __webpack_require__(37)
  , aNumberValue = __webpack_require__(122)
  , repeat       = __webpack_require__(98)
  , $toFixed     = 1..toFixed
  , floor        = Math.floor
  , data         = [0, 0, 0, 0, 0, 0]
  , ERROR        = 'Number.toFixed: incorrect invocation!'
  , ZERO         = '0';

var multiply = function(n, c){
  var i  = -1
    , c2 = c;
  while(++i < 6){
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function(n){
  var i = 6
    , c = 0;
  while(--i >= 0){
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function(){
  var i = 6
    , s = '';
  while(--i >= 0){
    if(s !== '' || i === 0 || data[i] !== 0){
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function(x, n, acc){
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x){
  var n  = 0
    , x2 = x;
  while(x2 >= 4096){
    n += 12;
    x2 /= 4096;
  }
  while(x2 >= 2){
    n  += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128..toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(3)(function(){
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits){
    var x = aNumberValue(this, ERROR)
      , f = toInteger(fractionDigits)
      , s = ''
      , m = ZERO
      , e, z, j, k;
    if(f < 0 || f > 20)throw RangeError(ERROR);
    if(x != x)return 'NaN';
    if(x <= -1e21 || x >= 1e21)return String(x);
    if(x < 0){
      s = '-';
      x = -x;
    }
    if(x > 1e-21){
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if(e > 0){
        multiply(0, z);
        j = f;
        while(j >= 7){
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while(j >= 23){
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if(f > 0){
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export      = __webpack_require__(0)
  , $fails       = __webpack_require__(3)
  , aNumberValue = __webpack_require__(122)
  , $toPrecision = 1..toPrecision;

$export($export.P + $export.F * ($fails(function(){
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function(){
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision){
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
  }
});

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', {assign: __webpack_require__(135)});

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(40)});

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperties: __webpack_require__(136)});

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperty: __webpack_require__(7).f});

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(4)
  , meta     = __webpack_require__(35).onFreeze;

__webpack_require__(25)('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = __webpack_require__(18)
  , $getOwnPropertyDescriptor = __webpack_require__(19).f;

__webpack_require__(25)('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(25)('getOwnPropertyNames', function(){
  return __webpack_require__(137).f;
});

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = __webpack_require__(10)
  , $getPrototypeOf = __webpack_require__(20);

__webpack_require__(25)('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(4);

__webpack_require__(25)('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(4);

__webpack_require__(25)('isFrozen', function($isFrozen){
  return function isFrozen(it){
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(4);

__webpack_require__(25)('isSealed', function($isSealed){
  return function isSealed(it){
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', {is: __webpack_require__(143)});

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(10)
  , $keys    = __webpack_require__(42);

__webpack_require__(25)('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(4)
  , meta     = __webpack_require__(35).onFreeze;

__webpack_require__(25)('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(4)
  , meta     = __webpack_require__(35).onFreeze;

__webpack_require__(25)('seal', function($seal){
  return function seal(it){
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(93).set});

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(55)
  , test    = {};
test[__webpack_require__(5)('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  __webpack_require__(16)(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var $export     = __webpack_require__(0)
  , $parseFloat = __webpack_require__(141);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

var $export   = __webpack_require__(0)
  , $parseInt = __webpack_require__(142);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY            = __webpack_require__(39)
  , global             = __webpack_require__(2)
  , ctx                = __webpack_require__(29)
  , classof            = __webpack_require__(55)
  , $export            = __webpack_require__(0)
  , isObject           = __webpack_require__(4)
  , aFunction          = __webpack_require__(14)
  , anInstance         = __webpack_require__(38)
  , forOf              = __webpack_require__(49)
  , speciesConstructor = __webpack_require__(95)
  , task               = __webpack_require__(100).set
  , microtask          = __webpack_require__(92)()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[__webpack_require__(5)('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(43)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
__webpack_require__(51)($Promise, PROMISE);
__webpack_require__(44)(PROMISE);
Wrapper = __webpack_require__(28)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(69)(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export   = __webpack_require__(0)
  , aFunction = __webpack_require__(14)
  , anObject  = __webpack_require__(1)
  , rApply    = (__webpack_require__(2).Reflect || {}).apply
  , fApply    = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(3)(function(){
  rApply(function(){});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList){
    var T = aFunction(target)
      , L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export    = __webpack_require__(0)
  , create     = __webpack_require__(40)
  , aFunction  = __webpack_require__(14)
  , anObject   = __webpack_require__(1)
  , isObject   = __webpack_require__(4)
  , fails      = __webpack_require__(3)
  , bind       = __webpack_require__(126)
  , rConstruct = (__webpack_require__(2).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function(){
  function F(){}
  return !(rConstruct(function(){}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function(){
  rConstruct(function(){});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /*, newTarget*/){
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
    if(Target == newTarget){
      // w/o altered newTarget, optimization for 0-4 arguments
      switch(args.length){
        case 0: return new Target;
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args));
    }
    // with altered newTarget, not support built-in constructors
    var proto    = newTarget.prototype
      , instance = create(isObject(proto) ? proto : Object.prototype)
      , result   = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP          = __webpack_require__(7)
  , $export     = __webpack_require__(0)
  , anObject    = __webpack_require__(1)
  , toPrimitive = __webpack_require__(26);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(3)(function(){
  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes){
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  }
});

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export  = __webpack_require__(0)
  , gOPD     = __webpack_require__(19).f
  , anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export  = __webpack_require__(0)
  , anObject = __webpack_require__(1);
var Enumerate = function(iterated){
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = []       // keys
    , key;
  for(key in iterated)keys.push(key);
};
__webpack_require__(88)(Enumerate, 'Object', function(){
  var that = this
    , keys = that._k
    , key;
  do {
    if(that._i >= keys.length)return {value: undefined, done: true};
  } while(!((key = keys[that._i++]) in that._t));
  return {value: key, done: false};
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target){
    return new Enumerate(target);
  }
});

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD     = __webpack_require__(19)
  , $export  = __webpack_require__(0)
  , anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export  = __webpack_require__(0)
  , getProto = __webpack_require__(20)
  , anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(anObject(target));
  }
});

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD           = __webpack_require__(19)
  , getPrototypeOf = __webpack_require__(20)
  , has            = __webpack_require__(12)
  , $export        = __webpack_require__(0)
  , isObject       = __webpack_require__(4)
  , anObject       = __webpack_require__(1);

function get(target, propertyKey/*, receiver*/){
  var receiver = arguments.length < 3 ? target : arguments[2]
    , desc, proto;
  if(anObject(target) === receiver)return target[propertyKey];
  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {get: get});

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey){
    return propertyKey in target;
  }
});

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export       = __webpack_require__(0)
  , anObject      = __webpack_require__(1)
  , $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target){
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {ownKeys: __webpack_require__(140)});

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export            = __webpack_require__(0)
  , anObject           = __webpack_require__(1)
  , $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target){
    anObject(target);
    try {
      if($preventExtensions)$preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  }
});

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export  = __webpack_require__(0)
  , setProto = __webpack_require__(93);

if(setProto)$export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto){
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch(e){
      return false;
    }
  }
});

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP             = __webpack_require__(7)
  , gOPD           = __webpack_require__(19)
  , getPrototypeOf = __webpack_require__(20)
  , has            = __webpack_require__(12)
  , $export        = __webpack_require__(0)
  , createDesc     = __webpack_require__(36)
  , anObject       = __webpack_require__(1)
  , isObject       = __webpack_require__(4);

function set(target, propertyKey, V/*, receiver*/){
  var receiver = arguments.length < 4 ? target : arguments[3]
    , ownDesc  = gOPD.f(anObject(target), propertyKey)
    , existingDescriptor, proto;
  if(!ownDesc){
    if(isObject(proto = getPrototypeOf(target))){
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if(has(ownDesc, 'value')){
    if(ownDesc.writable === false || !isObject(receiver))return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {set: set});

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

var global            = __webpack_require__(2)
  , inheritIfRequired = __webpack_require__(85)
  , dP                = __webpack_require__(7).f
  , gOPN              = __webpack_require__(41).f
  , isRegExp          = __webpack_require__(68)
  , $flags            = __webpack_require__(66)
  , $RegExp           = global.RegExp
  , Base              = $RegExp
  , proto             = $RegExp.prototype
  , re1               = /a/g
  , re2               = /a/g
  // "new" creates a new object, old webkit buggy here
  , CORRECT_NEW       = new $RegExp(re1) !== re1;

if(__webpack_require__(6) && (!CORRECT_NEW || __webpack_require__(3)(function(){
  re2[__webpack_require__(5)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))){
  $RegExp = function RegExp(p, f){
    var tiRE = this instanceof $RegExp
      , piRE = isRegExp(p)
      , fiU  = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function(key){
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function(){ return Base[key]; },
      set: function(it){ Base[key] = it; }
    });
  };
  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(16)(global, 'RegExp', $RegExp);
}

__webpack_require__(44)('RegExp');

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(65)('match', 1, function(defined, MATCH, $match){
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(65)('replace', 2, function(defined, REPLACE, $replace){
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue){
    'use strict';
    var O  = defined(this)
      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(65)('search', 1, function(defined, SEARCH, $search){
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(65)('split', 2, function(defined, SPLIT, $split){
  'use strict';
  var isRegExp   = __webpack_require__(68)
    , _split     = $split
    , $push      = [].push
    , $SPLIT     = 'split'
    , LENGTH     = 'length'
    , LAST_INDEX = 'lastIndex';
  if(
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ){
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function(separator, limit){
      var string = String(this);
      if(separator === undefined && limit === 0)return [];
      // If `separator` is not a regex, use native split
      if(!isRegExp(separator))return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while(match = separatorCopy.exec(string)){
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if(lastIndex > lastLastIndex){
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
          });
          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if(output[LENGTH] >= splitLimit)break;
        }
        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if(lastLastIndex === string[LENGTH]){
        if(lastLength || !separatorCopy.test(''))output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
    $split = function(separator, limit){
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit){
    var O  = defined(this)
      , fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(147);
var anObject    = __webpack_require__(1)
  , $flags      = __webpack_require__(66)
  , DESCRIPTORS = __webpack_require__(6)
  , TO_STRING   = 'toString'
  , $toString   = /./[TO_STRING];

var define = function(fn){
  __webpack_require__(16)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if(__webpack_require__(3)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
  define(function toString(){
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if($toString.name != TO_STRING){
  define(function toString(){
    return $toString.call(this);
  });
}

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(17)('anchor', function(createHTML){
  return function anchor(name){
    return createHTML(this, 'a', 'name', name);
  }
});

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(17)('big', function(createHTML){
  return function big(){
    return createHTML(this, 'big', '', '');
  }
});

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(17)('blink', function(createHTML){
  return function blink(){
    return createHTML(this, 'blink', '', '');
  }
});

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(17)('bold', function(createHTML){
  return function bold(){
    return createHTML(this, 'b', '', '');
  }
});

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $at     = __webpack_require__(96)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export   = __webpack_require__(0)
  , toLength  = __webpack_require__(9)
  , context   = __webpack_require__(97)
  , ENDS_WITH = 'endsWith'
  , $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(83)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    var that = context(this, searchString, ENDS_WITH)
      , endPosition = arguments.length > 1 ? arguments[1] : undefined
      , len    = toLength(that.length)
      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
      , search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(17)('fixed', function(createHTML){
  return function fixed(){
    return createHTML(this, 'tt', '', '');
  }
});

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(17)('fontcolor', function(createHTML){
  return function fontcolor(color){
    return createHTML(this, 'font', 'color', color);
  }
});

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(17)('fontsize', function(createHTML){
  return function fontsize(size){
    return createHTML(this, 'font', 'size', size);
  }
});

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

var $export        = __webpack_require__(0)
  , toIndex        = __webpack_require__(45)
  , fromCharCode   = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res  = []
      , aLen = arguments.length
      , i    = 0
      , code;
    while(aLen > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export  = __webpack_require__(0)
  , context  = __webpack_require__(97)
  , INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(83)(INCLUDES), 'String', {
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(17)('italics', function(createHTML){
  return function italics(){
    return createHTML(this, 'i', '', '');
  }
});

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at  = __webpack_require__(96)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(89)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(17)('link', function(createHTML){
  return function link(url){
    return createHTML(this, 'a', 'href', url);
  }
});

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var $export   = __webpack_require__(0)
  , toIObject = __webpack_require__(18)
  , toLength  = __webpack_require__(9);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl  = toIObject(callSite.raw)
      , len  = toLength(tpl.length)
      , aLen = arguments.length
      , res  = []
      , i    = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < aLen)res.push(String(arguments[i]));
    } return res.join('');
  }
});

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(98)
});

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(17)('small', function(createHTML){
  return function small(){
    return createHTML(this, 'small', '', '');
  }
});

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export     = __webpack_require__(0)
  , toLength    = __webpack_require__(9)
  , context     = __webpack_require__(97)
  , STARTS_WITH = 'startsWith'
  , $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(83)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /*, position = 0 */){
    var that   = context(this, searchString, STARTS_WITH)
      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
      , search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(17)('strike', function(createHTML){
  return function strike(){
    return createHTML(this, 'strike', '', '');
  }
});

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(17)('sub', function(createHTML){
  return function sub(){
    return createHTML(this, 'sub', '', '');
  }
});

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(17)('sup', function(createHTML){
  return function sup(){
    return createHTML(this, 'sup', '', '');
  }
});

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(52)('trim', function($trim){
  return function trim(){
    return $trim(this, 3);
  };
});

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(2)
  , has            = __webpack_require__(12)
  , DESCRIPTORS    = __webpack_require__(6)
  , $export        = __webpack_require__(0)
  , redefine       = __webpack_require__(16)
  , META           = __webpack_require__(35).KEY
  , $fails         = __webpack_require__(3)
  , shared         = __webpack_require__(72)
  , setToStringTag = __webpack_require__(51)
  , uid            = __webpack_require__(46)
  , wks            = __webpack_require__(5)
  , wksExt         = __webpack_require__(145)
  , wksDefine      = __webpack_require__(102)
  , keyOf          = __webpack_require__(197)
  , enumKeys       = __webpack_require__(196)
  , isArray        = __webpack_require__(87)
  , anObject       = __webpack_require__(1)
  , toIObject      = __webpack_require__(18)
  , toPrimitive    = __webpack_require__(26)
  , createDesc     = __webpack_require__(36)
  , _create        = __webpack_require__(40)
  , gOPNExt        = __webpack_require__(137)
  , $GOPD          = __webpack_require__(19)
  , $DP            = __webpack_require__(7)
  , $keys          = __webpack_require__(42)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(41).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(57).f  = $propertyIsEnumerable;
  __webpack_require__(71).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(39)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(15)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export      = __webpack_require__(0)
  , $typed       = __webpack_require__(73)
  , buffer       = __webpack_require__(101)
  , anObject     = __webpack_require__(1)
  , toIndex      = __webpack_require__(45)
  , toLength     = __webpack_require__(9)
  , isObject     = __webpack_require__(4)
  , ArrayBuffer  = __webpack_require__(2).ArrayBuffer
  , speciesConstructor = __webpack_require__(95)
  , $ArrayBuffer = buffer.ArrayBuffer
  , $DataView    = buffer.DataView
  , $isView      = $typed.ABV && ArrayBuffer.isView
  , $slice       = $ArrayBuffer.prototype.slice
  , VIEW         = $typed.VIEW
  , ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it){
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(3)(function(){
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end){
    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
    var len    = anObject(this).byteLength
      , first  = toIndex(start, len)
      , final  = toIndex(end === undefined ? len : end, len)
      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
      , viewS  = new $DataView(this)
      , viewT  = new $DataView(result)
      , index  = 0;
    while(first < final){
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(44)(ARRAY_BUFFER);

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(73).ABV, {
  DataView: __webpack_require__(101).DataView
});

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31)('Float32', 4, function(init){
  return function Float32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31)('Float64', 8, function(init){
  return function Float64Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31)('Int16', 2, function(init){
  return function Int16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31)('Int32', 4, function(init){
  return function Int32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31)('Int8', 1, function(init){
  return function Int8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31)('Uint16', 2, function(init){
  return function Uint16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31)('Uint32', 4, function(init){
  return function Uint32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31)('Uint8', 1, function(init){
  return function Uint8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31)('Uint8', 1, function(init){
  return function Uint8ClampedArray(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(129);

// 23.4 WeakSet Objects
__webpack_require__(64)('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export   = __webpack_require__(0)
  , $includes = __webpack_require__(63)(true);

$export($export.P, 'Array', {
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(48)('includes');

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export   = __webpack_require__(0)
  , microtask = __webpack_require__(92)()
  , process   = __webpack_require__(2).process
  , isNode    = __webpack_require__(21)(process) == 'process';

$export($export.G, {
  asap: function asap(fn){
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0)
  , cof     = __webpack_require__(21);

$export($export.S, 'Error', {
  isError: function isError(it){
    return cof(it) === 'Error';
  }
});

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = __webpack_require__(0);

$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(128)('Map')});

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >> 16
      , v1 = $v >> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >>> 16
      , v1 = $v >>> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export         = __webpack_require__(0)
  , toObject        = __webpack_require__(10)
  , aFunction       = __webpack_require__(14)
  , $defineProperty = __webpack_require__(7);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(6) && $export($export.P + __webpack_require__(70), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter){
    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
  }
});

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export         = __webpack_require__(0)
  , toObject        = __webpack_require__(10)
  , aFunction       = __webpack_require__(14)
  , $defineProperty = __webpack_require__(7);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(6) && $export($export.P + __webpack_require__(70), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter){
    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
  }
});

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export  = __webpack_require__(0)
  , $entries = __webpack_require__(139)(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export        = __webpack_require__(0)
  , ownKeys        = __webpack_require__(140)
  , toIObject      = __webpack_require__(18)
  , gOPD           = __webpack_require__(19)
  , createProperty = __webpack_require__(80);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O       = toIObject(object)
      , getDesc = gOPD.f
      , keys    = ownKeys(O)
      , result  = {}
      , i       = 0
      , key;
    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
    return result;
  }
});

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export                  = __webpack_require__(0)
  , toObject                 = __webpack_require__(10)
  , toPrimitive              = __webpack_require__(26)
  , getPrototypeOf           = __webpack_require__(20)
  , getOwnPropertyDescriptor = __webpack_require__(19).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(6) && $export($export.P + __webpack_require__(70), 'Object', {
  __lookupGetter__: function __lookupGetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.get;
    } while(O = getPrototypeOf(O));
  }
});

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export                  = __webpack_require__(0)
  , toObject                 = __webpack_require__(10)
  , toPrimitive              = __webpack_require__(26)
  , getPrototypeOf           = __webpack_require__(20)
  , getOwnPropertyDescriptor = __webpack_require__(19).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(6) && $export($export.P + __webpack_require__(70), 'Object', {
  __lookupSetter__: function __lookupSetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.set;
    } while(O = getPrototypeOf(O));
  }
});

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0)
  , $values = __webpack_require__(139)(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable
var $export     = __webpack_require__(0)
  , global      = __webpack_require__(2)
  , core        = __webpack_require__(28)
  , microtask   = __webpack_require__(92)()
  , OBSERVABLE  = __webpack_require__(5)('observable')
  , aFunction   = __webpack_require__(14)
  , anObject    = __webpack_require__(1)
  , anInstance  = __webpack_require__(38)
  , redefineAll = __webpack_require__(43)
  , hide        = __webpack_require__(15)
  , forOf       = __webpack_require__(49)
  , RETURN      = forOf.RETURN;

var getMethod = function(fn){
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function(subscription){
  var cleanup = subscription._c;
  if(cleanup){
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function(subscription){
  return subscription._o === undefined;
};

var closeSubscription = function(subscription){
  if(!subscriptionClosed(subscription)){
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function(observer, subscriber){
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup      = subscriber(observer)
      , subscription = cleanup;
    if(cleanup != null){
      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch(e){
    observer.error(e);
    return;
  } if(subscriptionClosed(this))cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe(){ closeSubscription(this); }
});

var SubscriptionObserver = function(subscription){
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if(m)return m.call(observer, value);
      } catch(e){
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value){
    var subscription = this._s;
    if(subscriptionClosed(subscription))throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if(!m)throw value;
      value = m.call(observer, value);
    } catch(e){
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch(e){
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber){
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer){
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn){
    var that = this;
    return new (core.Promise || global.Promise)(function(resolve, reject){
      aFunction(fn);
      var subscription = that.subscribe({
        next : function(value){
          try {
            return fn(value);
          } catch(e){
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x){
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if(method){
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function(observer){
        return observable.subscribe(observer);
      });
    }
    return new C(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          try {
            if(forOf(x, false, function(it){
              observer.next(it);
              if(done)return RETURN;
            }) === RETURN)return;
          } catch(e){
            if(done)throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  },
  of: function of(){
    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          for(var i = 0; i < items.length; ++i){
            observer.next(items[i]);
            if(done)return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function(){ return this; });

$export($export.G, {Observable: $Observable});

__webpack_require__(44)('Observable');

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var metadata                  = __webpack_require__(30)
  , anObject                  = __webpack_require__(1)
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
}});

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(30)
  , anObject               = __webpack_require__(1)
  , toMetaKey              = metadata.key
  , getOrCreateMetadataMap = metadata.map
  , store                  = metadata.store;

metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
  if(metadataMap.size)return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
}});

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

var Set                     = __webpack_require__(148)
  , from                    = __webpack_require__(124)
  , metadata                = __webpack_require__(30)
  , anObject                = __webpack_require__(1)
  , getPrototypeOf          = __webpack_require__(20)
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

var ordinaryMetadataKeys = function(O, P){
  var oKeys  = ordinaryOwnMetadataKeys(O, P)
    , parent = getPrototypeOf(O);
  if(parent === null)return oKeys;
  var pKeys  = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(30)
  , anObject               = __webpack_require__(1)
  , getPrototypeOf         = __webpack_require__(20)
  , ordinaryHasOwnMetadata = metadata.has
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

var ordinaryGetMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

var metadata                = __webpack_require__(30)
  , anObject                = __webpack_require__(1)
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(30)
  , anObject               = __webpack_require__(1)
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(30)
  , anObject               = __webpack_require__(1)
  , getPrototypeOf         = __webpack_require__(20)
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

var ordinaryHasMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(30)
  , anObject               = __webpack_require__(1)
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

var metadata                  = __webpack_require__(30)
  , anObject                  = __webpack_require__(1)
  , aFunction                 = __webpack_require__(14)
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({metadata: function metadata(metadataKey, metadataValue){
  return function decorator(target, targetKey){
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
}});

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = __webpack_require__(0);

$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(128)('Set')});

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(0)
  , $at     = __webpack_require__(96)(true);

$export($export.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/
var $export     = __webpack_require__(0)
  , defined     = __webpack_require__(22)
  , toLength    = __webpack_require__(9)
  , isRegExp    = __webpack_require__(68)
  , getFlags    = __webpack_require__(66)
  , RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function(regexp, string){
  this._r = regexp;
  this._s = string;
};

__webpack_require__(88)($RegExpStringIterator, 'RegExp String', function next(){
  var match = this._r.exec(this._s);
  return {value: match, done: match === null};
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp){
    defined(this);
    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
    var S     = String(this)
      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0)
  , $pad    = __webpack_require__(144);

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0)
  , $pad    = __webpack_require__(144);

$export($export.P, 'String', {
  padStart: function padStart(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(52)('trimLeft', function($trim){
  return function trimLeft(){
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(52)('trimRight', function($trim){
  return function trimRight(){
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(102)('asyncIterator');

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(102)('observable');

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', {global: __webpack_require__(2)});

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators    = __webpack_require__(104)
  , redefine      = __webpack_require__(16)
  , global        = __webpack_require__(2)
  , hide          = __webpack_require__(15)
  , Iterators     = __webpack_require__(50)
  , wks           = __webpack_require__(5)
  , ITERATOR      = wks('iterator')
  , TO_STRING_TAG = wks('toStringTag')
  , ArrayValues   = Iterators.Array;

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype
    , key;
  if(proto){
    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
  , $task   = __webpack_require__(100);
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global     = __webpack_require__(2)
  , $export    = __webpack_require__(0)
  , invoke     = __webpack_require__(67)
  , partial    = __webpack_require__(198)
  , navigator  = global.navigator
  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout:  wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(321);
__webpack_require__(260);
__webpack_require__(262);
__webpack_require__(261);
__webpack_require__(264);
__webpack_require__(266);
__webpack_require__(271);
__webpack_require__(265);
__webpack_require__(263);
__webpack_require__(273);
__webpack_require__(272);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(267);
__webpack_require__(259);
__webpack_require__(270);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(227);
__webpack_require__(229);
__webpack_require__(228);
__webpack_require__(277);
__webpack_require__(276);
__webpack_require__(247);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(251);
__webpack_require__(252);
__webpack_require__(253);
__webpack_require__(254);
__webpack_require__(255);
__webpack_require__(256);
__webpack_require__(230);
__webpack_require__(231);
__webpack_require__(232);
__webpack_require__(233);
__webpack_require__(234);
__webpack_require__(235);
__webpack_require__(236);
__webpack_require__(237);
__webpack_require__(238);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(308);
__webpack_require__(313);
__webpack_require__(320);
__webpack_require__(311);
__webpack_require__(303);
__webpack_require__(304);
__webpack_require__(309);
__webpack_require__(314);
__webpack_require__(316);
__webpack_require__(299);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(302);
__webpack_require__(305);
__webpack_require__(306);
__webpack_require__(307);
__webpack_require__(310);
__webpack_require__(312);
__webpack_require__(315);
__webpack_require__(317);
__webpack_require__(318);
__webpack_require__(319);
__webpack_require__(222);
__webpack_require__(224);
__webpack_require__(223);
__webpack_require__(226);
__webpack_require__(225);
__webpack_require__(211);
__webpack_require__(209);
__webpack_require__(215);
__webpack_require__(212);
__webpack_require__(218);
__webpack_require__(220);
__webpack_require__(208);
__webpack_require__(214);
__webpack_require__(205);
__webpack_require__(219);
__webpack_require__(203);
__webpack_require__(217);
__webpack_require__(216);
__webpack_require__(210);
__webpack_require__(213);
__webpack_require__(202);
__webpack_require__(204);
__webpack_require__(207);
__webpack_require__(206);
__webpack_require__(221);
__webpack_require__(104);
__webpack_require__(293);
__webpack_require__(298);
__webpack_require__(147);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(278);
__webpack_require__(146);
__webpack_require__(148);
__webpack_require__(149);
__webpack_require__(333);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(328);
__webpack_require__(331);
__webpack_require__(332);
__webpack_require__(326);
__webpack_require__(329);
__webpack_require__(327);
__webpack_require__(330);
__webpack_require__(324);
__webpack_require__(325);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(283);
__webpack_require__(286);
__webpack_require__(284);
__webpack_require__(285);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(292);
__webpack_require__(291);
__webpack_require__(334);
__webpack_require__(360);
__webpack_require__(363);
__webpack_require__(362);
__webpack_require__(364);
__webpack_require__(365);
__webpack_require__(361);
__webpack_require__(366);
__webpack_require__(367);
__webpack_require__(345);
__webpack_require__(348);
__webpack_require__(344);
__webpack_require__(342);
__webpack_require__(343);
__webpack_require__(346);
__webpack_require__(347);
__webpack_require__(337);
__webpack_require__(359);
__webpack_require__(368);
__webpack_require__(336);
__webpack_require__(338);
__webpack_require__(340);
__webpack_require__(339);
__webpack_require__(341);
__webpack_require__(350);
__webpack_require__(351);
__webpack_require__(353);
__webpack_require__(352);
__webpack_require__(355);
__webpack_require__(354);
__webpack_require__(356);
__webpack_require__(357);
__webpack_require__(358);
__webpack_require__(335);
__webpack_require__(349);
__webpack_require__(371);
__webpack_require__(370);
__webpack_require__(369);
module.exports = __webpack_require__(28);

/***/ }),
/* 373 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 374 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Drawing utility functions.



// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

exports.line = line;


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The Font object



var path = __webpack_require__(58);
var sfnt = __webpack_require__(384);
var encoding = __webpack_require__(74);
var glyphset = __webpack_require__(105);
var Substitution = __webpack_require__(378);
var util = __webpack_require__(165);

/**
 * @typedef FontOptions
 * @type Object
 * @property {Boolean} empty - whether to create a new empty font
 * @property {string} familyName
 * @property {string} styleName
 * @property {string=} fullName
 * @property {string=} postScriptName
 * @property {string=} designer
 * @property {string=} designerURL
 * @property {string=} manufacturer
 * @property {string=} manufacturerURL
 * @property {string=} license
 * @property {string=} licenseURL
 * @property {string=} version
 * @property {string=} description
 * @property {string=} copyright
 * @property {string=} trademark
 * @property {Number} unitsPerEm
 * @property {Number} ascender
 * @property {Number} descender
 * @property {Number} createdTimestamp
 * @property {string=} weightClass
 * @property {string=} widthClass
 * @property {string=} fsSelection
 */

/**
 * A Font represents a loaded OpenType font file.
 * It contains a set of glyphs and methods to draw text on a drawing context,
 * or to get a path representing the text.
 * @exports opentype.Font
 * @class
 * @param {FontOptions}
 * @constructor
 */
function Font(options) {
    options = options || {};

    if (!options.empty) {
        // Check that we've provided the minimum set of names.
        util.checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
        util.checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
        util.checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
        util.checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
        util.checkArgument(options.descender, 'When creating a new Font object, descender is required.');
        util.checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).');

        // OS X will complain if the names are empty, so we put a single space everywhere by default.
        this.names = {
            fontFamily: {en: options.familyName || ' '},
            fontSubfamily: {en: options.styleName || ' '},
            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
            postScriptName: {en: options.postScriptName || options.familyName + options.styleName},
            designer: {en: options.designer || ' '},
            designerURL: {en: options.designerURL || ' '},
            manufacturer: {en: options.manufacturer || ' '},
            manufacturerURL: {en: options.manufacturerURL || ' '},
            license: {en: options.license || ' '},
            licenseURL: {en: options.licenseURL || ' '},
            version: {en: options.version || 'Version 0.1'},
            description: {en: options.description || ' '},
            copyright: {en: options.copyright || ' '},
            trademark: {en: options.trademark || ' '}
        };
        this.unitsPerEm = options.unitsPerEm || 1000;
        this.ascender = options.ascender;
        this.descender = options.descender;
        this.createdTimestamp = options.createdTimestamp;
        this.tables = { os2: {
            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
        } };
    }

    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
    this.encoding = new encoding.DefaultEncoding(this);
    this.substitution = new Substitution(this);
    this.tables = this.tables || {};
}

/**
 * Check if the font has a glyph for the given character.
 * @param  {string}
 * @return {Boolean}
 */
Font.prototype.hasChar = function(c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

/**
 * Convert the given character to a single glyph index.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {Number}
 */
Font.prototype.charToGlyphIndex = function(s) {
    return this.encoding.charToGlyphIndex(s);
};

/**
 * Convert the given character to a single Glyph object.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font.prototype.charToGlyph = function(c) {
    var glyphIndex = this.charToGlyphIndex(c);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * Convert the given text to a list of Glyph objects.
 * Note that there is no strict one-to-one mapping between characters and
 * glyphs, so the list of returned glyphs can be larger or smaller than the
 * length of the given string.
 * @param  {string}
 * @param  {GlyphRenderOptions} [options]
 * @return {opentype.Glyph[]}
 */
Font.prototype.stringToGlyphs = function(s, options) {
    options = options || this.defaultRenderOptions;
    var i;
    // Get glyph indexes
    var indexes = [];
    for (i = 0; i < s.length; i += 1) {
        var c = s[i];
        indexes.push(this.charToGlyphIndex(c));
    }
    var length = indexes.length;

    // Apply substitutions on glyph indexes
    if (options.features) {
        var script = options.script || this.substitution.getDefaultScriptName();
        var manyToOne = [];
        if (options.features.liga) manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language));
        if (options.features.rlig) manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language));
        for (i = 0; i < length; i += 1) {
            for (var j = 0; j < manyToOne.length; j++) {
                var ligature = manyToOne[j];
                var components = ligature.sub;
                var compCount = components.length;
                var k = 0;
                while (k < compCount && components[k] === indexes[i + k]) k++;
                if (k === compCount) {
                    indexes.splice(i, compCount, ligature.by);
                    length = length - compCount + 1;
                }
            }
        }
    }

    // convert glyph indexes to glyph objects
    var glyphs = new Array(length);
    var notdef = this.glyphs.get(0);
    for (i = 0; i < length; i += 1) {
        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;
    }
    return glyphs;
};

/**
 * @param  {string}
 * @return {Number}
 */
Font.prototype.nameToGlyphIndex = function(name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

/**
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font.prototype.nameToGlyph = function(name) {
    var glyphIndex = this.nameToGlyphIndex(name);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * @param  {Number}
 * @return {String}
 */
Font.prototype.glyphIndexToName = function(gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }

    return this.glyphNames.glyphIndexToName(gid);
};

/**
 * Retrieve the value of the kerning pair between the left glyph (or its index)
 * and the right glyph (or its index). If no kerning pair is found, return 0.
 * The kerning value gets added to the advance width when calculating the spacing
 * between glyphs.
 * @param  {opentype.Glyph} leftGlyph
 * @param  {opentype.Glyph} rightGlyph
 * @return {Number}
 */
Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    var gposKerning = this.getGposKerningValue;
    return gposKerning ? gposKerning(leftGlyph, rightGlyph) :
        (this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0);
};

/**
 * @typedef GlyphRenderOptions
 * @type Object
 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
 * @property {string} [language='dflt'] - language system used to determine which features to apply.
 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
 * @property {boolean} [kerning=true] - whether to include kerning values
 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
 */
Font.prototype.defaultRenderOptions = {
    kerning: true,
    features: {
        liga: true,
        rlig: true
    }
};

/**
 * Helper function that invokes the given callback for each glyph in the given text.
 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
 * @param {string} text - The text to apply.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @param  {Function} callback
 */
Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || this.defaultRenderOptions;
    var fontScale = 1 / this.unitsPerEm * fontSize;
    var glyphs = this.stringToGlyphs(text, options);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        callback(glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }

        if (options.kerning && i < glyphs.length - 1) {
            var kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }

        if (options.letterSpacing) {
            x += options.letterSpacing * fontSize;
        } else if (options.tracking) {
            x += (options.tracking / 1000) * fontSize;
        }
    }
};

/**
 * Create a Path object that represents the given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path}
 */
Font.prototype.getPath = function(text, x, y, fontSize, options) {
    var fullPath = new path.Path();
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize);
        fullPath.extend(glyphPath);
    });

    return fullPath;
};

/**
 * Create an array of Path objects that represent the glyps of a given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path[]}
 */
Font.prototype.getPaths = function(text, x, y, fontSize, options) {
    var glyphPaths = [];
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize);
        glyphPaths.push(glyphPath);
    });

    return glyphPaths;
};

/**
 * Draw the text on the given drawing context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 */
Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of all glyphs in the text.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawPoints(ctx, gX, gY, gFontSize);
    });
};

/**
 * Draw lines indicating important font measurements for all glyphs in the text.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawMetrics(ctx, gX, gY, gFontSize);
    });
};

/**
 * @param  {string}
 * @return {string}
 */
Font.prototype.getEnglishName = function(name) {
    var translations = this.names[name];
    if (translations) {
        return translations.en;
    }
};

/**
 * Validate
 */
Font.prototype.validate = function() {
    var warnings = [];
    var _this = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertNamePresent(name) {
        var englishName = _this.getEnglishName(name);
        assert(englishName && englishName.trim().length > 0,
               'No English ' + name + ' specified.');
    }

    // Identification information
    assertNamePresent('fontFamily');
    assertNamePresent('weightName');
    assertNamePresent('manufacturer');
    assertNamePresent('copyright');
    assertNamePresent('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

/**
 * Convert the font object to a SFNT data structure.
 * This structure contains all the necessary tables and metadata to create a binary OTF file.
 * @return {opentype.Table}
 */
Font.prototype.toTables = function() {
    return sfnt.fontToTable(this);
};
/**
 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
 */
Font.prototype.toBuffer = function() {
    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
    return this.toArrayBuffer();
};
/**
 * Converts a `opentype.Font` into an `ArrayBuffer`
 * @return {ArrayBuffer}
 */
Font.prototype.toArrayBuffer = function() {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }

    return buffer;
};

/**
 * Initiate a download of the OpenType font.
 */
Font.prototype.download = function(fileName) {
    var familyName = this.getEnglishName('fontFamily');
    var styleName = this.getEnglishName('fontSubfamily');
    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
    var arrayBuffer = this.toArrayBuffer();

    if (util.isBrowser()) {
        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
        window.requestFileSystem(window.TEMPORARY, arrayBuffer.byteLength, function(fs) {
            fs.root.getFile(fileName, {create: true}, function(fileEntry) {
                fileEntry.createWriter(function(writer) {
                    var dataView = new DataView(arrayBuffer);
                    var blob = new Blob([dataView], {type: 'font/opentype'});
                    writer.write(blob);

                    writer.addEventListener('writeend', function() {
                        // Navigating to the file will download it.
                        location.href = fileEntry.toURL();
                    }, false);
                });
            });
        },
        function(err) {
            throw new Error(err.name + ': ' + err.message);
        });
    } else {
        var fs = __webpack_require__(107);
        var buffer = util.arrayBufferToNodeBuffer(arrayBuffer);
        fs.writeFileSync(fileName, buffer);
    }
};
/**
 * @private
 */
Font.prototype.fsSelectionValues = {
    ITALIC:              0x001, //1
    UNDERSCORE:          0x002, //2
    NEGATIVE:            0x004, //4
    OUTLINED:            0x008, //8
    STRIKEOUT:           0x010, //16
    BOLD:                0x020, //32
    REGULAR:             0x040, //64
    USER_TYPO_METRICS:   0x080, //128
    WWS:                 0x100, //256
    OBLIQUE:             0x200  //512
};

/**
 * @private
 */
Font.prototype.usWidthClasses = {
    ULTRA_CONDENSED: 1,
    EXTRA_CONDENSED: 2,
    CONDENSED: 3,
    SEMI_CONDENSED: 4,
    MEDIUM: 5,
    SEMI_EXPANDED: 6,
    EXPANDED: 7,
    EXTRA_EXPANDED: 8,
    ULTRA_EXPANDED: 9
};

/**
 * @private
 */
Font.prototype.usWeightClasses = {
    THIN: 100,
    EXTRA_LIGHT: 200,
    LIGHT: 300,
    NORMAL: 400,
    MEDIUM: 500,
    SEMI_BOLD: 600,
    BOLD: 700,
    EXTRA_BOLD: 800,
    BLACK:    900
};

exports.Font = Font;


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The Layout object is the prototype of Substition objects, and provides utility methods to manipulate
// common layout tables (GPOS, GSUB, GDEF...)



var check = __webpack_require__(11);

function searchTag(arr, tag) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid].tag;
        if (val === tag) {
            return imid;
        } else if (val < tag) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}

function binSearch(arr, value) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid];
        if (val === value) {
            return imid;
        } else if (val < value) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}

/**
 * @exports opentype.Layout
 * @class
 */
function Layout(font, tableName) {
    this.font = font;
    this.tableName = tableName;
}

Layout.prototype = {

    /**
     * Binary search an object by "tag" property
     * @instance
     * @function searchTag
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {string} tag
     * @return {number}
     */
    searchTag: searchTag,

    /**
     * Binary search in a list of numbers
     * @instance
     * @function binSearch
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {number} value
     * @return {number}
     */
    binSearch: binSearch,

    /**
     * Get or create the Layout table (GSUB, GPOS etc).
     * @param  {boolean} create - Whether to create a new one.
     * @return {Object} The GSUB or GPOS table.
     */
    getTable: function(create) {
        var layout = this.font.tables[this.tableName];
        if (!layout && create) {
            layout = this.font.tables[this.tableName] = this.createDefaultTable();
        }
        return layout;
    },

    /**
     * Returns all scripts in the substitution table.
     * @instance
     * @return {Array}
     */
    getScriptNames: function() {
        var layout = this.getTable();
        if (!layout) { return []; }
        return layout.scripts.map(function(script) {
            return script.tag;
        });
    },

    /**
     * Returns the best bet for a script name.
     * Returns 'DFLT' if it exists.
     * If not, returns 'latn' if it exists.
     * If neither exist, returns undefined.
     */
    getDefaultScriptName: function() {
        var layout = this.getTable();
        if (!layout) { return; }
        var hasLatn = false;
        for (var i = 0; i < layout.scripts.length; i++) {
            var name = layout.scripts[i].tag;
            if (name === 'DFLT') return name;
            if (name === 'latn') hasLatn = true;
        }
        if (hasLatn) return 'latn';
    },

    /**
     * Returns all LangSysRecords in the given script.
     * @instance
     * @param {string} [script='DFLT']
     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
     * @return {Object} An object with tag and script properties.
     */
    getScriptTable: function(script, create) {
        var layout = this.getTable(create);
        if (layout) {
            script = script || 'DFLT';
            var scripts = layout.scripts;
            var pos = searchTag(layout.scripts, script);
            if (pos >= 0) {
                return scripts[pos].script;
            } else if (create) {
                var scr = {
                    tag: script,
                    script: {
                        defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                        langSysRecords: []
                    }
                };
                scripts.splice(-1 - pos, 0, scr);
                return scr.script;
            }
        }
    },

    /**
     * Returns a language system table
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
     * @return {Object}
     */
    getLangSysTable: function(script, language, create) {
        var scriptTable = this.getScriptTable(script, create);
        if (scriptTable) {
            if (!language || language === 'dflt' || language === 'DFLT') {
                return scriptTable.defaultLangSys;
            }
            var pos = searchTag(scriptTable.langSysRecords, language);
            if (pos >= 0) {
                return scriptTable.langSysRecords[pos].langSys;
            } else if (create) {
                var langSysRecord = {
                    tag: language,
                    langSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] }
                };
                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
                return langSysRecord.langSys;
            }
        }
    },

    /**
     * Get a specific feature table.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
     * @return {Object}
     */
    getFeatureTable: function(script, language, feature, create) {
        var langSysTable = this.getLangSysTable(script, language, create);
        if (langSysTable) {
            var featureRecord;
            var featIndexes = langSysTable.featureIndexes;
            var allFeatures = this.font.tables[this.tableName].features;
            // The FeatureIndex array of indices is in arbitrary order,
            // even if allFeatures is sorted alphabetically by feature tag.
            for (var i = 0; i < featIndexes.length; i++) {
                featureRecord = allFeatures[featIndexes[i]];
                if (featureRecord.tag === feature) {
                    return featureRecord.feature;
                }
            }
            if (create) {
                var index = allFeatures.length;
                // Automatic ordering of features would require to shift feature indexes in the script list.
                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
                featureRecord = {
                    tag: feature,
                    feature: { params: 0, lookupListIndexes: [] }
                };
                allFeatures.push(featureRecord);
                featIndexes.push(index);
                return featureRecord.feature;
            }
        }
    },

    /**
     * Get the lookup tables of a given type for a script/language/feature.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - 4-letter feature code
     * @param {number} lookupType - 1 to 8
     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
     * @return {Object[]}
     */
    getLookupTables: function(script, language, feature, lookupType, create) {
        var featureTable = this.getFeatureTable(script, language, feature, create);
        var tables = [];
        if (featureTable) {
            var lookupTable;
            var lookupListIndexes = featureTable.lookupListIndexes;
            var allLookups = this.font.tables[this.tableName].lookups;
            // lookupListIndexes are in no particular order, so use naïve search.
            for (var i = 0; i < lookupListIndexes.length; i++) {
                lookupTable = allLookups[lookupListIndexes[i]];
                if (lookupTable.lookupType === lookupType) {
                    tables.push(lookupTable);
                }
            }
            if (tables.length === 0 && create) {
                lookupTable = {
                    lookupType: lookupType,
                    lookupFlag: 0,
                    subtables: [],
                    markFilteringSet: undefined
                };
                var index = allLookups.length;
                allLookups.push(lookupTable);
                lookupListIndexes.push(index);
                return [lookupTable];
            }
        }
        return tables;
    },

    /**
     * Returns the list of glyph indexes of a coverage table.
     * Format 1: the list is stored raw
     * Format 2: compact list as range records.
     * @instance
     * @param  {Object} coverageTable
     * @return {Array}
     */
    expandCoverage: function(coverageTable) {
        if (coverageTable.format === 1) {
            return coverageTable.glyphs;
        } else {
            var glyphs = [];
            var ranges = coverageTable.ranges;
            for (var i = 0; i < ranges; i++) {
                var range = ranges[i];
                var start = range.start;
                var end = range.end;
                for (var j = start; j <= end; j++) {
                    glyphs.push(j);
                }
            }
            return glyphs;
        }
    }

};

module.exports = Layout;


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The Substitution object provides utility methods to manipulate
// the GSUB substitution table.



var check = __webpack_require__(11);
var Layout = __webpack_require__(377);

/**
 * @exports opentype.Substitution
 * @class
 * @extends opentype.Layout
 * @param {opentype.Font}
 * @constructor
 */
var Substitution = function(font) {
    Layout.call(this, font, 'gsub');
};

// Check if 2 arrays of primitives are equal.
function arraysEqual(ar1, ar2) {
    var n = ar1.length;
    if (n !== ar2.length) { return false; }
    for (var i = 0; i < n; i++) {
        if (ar1[i] !== ar2[i]) { return false; }
    }
    return true;
}

// Find the first subtable of a lookup table in a particular format.
function getSubstFormat(lookupTable, format, defaultSubtable) {
    var subtables = lookupTable.subtables;
    for (var i = 0; i < subtables.length; i++) {
        var subtable = subtables[i];
        if (subtable.substFormat === format) {
            return subtable;
        }
    }
    if (defaultSubtable) {
        subtables.push(defaultSubtable);
        return defaultSubtable;
    }
}

Substitution.prototype = Layout.prototype;

/**
 * Create a default GSUB table.
 * @return {Object} gsub - The GSUB table.
 */
Substitution.prototype.createDefaultTable = function() {
    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
    return {
        version: 1,
        scripts: [{
            tag: 'DFLT',
            script: {
                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                langSysRecords: []
            }
        }],
        features: [],
        lookups: []
    };
};

/**
 * List all single substitutions (lookup type 1) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getSingle = function(feature, script, language) {
    var substitutions = [];
    var lookupTables = this.getLookupTables(script, language, feature, 1);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var j;
            if (subtable.substFormat === 1) {
                var delta = subtable.deltaGlyphId;
                for (j = 0; j < glyphs.length; j++) {
                    var glyph = glyphs[j];
                    substitutions.push({ sub: glyph, by: glyph + delta });
                }
            } else {
                var substitute = subtable.substitute;
                for (j = 0; j < glyphs.length; j++) {
                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
                }
            }
        }
    }
    return substitutions;
};

/**
 * List all alternates (lookup type 3) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
 * @return {Array} alternates - The list of alternates
 */
Substitution.prototype.getAlternates = function(feature, script, language) {
    var alternates = [];
    var lookupTables = this.getLookupTables(script, language, feature, 3);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var alternateSets = subtable.alternateSets;
            for (var j = 0; j < glyphs.length; j++) {
                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
            }
        }
    }
    return alternates;
};

/**
 * List all ligatures (lookup type 4) for a given script, language, and feature.
 * The result is an array of ligature objects like { sub: [ids], by: id }
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} ligatures - The list of ligatures.
 */
Substitution.prototype.getLigatures = function(feature, script, language) {
    var ligatures = [];
    var lookupTables = this.getLookupTables(script, language, feature, 4);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this.expandCoverage(subtable.coverage);
            var ligatureSets = subtable.ligatureSets;
            for (var j = 0; j < glyphs.length; j++) {
                var startGlyph = glyphs[j];
                var ligSet = ligatureSets[j];
                for (var k = 0; k < ligSet.length; k++) {
                    var lig = ligSet[k];
                    ligatures.push({
                        sub: [startGlyph].concat(lig.components),
                        by: lig.ligGlyph
                    });
                }
            }
        }
    }
    return ligatures;
};

/**
 * Add or modify a single substitution (lookup type 1)
 * Format 2, more flexible, is always used.
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addSingle = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
        substFormat: 2,
        coverage: { format: 1, glyphs: [] },
        substitute: []
    });
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.substitute.splice(pos, 0, 0);
    }
    subtable.substitute[pos] = substitution.by;
};

/**
 * Add or modify an alternate substitution (lookup type 1)
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, by: [ids] }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
        substFormat: 1,
        coverage: { format: 1, glyphs: [] },
        alternateSets: []
    });
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.alternateSets.splice(pos, 0, 0);
    }
    subtable.alternateSets[pos] = substitution.by;
};

/**
 * Add a ligature (lookup type 4)
 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} ligature - { sub: [ids], by: id }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addLigature = function(feature, ligature, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
    var subtable = lookupTable.subtables[0];
    if (!subtable) {
        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
            substFormat: 1,
            coverage: { format: 1, glyphs: [] },
            ligatureSets: []
        };
        lookupTable.subtables[0] = subtable;
    }
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = ligature.sub[0];
    var ligComponents = ligature.sub.slice(1);
    var ligatureTable = {
        ligGlyph: ligature.by,
        components: ligComponents
    };
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos >= 0) {
        // ligatureSet already exists
        var ligatureSet = subtable.ligatureSets[pos];
        for (var i = 0; i < ligatureSet.length; i++) {
            // If ligature already exists, return.
            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
                return;
            }
        }
        // ligature does not exist: add it.
        ligatureSet.push(ligatureTable);
    } else {
        // Create a new ligatureSet and add coverage for the first glyph.
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
    }
};

/**
 * List all feature data for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getFeature = function(feature, script, language) {
    if (/ss\d\d/.test(feature)) {               // ss01 - ss20
        return this.getSingle(feature, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            return this.getSingle(feature, script, language)
                    .concat(this.getAlternates(feature, script, language));
        case 'dlig':
        case 'liga':
        case 'rlig': return this.getLigatures(feature, script, language);
    }
};

/**
 * Add a substitution to a feature for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.add = function(feature, sub, script, language) {
    if (/ss\d\d/.test(feature)) {               // ss01 - ss20
        return this.addSingle(feature, sub, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            if (typeof sub.by === 'number') {
                return this.addSingle(feature, sub, script, language);
            }
            return this.addAlternate(feature, sub, script, language);
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.addLigature(feature, sub, script, language);
    }
};

module.exports = Substitution;


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `fvar` table stores font variation axes and instances.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6fvar.html



var check = __webpack_require__(11);
var parse = __webpack_require__(8);
var table = __webpack_require__(13);

function addName(name, names) {
    var nameString = JSON.stringify(name);
    var nameID = 256;
    for (var nameKey in names) {
        var n = parseInt(nameKey);
        if (!n || n < 256) {
            continue;
        }

        if (JSON.stringify(names[nameKey]) === nameString) {
            return n;
        }

        if (nameID <= n) {
            nameID = n + 1;
        }
    }

    names[nameID] = name;
    return nameID;
}

function makeFvarAxis(n, axis, names) {
    var nameID = addName(axis.name, names);
    return [
        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
        {name: 'flags_' + n, type: 'USHORT', value: 0},
        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
    ];
}

function parseFvarAxis(data, start, names) {
    var axis = {};
    var p = new parse.Parser(data, start);
    axis.tag = p.parseTag();
    axis.minValue = p.parseFixed();
    axis.defaultValue = p.parseFixed();
    axis.maxValue = p.parseFixed();
    p.skip('uShort', 1);  // reserved for flags; no values defined
    axis.name = names[p.parseUShort()] || {};
    return axis;
}

function makeFvarInstance(n, inst, axes, names) {
    var nameID = addName(inst.name, names);
    var fields = [
        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
        {name: 'flags_' + n, type: 'USHORT', value: 0}
    ];

    for (var i = 0; i < axes.length; ++i) {
        var axisTag = axes[i].tag;
        fields.push({
            name: 'axis_' + n + ' ' + axisTag,
            type: 'FIXED',
            value: inst.coordinates[axisTag] << 16
        });
    }

    return fields;
}

function parseFvarInstance(data, start, axes, names) {
    var inst = {};
    var p = new parse.Parser(data, start);
    inst.name = names[p.parseUShort()] || {};
    p.skip('uShort', 1);  // reserved for flags; no values defined

    inst.coordinates = {};
    for (var i = 0; i < axes.length; ++i) {
        inst.coordinates[axes[i].tag] = p.parseFixed();
    }

    return inst;
}

function makeFvarTable(fvar, names) {
    var result = new table.Table('fvar', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'offsetToData', type: 'USHORT', value: 0},
        {name: 'countSizePairs', type: 'USHORT', value: 2},
        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
        {name: 'axisSize', type: 'USHORT', value: 20},
        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
    ]);
    result.offsetToData = result.sizeOf();

    for (var i = 0; i < fvar.axes.length; i++) {
        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
    }

    for (var j = 0; j < fvar.instances.length; j++) {
        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
    }

    return result;
}

function parseFvarTable(data, start, names) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
    var offsetToData = p.parseOffset16();
    // Skip countSizePairs.
    p.skip('uShort', 1);
    var axisCount = p.parseUShort();
    var axisSize = p.parseUShort();
    var instanceCount = p.parseUShort();
    var instanceSize = p.parseUShort();

    var axes = [];
    for (var i = 0; i < axisCount; i++) {
        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
    }

    var instances = [];
    var instanceStart = start + offsetToData + axisCount * axisSize;
    for (var j = 0; j < instanceCount; j++) {
        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
    }

    return {axes: axes, instances: instances};
}

exports.make = makeFvarTable;
exports.parse = parseFvarTable;


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm



var check = __webpack_require__(11);
var glyphset = __webpack_require__(105);
var parse = __webpack_require__(8);
var path = __webpack_require__(58);

// Parse the coordinate data for a glyph.
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }

        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }

    return v;
}

// Parse a TrueType glyph.
function parseGlyph(glyph, data, start) {
    var p = new parse.Parser(data, start);
    glyph.numberOfContours = p.parseShort();
    glyph._xMin = p.parseShort();
    glyph._yMin = p.parseShort();
    glyph._xMax = p.parseShort();
    glyph._yMax = p.parseShort();
    var flags;
    var flag;
    if (glyph.numberOfContours > 0) {
        var i;
        // This glyph is not a composite.
        var endPointIndices = glyph.endPointIndices = [];
        for (i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (i = 0; i < glyph.instructionLength; i += 1) {
            glyph.instructions.push(p.parseByte());
        }

        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (i = 0; i < numberOfCoordinates; i += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                var repeatCount = p.parseByte();
                for (var j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i += 1;
                }
            }
        }

        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            var points = [];
            var point;
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;
                    points.push(point);
                }

                var px = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                var py = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }

            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        var moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            var component = {
                glyphIndex: p.parseUShort(),
                xScale: 1,
                scale01: 0,
                scale10: 0,
                yScale: 1,
                dx: 0,
                dy: 0
            };
            if ((flags & 1) > 0) {
                // The arguments are words
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseShort();
                    component.dy = p.parseShort();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
                }

            } else {
                // The arguments are bytes
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseChar();
                    component.dy = p.parseChar();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseByte(), p.parseByte()];
                }
            }

            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
    }
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        var newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }

    return newPoints;
}

function getContours(points) {
    var contours = [];
    var currentContour = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p = new path.Path();
    if (!points) {
        return p;
    }

    var contours = getContours(points);
    for (var i = 0; i < contours.length; i += 1) {
        var contour = contours[i];
        var firstPt = contour[0];
        var lastPt = contour[contour.length - 1];
        var curvePt;
        var realFirstPoint;
        if (firstPt.onCurve) {
            curvePt = null;
            // The first point will be consumed by the moveTo command,
            // so skip it in the loop.
            realFirstPoint = true;
        } else {
            if (lastPt.onCurve) {
                // If the first point is off-curve and the last point is on-curve,
                // start at the last point.
                firstPt = lastPt;
            } else {
                // If both first and last points are off-curve, start at their middle.
                firstPt = { x: (firstPt.x + lastPt.x) / 2, y: (firstPt.y + lastPt.y) / 2 };
            }

            curvePt = firstPt;
            // The first point is synthesized, so don't skip the real first point.
            realFirstPoint = false;
        }

        p.moveTo(firstPt.x, firstPt.y);

        for (var j = realFirstPoint ? 1 : 0; j < contour.length; j += 1) {
            var pt = contour[j];
            var prevPt = j === 0 ? firstPt : contour[j - 1];
            if (prevPt.onCurve && pt.onCurve) {
                // This is a straight line.
                p.lineTo(pt.x, pt.y);
            } else if (prevPt.onCurve && !pt.onCurve) {
                curvePt = pt;
            } else if (!prevPt.onCurve && !pt.onCurve) {
                var midPt = { x: (prevPt.x + pt.x) / 2, y: (prevPt.y + pt.y) / 2 };
                p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);
                curvePt = pt;
            } else if (!prevPt.onCurve && pt.onCurve) {
                // Previous point off-curve, this point on-curve.
                p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                curvePt = null;
            } else {
                throw new Error('Invalid state.');
            }
        }

        if (firstPt !== lastPt) {
            // Connect the last and first points
            if (curvePt) {
                p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
            } else {
                p.lineTo(firstPt.x, firstPt.y);
            }
        }
    }

    p.closePath();
    return p;
}

function buildPath(glyphs, glyph) {
    if (glyph.isComposite) {
        for (var j = 0; j < glyph.components.length; j += 1) {
            var component = glyph.components[j];
            var componentGlyph = glyphs.get(component.glyphIndex);
            // Force the ttfGlyphLoader to parse the glyph.
            componentGlyph.getPath();
            if (componentGlyph.points) {
                var transformedPoints;
                if (component.matchedPoints === undefined) {
                    // component positioned by offset
                    transformedPoints = transformPoints(componentGlyph.points, component);
                } else {
                    // component positioned by matched points
                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
                        throw Error('Matched points out of range in ' + glyph.name);
                    }
                    var firstPt = glyph.points[component.matchedPoints[0]];
                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
                    var transform = {
                        xScale: component.xScale, scale01: component.scale01,
                        scale10: component.scale10, yScale: component.yScale,
                        dx: 0, dy: 0
                    };
                    secondPt = transformPoints([secondPt], transform)[0];
                    transform.dx = firstPt.x - secondPt.x;
                    transform.dy = firstPt.y - secondPt.y;
                    transformedPoints = transformPoints(componentGlyph.points, transform);
                }
                glyph.points = glyph.points.concat(transformedPoints);
            }
        }
    }

    return getPath(glyph.points);
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs = new glyphset.GlyphSet(font);
    var i;

    // The last element of the loca table is invalid.
    for (i = 0; i < loca.length - 1; i += 1) {
        var offset = loca[i];
        var nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
        } else {
            glyphs.push(i, glyphset.glyphLoader(font, i));
        }
    }

    return glyphs;
}

exports.parse = parseGlyfTable;


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm



var check = __webpack_require__(11);
var parse = __webpack_require__(8);

// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.
// These lists are unused by now, this function is just the basis for a real parsing.
function parseTaggedListTable(data, start) {
    var p = new parse.Parser(data, start);
    var n = p.parseUShort();
    var list = [];
    for (var i = 0; i < n; i++) {
        list[p.parseTag()] = { offset: p.parseUShort() };
    }

    return list;
}

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// Format 1 is a simple list of glyph ids,
// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.
function parseCoverageTable(data, start) {
    var p = new parse.Parser(data, start);
    var format = p.parseUShort();
    var count =  p.parseUShort();
    if (format === 1) {
        return p.parseUShortList(count);
    } else if (format === 2) {
        var coverage = [];
        for (; count--;) {
            var begin = p.parseUShort();
            var end = p.parseUShort();
            var index = p.parseUShort();
            for (var i = begin; i <= end; i++) {
                coverage[index++] = i;
            }
        }

        return coverage;
    }
}

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// Returns a function that gets a class value from a glyph ID.
function parseClassDefTable(data, start) {
    var p = new parse.Parser(data, start);
    var format = p.parseUShort();
    if (format === 1) {
        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.
        var startGlyph = p.parseUShort();
        var glyphCount = p.parseUShort();
        var classes = p.parseUShortList(glyphCount);
        return function(glyphID) {
            return classes[glyphID - startGlyph] || 0;
        };
    } else if (format === 2) {
        // Format 2 defines multiple groups of glyph indices that belong to the same class.
        var rangeCount = p.parseUShort();
        var startGlyphs = [];
        var endGlyphs = [];
        var classValues = [];
        for (var i = 0; i < rangeCount; i++) {
            startGlyphs[i] = p.parseUShort();
            endGlyphs[i] = p.parseUShort();
            classValues[i] = p.parseUShort();
        }

        return function(glyphID) {
            var l = 0;
            var r = startGlyphs.length - 1;
            while (l < r) {
                var c = (l + r + 1) >> 1;
                if (glyphID < startGlyphs[c]) {
                    r = c - 1;
                } else {
                    l = c;
                }
            }

            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {
                return classValues[l] || 0;
            }

            return 0;
        };
    }
}

// Parse a pair adjustment positioning subtable, format 1 or format 2
// The subtable is returned in the form of a lookup function.
function parsePairPosSubTable(data, start) {
    var p = new parse.Parser(data, start);
    // This part is common to format 1 and format 2 subtables
    var format = p.parseUShort();
    var coverageOffset = p.parseUShort();
    var coverage = parseCoverageTable(data, start + coverageOffset);
    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph
    // Only valueFormat1=4 and valueFormat2=0 is supported.
    var valueFormat1 = p.parseUShort();
    var valueFormat2 = p.parseUShort();
    var value1;
    var value2;
    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;
    var sharedPairSets = {};
    if (format === 1) {
        // Pair Positioning Adjustment: Format 1
        var pairSetCount = p.parseUShort();
        var pairSet = [];
        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index
        var pairSetOffsets = p.parseOffset16List(pairSetCount);
        for (var firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {
            var pairSetOffset = pairSetOffsets[firstGlyph];
            var sharedPairSet = sharedPairSets[pairSetOffset];
            if (!sharedPairSet) {
                // Parse a pairset table in a pair adjustment subtable format 1
                sharedPairSet = {};
                p.relativeOffset = pairSetOffset;
                var pairValueCount = p.parseUShort();
                for (; pairValueCount--;) {
                    var secondGlyph = p.parseUShort();
                    if (valueFormat1) value1 = p.parseShort();
                    if (valueFormat2) value2 = p.parseShort();
                    // We only support valueFormat1 = 4 and valueFormat2 = 0,
                    // so value1 is the XAdvance and value2 is empty.
                    sharedPairSet[secondGlyph] = value1;
                }
            }

            pairSet[coverage[firstGlyph]] = sharedPairSet;
        }

        return function(leftGlyph, rightGlyph) {
            var pairs = pairSet[leftGlyph];
            if (pairs) return pairs[rightGlyph];
        };
    } else if (format === 2) {
        // Pair Positioning Adjustment: Format 2
        var classDef1Offset = p.parseUShort();
        var classDef2Offset = p.parseUShort();
        var class1Count = p.parseUShort();
        var class2Count = p.parseUShort();
        var getClass1 = parseClassDefTable(data, start + classDef1Offset);
        var getClass2 = parseClassDefTable(data, start + classDef2Offset);

        // Parse kerning values by class pair.
        var kerningMatrix = [];
        for (var i = 0; i < class1Count; i++) {
            var kerningRow = kerningMatrix[i] = [];
            for (var j = 0; j < class2Count; j++) {
                if (valueFormat1) value1 = p.parseShort();
                if (valueFormat2) value2 = p.parseShort();
                // We only support valueFormat1 = 4 and valueFormat2 = 0,
                // so value1 is the XAdvance and value2 is empty.
                kerningRow[j] = value1;
            }
        }

        // Convert coverage list to a hash
        var covered = {};
        for (i = 0; i < coverage.length; i++) covered[coverage[i]] = 1;

        // Get the kerning value for a specific glyph pair.
        return function(leftGlyph, rightGlyph) {
            if (!covered[leftGlyph]) return;
            var class1 = getClass1(leftGlyph);
            var class2 = getClass2(rightGlyph);
            var kerningRow = kerningMatrix[class1];

            if (kerningRow) {
                return kerningRow[class2];
            }
        };
    }
}

// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).
function parseLookupTable(data, start) {
    var p = new parse.Parser(data, start);
    var lookupType = p.parseUShort();
    var lookupFlag = p.parseUShort();
    var useMarkFilteringSet = lookupFlag & 0x10;
    var subTableCount = p.parseUShort();
    var subTableOffsets = p.parseOffset16List(subTableCount);
    var table = {
        lookupType: lookupType,
        lookupFlag: lookupFlag,
        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
    };
    // LookupType 2, Pair adjustment
    if (lookupType === 2) {
        var subtables = [];
        for (var i = 0; i < subTableCount; i++) {
            var pairPosSubTable = parsePairPosSubTable(data, start + subTableOffsets[i]);
            if (pairPosSubTable) subtables.push(pairPosSubTable);
        }
        // Return a function which finds the kerning values in the subtables.
        table.getKerningValue = function(leftGlyph, rightGlyph) {
            for (var i = subtables.length; i--;) {
                var value = subtables[i](leftGlyph, rightGlyph);
                if (value !== undefined) return value;
            }

            return 0;
        };
    }

    return table;
}

// Parse the `GPOS` table which contains, among other things, kerning pairs.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm
function parseGposTable(data, start, font) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseFixed();
    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');

    // ScriptList and FeatureList - ignored for now
    parseTaggedListTable(data, start + p.parseUShort());
    // 'kern' is the feature we are looking for.
    parseTaggedListTable(data, start + p.parseUShort());

    // LookupList
    var lookupListOffset = p.parseUShort();
    p.relativeOffset = lookupListOffset;
    var lookupCount = p.parseUShort();
    var lookupTableOffsets = p.parseOffset16List(lookupCount);
    var lookupListAbsoluteOffset = start + lookupListOffset;
    for (var i = 0; i < lookupCount; i++) {
        var table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;
    }
}

exports.parse = parseGposTable;


/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm



var check = __webpack_require__(11);
var parse = __webpack_require__(8);

function parseWindowsKernTable(p) {
    var pairs = {};
    // Skip nTables.
    p.skip('uShort');
    var subtableVersion = p.parseUShort();
    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subtableLength, subtableCoverage
    p.skip('uShort', 2);
    var nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (var i = 0; i < nPairs; i += 1) {
        var leftIndex = p.parseUShort();
        var rightIndex = p.parseUShort();
        var value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}

function parseMacKernTable(p) {
    var pairs = {};
    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
    // Skip the rest.
    p.skip('uShort');
    var nTables = p.parseULong();
    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
    if (nTables > 1) {
        console.warn('Only the first kern subtable is supported.');
    }
    p.skip('uLong');
    var coverage = p.parseUShort();
    var subtableVersion = coverage & 0xFF;
    p.skip('uShort');
    if (subtableVersion === 0) {
        var nPairs = p.parseUShort();
        // Skip searchRange, entrySelector, rangeShift.
        p.skip('uShort', 3);
        for (var i = 0; i < nPairs; i += 1) {
            var leftIndex = p.parseUShort();
            var rightIndex = p.parseUShort();
            var value = p.parseShort();
            pairs[leftIndex + ',' + rightIndex] = value;
        }
    }
    return pairs;
}

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseUShort();
    if (tableVersion === 0) {
        return parseWindowsKernTable(p);
    } else if (tableVersion === 1) {
        return parseMacKernTable(p);
    } else {
        throw new Error('Unsupported kern table version (' + tableVersion + ').');
    }
}

exports.parse = parseKernTable;


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm



var parse = __webpack_require__(8);

// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p = new parse.Parser(data, start);
    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    var glyphOffsets = [];
    for (var i = 0; i < numGlyphs + 1; i += 1) {
        var glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }

        glyphOffsets.push(glyphOffset);
    }

    return glyphOffsets;
}

exports.parse = parseLocaTable;


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm



var check = __webpack_require__(11);
var table = __webpack_require__(13);

var cmap = __webpack_require__(154);
var cff = __webpack_require__(153);
var head = __webpack_require__(156);
var hhea = __webpack_require__(157);
var hmtx = __webpack_require__(158);
var ltag = __webpack_require__(159);
var maxp = __webpack_require__(160);
var _name = __webpack_require__(162);
var os2 = __webpack_require__(163);
var post = __webpack_require__(164);
var gsub = __webpack_require__(155);
var meta = __webpack_require__(161);

function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }

    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }

    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Record('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}

function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function(r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs.get(glyphIndex);
            return glyph.getMetrics();
        }
    }

    return notFoundMetrics;
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }

    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    var firstCharIndex;
    var lastCharIndex = 0;
    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;

    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs.get(i);
        var unicode = glyph.unicode | 0;

        if (isNaN(glyph.advanceWidth)) {
            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
        }

        if (firstCharIndex > unicode || firstCharIndex === undefined) {
            // ignore .notdef char
            if (unicode > 0) {
                firstCharIndex = unicode;
            }
        }

        if (lastCharIndex < unicode) {
            lastCharIndex = unicode;
        }

        var position = os2.getUnicodeRange(unicode);
        if (position < 32) {
            ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
            ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
            ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
            ulUnicodeRange4 |= 1 << position - 96;
        } else {
            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
        }
        // Skip non-important characters.
        if (glyph.name === '.notdef') continue;
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }

    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = font.ascender;
    globals.descender = font.descender;

    var headTable = head.make({
        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax,
        lowestRecPPEM: 3,
        createdTimestamp: font.createdTimestamp
    });

    var hheaTable = hhea.make({
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = maxp.make(font.glyphs.length);

    var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: font.tables.os2.usWeightClass,
        usWidthClass: font.tables.os2.usWidthClass,
        usFirstCharIndex: firstCharIndex,
        usLastCharIndex: lastCharIndex,
        ulUnicodeRange1: ulUnicodeRange1,
        ulUnicodeRange2: ulUnicodeRange2,
        ulUnicodeRange3: ulUnicodeRange3,
        ulUnicodeRange4: ulUnicodeRange4,
        fsSelection: font.tables.os2.fsSelection, // REGULAR
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.yMax,
        usWinDescent: Math.abs(globals.yMin),
        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });

    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);

    var englishFamilyName = font.getEnglishName('fontFamily');
    var englishStyleName = font.getEnglishName('fontSubfamily');
    var englishFullName = englishFamilyName + ' ' + englishStyleName;
    var postScriptName = font.getEnglishName('postScriptName');
    if (!postScriptName) {
        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
    }

    var names = {};
    for (var n in font.names) {
        names[n] = font.names[n];
    }

    if (!names.uniqueID) {
        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
    }

    if (!names.postScriptName) {
        names.postScriptName = {en: postScriptName};
    }

    if (!names.preferredFamily) {
        names.preferredFamily = font.names.fontFamily;
    }

    if (!names.preferredSubfamily) {
        names.preferredSubfamily = font.names.fontSubfamily;
    }

    var languageTags = [];
    var nameTable = _name.make(names, languageTags);
    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.getEnglishName('version'),
        fullName: englishFullName,
        familyName: englishFamilyName,
        weightName: englishStyleName,
        postScriptName: postScriptName,
        unitsPerEm: font.unitsPerEm,
        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
    });

    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

    // The order does not matter because makeSfntTable() will sort them.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
    if (ltagTable) {
        tables.push(ltagTable);
    }
    // Optional tables
    if (font.tables.gsub) {
        tables.push(gsub.make(font.tables.gsub));
    }
    if (metaTable) {
        tables.push(metaTable);
    }

    var sfntTable = makeSfntTable(tables);

    // Compute the font's checkSum and store it in head.checkSumAdjustment.
    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    var tableFields = sfntTable.fields;
    var checkSumAdjusted = false;
    for (i = 0; i < tableFields.length; i += 1) {
        if (tableFields[i].name === 'head table') {
            tableFields[i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
            checkSumAdjusted = true;
            break;
        }
    }

    if (!checkSumAdjusted) {
        throw new Error('Could not find head table with checkSum to adjust.');
    }

    return sfntTable;
}

exports.computeCheckSum = computeCheckSum;
exports.make = makeSfntTable;
exports.fontToTable = fontToSfntTable;


/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(76), __webpack_require__(106)))

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(76), __webpack_require__(106)))

/***/ }),
/* 387 */
/***/ (function(module, exports) {

var TINF_OK = 0;
var TINF_DATA_ERROR = -3;

function Tree() {
  this.table = new Uint16Array(16);   /* table of code length counts */
  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
}

function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  
  this.dest = dest;
  this.destLen = 0;
  
  this.ltree = new Tree();  /* dynamic length/symbol tree */
  this.dtree = new Tree();  /* dynamic distance tree */
}

/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */

var sltree = new Tree();
var sdtree = new Tree();

/* extra bits and base tables for length codes */
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);

/* extra bits and base tables for distance codes */
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);

/* special ordering of code length codes */
var clcidx = new Uint8Array([
  16, 17, 18, 0, 8, 7, 9, 6,
  10, 5, 11, 4, 12, 3, 13, 2,
  14, 1, 15
]);

/* used by tinf_decode_trees, avoids allocations every call */
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

/* build extra bits and base tables */
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;

  /* build bits table */
  for (i = 0; i < delta; ++i) bits[i] = 0;
  for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;

  /* build base table */
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}

/* build the fixed huffman trees */
function tinf_build_fixed_trees(lt, dt) {
  var i;

  /* build fixed length tree */
  for (i = 0; i < 7; ++i) lt.table[i] = 0;

  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;

  for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
  for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
  for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
  for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;

  /* build fixed distance tree */
  for (i = 0; i < 5; ++i) dt.table[i] = 0;

  dt.table[5] = 32;

  for (i = 0; i < 32; ++i) dt.trans[i] = i;
}

/* given an array of code lengths, build a tree */
var offs = new Uint16Array(16);

function tinf_build_tree(t, lengths, off, num) {
  var i, sum;

  /* clear code length count table */
  for (i = 0; i < 16; ++i) t.table[i] = 0;

  /* scan symbol lengths, and sum code length counts */
  for (i = 0; i < num; ++i) t.table[lengths[off + i]]++;

  t.table[0] = 0;

  /* compute offset table for distribution sort */
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }

  /* create code->symbol translation table (symbols sorted by code) */
  for (i = 0; i < num; ++i) {
    if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;
  }
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

/* get one bit from source stream */
function tinf_getbit(d) {
  /* check if tag is empty */
  if (!d.bitcount--) {
    /* load next tag */
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }

  /* shift bit out of tag */
  var bit = d.tag & 1;
  d.tag >>>= 1;

  return bit;
}

/* read a num bit value from a stream and add base */
function tinf_read_bits(d, num, base) {
  if (!num)
    return base;

  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }

  var val = d.tag & (0xffff >>> (16 - num));
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}

/* given a data stream and a tree, decode a symbol */
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;

  /* get more bits while code value is above sum */
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;

    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  
  d.tag = tag;
  d.bitcount -= len;

  return t.trans[sum + cur];
}

/* given a data stream, decode dynamic trees from it */
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;

  /* get 5 bits HLIT (257-286) */
  hlit = tinf_read_bits(d, 5, 257);

  /* get 5 bits HDIST (1-32) */
  hdist = tinf_read_bits(d, 5, 1);

  /* get 4 bits HCLEN (4-19) */
  hclen = tinf_read_bits(d, 4, 4);

  for (i = 0; i < 19; ++i) lengths[i] = 0;

  /* read code lengths for code length alphabet */
  for (i = 0; i < hclen; ++i) {
    /* get 3 bits code length (0-7) */
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }

  /* build code length tree */
  tinf_build_tree(code_tree, lengths, 0, 19);

  /* decode code lengths for the dynamic trees */
  for (num = 0; num < hlit + hdist;) {
    var sym = tinf_decode_symbol(d, code_tree);

    switch (sym) {
      case 16:
        /* copy previous code length 3-6 times (read 2 bits) */
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        /* repeat code length 0 for 3-10 times (read 3 bits) */
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        /* repeat code length 0 for 11-138 times (read 7 bits) */
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        /* values 0-15 represent the actual code lengths */
        lengths[num++] = sym;
        break;
    }
  }

  /* build dynamic trees */
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);

    /* check for end of block */
    if (sym === 256) {
      return TINF_OK;
    }

    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs;
      var i;

      sym -= 257;

      /* possibly get more bits from length code */
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

      dist = tinf_decode_symbol(d, dt);

      /* possibly get more bits from distance code */
      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

      /* copy match */
      for (i = offs; i < offs + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}

/* inflate an uncompressed block of data */
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  
  /* unread from bitbuffer */
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }

  /* get length */
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];

  /* get one's complement of length */
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

  /* check length */
  if (length !== (~invlength & 0x0000ffff))
    return TINF_DATA_ERROR;

  d.sourceIndex += 4;

  /* copy block */
  for (i = length; i; --i)
    d.dest[d.destLen++] = d.source[d.sourceIndex++];

  /* make sure we start next block on a byte boundary */
  d.bitcount = 0;

  return TINF_OK;
}

/* inflate stream from source to dest */
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;

  do {
    /* read final block flag */
    bfinal = tinf_getbit(d);

    /* read block type (2 bits) */
    btype = tinf_read_bits(d, 2, 0);

    /* decompress block */
    switch (btype) {
      case 0:
        /* decompress uncompressed block */
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        /* decompress block with fixed huffman trees */
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        /* decompress block with dynamic huffman trees */
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }

    if (res !== TINF_OK)
      throw new Error('Data error');

  } while (!bfinal);

  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === 'function')
      return d.dest.slice(0, d.destLen);
    else
      return d.dest.subarray(0, d.destLen);
  }
  
  return d.dest;
}

/* -------------------- *
 * -- initialization -- *
 * -------------------- */

/* build fixed huffman trees */
tinf_build_fixed_trees(sltree, sdtree);

/* build extra bits and base tables */
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);

/* fix a special case */
length_bits[28] = 0;
length_base[28] = 258;

module.exports = tinf_uncompress;


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(168);
module.exports = __webpack_require__(167);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNzBlMDU4ZTYxMDQyMDQ2MTI4ZjIiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9+L29wZW50eXBlLmpzL3NyYy9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvY2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L29wZW50eXBlLmpzL3NyYy90YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvZ2VvbWV0cnkvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL2NvcmUvSU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmV2aS9nZW9tZXRyeS9FdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvZ3JhcGhpY3MvTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmV2aS9jb3JlL0lCaW5kYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL2dyYXBoaWNzL0NhbnZhcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmV2aS9ncmFwaGljcy9FdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmV2aS9nZW9tZXRyeS9TaXplLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL2dyYXBoaWNzL3ByaW1pdGl2ZXMvUHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL3BsdWdpbnMvaW5wdXQvRXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL3BsdWdpbnMvaW5wdXQvSW5wdXRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwid2VicGFjazovLy8uL34vb3BlbnR5cGUuanMvc3JjL2VuY29kaW5nLmpzIiwid2VicGFjazovLy8uL34vb3BlbnR5cGUuanMvc3JjL3R5cGVzLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvZ3JhcGhpY3MvcHJpbWl0aXZlcy9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvdGV4dC9Gb250TWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvZ2x5cGhzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL2ZzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9zcmMvbGF5b3V0L0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGVyc29uYS9FdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvY29yZS9Bc3NldENhY2hlLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL2NvcmUvbmV4dFRpY2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvZ3JhcGhpY3MvQ2FjaGVkTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmV2aS9ncmFwaGljcy9wcmltaXRpdmVzL0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvZ3JhcGhpY3MvcHJpbWl0aXZlcy9SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvcGx1Z2lucy9TY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvcGx1Z2lucy9lYXNpbmcvRWFzaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL3BsdWdpbnMvZWFzaW5nL0Vhc2luZ1R5cGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL3BsdWdpbnMvZWFzaW5nL0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmV2aS90ZXh0L0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmV2aS90ZXh0L0xhYmVsLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL3RleHQvV29yZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L29wZW50eXBlLmpzL3NyYy9iYm94LmpzIiwid2VicGFjazovLy8uL34vb3BlbnR5cGUuanMvc3JjL2dseXBoLmpzIiwid2VicGFjazovLy8uL34vb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzIiwid2VicGFjazovLy8uL34vb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9jZmYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2NtYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dzdWIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2hlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2hoZWEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2htdHguanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2x0YWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL21heHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL25hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL29zMi5qcyIsIndlYnBhY2s6Ly8vLi9+L29wZW50eXBlLmpzL3NyYy90YWJsZXMvcG9zdC5qcyIsIndlYnBhY2s6Ly8vLi9+L29wZW50eXBlLmpzL3NyYy91dGlsLmpzIiwid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGVyc29uYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9HZW5lcmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvTGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvUGVyc29uYS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2ZvbnRzL0FyaWFsLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvZm9udHMvT3N3YWxkNzAwLmpzIiwid2VicGFjazovLy8uL3NyYy9sYXlvdXQvVmlld3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xheW91dC9ab29tQ29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGVyc29uYS9BdmF0YXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BlcnNvbmEvR2F1Z2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BlcnNvbmEvR2F1Z2VCYXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BlcnNvbmEvTGFiZWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BlcnNvbmEvUGVyc29uYS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmV2aS9jb3JlL1R1cGxlLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL2dlb21ldHJ5L0JvdW5kaW5nQm94LmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL2dlb21ldHJ5L01hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmV2aS9nZW9tZXRyeS9SZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL2dyYXBoaWNzL3ByaW1pdGl2ZXMvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvZ3JhcGhpY3MvcHJpbWl0aXZlcy9TZW1pQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL3BsdWdpbnMvaW5wdXQvUG9pbnRlckV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9yZXZpL3RleHQvRm9udEF3ZXNvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JldmkvdGV4dC9MaW5lLmpzIiwid2VicGFjazovLy8uL34vYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fa2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFzYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9zaGltLmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvZHJhdy5qcyIsIndlYnBhY2s6Ly8vLi9+L29wZW50eXBlLmpzL3NyYy9mb250LmpzIiwid2VicGFjazovLy8uL34vb3BlbnR5cGUuanMvc3JjL2xheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9+L29wZW50eXBlLmpzL3NyYy9zdWJzdGl0dXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2Z2YXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dseWYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dwb3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2tlcm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2xvY2EuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL3NmbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL34vdGlueS1pbmZsYXRlL2luZGV4LmpzIl0sIm5hbWVzIjpbIlVOSVRfVFlQRVMiLCJQSVhFTFMiLCJTeW1ib2wiLCJQRVJDRU5UQUdFIiwiVU5TVVBQT1JURUQiLCJQb2ludCIsInBvaW50IiwieFZhbHVlIiwieFVuaXRzIiwiVU5JVF9UWVBFX1BFUkNFTlRBR0UiLCJ4IiwieVZhbHVlIiwieVVuaXRzIiwieSIsIm1Vbml0c1R5cGVYIiwibVVuaXRzVHlwZVkiLCJfYXNzaWduVmFsdWUiLCJjaGFuZ2VkWCIsImNoYW5nZWRZIiwiZW1pdCIsIkV2ZW50cyIsIkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJhdXRvcmVsZWFzZSIsInZhbHVlIiwidmFsdWVQcm9wZXJ0eSIsInVuaXRzUHJvcGVydHkiLCJTdHJpbmciLCJuZXdWYWx1ZSIsIk51bWJlciIsIk5hTiIsIm51bWJlclN0cmluZyIsInRvU3RyaW5nIiwibGFzdENoYXIiLCJsZW5ndGgiLCJ1bml0c1R5cGUiLCJwYXJzZUZsb2F0Iiwic2xpY2UiLCJpc05hTiIsInBhcnNlSW50IiwiRXJyb3IiLCJfcmNLZXkiLCJJT2JqZWN0IiwidmFyQXJncyIsImRlc3Ryb3kiLCJuZXh0VGljayIsInJlbGVhc2UiLCJSRURSQVdfUkVBU09OIiwiUkVEUkFXX0VYVEVSTkFMX1JFUVVFU1QiLCJSRURSQVdfQ0hJTERfQURERUQiLCJSRURSQVdfQ0hJTERfUkVNT1ZFRCIsIlJFRFJBV19UUkFOU0ZPUk1BVElPTl9DSEFOR0UiLCJSRURSQVdfQ0FDSEVfUkVGUkVTSCIsIk9iamVjdCIsImZyZWV6ZSIsIk1BVFJJWF9VUERBVEVfUkVBU09OIiwiTUFUUklYX1VQREFURV9VTkRFRklORUQiLCJNQVRSSVhfVVBEQVRFX1BPU0lUSU9OIiwiTUFUUklYX1VQREFURV9TSVpFIiwiTUFUUklYX1VQREFURV9TQ0FMRSIsIk1BVFJJWF9VUERBVEVfUk9UQVRJT04iLCJNQVRSSVhfVVBEQVRFX0FOQ0hPUiIsIk1BVFJJWF9VUERBVEVfUEFSRU5UX1JFUVVFU1QiLCJOb2RlIiwid2lkdGgiLCJoZWlnaHQiLCJtUnVubmluZyIsIm1DaGlsZHJlbiIsIm1QYXJlbnQiLCJtQm91bmRpbmdCb3giLCJtUG9zaXRpb24iLCJtUGl4ZWxQb3NpdGlvbiIsIm1TaXplIiwibVBpeGVsU2l6ZSIsIm1BbmNob3IiLCJtUGl4ZWxBbmNob3IiLCJtTWF0cml4IiwibUNhY2hlZE1hdHJpeCIsIm1Sb3RhdGlvbiIsIm1TY2FsZSIsIm1EZXZpY2VTY2FsZSIsIm1HbG9iYWxTY2FsZSIsIm1SZXZpQ29udGV4dCIsInNpemUiLCJzZXQiLCJvbiIsIkdlb21ldHJ5RXZlbnRzIiwic2FmZUJpbmQiLCJfdXBkYXRlTWF0cml4Iiwib25FeGl0IiwicmVtb3ZlQ2hpbGRyZW4iLCJvZmYiLCJyZXZpQ29udGV4dCIsImZvckVhY2giLCJjaGlsZCIsIm9uRW50ZXIiLCJkZWx0YSIsInVwZGF0ZSIsImNvbnRleHQiLCJfcHVzaFRyYW5zZm9ybSIsImRyYXciLCJfcG9wVHJhbnNmb3JtIiwiYWRkQ2hpbGRBdCIsImluZGV4IiwicmV0YWluIiwicmVtb3ZlQ2hpbGQiLCJkZXZpY2VTY2FsZSIsImdsb2JhbFNjYWxlIiwic3BsaWNlIiwiZm9yd2FyZCIsIkdSQVBISUNTX05PREVfQ0hJTERfQURERUQiLCJHUkFQSElDU19OT0RFX0NISUxEX1JFTU9WRUQiLCJHUkFQSElDU19OT0RFX05FRURTX1JFRFJBVyIsIl9uZWVkc1JlZHJhdyIsImluZGV4T2YiLCJyZW1vdmVDaGlsZEF0IiwiX2dldENoaWxkQXQiLCJ1bmZvcndhcmQiLCJtZXRob2ROYW1lIiwicmVjdXJzaXZlIiwibWFrZUNoaWxkcmVuUGVyZm9ybSIsImdsb2JhbFRvTG9jYWxDb29yZHMiLCJpbnN0YW5jZSIsIm1hdHJpeCIsIm5vZGVzIiwiY3VycmVudE5vZGUiLCJwdXNoIiwicGFyZW50IiwibXVsdGlwbHkiLCJwb3AiLCJhcHBseVRvUG9pbnRJbnZlcnNlIiwibG9jYWxUb0dsb2JhbENvb3JkcyIsImFwcGx5VG9Qb2ludCIsInNhdmUiLCJhcHBseVRvQ29udGV4dCIsInJlc3RvcmUiLCJ0cmlnZ2VyIiwicGl4ZWxTaXplIiwieE9mZiIsInlPZmYiLCJyZXNldCIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInNjYWxlIiwiaXNFcXVhbCIsInNldEZyb21NYXRyaXgiLCJib3VuZGluZ0JveCIsImFwcGx5VG9Cb3VuZGluZ0JveCIsInJlYXNvbiIsIl9zb3VyY2VGdW5jdGlvbktleSIsIl9zb3VyY2VPd25lcktleSIsIklCaW5kYWJsZSIsIm1IYW5kbGVycyIsIm1PbW5pSGFuZGxlcnMiLCJtQm91bmRGb3J3YXJkRXZlbnQiLCJfZm9yd2FyZEV2ZW50IiwiYmluZCIsImtleXMiLCJrZXkiLCJldmVudHMiLCJjYWxsYmFjayIsImV2ZW50QXJyYXkiLCJBcnJheSIsInNwbGl0IiwiaGFuZGxlcnMiLCJldmVudCIsIm93bmVyIiwiaSIsIm4iLCJvbW5pSGFuZGxlcnMiLCJhcmd1bWVudHMiLCJiaW5kYWJsZSIsImZ1bmMiLCJib3VuZEZ1bmN0aW9uIiwiYXBwbHkiLCJDQU5WQVNfTUFQIiwiTWFwIiwiQ2FudmFzIiwiaGFzIiwiZ2V0IiwiZWxlbWVudCIsImluaXRpYWxQaXhlbERlbnNpdHkiLCJtaW5QaXhlbERlbnNpdHkiLCJtRWxlbWVudCIsIm1BbmltYXRpb25JRCIsIm1NaW5QaXhlbERlbnNpdHkiLCJtSWRsZSIsIm1MYXN0VGltZXN0YW1wIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJtQ2FudmFzIiwibU93bnNDYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImFwcGVuZENoaWxkIiwiYW5jaG9yIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJNYXRoIiwibWF4Iiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsIm1Cb3VuZFRpY2siLCJfdGljayIsIm1Db250ZXh0IiwiZ2V0Q29udGV4dCIsIm1NZWRpYVF1ZXJ5IiwibWF0Y2hNZWRpYSIsIm1QaXhlbFJhdGlvQ2hhbmdlZCIsImFkZExpc3RlbmVyIiwiX2hhbmRsZVNpemVDaGFuZ2VkIiwicnVubmluZyIsImRlbGV0ZSIsInJlbW92ZUxpc3RlbmVyIiwibmVlZHNSZWRyYXciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9zZXRJZGxlIiwidGltZXN0YW1wIiwibWluIiwiR1JBUEhJQ1NfQ0FOVkFTX1BSRV9VUERBVEUiLCJHUkFQSElDU19DQU5WQVNfUE9TVF9VUERBVEUiLCJzZXRUcmFuc2Zvcm0iLCJjbGVhclJlY3QiLCJHUkFQSElDU19DQU5WQVNfUFJFX0RSQVciLCJHUkFQSElDU19DQU5WQVNfUE9TVF9EUkFXIiwic2VuZGVyIiwiaWRsZSIsInBlcmZvcm1hbmNlIiwibm93IiwiR1JBUEhJQ1NfQ0FOVkFTX0lETEVfU1RBVEVfQ0hBTkdFRCIsInVwZGF0ZUdsb2JhbFNjYWxlIiwiU2l6ZSIsIlNUUk9LRV9UWVBFUyIsIlNUUk9LRV9OT05FIiwiU1RST0tFX01JRERMRSIsIlNUUk9LRV9JTk5FUiIsIlNUUk9LRV9PVVRFUiIsIkxJTkVfQ0FQX1RZUEVTIiwiTElORV9DQVBfQlVUVCIsIkxJTkVfQ0FQX1JPVU5EIiwiTElORV9DQVBfU1FVQVJFIiwicHJpbWl0aXZlRGVmYXVsdE9wdGlvbnMiLCJmaWxsRW5hYmxlZCIsImZpbGxDb2xvciIsInN0cm9rZSIsInN0cm9rZUNvbG9yIiwic3Ryb2tlVHlwZSIsImxpbmVDYXBUeXBlIiwiY2xvc2VQYXRoIiwiUHJpbWl0aXZlIiwiYXNzaWduIiwib3B0aW9ucyIsIm1PcHRpb25zIiwiX3JlbmRlclBhdGgiLCJfYXBwbHlSZW5kZXJPcHRpb25zIiwiZmlsbFN0eWxlIiwiZmlsbCIsImxpbmVDYXAiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsIklOUFVUX1BPSU5URVJfQkVHQU4iLCJJTlBVVF9QT0lOVEVSX01PVkVEIiwiSU5QVVRfUE9JTlRFUl9FTkRFRCIsIklOUFVUX1BPSU5URVJfQ0FOQ0VMTEVEIiwiSU5QVVRfTU9VU0VfU0NST0xMX1VQIiwiSU5QVVRfTU9VU0VfU0NST0xMX0RPV04iLCJJbnB1dE1hbmFnZXJJbnN0YW5jZXMiLCJJbnB1dE1hbmFnZXIiLCJjYW52YXMiLCJnZXRDYW52YXNGb3JDb250ZXh0IiwibVBvaW50ZXJEb3duIiwibVRvdWNoVHJhY2tpbmdJRCIsIm1BbGxvd3NNdWx0aXBsZVBvaW50ZXJzIiwibUVuYWJsZWQiLCJtTGluZUhlaWdodCIsIm1QYWdlSGVpZ2h0IiwibUJvdW5kTW91c2VIYW5kbGVyIiwiX21vdXNlSGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJtQm91bmRUb3VjaEhhbmRsZXIiLCJfdG91Y2hIYW5kbGVyIiwibUJvdW5kV2hlZWxIYW5kbGVyIiwiX3doZWVsSGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpbnB1dEV2ZW50IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJldmVudFR5cGUiLCJ0eXBlIiwiZW5hYmxlZCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwibGVmdCIsImNsaWVudFkiLCJ0b3AiLCJwb2ludGVyRXZlbnQiLCJQb2ludGVyRXZlbnQiLCJEYXRlIiwic2hvdWxkUmVzZXRUb3VjaElEIiwidG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwidG91Y2hlc0xlbmd0aCIsInRvdWNoIiwidG91Y2hJRCIsImlkZW50aWZpZXIiLCJ3aGVlbEV2ZW50IiwiZGVsdGFZIiwibGF5ZXJYIiwibGF5ZXJZIiwiYWJzIiwiZGVsdGFNb2RlIiwiY2lyY2xlUmFkaWFucyIsIlBJIiwiQ2lyY2xlIiwicmFkaXVzIiwibVJhZGl1cyIsImJlZ2luUGF0aCIsImFyYyIsImZvbnRNYW5hZ2VyU2hhcmVkSW5zdGFuY2UiLCJGb250TWFuYWdlciIsIm1Gb250Q2FjaGUiLCJmb250S2V5cyIsInVybCIsImZvbnRLZXkiLCJsb2FkZWRGb250IiwiUHJvbWlzZSIsInJlc29sdmUiLCJBc3NldENhY2hlIiwiaXNVUkwiLCJsb2FkRm9udEI2NCIsImxvYWRBcnJheUJ1ZmZlciIsInRoZW4iLCJsb2FkZWQiLCJidWZmZXIiLCJyZWplY3QiLCJkYXRhIiwiYmluYXJ5U3RyaW5nIiwiYXRvYiIsImxlbiIsImFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJjaGFyQ29kZUF0IiwiZSIsIkxheW91dEV2ZW50cyIsIkxBWU9VVF9aT09NX0lOX0NMSUNLRUQiLCJMQVlPVVRfWk9PTV9PVVRfQ0xJQ0tFRCIsIkxBWU9VVF9BVVRPX1pPT01fQ0xJQ0tFRCIsIlBFUlNPTkFfQ0xJQ0tFRCIsIkFzc2V0Q2FjaGVTdG9yYWdlIiwibURhdGEiLCJtS2V5cyIsImNsZWFyIiwia2V5TmFtZSIsImtleVZhbHVlIiwiVVJMUGF0dGVybiIsIlJlZ0V4cCIsIm1TdG9yYWdlIiwiZ2V0SXRlbSIsImltYWdlIiwiSW1hZ2UiLCJwcm9taXNlIiwic2V0SXRlbSIsInNyYyIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbmxvYWQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwicmVzcG9uc2UiLCJzZW5kIiwidGV4dCIsInRlc3QiLCJzdG9yYWdlIiwic2Vzc2lvblN0b3JhZ2UiLCJCb29sZWFuIiwiY2FjaGUiLCJ2YXJOYW1lIiwidmFyTmFtZUJhc2UiLCJoYXNPd25Qcm9wZXJ0eSIsIklUYXNrUXVldWUiLCJtUXVldWVQb29sIiwibVF1ZXVlUG9vbEluZGV4IiwibVRpY2tDYWxsYmFjayIsInRpY2siLCJ0YXNrIiwic2NoZWR1bGVEcmFpbiIsInF1ZXVlIiwic2hpZnQiLCJhY3RpdmVRdWV1ZSIsIk9ic2VydmVyVGFza1F1ZXVlIiwiT2JzZXJ2ZXJDbGFzcyIsIm1UZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwibVRleHROb2RlRGF0YSIsIm1PYnNlcnZlciIsIm1EcmFpblF1ZXVlZCIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwiZGlzY29ubmVjdCIsIkltbWVkaWF0ZVRhc2tRdWV1ZSIsIm1JbW1lZGlhdGVIYW5kbGUiLCJjbGVhckltbWVkaWF0ZSIsInNldEltbWVkaWF0ZSIsIlRpbWVvdXRUYXNrUXVldWUiLCJtVGltZW91dEhhbmRsZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJwcm9jZXNzIiwidGFza1F1ZXVlIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJlbnF1ZXVlIiwiQ2FjaGVkTm9kZSIsIm1PZmZzY3JlZW5DYW52YXMiLCJtT2Zmc2NyZWVuQ29udGV4dCIsIm1EaXJ0eSIsIl9oYW5kbGVOZWVkc1JlZHJhdyIsInVwZGF0ZUNhY2hlIiwiZHJhd0NhY2hlIiwibG9jYWxDYW52YXMiLCJkcmF3SW1hZ2UiLCJMaW5lIiwiZnJvbSIsInRvIiwiUmVjdGFuZ2xlIiwib2Zmc2V0IiwiX19JTlNUQU5DRVNfXyIsIlNjaGVkdWxlciIsIm1DdXJyZW50VGltZXIiLCJtTWV0aG9kcyIsIm1NZXRob2RzU2NoZWR1bGVkIiwibVRpbWVvdXQiLCJtVGltZW91dFN0YXJ0VGltZSIsIm1UaW1lb3V0SGFuZGxlciIsIl9oYW5kbGVUaW1lb3V0IiwiR3JhcGhpY0V2ZW50cyIsIl9oYW5kbGVJZGxlU3RhdGVDaGFuZ2UiLCJfaGFuZGxlQ2FudmFzVXBkYXRlIiwiZGVsYXkiLCJfc2NoZWR1bGVGdW5jdGlvbiIsImludGVydmFsIiwiaWQiLCJmaW5kSW5kZXgiLCJtZXRob2QiLCJfc2NoZWR1bGVUaW1lb3V0IiwicmVwZWF0cyIsInRhcmdldFRpbWUiLCJjb250YWluZXIiLCJtZXRob2RzIiwibWlkIiwidW5zaGlmdCIsImZsb29yIiwibmV4dFRhcmdldFRpbWUiLCJfZXhlY3V0ZUZ1bmN0aW9ucyIsInRpbWUiLCJlbGFwc2VkVGltZSIsIl9fQ09OVEVYVFNfXyIsIkVBU0lOR19PUFRJT05TX0RFRkFVTFRTIiwiRWFzaW5nVHlwZXMiLCJMaW5lYXIiLCJkdXJhdGlvbiIsInN0YXJ0VmFsdWUiLCJlbmRWYWx1ZSIsImFtcGxpdHVkZSIsInBlcmlvZCIsIm92ZXJzaG9vdCIsIkVhc2luZyIsIlNldCIsIkdyYXBoaWNzRXZlbnRzIiwiZWFzaW5ncyIsImVhc2luZyIsImFkZCIsImluc3RhbmNlcyIsIm1FbGFwc2VkIiwibVByb2dyZXNzIiwibUFyZ3VtZW50cyIsIl9idWlsZEFyZ3VtZW50cyIsInNjaGVkdWxlRWFzaW5nIiwiRUFTSU5HX1NUQVJUIiwiRUFTSU5HX0NPTlRJTlVFIiwicmVtb3ZlRWFzaW5nIiwiRUFTSU5HX1NUT1AiLCJfcGVyZm9ybVVwZGF0ZSIsIkVBU0lOR19FTkQiLCJwcm9ncmVzcyIsInZhbHVlQ2hhbmdlIiwiRUFTSU5HX1VQREFURSIsImFyZ3MiLCJFbGFzdGljIiwiRWFzZUluIiwiRWFzZU91dCIsIkVhc2VJbk91dCIsIkJhY2siLCJQSV9UXzIiLCJMaW5lYXJFYXNpbmciLCJzdGFydCIsImNoYW5nZSIsIlF1YWRyYXRpYyIsIlF1YWRyYXRpY0Vhc2VJbiIsIlF1YWRyYXRpY0Vhc2VPdXQiLCJxdWFkcmF0aWNFYXNlSW5PdXQiLCJDdWJpYyIsIkN1YmljRWFzZUluIiwiQ3ViaWNFYXNlT3V0IiwiQ3ViaWNFYXNlSW5PdXQiLCJRdWFydGljIiwiUXVhcnRpY0Vhc2VJbiIsIlF1YXJ0aWNFYXNlT3V0IiwiUXVhcnRpY0Vhc2VJbk91dCIsIlF1aW50aWMiLCJRdWludGljRWFzZUluIiwiUXVpbnRpY0Vhc2VPdXQiLCJRdWludGljRWFzZUluT3V0IiwiU2ludXNvaWRhbCIsIlNpbnVzb2lkYWxFYXNlSW4iLCJjb3MiLCJTaW51c29pZGFsRWFzZU91dCIsInNpbiIsIlNpbnVzb2lkYWxFYXNlSW5PdXQiLCJFeHBvbmVudGlhbCIsIkV4cG9uZW50aWFsRWFzZUluIiwicG93IiwiRXhwb25lbnRpYWxFYXNlT3V0IiwiRXhwb25lbnRpYWxFYXNlSW5PdXQiLCJDaXJjdWxhciIsIkNpcmN1bGFyRWFzZUluIiwic3FydCIsIkNpcmN1bGFyRWFzZU91dCIsIkNpcmN1bGFyRWFzZUluT3V0IiwiRWxhc3RpY0Vhc2VJbiIsInMiLCJhc2luIiwiRWxhc3RpY0Vhc2VPdXQiLCJFbGFzdGljRWFzZUluT3V0IiwiQmFja0Vhc2VJbiIsIkJhY2tFYXNlT3V0IiwiZHVyYXJ0aW9uIiwiQmFja0Vhc2VJbk91dCIsIkJvdW5jZSIsIlRFWFRfTEFCRUxfV0lMTF9SRU5ERVIiLCJURVhUX0xBQkVMX1JFTkRFUkVEIiwiVEVYVF9BTElHTk1FTlQiLCJURVhUX1RSVU5DQVRJTkdfTU9ERSIsIlRFWFRfTVVMVElfTElORV9NT0RFIiwiVEVYVF9SRU5ERVJJTkdfQkFDS0VORCIsIkRlZmF1bHRMYWJlbE9wdGlvbnMiLCJmb250U2l6ZSIsImNvbG9yIiwiYWxpZ25tZW50IiwiTEVGVCIsIm11bHRpTGluZU1vZGUiLCJBU19JUyIsInRydW5jYXRlTW9kZSIsIlRSVU5DQVRFIiwidHJhY2tpbmciLCJhdXRvU2l6ZSIsInJlbmRlclNoYWRvdyIsInNoYWRvd0NvbG9yIiwic2hhZG93T2Zmc2V0WCIsInNoYWRvd09mZnNldFkiLCJzaGFkb3dCbHVyIiwicmVuZGVyaW5nQmFja2VuZCIsIkNBTlZBUyIsIkxhYmVsIiwiZm9udFVSTCIsIm1NYXhTaXplIiwibUVmZmVjdHNTaXplIiwibUVmZmVjdHNPZmZzZXQiLCJtVGV4dCIsIm1Gb250IiwibU1pbkRldmljZVNjYWxlIiwibWF4U2l6ZSIsIl9oYW5kbGVNYXhTaXplQ2hhbmdlZCIsIl9sb2FkRm9udCIsInBhcmVudENvbnRleHQiLCJmb250IiwiaGhlYSIsInRhYmxlcyIsImZvbnRTY2FsZSIsInVuaXRzUGVyRW0iLCJ3b3JkcyIsIl9leHRyYWN0V29yZHMiLCJzcGFjZVdpZHRoIiwiY2hhclRvR2x5cGgiLCJhZHZhbmNlV2lkdGgiLCJsaW5lSGVpZ2h0IiwiYXNjZW5kZXIiLCJkZXNjZW5kZXIiLCJsaW5lcyIsIl9idWlsZExpbmVzIiwiY2VudGVyIiwiQ0VOVEVSIiwicmlnaHQiLCJSSUdIVCIsInRleHRQYXRoIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJtaW5CYXNlbGluZSIsImNvbXB1dGVkV2lkdGgiLCJyZWR1Y2UiLCJsaW5lIiwiZW1XaWR0aCIsImNhbnZhc0NlbnRlciIsIm9mZnNldExlZnQiLCJhZGRUb1BhdGgiLCJiYiIsImdldEJvdW5kaW5nQm94IiwiYmJXaWR0aCIsIngyIiwieDEiLCJiYkhlaWdodCIsInkyIiwieTEiLCJfYXV0b1NpemUiLCJjaGFyIiwid29yZFRleHQiLCJXb3JkIiwiU1BBQ0VfV09SRCIsIkxJTkVfQlJFQUtfV09SRCIsIkFVVE9fRklUIiwiYXNJc0xpbmVCcmVhayIsInNpbmdsZUxpbmUiLCJTSU5HTEVfTElORSIsImFkZEVsbGlwc2VzIiwiRUxMSVBTRVMiLCJ0YXJnZXRFbVdpZHRoIiwidGFyZ2V0RW1IZWlnaHQiLCJlbUhlaWdodCIsIndvcmQiLCJpc0xhc3RMaW5lIiwicGVyaW9kR2x5cGgiLCJlbGxpcHNlc0VtV2lkdGgiLCJhZGRXb3JkIiwidHJpbUJsYW5rU3BhY2UiLCJmb250TWFuYWdlciIsInNoYXJlZEluc3RhbmNlIiwiZm9udENhY2hlIiwibG9hZEZvbnQiLCJyZXRhaW5Db3VudCIsInBhdGgiLCJzaGFwZVJlbmRlcmluZyIsIlNWR19PUFRJTUlaRV9TUEVFRCIsIlNWR19DUklTUF9FREdFUyIsIlNWR19HRU9NRVRSSUNfUFJFQ0lTSU9OIiwiY29udGVudCIsInRvU1ZHIiwic3ZnU3RyaW5nIiwiYnRvYSIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImZpbGxSZWN0IiwibWF4RW1XaWR0aCIsImVsbGlwc2VzV29yZCIsIm1UcmFja2luZyIsImVsbGlwc2VzV2lkdGgiLCJvZmZzZXRzIiwic3Vic3RyIiwibUdseXBocyIsIm1PZmZzZXRzIiwibUVtV2lkdGgiLCJtRW1IZWlnaHQiLCJtQXNjZW5kaW5nIiwibURlc2NlbmRpbmciLCJtT2Zmc2V0TGVmdCIsIl9jYWxjdWxhdGVNZXRyaWNzIiwiZ2x5cGgiLCJnbHlwaFBhdGgiLCJnZXRQYXRoIiwiZXh0ZW5kIiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImdseXBoTWV0cmljcyIsInN0cmluZ1RvR2x5cGhzIiwiZ2V0TWV0cmljcyIsInlNYXgiLCJ5TWluIiwieE1pbiIsIlBlcnNvbmFzIiwiY29uZmlnIiwibUNvbmZpZyIsImdlbmVyYWwiLCJwZXJzb25hIiwibGF5b3V0IiwiaW5pdGlhbERldmljZVNjYWxlIiwibVZpZXdwb3J0IiwibVNpemVEb21haW4iLCJwZXJzb25hTWF4UmFkaXVzIiwicGVyc29uYU1pblJhZGl1cyIsInJlZ2lzdGVyQ29udGV4dCIsImFkZENoaWxkIiwidW5yZWdpc3RlckNvbnRleHQiLCJ0b3RhbFJhZGl1cyIsInBlcnNvbmFzIiwicGVyc29uYURhdGEiLCJzY2FsaW5nRmFjdG9yIiwic2FmZVJhZGl1cyIsInBvc2l0aW9uIiwiUGVyc29uYUV2ZW50cyIsInNlbGVjdGVkIiwiR2VuZXJhbENvbmZpZyIsIkxheW91dENvbmZpZyIsInpvb21Db250cm9sc1Bvc2l0aW9uIiwiem9vbUNvbnRyb2xzUGFkZGluZyIsInpvb21Db250cm9sc0J1dHRvblNpemUiLCJ6b29tQ29udHJvbHNCYWNrZ3JvdW5kQ29sb3IiLCJ6b29tQ29udHJvbHNCb3JkZXJTaXplIiwiem9vbUNvbnRyb2xzQm9yZGVyQ29sb3IiLCJ6b29tQ29udHJvbHNGb250U2l6ZSIsInpvb21Db250cm9sc0ZvbnRDb2xvciIsInpvb21Db250cm9sc0ZvbnRTaGFkb3ciLCJ6b29tQ29udHJvbHNGb250U2hhZG93Q29sb3IiLCJ6b29tQ29udHJvbHNGb250U2hhZG93Qmx1ciIsInpvb21Db250cm9sc0ZvbnRTaGFkb3dPZmZzZXRYIiwiem9vbUNvbnRyb2xzRm9udFNoYWRvd09mZnNldFkiLCJ2aWV3cG9ydERyYWdUaHJlc2hvbGQiLCJ2aWV3cG9ydE1heFpvb21NdWx0aXBsaWVyIiwidmlld3BvcnRNaW5ab29tTXVsdGlwbGllciIsInZpZXdwb3J0Wm9vbVNjcm9sbE11bHRpcGxpZXIiLCJ2aWV3cG9ydERlbGF5ZWRSZWRyYXciLCJ2aWV3cG9ydERlbGF5ZWRSZWRyYXdUaW1lIiwiUGVyc29uYUNvbmZpZyIsImJhY2tncm91bmRDb2xvciIsInJhZGl1c092ZXJsYXAiLCJzZWxlY3RlZEJvcmRlciIsInNlbGVjdGVkQm9yZGVyQ29sb3IiLCJ1bnNlbGVjdGVkQm9yZGVyIiwidW5zZWxlY3RlZEJvcmRlckNvbG9yIiwiZ2F1Z2VUaGlja25lc3MiLCJnYXVnZUJhY2tncm91bmRDb2xvciIsImdhdWdlUGFkZGluZyIsImdhdWdlTWFya2VyVGhpY2tuZXNzIiwiZ2F1Z2VNYXJrZXJTcGlsbCIsImdhdWdlTWFya2VyQ29sb3IiLCJnYXVnZUJhclBhZGRpbmciLCJnYXVnZUJhckNhcHMiLCJhdmF0YXJCb3JkZXIiLCJhdmF0YXJCb3JkZXJDb2xvciIsImF2YXRhclN1YkltYWdlUG9zaXRpb24iLCJsYWJlbFdpZHRoU3BpbGwiLCJsYWJlbFNjYWxlRm9udFNpemVzIiwibGFiZWxTY2FsZUJhc2VQZXJzb25hUmFkaXVzIiwibGFiZWxWZXJ0aWNhbFBvc2l0aW9uIiwibGFiZWxDb3VudERpc3BsYXlNb2RlIiwibGFiZWxQcm9wZXJ0eUNvdW50SW5kZXgiLCJsYWJlbE5hbWVBbmRDb3VudHNQYWRkaW5nIiwibGFiZWxNaW5Gb250U2l6ZSIsImxhYmVsTWF4Rm9udFNpemUiLCJsYWJlbE5hbWVGb250IiwibGFiZWxOYW1lRm9udFNpemUiLCJsYWJlbE5hbWVNYXhMaW5lcyIsImxhYmVsTmFtZUNvbG9yIiwibGFiZWxOYW1lQmFja2dyb3VuZENvbG9yIiwibGFiZWxOYW1lQmFja2dyb3VuZFBhZGRpbmciLCJsYWJlbE5hbWVTaGFkb3ciLCJsYWJlbE5hbWVTaGFkb3dDb2xvciIsImxhYmVsTmFtZVNoYWRvd0JsdXIiLCJsYWJlbE5hbWVTaGFkb3dPZmZzZXRYIiwibGFiZWxOYW1lU2hhZG93T2Zmc2V0WSIsImxhYmVsQ291bnRGb250IiwibGFiZWxDb3VudEZvbnRTaXplIiwibGFiZWxDb3VudENvbG9yIiwibGFiZWxDb3VudFNoYWRvdyIsImxhYmVsQ291bnRTaGFkb3dDb2xvciIsImxhYmVsQ291bnRTaGFkb3dCbHVyIiwibGFiZWxDb3VudFNoYWRvd09mZnNldFgiLCJsYWJlbENvdW50U2hhZG93T2Zmc2V0WSIsImxhYmVsVG90YWxDb3VudEZvbnQiLCJsYWJlbFRvdGFsQ291bnRGb250U2l6ZSIsImxhYmVsVG90YWxDb3VudENvbG9yIiwibGFiZWxUb3RhbENvdW50U2hhZG93IiwibGFiZWxUb3RhbENvdW50U2hhZG93Q29sb3IiLCJsYWJlbFRvdGFsQ291bnRTaGFkb3dCbHVyIiwibGFiZWxUb3RhbENvdW50U2hhZG93T2Zmc2V0WCIsImxhYmVsVG90YWxDb3VudFNoYWRvd09mZnNldFkiLCJBcmlhbCIsIk9zd2FsZDcwMCIsIlZpZXdwb3J0IiwibURyYWdnaW5nIiwibVVwZGF0ZVNjYWxlIiwibVRyYWNraW5nTW92ZVRocmVzaG9sZCIsIm1ab29tU2Nyb2xsTXVsdGlwbGllciIsIm1EZWxheWVkVXBkYXRlU2NhbGUiLCJtRGVsYXllZFVwZGF0ZVNjYWxlVGltZSIsIm1TY2hlZHVsZXIiLCJtQ29udGVudCIsIm1ab29tQ29udHJvbHMiLCJpbnB1dE1hbmFnZXIiLCJpbnN0YW5jZUZvckNvbnRleHQiLCJJbnB1dEV2ZW50cyIsIl9oYW5kbGVQb2ludGVyQmVnYW4iLCJfaGFuZGxlUG9pbnRlck1vdmVkIiwiX2hhbmRsZVBvaW50ZXJFbmRlZCIsIl9oYW5kbGVTY3JvbGxVcCIsIl9oYW5kbGVTY3JvbGxEb3duIiwiX3Bvc2l0aW9uWm9vbUNvbnRyb2xzIiwiX2hhbmRsZVBpeGVsU2l6ZUNoYW5nZWQiLCJ6b29tSW4iLCJ6b29tT3V0IiwiYXV0b1pvb20iLCJhbW91bnQiLCJhbmltYXRlZCIsInVzZUFjdHVhbEFtb3VudCIsImxvY2FsUG9pbnQiLCJvbGRTY2FsZSIsIm5ld1NjYWxlIiwic2NhbGVEaWZmZXJlbmNlIiwic3RhcnRYIiwic3RhcnRZIiwic3RhcnRTY2FsZSIsInpvb21FYXNpbmciLCJFYXNpbmdFdmVudHMiLCJjYW5jZWwiLCJzY2hlZHVsZVRpbWVvdXQiLCJvYmplY3QiLCJnbG9iYWxUTCIsImxvY2FsVG9HbG9iYWxQb2ludCIsInYxIiwiZ2xvYmFsQlIiLCJ2NCIsImdsb2JhbFdpZHRoIiwiZ2xvYmFsSGVpZ2h0IiwiY2VudGVyWCIsImNlbnRlclkiLCJjZW50ZXJQb3NpdGlvbiIsInRhcmdldFBvc2l0aW9uIiwiem9vbSIsInBpeGVsUG9zaXRpb24iLCJ0YXJnZXRYIiwidGFyZ2V0WSIsImNoYW5nZVgiLCJjaGFuZ2VZIiwibVRyYWNraW5nUG9pbnRlciIsIm1UcmFja2luZ1BvaW50IiwiZGlzdGFuY2VTUSIsInpvb21BbW91bnQiLCJwYWRkaW5nIiwiRk9OVF9BV0VTT01FX0tFWSIsIlpvb21Db250cm9sIiwiYmFja2dyb3VuZCIsInNlcGFyYXRvck9mZnNldCIsInNlcGFyYXRvcjAxIiwic2VwYXJhdG9yMDIiLCJfaGFuZGxlRm9udEF3ZXNvbWVMb2FkZWQiLCJidXR0b25TaXplIiwicGx1cyIsIkFVVE9fTElORVMiLCJob21lIiwibWludXMiLCJnbG9iYWxUb0xvY2FsUG9pbnQiLCJBdmF0YXIiLCJpbWFnZVVSTHMiLCJtSW1hZ2VzIiwibUJvcmRlciIsIl9sb2FkSW1hZ2VzIiwiaW1hZ2VzIiwiZmlsdGVyIiwiaW1hZ2VSYWRpdXMiLCJjbGlwIiwibWFpbkltYWdlSGVpZ2h0IiwiX2RyYXdJbWFnZSIsInN1YkltYWdlWSIsInN1YkltYWdlV2lkdGgiLCJzdWJJbWFnZUhlaWdodCIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0IiwiaW1hZ2VVUkwiLCJsb2FkSW1hZ2UiLCJHYXVnZSIsIm1CYXJzIiwibUJhY2tncm91bmQiLCJtTWFya2VyIiwibU1hcmtlclNwaWxsIiwibUJhclJhZGl1cyIsImJhciIsImFjYyIsImRvdWJsZVBJIiwiR2F1Z2VCYXIiLCJyYWRQYWRkaW5nIiwiU2VtaUNpcmNsZSIsIm1SYWRQYWRkaW5nIiwibU9mZnNldFBlcmNlbnRhZ2UiLCJtUHJvZ3Jlc3NQZXJjZW50YWdlIiwiUEVSU09OQV9GT05UUyIsIk5BTUUiLCJDT1VOVCIsIlRPVEFMX0NPVU5UIiwibmFtZSIsImNvdW50IiwidG90YWxDb3VudCIsIm1OYW1lIiwibUNvdW50IiwibVRvdGFsQ291bnQiLCJtRm9udFNpemVTY2FsZSIsIm1CaWdnZXN0Rm9udFNpemUiLCJtU21hbGxlc3RGb250U2l6ZSIsIm1OYW1lTGFiZWwiLCJtQ291bnRMYWJlbCIsIm1Ub3RhbENvdW50TGFiZWwiLCJtTmFtZUJhY2siLCJuYW1lRm9udCIsIl9oYW5kbGVOYW1lRm9udExvYWRlZCIsImNvdW50Rm9udCIsIl9oYW5kbGVDb3VudEZvbnRMb2FkZWQiLCJ0b3RhbENvdW50Rm9udCIsIl9oYW5kbGVUb3RhbENvdW50Rm9udExvYWRlZCIsIl9nZXRGb250U2l6ZSIsIl9jcmVhdGVMYWJlbCIsIlRleHRFdmVudHMiLCJzY2FsZWRQYWRkaW5nIiwiX3Bvc2l0aW9uTGFiZWxzIiwibGFiZWxXaWR0aCIsIl91cGRhdGVMYWJlbCIsIm1pbkZvbnRTaXplIiwibWF4V2lkdGgiLCJtYXhMaW5lcyIsImxhYmVsSGVpZ2h0IiwiVGV4dExhYmVsIiwibGFiZWwiLCJzY2FsZWRGb250U2l6ZSIsInRvdGFsSGVpZ2h0IiwiUGVyc29uYSIsInNpemVXaXRoQm9yZGVyIiwiY2VpbCIsInBlcnNvbmFXaWR0aCIsInBlcnNvbmFIZWlnaHQiLCJtSUQiLCJtU2VsZWN0ZWQiLCJiYWNrZ3JvdW5kUmFkaXVzIiwiYmFja2dyb3VuZFN0cm9rZSIsImJhY2tncm91bmRTdHJva2VDb2xvciIsIm1HYXVnZSIsInByb3BlcnRpZXMiLCJhZGRCYXIiLCJwcm9wZXJ0eSIsImF2YXRhclJhZGl1cyIsIm1BdmF0YXIiLCJjb3VudExhYmVsIiwidG90YWxDb3VudExhYmVsIiwibUxhYmVsIiwidXBkYXRlVGV4dCIsInVwZGF0ZUltYWdlcyIsIlR1cGxlIiwibUZyb3plbiIsIm1WYWx1ZXMiLCJpZ25vcmVkIiwiZGVmaW5lUHJvcGVydHkiLCJfZ2V0VmFsdWVBdEluZGV4IiwiX3NldFZhbHVlQXRJbmRleCIsIkJvdW5kaW5nQm94IiwibVZlcnRleDAxIiwibVZlcnRleDAyIiwibVZlcnRleDAzIiwibVZlcnRleDA0IiwibUZvcndhcmRFdmVudCIsIm1PcmlnaW4iLCJzZXRGcm9tUG9pbnQiLCJ2MiIsInYzIiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsIk1hdHJpeCIsIm1BIiwibUIiLCJtQyIsIm1EIiwibUUiLCJtRiIsInR4IiwidHkiLCJ0cmFuc2Zvcm0iLCJhbmdsZSIsInN4Iiwic3kiLCJhIiwiYiIsImMiLCJkIiwiZiIsImEyIiwiYjIiLCJjMiIsImQyIiwiZTIiLCJmMiIsImExIiwiYjEiLCJjMSIsImQxIiwiZTEiLCJmMSIsInQiLCJtIiwiZGV0IiwieE1heCIsIm9yaWdpbiIsIl9pc0VxdWFsIiwiZHQiLCJSZWN0IiwiUG9seWxpbmUiLCJtVmVydGljZXMiLCJ2ZXJ0aWNlcyIsInZlcnRleEFycmF5IiwiZnJvbVBvaW50IiwidmVydGV4IiwiX2dldFZlcnRleEluUGl4ZWxzIiwibW92ZVRvIiwibGluZVRvIiwiSU5JVElBTF9PRkZTRVQiLCJtT2Zmc2V0IiwibUFuZ2xlIiwibVR5cGUiLCJtUG9pbnQiLCJtSWRlbnRpZmllciIsIm1UaW1lc3RhbXAiLCJmcmVlemVWYWx1ZXMiLCJ1bmZyZWV6ZVZhbHVlcyIsIkZPTlRfQVdFU09NRSIsIm1Xb3JkcyIsIm1NaW5CYXNlbGluZSIsIm1TcGFjZVdpZHRoIiwid29yZFdpdGhFbGxpcHNlcyIsIm9sZFdvcmRzIiwiX3Jlc2V0Iiwib2xkV29yZCIsInNwYWNlV29yZCIsImxpbmVCcmVha1dvcmQiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsdUJBQXVCO0FBQzVHLG1FQUFtRTtBQUNuRSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQix5Qjs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdDOzs7Ozs7QUNIdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFOzs7Ozs7QUNOQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUI7Ozs7OztBQ1ZBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUSxnQkFBZ0IsVUFBVSxHQUFHO0FBQ3RFLENBQUMsRTs7Ozs7O0FDSEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxVQUFVO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQ2ZBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QyxFOzs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQ3pCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hSQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQjtBQUNwQix5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDaEJBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBTTtBQUNiO0FBQ0EsRTs7Ozs7O0FDWEE7QUFDQSxtRjs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFOzs7Ozs7QUNsRkE7QUFDQSxxRUFBc0UsZ0JBQWdCLFVBQVUsR0FBRztBQUNuRyxDQUFDLEU7Ozs7OztBQ0ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNYQTtBQUNBLFVBQVU7QUFDVixFOzs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVLEVBQUU7QUFDOUMsbUJBQW1CLHNDQUFzQztBQUN6RCxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxXOzs7Ozs7QUNoQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEU7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7OztBQ1RBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGU7Ozs7OztBQ1BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYTs7Ozs7O0FDUkQ7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2ZBLG1DOzs7Ozs7O0FDQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFtRTtBQUMzRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCOzs7Ozs7QUNoQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNKRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsbUVBQW1FO0FBQzNGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsVTs7Ozs7OztBQ1hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILEM7Ozs7Ozs7QUN2REE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMvSkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsTUFBTTtBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQyxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDs7QUFFQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7O0FBRUE7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckMsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcFZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUZBQWlGO0FBQzVHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLHFFQUFxRTtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0wsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELG9DQUFvQztBQUNwQyxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzQ0FBc0M7QUFDdEMsc0RBQXNEO0FBQ3RELHNDQUFzQztBQUN0QyxzREFBc0Q7QUFDdEQsb0NBQW9DO0FBQ3BDLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzQ0FBc0M7QUFDdEMsc0RBQXNEO0FBQ3RELHNDQUFzQztBQUN0QyxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksVUFBVSxJQUFJO0FBQ2xCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsc0RBQXNEO0FBQy9ELFNBQVMsc0RBQXNEO0FBQy9ELFNBQVMsc0RBQXNEO0FBQy9ELFNBQVMsOENBQThDO0FBQ3ZELFNBQVMsOENBQThDO0FBQ3ZELFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQyxjQUFjLGFBQWE7QUFDM0IsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxTQUFTLHlDQUF5QztBQUNsRCxTQUFTLHlEQUF5RDtBQUNsRSxTQUFTO0FBQ1Q7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQyx1QkFBdUIsMkRBQTJEO0FBQ2xGOztBQUVBLG1CQUFtQixvREFBb0Q7QUFDdkU7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2wwQkE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEM7O0FBRUE7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyx1REFBdUQ7QUFDaEUsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxzREFBc0Q7QUFDL0QsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyx3Q0FBd0M7QUFDakQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxpREFBaUQ7QUFDMUQsU0FBUyxvREFBb0Q7QUFDN0QsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUyxrREFBa0Q7QUFDM0QsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN1BBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBbUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzV2REE7QUFDQSx1RDs7Ozs7O0FDREE7QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7OztBQ1REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDM0JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7OztBQ3RCRCxpQzs7Ozs7O0FDQUE7QUFDQTs7QUFFQSw0QkFBNEIsZ0JBQWdCLDZCQUE2QixHQUFHLEU7Ozs7Ozs7QUNINUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUMzQkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0Usd0JBQXdCLFVBQVUsR0FBRztBQUM3RyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7O0FDYkQ7QUFDQTs7QUFFQSxtRzs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEM7Ozs7OztBQ1ZBO0FBQ0E7O0FB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QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFOzs7Ozs7O0FDckVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFrQyx3QkFBd0Isd0JBQXdCLFlBQVksRUFBRTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNILEM7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7OztBQ1JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNuQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMsRTs7Ozs7OztBQ3RCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNORDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsY0FBYztBQUNkO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUMsRTs7Ozs7OztBQ2hCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyxFOzs7Ozs7QUNqQkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDTEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDakJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxjQUFjO0FBQ2Q7QUFDQSxFQUFFLEU7Ozs7OztBQ2xCRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBLEVBQUUsRTs7Ozs7O0FDaEJGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBLEVBQUUsRTs7Ozs7O0FDUEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQSxFQUFFLEU7Ozs7OztBQ1JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBLEVBQUUsRTs7Ozs7O0FDZkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQSxFQUFFLEU7Ozs7OztBQ1JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFOzs7Ozs7QUNkRjtBQUNBOztBQUVBLHVDQUF1Qyx3Q0FBZ0QsRTs7Ozs7OztBQ0h2RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDN0JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGU7Ozs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGE7Ozs7OztBQ05ELDBDOzs7Ozs7QUNBQSx1Qzs7Ozs7O0FDQUE7QUFDQTs7QUFFQSw4QkFBOEIsK0JBQTZCLEU7Ozs7OztBQ0gzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0dBQXdHLE9BQU87QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7O0FDTEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7QUNuQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQTs7Ozs7OztBQ25GQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTs7QUFFQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDNU9BO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdEVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLDhEQUE4RDtBQUN2RSxTQUFTLDhFQUE4RTtBQUN2RixTQUFTLHdFQUF3RTtBQUNqRixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdDQUF3QztBQUNsRTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRFQUE0RTtBQUN2RywwQkFBMEIsdURBQXVEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdDQUF3QztBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1Q0FBdUM7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDclZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbHRCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDekxEO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkMsb0NBQW9D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QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6InVuY2hhcnRlZC5wZXJzb25hcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM4OCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNzBlMDU4ZTYxMDQyMDQ2MTI4ZjIiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL193a3MuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gUGFyc2luZyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgYnl0ZSBmcm9tIHRoZSBEYXRhVmlldy5cbmV4cG9ydHMuZ2V0Qnl0ZSA9IGZ1bmN0aW9uIGdldEJ5dGUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpO1xufTtcblxuZXhwb3J0cy5nZXRDYXJkOCA9IGV4cG9ydHMuZ2V0Qnl0ZTtcblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0VVNob3J0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgZmFsc2UpO1xufVxuXG5leHBvcnRzLmdldFVTaG9ydCA9IGV4cG9ydHMuZ2V0Q2FyZDE2ID0gZ2V0VVNob3J0O1xuXG4vLyBSZXRyaWV2ZSBhIHNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5leHBvcnRzLmdldFNob3J0ID0gZnVuY3Rpb24oZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbn07XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDMyLWJpdCBsb25nIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZXhwb3J0cy5nZXRVTG9uZyA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xufTtcblxuLy8gUmV0cmlldmUgYSAzMi1iaXQgc2lnbmVkIGZpeGVkLXBvaW50IG51bWJlciAoMTYuMTYpIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZXhwb3J0cy5nZXRGaXhlZCA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICB2YXIgZGVjaW1hbCA9IGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgZmFsc2UpO1xuICAgIHZhciBmcmFjdGlvbiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGRlY2ltYWwgKyBmcmFjdGlvbiAvIDY1NTM1O1xufTtcblxuLy8gUmV0cmlldmUgYSA0LWNoYXJhY3RlciB0YWcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUYWdzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRhYmxlcy5cbmV4cG9ydHMuZ2V0VGFnID0gZnVuY3Rpb24oZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciB0YWcgPSAnJztcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNDsgaSArPSAxKSB7XG4gICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldEludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWc7XG59O1xuXG4vLyBSZXRyaWV2ZSBhbiBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBPZmZzZXRzIGFyZSAxIHRvIDQgYnl0ZXMgaW4gbGVuZ3RoLCBkZXBlbmRpbmcgb24gdGhlIG9mZlNpemUgYXJndW1lbnQuXG5leHBvcnRzLmdldE9mZnNldCA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQsIG9mZlNpemUpIHtcbiAgICB2YXIgdiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZTaXplOyBpICs9IDEpIHtcbiAgICAgICAgdiA8PD0gODtcbiAgICAgICAgdiArPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbn07XG5cbi8vIFJldHJpZXZlIGEgbnVtYmVyIG9mIGJ5dGVzIGZyb20gc3RhcnQgb2Zmc2V0IHRvIHRoZSBlbmQgb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuZXhwb3J0cy5nZXRCeXRlcyA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgdmFyIGJ5dGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0T2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZXMucHVzaChkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLy8gQ29udmVydCB0aGUgbGlzdCBvZiBieXRlcyB0byBhIHN0cmluZy5cbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgdmFyIHMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHM7XG59O1xuXG52YXIgdHlwZU9mZnNldHMgPSB7XG4gICAgYnl0ZTogMSxcbiAgICB1U2hvcnQ6IDIsXG4gICAgc2hvcnQ6IDIsXG4gICAgdUxvbmc6IDQsXG4gICAgZml4ZWQ6IDQsXG4gICAgbG9uZ0RhdGVUaW1lOiA4LFxuICAgIHRhZzogNFxufTtcblxuLy8gQSBzdGF0ZWZ1bCBwYXJzZXIgdGhhdCBjaGFuZ2VzIHRoZSBvZmZzZXQgd2hlbmV2ZXIgYSB2YWx1ZSBpcyByZXRyaWV2ZWQuXG4vLyBUaGUgZGF0YSBpcyBhIERhdGFWaWV3LlxuZnVuY3Rpb24gUGFyc2VyKGRhdGEsIG9mZnNldCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IDA7XG59XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2hhciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDggPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkMTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNJRCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGMkRvdDE0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KSAvIDE2Mzg0O1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpeGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBleHBvcnRzLmdldEZpeGVkKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN0cmluZyA9ICcnO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gbGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmcoNCk7XG59O1xuXG4vLyBMT05HREFURVRJTUUgaXMgYSA2NC1iaXQgaW50ZWdlci5cbi8vIEphdmFTY3JpcHQgYW5kIHVuaXggdGltZXN0YW1wcyB0cmFkaXRpb25hbGx5IHVzZSAzMiBiaXRzLCBzbyB3ZVxuLy8gb25seSB0YWtlIHRoZSBsYXN0IDMyIGJpdHMuXG4vLyArIFNpbmNlIHVudGlsIDIwMzggdGhvc2UgYml0cyB3aWxsIGJlIGZpbGxlZCBieSB6ZXJvcyB3ZSBjYW4gaWdub3JlIHRoZW0uXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTG9uZ0RhdGVUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBleHBvcnRzLmdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgNCk7XG4gICAgLy8gU3VidHJhY3Qgc2Vjb25kcyBiZXR3ZWVuIDAxLzAxLzE5MDQgYW5kIDAxLzAxLzE5NzBcbiAgICAvLyB0byBjb252ZXJ0IEFwcGxlIE1hYyB0aW1zdGFtcCB0byBTdGFuZGFyZCBVbml4IHRpbWVzdGFtcFxuICAgIHYgLT0gMjA4Mjg0NDgwMDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYWpvciA9IGdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG5cbiAgICAvLyBIb3cgdG8gaW50ZXJwcmV0IHRoZSBtaW5vciB2ZXJzaW9uIGlzIHZlcnkgdmFndWUgaW4gdGhlIHNwZWMuIDB4NTAwMCBpcyA1LCAweDEwMDAgaXMgMVxuICAgIC8vIFRoaXMgcmV0dXJucyB0aGUgY29ycmVjdCBudW1iZXIgaWYgbWlub3IgPSAweE4wMDAgd2hlcmUgTiBpcyAwLTlcbiAgICB2YXIgbWlub3IgPSBnZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyAyKTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIG1ham9yICsgbWlub3IgLyAweDEwMDAgLyAxMDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKHR5cGUsIGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbW91bnQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gdHlwZU9mZnNldHNbdHlwZV0gKiBhbW91bnQ7XG59O1xuXG4vLy8vLyBQYXJzaW5nIGxpc3RzIGFuZCByZWNvcmRzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUGFyc2UgYSBsaXN0IG9mIDE2IGJpdCBpbnRlZ2Vycy4gVGhlIGxlbmd0aCBvZiB0aGUgbGlzdCBjYW4gYmUgcmVhZCBvbiB0aGUgc3RyZWFtXG4vLyBvciBwcm92aWRlZCBhcyBhbiBhcmd1bWVudC5cblBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNkxpc3QgPVxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7IGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpOyB9XG4gICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBvZmZzZXRzW2ldID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiAyO1xuICAgIHJldHVybiBvZmZzZXRzO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgaXRlbXMuXG4gKiBSZWNvcmQgY291bnQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKiBpdGVtQ2FsbGJhY2sgaXMgb25lIG9mIHRoZSBQYXJzZXIgbWV0aG9kcy5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3QgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgaWYgKCFpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgaXRlbUNhbGxiYWNrID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBpdGVtQ2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiByZWNvcmRzLlxuICogUmVjb3JkIGNvdW50IGlzIG9wdGlvbmFsLCBpZiBvbWl0dGVkIGl0IGlzIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICogRXhhbXBsZSBvZiByZWNvcmREZXNjcmlwdGlvbjogeyBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LCBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQgfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUmVjb3JkTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIC8vIElmIHRoZSBjb3VudCBhcmd1bWVudCBpcyBhYnNlbnQsIHJlYWQgaXQgaW4gdGhlIHN0cmVhbS5cbiAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJlY29yZERlc2NyaXB0aW9uID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICB2YXIgcmVjb3JkcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHJlYyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSByZWNvcmREZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgcmVjW2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRzW2ldID0gcmVjO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkcztcbn07XG5cbi8vIFBhcnNlIGEgZGF0YSBzdHJ1Y3R1cmUgaW50byBhbiBvYmplY3Rcbi8vIEV4YW1wbGUgb2YgZGVzY3JpcHRpb246IHsgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0IH1cblBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJ1Y3QgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uLmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgdmFyIHN0cnVjdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSBkZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgc3RydWN0W2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgIH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VQb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc3RydWN0T2Zmc2V0ID0gdGhpcy5wYXJzZU9mZnNldDE2KCk7XG4gICAgaWYgKHN0cnVjdE9mZnNldCA+IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIGluZGVmaW5lZFxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgc3RydWN0T2Zmc2V0KS5wYXJzZVN0cnVjdChkZXNjcmlwdGlvbik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2Ygb2Zmc2V0cyB0byBsaXN0cyBvZiAxNi1iaXQgaW50ZWdlcnMsXG4gKiBvciBhIGxpc3Qgb2Ygb2Zmc2V0cyB0byBsaXN0cyBvZiBvZmZzZXRzIHRvIGFueSBraW5kIG9mIGl0ZW1zLlxuICogSWYgaXRlbUNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZCwgYSBsaXN0IG9mIGxpc3Qgb2YgVVNob3J0IGlzIGFzc3VtZWQuXG4gKiBJZiBwcm92aWRlZCwgaXRlbUNhbGxiYWNrIGlzIGNhbGxlZCBvbiBlYWNoIGl0ZW0gYW5kIG11c3QgcGFyc2UgdGhlIGl0ZW0uXG4gKiBTZWUgZXhhbXBsZXMgaW4gdGFibGVzL2dzdWIuanNcbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3RPZkxpc3RzID0gZnVuY3Rpb24oaXRlbUNhbGxiYWNrKSB7XG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCk7XG4gICAgdmFyIGNvdW50ID0gb2Zmc2V0cy5sZW5ndGg7XG4gICAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbaV07XG4gICAgICAgIGlmIChzdGFydCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgIC8vIE5VTEwgb2Zmc2V0XG4gICAgICAgICAgICBsaXN0W2ldID0gdW5kZWZpbmVkOyAgICAgICAgICAgIC8vIEFkZCBpIGFzIG93bmVkIHByb3BlcnR5IHRvIGxpc3QuIENvbnZlbmllbnQgd2l0aCBhc3NlcnQuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGlmIChpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzdWJPZmZzZXRzID0gdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpO1xuICAgICAgICAgICAgdmFyIHN1Ykxpc3QgPSBuZXcgQXJyYXkoc3ViT2Zmc2V0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJPZmZzZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHN0YXJ0ICsgc3ViT2Zmc2V0c1tqXTtcbiAgICAgICAgICAgICAgICBzdWJMaXN0W2pdID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0W2ldID0gc3ViTGlzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RbaV0gPSB0aGlzLnBhcnNlVVNob3J0TGlzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSByZWxhdGl2ZU9mZnNldDtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8vLy8vIENvbXBsZXggdGFibGVzIHBhcnNpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBQYXJzZSBhIGNvdmVyYWdlIHRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cbi8vIHBhcnNlci5vZmZzZXQgbXVzdCBwb2ludCB0byB0aGUgc3RhcnQgb2YgdGhlIHRhYmxlIGNvbnRhaW5pbmcgdGhlIGNvdmVyYWdlLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvdmVyYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMSxcbiAgICAgICAgICAgIGdseXBoczogdGhpcy5wYXJzZVVTaG9ydExpc3QoY291bnQpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgcmFuZ2VzW2ldID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMucGFyc2VVU2hvcnQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAyLFxuICAgICAgICAgICAgcmFuZ2VzOiByYW5nZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnRPZmZzZXQudG9TdHJpbmcoMTYpICsgJzogQ292ZXJhZ2UgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuLy8gUGFyc2UgYSBDbGFzcyBEZWZpbml0aW9uIFRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cblBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMSxcbiAgICAgICAgICAgIHN0YXJ0R2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAyLFxuICAgICAgICAgICAgcmFuZ2VzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IFBhcnNlci51U2hvcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBQYXJzZXIudVNob3J0LFxuICAgICAgICAgICAgICAgIGNsYXNzSWQ6IFBhcnNlci51U2hvcnRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0T2Zmc2V0LnRvU3RyaW5nKDE2KSArICc6IENsYXNzRGVmIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vLy8vIFN0YXRpYyBtZXRob2RzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUaGVzZSBjb252ZW5pZW5jZSBtZXRob2RzIGNhbiBiZSB1c2VkIGFzIGNhbGxiYWNrcyBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIFwidGhpc1wiIGNvbnRleHQgc2V0IHRvIGEgUGFyc2VyIGluc3RhbmNlLlxuXG5QYXJzZXIubGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChjb3VudCwgaXRlbUNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnJlY29yZExpc3QgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVjb3JkTGlzdChjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIucG9pbnRlciA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoZGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIudGFnID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZztcblBhcnNlci5ieXRlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5QYXJzZXIudVNob3J0ID0gUGFyc2VyLm9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci51U2hvcnRMaXN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3Q7XG5QYXJzZXIuc3RydWN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cnVjdDtcblBhcnNlci5jb3ZlcmFnZSA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VDb3ZlcmFnZTtcblBhcnNlci5jbGFzc0RlZiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlZjtcblxuLy8vLy8gU2NyaXB0LCBGZWF0dXJlLCBMb29rdXAgbGlzdHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG5cbnZhciBsYW5nU3lzVGFibGUgPSB7XG4gICAgcmVzZXJ2ZWQ6IFBhcnNlci51U2hvcnQsXG4gICAgcmVxRmVhdHVyZUluZGV4OiBQYXJzZXIudVNob3J0LFxuICAgIGZlYXR1cmVJbmRleGVzOiBQYXJzZXIudVNob3J0TGlzdFxufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNjcmlwdExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgIHNjcmlwdDogUGFyc2VyLnBvaW50ZXIoe1xuICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IFBhcnNlci5wb2ludGVyKGxhbmdTeXNUYWJsZSksXG4gICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICAgICAgICAgIHRhZzogUGFyc2VyLnRhZyxcbiAgICAgICAgICAgICAgICBsYW5nU3lzOiBQYXJzZXIucG9pbnRlcihsYW5nU3lzVGFibGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH0pKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGZWF0dXJlTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIucmVjb3JkTGlzdCh7XG4gICAgICAgIHRhZzogUGFyc2VyLnRhZyxcbiAgICAgICAgZmVhdHVyZTogUGFyc2VyLnBvaW50ZXIoe1xuICAgICAgICAgICAgZmVhdHVyZVBhcmFtczogUGFyc2VyLm9mZnNldDE2LFxuICAgICAgICAgICAgbG9va3VwTGlzdEluZGV4ZXM6IFBhcnNlci51U2hvcnRMaXN0XG4gICAgICAgIH0pXG4gICAgfSkpO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvb2t1cExpc3QgPSBmdW5jdGlvbihsb29rdXBUYWJsZVBhcnNlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmxpc3QoUGFyc2VyLnBvaW50ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb29rdXBUeXBlID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjaGVjay5hcmd1bWVudCgxIDw9IGxvb2t1cFR5cGUgJiYgbG9va3VwVHlwZSA8PSA4LCAnR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVHlwZSArICcgdW5rbm93bi4nKTtcbiAgICAgICAgdmFyIGxvb2t1cEZsYWcgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICAgICAgbG9va3VwRmxhZzogbG9va3VwRmxhZyxcbiAgICAgICAgICAgIHN1YnRhYmxlczogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIobG9va3VwVGFibGVQYXJzZXJzW2xvb2t1cFR5cGVdKSksXG4gICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gdGhpcy5wYXJzZVVTaG9ydCgpIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfSkpKTtcbn07XG5cbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy9wYXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gUnVuLXRpbWUgY2hlY2tpbmcgb2YgcHJlY29uZGl0aW9ucy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmZhaWwgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufTtcblxuLy8gUHJlY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBnaXZlbiBwcmVkaWNhdGUgaXMgdHJ1ZS5cbi8vIElmIG5vdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbmV4cG9ydHMuYXJndW1lbnQgPSBmdW5jdGlvbihwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICBleHBvcnRzLmZhaWwobWVzc2FnZSk7XG4gICAgfVxufTtcblxuLy8gUHJlY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gaXMgdHJ1ZS5cbi8vIElmIG5vdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbmV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5hcmd1bWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvY2hlY2suanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGFibGUgbWV0YWRhdGFcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJyk7XG52YXIgZW5jb2RlID0gcmVxdWlyZSgnLi90eXBlcycpLmVuY29kZTtcbnZhciBzaXplT2YgPSByZXF1aXJlKCcuL3R5cGVzJykuc2l6ZU9mO1xuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5UYWJsZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFibGVOYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVGFibGUodGFibGVOYW1lLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9IGZpZWxkLnZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25LZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgayA9IG9wdGlvbktleXNbaV07XG4gICAgICAgICAgICB2YXIgdiA9IG9wdGlvbnNba107XG4gICAgICAgICAgICBpZiAodGhpc1trXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogRW5jb2RlcyB0aGUgdGFibGUgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYnl0ZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5UYWJsZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGVuY29kZS5UQUJMRSh0aGlzKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0YWJsZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuVGFibGUucHJvdG90eXBlLnNpemVPZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzaXplT2YuVEFCTEUodGhpcyk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVzaG9ydExpc3QoaXRlbU5hbWUsIGxpc3QsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY291bnQgPSBsaXN0Lmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGZpZWxkcyA9IG5ldyBBcnJheShsaXN0Lmxlbmd0aCArIDEpO1xuICAgIGZpZWxkc1swXSA9IHtuYW1lOiBpdGVtTmFtZSArICdDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogY291bnR9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmaWVsZHNbaSArIDFdID0ge25hbWU6IGl0ZW1OYW1lICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsaXN0W2ldfTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0YWJsZUxpc3QoaXRlbU5hbWUsIHJlY29yZHMsIGl0ZW1DYWxsYmFjaykge1xuICAgIHZhciBjb3VudCA9IHJlY29yZHMubGVuZ3RoO1xuICAgIHZhciBmaWVsZHMgPSBuZXcgQXJyYXkoY291bnQgKyAxKTtcbiAgICBmaWVsZHNbMF0gPSB7bmFtZTogaXRlbU5hbWUgKyAnQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGNvdW50fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgZmllbGRzW2kgKyAxXSA9IHtuYW1lOiBpdGVtTmFtZSArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBpdGVtQ2FsbGJhY2socmVjb3Jkc1tpXSwgaSl9O1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29yZExpc3QoaXRlbU5hbWUsIHJlY29yZHMsIGl0ZW1DYWxsYmFjaykge1xuICAgIHZhciBjb3VudCA9IHJlY29yZHMubGVuZ3RoO1xuICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICBmaWVsZHNbMF0gPSB7bmFtZTogaXRlbU5hbWUgKyAnQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGNvdW50fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgZmllbGRzID0gZmllbGRzLmNvbmNhdChpdGVtQ2FsbGJhY2socmVjb3Jkc1tpXSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG4vLyBDb21tb24gTGF5b3V0IFRhYmxlc1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkNvdmVyYWdlXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG9wZW50eXBlLlRhYmxlXG4gKi9cbmZ1bmN0aW9uIENvdmVyYWdlKGNvdmVyYWdlVGFibGUpIHtcbiAgICBpZiAoY292ZXJhZ2VUYWJsZS5mb3JtYXQgPT09IDEpIHtcbiAgICAgICAgVGFibGUuY2FsbCh0aGlzLCAnY292ZXJhZ2VUYWJsZScsXG4gICAgICAgICAgICBbe25hbWU6ICdjb3ZlcmFnZUZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX1dXG4gICAgICAgICAgICAuY29uY2F0KHVzaG9ydExpc3QoJ2dseXBoJywgY292ZXJhZ2VUYWJsZS5nbHlwaHMpKVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJ0NhblxcJ3QgY3JlYXRlIGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAyIHlldC4nKTtcbiAgICB9XG59XG5Db3ZlcmFnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5Db3ZlcmFnZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb3ZlcmFnZTtcblxuZnVuY3Rpb24gU2NyaXB0TGlzdChzY3JpcHRMaXN0VGFibGUpIHtcbiAgICBUYWJsZS5jYWxsKHRoaXMsICdzY3JpcHRMaXN0VGFibGUnLFxuICAgICAgICByZWNvcmRMaXN0KCdzY3JpcHRSZWNvcmQnLCBzY3JpcHRMaXN0VGFibGUsIGZ1bmN0aW9uKHNjcmlwdFJlY29yZCwgaSkge1xuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IHNjcmlwdFJlY29yZC5zY3JpcHQ7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdExhbmdTeXMgPSBzY3JpcHQuZGVmYXVsdExhbmdTeXM7XG4gICAgICAgICAgICBjaGVjay5hc3NlcnQoISFkZWZhdWx0TGFuZ1N5cywgJ1VuYWJsZSB0byB3cml0ZSBHU1VCOiBzY3JpcHQgJyArIHNjcmlwdFJlY29yZC50YWcgKyAnIGhhcyBubyBkZWZhdWx0IGxhbmd1YWdlIHN5c3RlbS4nKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdzY3JpcHRUYWcnICsgaSwgdHlwZTogJ1RBRycsIHZhbHVlOiBzY3JpcHRSZWNvcmQudGFnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3NjcmlwdCcgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdzY3JpcHRUYWJsZScsIFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdkZWZhdWx0TGFuZ1N5cycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ2RlZmF1bHRMYW5nU3lzJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsb29rdXBPcmRlcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ3JlcUZlYXR1cmVJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZGVmYXVsdExhbmdTeXMucmVxRmVhdHVyZUluZGV4fV1cbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQodXNob3J0TGlzdCgnZmVhdHVyZUluZGV4JywgZGVmYXVsdExhbmdTeXMuZmVhdHVyZUluZGV4ZXMpKSl9XG4gICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHJlY29yZExpc3QoJ2xhbmdTeXMnLCBzY3JpcHQubGFuZ1N5c1JlY29yZHMsIGZ1bmN0aW9uKGxhbmdTeXNSZWNvcmQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzID0gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xhbmdTeXNUYWcnICsgaSwgdHlwZTogJ1RBRycsIHZhbHVlOiBsYW5nU3lzUmVjb3JkLnRhZ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsYW5nU3lzJyArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ2xhbmdTeXMnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbG9va3VwT3JkZXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ3JlcUZlYXR1cmVJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGFuZ1N5cy5yZXFGZWF0dXJlSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHVzaG9ydExpc3QoJ2ZlYXR1cmVJbmRleCcsIGxhbmdTeXMuZmVhdHVyZUluZGV4ZXMpKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9KSkpfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICApO1xufVxuU2NyaXB0TGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5TY3JpcHRMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjcmlwdExpc3Q7XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuRmVhdHVyZUxpc3RcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtvcGVudHlwZS5UYWJsZX1cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgb3BlbnR5cGUuVGFibGVcbiAqL1xuZnVuY3Rpb24gRmVhdHVyZUxpc3QoZmVhdHVyZUxpc3RUYWJsZSkge1xuICAgIFRhYmxlLmNhbGwodGhpcywgJ2ZlYXR1cmVMaXN0VGFibGUnLFxuICAgICAgICByZWNvcmRMaXN0KCdmZWF0dXJlUmVjb3JkJywgZmVhdHVyZUxpc3RUYWJsZSwgZnVuY3Rpb24oZmVhdHVyZVJlY29yZCwgaSkge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAnZmVhdHVyZVRhZycgKyBpLCB0eXBlOiAnVEFHJywgdmFsdWU6IGZlYXR1cmVSZWNvcmQudGFnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2ZlYXR1cmUnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnZmVhdHVyZVRhYmxlJywgW1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2ZlYXR1cmVQYXJhbXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGZlYXR1cmUuZmVhdHVyZVBhcmFtc30sXG4gICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHVzaG9ydExpc3QoJ2xvb2t1cExpc3RJbmRleCcsIGZlYXR1cmUubG9va3VwTGlzdEluZGV4ZXMpKSl9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICk7XG59XG5GZWF0dXJlTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5GZWF0dXJlTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGZWF0dXJlTGlzdDtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Mb29rdXBMaXN0XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgb3BlbnR5cGUuVGFibGVcbiAqL1xuZnVuY3Rpb24gTG9va3VwTGlzdChsb29rdXBMaXN0VGFibGUsIHN1YnRhYmxlTWFrZXJzKSB7XG4gICAgVGFibGUuY2FsbCh0aGlzLCAnbG9va3VwTGlzdFRhYmxlJywgdGFibGVMaXN0KCdsb29rdXAnLCBsb29rdXBMaXN0VGFibGUsIGZ1bmN0aW9uKGxvb2t1cFRhYmxlKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZUNhbGxiYWNrID0gc3VidGFibGVNYWtlcnNbbG9va3VwVGFibGUubG9va3VwVHlwZV07XG4gICAgICAgIGNoZWNrLmFzc2VydCghIXN1YnRhYmxlQ2FsbGJhY2ssICdVbmFibGUgdG8gd3JpdGUgR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVGFibGUubG9va3VwVHlwZSArICcgdGFibGVzLicpO1xuICAgICAgICByZXR1cm4gbmV3IFRhYmxlKCdsb29rdXBUYWJsZScsIFtcbiAgICAgICAgICAgIHtuYW1lOiAnbG9va3VwVHlwZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbG9va3VwVGFibGUubG9va3VwVHlwZX0sXG4gICAgICAgICAgICB7bmFtZTogJ2xvb2t1cEZsYWcnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxvb2t1cFRhYmxlLmxvb2t1cEZsYWd9XG4gICAgICAgIF0uY29uY2F0KHRhYmxlTGlzdCgnc3VidGFibGUnLCBsb29rdXBUYWJsZS5zdWJ0YWJsZXMsIHN1YnRhYmxlQ2FsbGJhY2spKSk7XG4gICAgfSkpO1xufVxuTG9va3VwTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5Mb29rdXBMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvb2t1cExpc3Q7XG5cbi8vIFJlY29yZCA9IHNhbWUgYXMgVGFibGUsIGJ1dCBpbmxpbmVkIChhIFRhYmxlIGhhcyBhbiBvZmZzZXQgYW5kIGl0cyBkYXRhIGlzIGZ1cnRoZXIgaW4gdGhlIHN0cmVhbSlcbi8vIERvbid0IHVzZSBvZmZzZXRzIGluc2lkZSBSZWNvcmRzIChwcm9iYWJsZSBidWcpLCBvbmx5IGluIFRhYmxlcy5cbmV4cG9ydHMuUmVjb3JkID0gZXhwb3J0cy5UYWJsZSA9IFRhYmxlO1xuZXhwb3J0cy5Db3ZlcmFnZSA9IENvdmVyYWdlO1xuZXhwb3J0cy5TY3JpcHRMaXN0ID0gU2NyaXB0TGlzdDtcbmV4cG9ydHMuRmVhdHVyZUxpc3QgPSBGZWF0dXJlTGlzdDtcbmV4cG9ydHMuTG9va3VwTGlzdCA9IExvb2t1cExpc3Q7XG5cbmV4cG9ydHMudXNob3J0TGlzdCA9IHVzaG9ydExpc3Q7XG5leHBvcnRzLnRhYmxlTGlzdCA9IHRhYmxlTGlzdDtcbmV4cG9ydHMucmVjb3JkTGlzdCA9IHJlY29yZExpc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL3RhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBxdW90ICAgID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24oc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSlcbiAgICAsIHAxID0gJzwnICsgdGFnO1xuICBpZihhdHRyaWJ1dGUgIT09ICcnKXAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgZXhlYyl7XG4gIHZhciBPID0ge307XG4gIE9bTkFNRV0gPSBleGVjKGNyZWF0ZUhUTUwpO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uKCl7fSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFzYyAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSwgJGNyZWF0ZSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVhcbiAgICAsIGNyZWF0ZSAgICAgICAgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QoJHRoaXMpXG4gICAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IFR1cGxlIGZyb20gJy4vLi4vY29yZS9UdXBsZS5qcyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vRXZlbnRzLmpzJztcblxuY29uc3QgVU5JVF9UWVBFUyA9IHtcbiAgICBQSVhFTFM6IFN5bWJvbCgnVU5JVF9UWVBFX1BJWEVMUycpLFxuICAgIFBFUkNFTlRBR0U6IFN5bWJvbCgnVU5JVF9UWVBFX1BFUkNFTlRBR0UnKSxcbiAgICBVTlNVUFBPUlRFRDogU3ltYm9sKCdVTklUX1RZUEVfVU5TVVBQT1JURUQnKSxcbn07XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBwb2ludCBpbiBhIDJEIHNwYWNlLlxuICpcbiAqIEBjbGFzcyBQb2ludFxuICovXG5leHBvcnQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBUdXBsZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBQb2ludCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgcHJvdmlkZWQgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZyb21Qb2ludFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIGNvcHkuXG4gICAgICogQHJldHVybnMge1BvaW50fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBvaW50KHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHhWYWx1ZSA9IHBvaW50LnhVbml0cyA9PT0gUG9pbnQuVU5JVF9UWVBFX1BFUkNFTlRBR0UgPyAocG9pbnQueCAqIDEwMCkgKyAnJScgOiBwb2ludC54O1xuICAgICAgICBjb25zdCB5VmFsdWUgPSBwb2ludC55VW5pdHMgPT09IFBvaW50LlVOSVRfVFlQRV9QRVJDRU5UQUdFID8gKHBvaW50LnkgKiAxMDApICsgJyUnIDogcG9pbnQueTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4VmFsdWUsIHlWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhZyB1c2VkIHRvIGRlZmluZSB0aGF0IHRoaXMgcG9pbnQgdXNlcyBwaXhlbHMgYXMgaXRzIHVuaXRzLlxuICAgICAqXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFVOSVRfVFlQRV9QSVhFTFMoKSB7XG4gICAgICAgIHJldHVybiBVTklUX1RZUEVTLlBJWEVMUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGFnIHVzZWQgdG8gZGVmaW5lIHRoYXQgdGhpcyBwb2ludCB1c2VzIHBlcmNlbnRhZ2VzIGFzIGl0cyB1bml0cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTeW1ib2x9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBVTklUX1RZUEVfUEVSQ0VOVEFHRSgpIHtcbiAgICAgICAgcmV0dXJuIFVOSVRfVFlQRVMuUEVSQ0VOVEFHRTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGFnIHVzZWQgdG8gZGVmaW5lIHVuc3VwcG9ydGVkIG1lYXN1cmVtZW50IHVuaXRzLlxuICAgICAqXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFVOSVRfVFlQRV9VTlNVUFBPUlRFRCgpIHtcbiAgICAgICAgcmV0dXJuIFVOSVRfVFlQRVMuVU5TVVBQT1JURUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yIFBvaW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyPX0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhpcyBwb2ludC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXI9fSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGlzIHBvaW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCkge1xuICAgICAgICBzdXBlcigwLCAwKTtcbiAgICAgICAgdGhpcy5tVW5pdHNUeXBlWCA9IFVOSVRfVFlQRVMuVU5TVVBQT1JURUQ7XG4gICAgICAgIHRoaXMubVVuaXRzVHlwZVkgPSBVTklUX1RZUEVTLlVOU1VQUE9SVEVEO1xuICAgICAgICB0aGlzLl9hc3NpZ25WYWx1ZSh4LCAndmFsdWUxJywgJ21Vbml0c1R5cGVYJyk7XG4gICAgICAgIHRoaXMuX2Fzc2lnblZhbHVlKHksICd2YWx1ZTInLCAnbVVuaXRzVHlwZVknKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1Vbml0c1R5cGVYO1xuICAgICAgICBkZWxldGUgdGhpcy5tVW5pdHNUeXBlWTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFggY29vcmRpbmF0ZSBvZiB0aGlzIHBvaW50LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ8U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgWCBjb29yZGluYXRlIG9mIHRoaXMgcG9pbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAtIFRoZSBuZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHNldCB4KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9hc3NpZ25WYWx1ZSh2YWx1ZSwgJ3ZhbHVlMScsICdtVW5pdHNUeXBlWCcpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMsIHRoaXMudmFsdWUxLCB0aGlzLnZhbHVlMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5pdHMgdHlwZSB0aGF0IHRoZSB4IHZhbHVlIHVzZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3ltYm9sfVxuICAgICAqL1xuICAgIGdldCB4VW5pdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1Vbml0c1R5cGVYO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVuaXRzIHR5cGUgZm9yIHRoZSB4IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHZhbHVlIC0gVGhlIG5ldyB1bml0cyB0eXBlLlxuICAgICAqL1xuICAgIHNldCB4VW5pdHModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLm1Vbml0c1R5cGVYKSB7XG4gICAgICAgICAgICB0aGlzLm1Vbml0c1R5cGVYID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBZIGNvb3JkaW5hdGUgb2YgdGhpcyBwb2ludC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfFN0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFkgY29vcmRpbmF0ZSBvZiB0aGlzIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAtIFRoZSBuZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHNldCB5KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9hc3NpZ25WYWx1ZSh2YWx1ZSwgJ3ZhbHVlMicsICdtVW5pdHNUeXBlWScpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMsIHRoaXMudmFsdWUxLCB0aGlzLnZhbHVlMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5pdHMgdHlwZSB0aGF0IHRoZSB5IHZhbHVlIHVzZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3ltYm9sfVxuICAgICAqL1xuICAgIGdldCB5VW5pdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1Vbml0c1R5cGVZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVuaXRzIHR5cGUgZm9yIHRoZSB5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHZhbHVlIC0gVGhlIG5ldyB1bml0cyB0eXBlLlxuICAgICAqL1xuICAgIHNldCB5VW5pdHModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLm1Vbml0c1R5cGVZKSB7XG4gICAgICAgICAgICB0aGlzLm1Vbml0c1R5cGVZID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBYIGFuZCBZIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30geCAtIFRoZSBuZXcgWCBjb29yZGluYXRlIGZvciB0aGlzIHBvaW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30geSAtIFRoZSBuZXcgWSBjb29yZGluYXRlIGZvciB0aGlzIHBvaW50LlxuICAgICAqL1xuICAgIHNldCh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRYID0gdGhpcy5fYXNzaWduVmFsdWUoeCwgJ3ZhbHVlMScsICdtVW5pdHNUeXBlWCcpO1xuICAgICAgICBjb25zdCBjaGFuZ2VkWSA9IHRoaXMuX2Fzc2lnblZhbHVlKHksICd2YWx1ZTInLCAnbVVuaXRzVHlwZVknKTtcbiAgICAgICAgaWYgKGNoYW5nZWRYIHx8IGNoYW5nZWRZKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMsIHRoaXMudmFsdWUxLCB0aGlzLnZhbHVlMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBYIGFuZCBZIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgdXNpbmcgdGhlIHByb3ZpZGVkIHBvaW50IGFzIHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0RnJvbVBvaW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBzZXRGcm9tUG9pbnQocG9pbnQpIHtcbiAgICAgICAgaWYgKHBvaW50LnggIT09IHRoaXMudmFsdWUxIHx8IHBvaW50LnkgIT09IHRoaXMudmFsdWUyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlMSA9IHBvaW50Lng7XG4gICAgICAgICAgICB0aGlzLnZhbHVlMiA9IHBvaW50Lnk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMsIHRoaXMudmFsdWUxLCB0aGlzLnZhbHVlMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBwYXNzZWQgcG9pbnQgdG8gdGhpcyBwb2ludC4gVGhlIHJlc3VsdCBpcyBzYXZlZCBpbiB0aGlzIHBvaW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIFRoZSBwb2ludCB0byBhZGQuXG4gICAgICovXG4gICAgYWRkKHBvaW50KSB7XG4gICAgICAgIGlmIChwb2ludC52YWx1ZTEgIT09IDAgfHwgcG9pbnQudmFsdWUyICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlMSArPSBwb2ludC52YWx1ZTE7XG4gICAgICAgICAgICB0aGlzLnZhbHVlMiArPSBwb2ludC52YWx1ZTI7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMsIHRoaXMudmFsdWUxLCB0aGlzLnZhbHVlMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIHBhc3NlZCBwb2ludCBmcm9tIHRoaXMgcG9pbnQuIFRoZSByZXN1bHQgaXMgc2F2ZWQgaW4gdGhpcyBwb2ludC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc3VidHJhY3RcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIFRoZSBwb2ludCB0byBzdWJ0cmFjdC5cbiAgICAgKi9cbiAgICBzdWJ0cmFjdChwb2ludCkge1xuICAgICAgICBpZiAocG9pbnQudmFsdWUxICE9PSAwIHx8IHBvaW50LnZhbHVlMiAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZTEgLT0gcG9pbnQudmFsdWUxO1xuICAgICAgICAgICAgdGhpcy52YWx1ZTIgLT0gcG9pbnQudmFsdWUyO1xuICAgICAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5HRU9NRVRSWV9WQUxVRV9DSEFOR0VELCB0aGlzLCB0aGlzLnZhbHVlMSwgdGhpcy52YWx1ZTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgdGhlIGNvcGllZCBwb2ludC5cbiAgICAgKiBOT1RFOiBUaGUgcmVzdWx0aW5nIHBvaW50IGlzIHJldHVybmVkIGFzIGFuIGF1dG8gcmVsZWFzZWQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICogQHJldHVybnMge1BvaW50fVxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gKG5ldyBQb2ludCh0aGlzLnZhbHVlMSwgdGhpcy52YWx1ZTIpKS5hdXRvcmVsZWFzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBwcm9wZXJ0eSB3aXRoIGB2YWx1ZVByb3BlcnR5YCBuYW1lIGFuZCBjaGFuZ2VzIHRoZSB1bml0IHR5cGUgaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfYXNzaWduVmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVQcm9wZXJ0eSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBpbiB0aGlzIG9iamVjdCB3aGVyZSB0aGUgdmFsdWUgd2lsbCBiZSBzdG9yZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVuaXRzUHJvcGVydHkgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgaW4gdGhpcyBvYmplY3Qgd2hlcmUgdGhlIHVuaXQgdHlwZSBvZiB0aGUgdmFsdWUgc2hvdWxkIGJlIHN0b3JlZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHZhbHVlIG9yIGl0cyB1bml0cyBjaGFuZ2VkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Fzc2lnblZhbHVlKHZhbHVlLCB2YWx1ZVByb3BlcnR5LCB1bml0c1Byb3BlcnR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgbGV0IG51bWJlclN0cmluZyA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvKiBjaGVjayB0aGUgbnVtYmVyIHR5cGUgKi9cbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyID0gbnVtYmVyU3RyaW5nW251bWJlclN0cmluZy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxldCB1bml0c1R5cGU7XG4gICAgICAgICAgICBpZiAobGFzdENoYXIgPT09ICclJykge1xuICAgICAgICAgICAgICAgIHVuaXRzVHlwZSA9IFVOSVRfVFlQRVMuUEVSQ0VOVEFHRTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHBhcnNlRmxvYXQobnVtYmVyU3RyaW5nLnNsaWNlKDAsIC0xKSkgLyAxMDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RDaGFyID09PSAneCcgJiYgbnVtYmVyU3RyaW5nW251bWJlclN0cmluZy5sZW5ndGggLSAyXSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgdW5pdHNUeXBlID0gVU5JVF9UWVBFUy5QSVhFTFM7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBwYXJzZUZsb2F0KG51bWJlclN0cmluZy5zbGljZSgwLCAtMikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4ocGFyc2VJbnQobGFzdENoYXIsIDEwKSkpIHtcbiAgICAgICAgICAgICAgICB1bml0c1R5cGUgPSBVTklUX1RZUEVTLlBJWEVMUztcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHBhcnNlRmxvYXQobnVtYmVyU3RyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzTmFOKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHZhbHVlOiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IHRoaXNbdmFsdWVQcm9wZXJ0eV0gfHwgdW5pdHNUeXBlICE9PSB0aGlzW3VuaXRzUHJvcGVydHldKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t2YWx1ZVByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXNbdW5pdHNQcm9wZXJ0eV0gPSB1bml0c1R5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHRoaXNbdmFsdWVQcm9wZXJ0eV0gfHwgdGhpc1t1bml0c1Byb3BlcnR5XSAhPT0gVU5JVF9UWVBFUy5QSVhFTFMpIHtcbiAgICAgICAgICAgIHRoaXNbdmFsdWVQcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXNbdW5pdHNQcm9wZXJ0eV0gPSBVTklUX1RZUEVTLlBJWEVMUztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvaW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvZ2VvbWV0cnkvUG9pbnQuanMiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jdHguanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXAgICAgID0gcmVxdWlyZSgnLi9lczYubWFwJylcbiAgLCAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaGFyZWQgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ21ldGFkYXRhJylcbiAgLCBzdG9yZSAgID0gc2hhcmVkLnN0b3JlIHx8IChzaGFyZWQuc3RvcmUgPSBuZXcgKHJlcXVpcmUoJy4vZXM2LndlYWstbWFwJykpKTtcblxudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldEtleSwgY3JlYXRlKXtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIGlmKCF0YXJnZXRNZXRhZGF0YSl7XG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gdW5kZWZpbmVkO1xuICAgIHN0b3JlLnNldCh0YXJnZXQsIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCk7XG4gIH1cbiAgdmFyIGtleU1ldGFkYXRhID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KHRhcmdldEtleSk7XG4gIGlmKCFrZXlNZXRhZGF0YSl7XG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRhcmdldE1ldGFkYXRhLnNldCh0YXJnZXRLZXksIGtleU1ldGFkYXRhID0gbmV3IE1hcCk7XG4gIH0gcmV0dXJuIGtleU1ldGFkYXRhO1xufTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCl7XG4gIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgdHJ1ZSkuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbn07XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldEtleSl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCB0YXJnZXRLZXksIGZhbHNlKVxuICAgICwga2V5cyAgICAgICAgPSBbXTtcbiAgaWYobWV0YWRhdGFNYXApbWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbihfLCBrZXkpeyBrZXlzLnB1c2goa2V5KTsgfSk7XG4gIHJldHVybiBrZXlzO1xufTtcbnZhciB0b01ldGFLZXkgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG52YXIgZXhwID0gZnVuY3Rpb24oTyl7XG4gICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIE8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0b3JlOiBzdG9yZSxcbiAgbWFwOiBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwLFxuICBoYXM6IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEsXG4gIGdldDogb3JkaW5hcnlHZXRPd25NZXRhZGF0YSxcbiAgc2V0OiBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhLFxuICBrZXlzOiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAga2V5OiB0b01ldGFLZXksXG4gIGV4cDogZXhwXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKXtcbiAgdmFyIExJQlJBUlkgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgICAsIGdsb2JhbCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAgICwgZmFpbHMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgICAsICRleHBvcnQgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAgICwgJHR5cGVkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgICAsICRidWZmZXIgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAgICwgY3R4ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICAgLCBhbkluc3RhbmNlICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAgICwgcHJvcGVydHlEZXNjICAgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAgICwgaGlkZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAgICwgcmVkZWZpbmVBbGwgICAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICAgLCB0b0ludGVnZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICAgLCB0b0xlbmd0aCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgICAsIHRvSW5kZXggICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICAgLCB0b1ByaW1pdGl2ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgICAsIGhhcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAgICwgc2FtZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKVxuICAgICwgY2xhc3NvZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAgICwgaXNPYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICAgLCB0b09iamVjdCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgICAsIGlzQXJyYXlJdGVyICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgICAsIGNyZWF0ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgICAsIGdldFByb3RvdHlwZU9mICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgICAsIGdPUE4gICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgICAsIGdldEl0ZXJGbiAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICAgLCB1aWQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgICAsIHdrcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAgICwgY3JlYXRlQXJyYXlNZXRob2QgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKVxuICAgICwgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJylcbiAgICAsIHNwZWNpZXNDb25zdHJ1Y3RvciAgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgICAsIEFycmF5SXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICAgLCBJdGVyYXRvcnMgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgICAsICRpdGVyRGV0ZWN0ICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpXG4gICAgLCBzZXRTcGVjaWVzICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAgICwgYXJyYXlGaWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAgICwgYXJyYXlDb3B5V2l0aGluICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJylcbiAgICAsICREUCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAgICwgJEdPUEQgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgICAsIGRQICAgICAgICAgICAgICAgICAgPSAkRFAuZlxuICAgICwgZ09QRCAgICAgICAgICAgICAgICA9ICRHT1BELmZcbiAgICAsIFJhbmdlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAgICwgVHlwZUVycm9yICAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgICAsIFVpbnQ4QXJyYXkgICAgICAgICAgPSBnbG9iYWwuVWludDhBcnJheVxuICAgICwgQVJSQVlfQlVGRkVSICAgICAgICA9ICdBcnJheUJ1ZmZlcidcbiAgICAsIFNIQVJFRF9CVUZGRVIgICAgICAgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUlxuICAgICwgQllURVNfUEVSX0VMRU1FTlQgICA9ICdCWVRFU19QRVJfRUxFTUVOVCdcbiAgICAsIFBST1RPVFlQRSAgICAgICAgICAgPSAncHJvdG90eXBlJ1xuICAgICwgQXJyYXlQcm90byAgICAgICAgICA9IEFycmF5W1BST1RPVFlQRV1cbiAgICAsICRBcnJheUJ1ZmZlciAgICAgICAgPSAkYnVmZmVyLkFycmF5QnVmZmVyXG4gICAgLCAkRGF0YVZpZXcgICAgICAgICAgID0gJGJ1ZmZlci5EYXRhVmlld1xuICAgICwgYXJyYXlGb3JFYWNoICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDApXG4gICAgLCBhcnJheUZpbHRlciAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMilcbiAgICAsIGFycmF5U29tZSAgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgzKVxuICAgICwgYXJyYXlFdmVyeSAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpXG4gICAgLCBhcnJheUZpbmQgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgICAsIGFycmF5RmluZEluZGV4ICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg2KVxuICAgICwgYXJyYXlJbmNsdWRlcyAgICAgICA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSlcbiAgICAsIGFycmF5SW5kZXhPZiAgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKVxuICAgICwgYXJyYXlWYWx1ZXMgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLnZhbHVlc1xuICAgICwgYXJyYXlLZXlzICAgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLmtleXNcbiAgICAsIGFycmF5RW50cmllcyAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzXG4gICAgLCBhcnJheUxhc3RJbmRleE9mICAgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZlxuICAgICwgYXJyYXlSZWR1Y2UgICAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlXG4gICAgLCBhcnJheVJlZHVjZVJpZ2h0ICAgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodFxuICAgICwgYXJyYXlKb2luICAgICAgICAgICA9IEFycmF5UHJvdG8uam9pblxuICAgICwgYXJyYXlTb3J0ICAgICAgICAgICA9IEFycmF5UHJvdG8uc29ydFxuICAgICwgYXJyYXlTbGljZSAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2VcbiAgICAsIGFycmF5VG9TdHJpbmcgICAgICAgPSBBcnJheVByb3RvLnRvU3RyaW5nXG4gICAgLCBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZ1xuICAgICwgSVRFUkFUT1IgICAgICAgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAgICwgVEFHICAgICAgICAgICAgICAgICA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAgICwgVFlQRURfQ09OU1RSVUNUT1IgICA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKVxuICAgICwgREVGX0NPTlNUUlVDVE9SICAgICA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJylcbiAgICAsIEFMTF9DT05TVFJVQ1RPUlMgICAgPSAkdHlwZWQuQ09OU1RSXG4gICAgLCBUWVBFRF9BUlJBWSAgICAgICAgID0gJHR5cGVkLlRZUEVEXG4gICAgLCBWSUVXICAgICAgICAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgICAsIFdST05HX0xFTkdUSCAgICAgICAgPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbihPLCBsZW5ndGgpe1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgc3RyaWN0VG9MZW5ndGggPSBmdW5jdGlvbihpdCwgU0FNRSl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB2YXIgbnVtYmVyID0gK2l0XG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0KTtcbiAgICBpZihTQU1FICYmICFzYW1lKG51bWJlciwgbGVuZ3RoKSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbihpdCwgQllURVMpe1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oaXQpe1xuICAgIGlmKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdClyZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbihDLCBsZW5ndGgpe1xuICAgIGlmKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbihPLCBsaXN0KXtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uKEMsIGxpc3Qpe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24oaXQsIGtleSwgaW50ZXJuYWwpe1xuICAgIGRQKGl0LCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfX0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qLCBtYXBmbiwgdGhpc0FyZyAqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChzb3VyY2UpXG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspe1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYobWFwcGluZyAmJiBhTGVuID4gMiltYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKXtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qLi4uaXRlbXMqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uKCl7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpe1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiwgZW5kICovKXtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0LCBlbmQgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pe1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiwgaW5pdGlhbFZhbHVlICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpe1xuICAgICAgdmFyIHRoYXQgICA9IHRoaXNcbiAgICAgICAgLCBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGhcbiAgICAgICAgLCBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpXG4gICAgICAgICwgaW5kZXggID0gMFxuICAgICAgICAsIHZhbHVlO1xuICAgICAgd2hpbGUoaW5kZXggPCBtaWRkbGUpe1xuICAgICAgICB2YWx1ZSAgICAgICAgID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdICA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCl7XG4gICAgICB2YXIgTyAgICAgID0gdmFsaWRhdGUodGhpcylcbiAgICAgICAgLCBsZW5ndGggPSBPLmxlbmd0aFxuICAgICAgICAsICRiZWdpbiA9IHRvSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyosIG9mZnNldCAqLyl7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSlcbiAgICAgICwgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICAgICwgc3JjICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aChzcmMubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIGlmKGxlbiArIG9mZnNldCA+IGxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUoaW5kZXggPCBsZW4pdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpe1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKXtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpe1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24odGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSl7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKXtcbiAgICBpZihpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKXtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYoIUFMTF9DT05TVFJVQ1RPUlMpe1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiAgID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICAgICAgICAgICAkc2V0RGVzY1xuICB9KTtcblxuICBpZihmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSl7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICAgICAgICAgICRzbGljZSxcbiAgICBzZXQ6ICAgICAgICAgICAgJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogICAgZnVuY3Rpb24oKXsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiAgICAgICBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKXtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FICAgICAgID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknXG4gICAgICAsIElTTlRfVUlOVDggPSBOQU1FICE9ICdVaW50OEFycmF5J1xuICAgICAgLCBHRVRURVIgICAgID0gJ2dldCcgKyBLRVlcbiAgICAgICwgU0VUVEVSICAgICA9ICdzZXQnICsgS0VZXG4gICAgICAsIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV1cbiAgICAgICwgQmFzZSAgICAgICA9IFR5cGVkQXJyYXkgfHwge31cbiAgICAgICwgVEFDICAgICAgICA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSlcbiAgICAgICwgRk9SQ0VEICAgICA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWXG4gICAgICAsIE8gICAgICAgICAgPSB7fVxuICAgICAgLCBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCwgdmFsdWUpe1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYoQ0xBTVBFRCl2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24odGhhdCwgaW5kZXgpe1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggID0gMFxuICAgICAgICAgICwgb2Zmc2V0ID0gMFxuICAgICAgICAgICwgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZighaXNPYmplY3QoZGF0YSkpe1xuICAgICAgICAgIGxlbmd0aCAgICAgPSBzdHJpY3RUb0xlbmd0aChkYXRhLCB0cnVlKVxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgICAgID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmKCRsZW5ndGggPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZigkbGVuICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZihieXRlTGVuZ3RoIDwgMCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZihUWVBFRF9BUlJBWSBpbiBkYXRhKXtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKGluZGV4IDwgbGVuZ3RoKWFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmKCEkaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXtcbiAgICAgIC8vIFY4IHdvcmtzIHdpdGggaXRlcmF0b3JzLCBidXQgZmFpbHMgaW4gbWFueSBvdGhlciBjYXNlc1xuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQ1NTJcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpe1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXJldHVybiBuZXcgQmFzZShzdHJpY3RUb0xlbmd0aChkYXRhLCBJU05UX1VJTlQ4KSk7XG4gICAgICAgIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSlyZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIShrZXkgaW4gVHlwZWRBcnJheSkpaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZighTElCUkFSWSlUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciAgID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICAgICwgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvciAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKVxuICAgICAgLCAkaXRlcmF0b3IgICAgICAgICA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKXtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFUyxcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwge3NldDogJHNldH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSwgTkFNRSwge3RvU3RyaW5nOiBhcnJheVRvU3RyaW5nfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7c2xpY2U6ICRzbGljZX0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKClcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwge3RvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmd9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IG5leHRUaWNrIGZyb20gJy4vbmV4dFRpY2suanMnO1xuXG5jb25zdCBfcmNLZXkgPSBTeW1ib2woJ1JlZmVyZW5jZUNvdW50S2V5Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIEpTIG9iamVjdHMgdGhhdCBhcmUgcGFydCBvZiB0aGlzIGZyYW1ld29yay5cbiAqXG4gKiBAY2xhc3MgSU9iamVjdFxuICovXG5leHBvcnQgY2xhc3MgSU9iamVjdCB7XG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXV0byByZWxlYXNlZCBpbnN0YW5jZSBvZiB0aGUgY2xhc3MgdGhlIG1ldGhvZCBpcyBjYWxsZWQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gey4uLip9IHZhckFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIGJlIGZvcndhcmRlZCB0byB0aGUgY2xhc3MnIGNvbnN0cnVjdG9yLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnN0YW5jZSguLi52YXJBcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyguLi52YXJBcmdzKS5hdXRvcmVsZWFzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiBldmVyeSBvYmplY3QgaXMgYWxsb2NhdGVkIHdpdGggYSByZXRhaW4gY291bnQgb2YgMSAqL1xuICAgICAgICB0aGlzW19yY0tleV0gPSAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXNbX3JjS2V5XSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcmV0YWluIGNvdW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcmV0YWluQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW19yY0tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCByZXRhaW5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICByZXRhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzW19yY0tleV0gPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJT2JqZWN0OiBSZWZlcmVuY2UgY291bnQgdW5kZXIgb3IgZXF1YWwgdG8gemVybywgYXJlIHlvdSB0cnlpbmcgdG8gcmV2aXZlIGEgem9tYmllPycpO1xuICAgICAgICB9XG4gICAgICAgICsrdGhpc1tfcmNLZXldO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHJlbGVhc2VcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICByZWxlYXNlKCkge1xuICAgICAgICBpZiAoLS10aGlzW19yY0tleV0gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbX3JjS2V5XSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSU9iamVjdDogUmVmZXJlbmNlIGNvdW50IHVuZGVyIHplcm8sIGFyZSB5b3UgcmV0YWluaW5nIHlvdXIgb2JqZWN0PycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgYXV0b3JlbGVhc2VcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBhdXRvcmVsZWFzZSgpIHtcbiAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElPYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9jb3JlL0lPYmplY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBFdmVudHMgPSB7XG4gICAgR0VPTUVUUllfVkFMVUVfQ0hBTkdFRDogJ0dlb21ldHJ5OjpWYWx1ZUNoYW5nZWQnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvZ2VvbWV0cnkvRXZlbnRzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IElCaW5kYWJsZSBmcm9tICcuLi9jb3JlL0lCaW5kYWJsZS5qcyc7XG5pbXBvcnQgQm91bmRpbmdCb3ggZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRpbmdCb3guanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50LmpzJztcbmltcG9ydCBTaXplIGZyb20gJy4uL2dlb21ldHJ5L1NpemUuanMnO1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi9nZW9tZXRyeS9NYXRyaXguanMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL0V2ZW50cy5qcyc7XG5pbXBvcnQgR2VvbWV0cnlFdmVudHMgZnJvbSAnLi4vZ2VvbWV0cnkvRXZlbnRzLmpzJztcblxuY29uc3QgUkVEUkFXX1JFQVNPTiA9IHtcbiAgICBSRURSQVdfRVhURVJOQUxfUkVRVUVTVDogU3ltYm9sKCdSRURSQVdfRVhURVJOQUxfUkVRVUVTVCcpLFxuICAgIFJFRFJBV19DSElMRF9BRERFRDogU3ltYm9sKCdSRURSQVdfQ0hJTERfQURERUQnKSxcbiAgICBSRURSQVdfQ0hJTERfUkVNT1ZFRDogU3ltYm9sKCdSRURSQVdfQ0hJTERfUkVNT1ZFRCcpLFxuICAgIFJFRFJBV19UUkFOU0ZPUk1BVElPTl9DSEFOR0U6IFN5bWJvbCgnUkVEUkFXX1RSQU5TRk9STUFUSU9OX0NIQU5HRScpLFxuICAgIFJFRFJBV19DQUNIRV9SRUZSRVNIOiBTeW1ib2woJ1JFRFJBV19DQUNIRV9SRUZSRVNIJyksXG59O1xuT2JqZWN0LmZyZWV6ZShSRURSQVdfUkVBU09OKTtcblxuY29uc3QgTUFUUklYX1VQREFURV9SRUFTT04gPSB7XG4gICAgTUFUUklYX1VQREFURV9VTkRFRklORUQ6IG51bGwsXG4gICAgTUFUUklYX1VQREFURV9QT1NJVElPTjogU3ltYm9sKCdNQVRSSVhfVVBEQVRFX1BPU0lUSU9OJyksXG4gICAgTUFUUklYX1VQREFURV9TSVpFOiBTeW1ib2woJ01BVFJJWF9VUERBVEVfU0laRScpLFxuICAgIE1BVFJJWF9VUERBVEVfU0NBTEU6IFN5bWJvbCgnTUFUUklYX1VQREFURV9TQ0FMRScpLFxuICAgIE1BVFJJWF9VUERBVEVfUk9UQVRJT046IFN5bWJvbCgnTUFUUklYX1VQREFURV9ST1RBVElPTicpLFxuICAgIE1BVFJJWF9VUERBVEVfQU5DSE9SOiBTeW1ib2woJ01BVFJJWF9VUERBVEVfQU5DSE9SJyksXG4gICAgTUFUUklYX1VQREFURV9QQVJFTlRfUkVRVUVTVDogU3ltYm9sKCdNQVRSSVhfVVBEQVRFX1BBUkVOVF9SRVFVRVNUJyksXG59O1xuT2JqZWN0LmZyZWV6ZShNQVRSSVhfVVBEQVRFX1JFQVNPTik7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGRyYXdhYmxlIG9iamVjdHMuXG4gKlxuICogQGNsYXNzIE5vZGVcbiAqL1xuZXhwb3J0IGNsYXNzIE5vZGUgZXh0ZW5kcyBJQmluZGFibGUge1xuICAgIC8qKlxuICAgICAqIFJlZHJhd2luZyB0aGlzIG5vZGUgd2FzIHJlcXVlc3RlZCBieSBhbiBleHRlcm5hbCBjYWxsZXIuXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFJFRFJBV19FWFRFUk5BTF9SRVFVRVNUKCkge1xuICAgICAgICByZXR1cm4gUkVEUkFXX1JFQVNPTi5SRURSQVdfRVhURVJOQUxfUkVRVUVTVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXdpbmcgdGhpcyBub2RlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGEgY2hpbGQgd2FzIGFkZGVkLlxuICAgICAqIEB0eXBlIHtTeW1ib2x9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBSRURSQVdfQ0hJTERfQURERUQoKSB7XG4gICAgICAgIHJldHVybiBSRURSQVdfUkVBU09OLlJFRFJBV19DSElMRF9BRERFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXdpbmcgdGhpcyBub2RlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGEgY2hpbGQgd2FzIHJlbW92ZWQuXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFJFRFJBV19DSElMRF9SRU1PVkVEKCkge1xuICAgICAgICByZXR1cm4gUkVEUkFXX1JFQVNPTi5SRURSQVdfQ0hJTERfUkVNT1ZFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXdpbmcgdGhpcyBub2RlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhpcyBub2RlIGNoYW5nZWQuXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFJFRFJBV19UUkFOU0ZPUk1BVElPTl9DSEFOR0UoKSB7XG4gICAgICAgIHJldHVybiBSRURSQVdfUkVBU09OLlJFRFJBV19UUkFOU0ZPUk1BVElPTl9DSEFOR0U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3aW5nIHRoaXMgbm9kZSBpcyBuZWNlc3NhcnkgYmVjYXVzZSBpdHMgaW50ZXJuYWwgY2FjaGUgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKiBAdHlwZSB7U3ltYm9sfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUkVEUkFXX0NBQ0hFX1JFRlJFU0goKSB7XG4gICAgICAgIHJldHVybiBSRURSQVdfUkVBU09OLlJFRFJBV19DQUNIRV9SRUZSRVNIO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gd2h5IHRoaXMgbm9kZSdzIG1hdHJpeCBuZWVkcyB0byBiZSB1cGRhdGVkIGlzIHVua25vd24uXG4gICAgICogQHR5cGUge251bGx9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBNQVRSSVhfVVBEQVRFX1VOREVGSU5FRCgpIHtcbiAgICAgICAgcmV0dXJuIE1BVFJJWF9VUERBVEVfUkVBU09OLk1BVFJJWF9VUERBVEVfVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbm9kZSdzIG1hdHJpeCBuZWVkcyB0byBiZSB1cGRhdGVkIGJlY2F1c2UgaXRzIHBvc2l0aW9uIGNoYW5nZWQuXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1BVFJJWF9VUERBVEVfUE9TSVRJT04oKSB7XG4gICAgICAgIHJldHVybiBNQVRSSVhfVVBEQVRFX1JFQVNPTi5NQVRSSVhfVVBEQVRFX1BPU0lUSU9OO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbm9kZSdzIG1hdHJpeCBuZWVkcyB0byBiZSB1cGRhdGVkIGJlY2F1c2UgaXRzIHNpemUgY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7U3ltYm9sfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTUFUUklYX1VQREFURV9TSVpFKCkge1xuICAgICAgICByZXR1cm4gTUFUUklYX1VQREFURV9SRUFTT04uTUFUUklYX1VQREFURV9TSVpFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbm9kZSdzIG1hdHJpeCBuZWVkcyB0byBiZSB1cGRhdGVkIGJlY2F1c2UgaXRzIHNjYWxlIGNoYW5nZWQuXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1BVFJJWF9VUERBVEVfU0NBTEUoKSB7XG4gICAgICAgIHJldHVybiBNQVRSSVhfVVBEQVRFX1JFQVNPTi5NQVRSSVhfVVBEQVRFX1NDQUxFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbm9kZSdzIG1hdHJpeCBuZWVkcyB0byBiZSB1cGRhdGVkIGJlY2F1c2UgaXRzIHJvdGF0aW9uIGNoYW5nZWQuXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1BVFJJWF9VUERBVEVfUk9UQVRJT04oKSB7XG4gICAgICAgIHJldHVybiBNQVRSSVhfVVBEQVRFX1JFQVNPTi5NQVRSSVhfVVBEQVRFX1JPVEFUSU9OO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbm9kZSdzIG1hdHJpeCBuZWVkcyB0byBiZSB1cGRhdGVkIGJlY2F1c2UgaXRzIGFuY2hvciBwb2ludCBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIHtTeW1ib2x9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBNQVRSSVhfVVBEQVRFX0FOQ0hPUigpIHtcbiAgICAgICAgcmV0dXJuIE1BVFJJWF9VUERBVEVfUkVBU09OLk1BVFJJWF9VUERBVEVfQU5DSE9SO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbm9kZSdzIG1hdHJpeCBuZWVkcyB0byBiZSB1cGRhdGVkIGJlY2F1c2UgaXRzIHBhcmVudCBoYXMgdXBkYXRlZCBpdHMgbWF0cml4IGFuZCB0aGlzIG5vZGUncyBtYXRyaXggbmVlZHMgdG9cbiAgICAgKiBiZSByZWNhbGN1bGF0ZWQgaWYgaXQgdXNlcyBwZXJjZW50YWdlcyBmb3IgaXRzIHNpemUgb3IgcG9zaXRpb24uXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1BVFJJWF9VUERBVEVfUEFSRU5UX1JFUVVFU1QoKSB7XG4gICAgICAgIHJldHVybiBNQVRSSVhfVVBEQVRFX1JFQVNPTi5NQVRSSVhfVVBEQVRFX1BBUkVOVF9SRVFVRVNUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZz19IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoaXMgbm9kZS4gT3B0aW9uYWwsIGRlZmF1bHRzIHRvIDAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nPX0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGlzIG5vZGUuIE9wdGlvbmFsLCBkZWZhdWx0cyB0byAwLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1SdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubUNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMubVBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMubUJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICAgIHRoaXMubVBvc2l0aW9uID0gbmV3IFBvaW50KCk7XG4gICAgICAgIHRoaXMubVBpeGVsUG9zaXRpb24gPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgdGhpcy5tU2l6ZSA9IG5ldyBTaXplKCk7XG4gICAgICAgIHRoaXMubVBpeGVsU2l6ZSA9IG5ldyBTaXplKCk7XG4gICAgICAgIHRoaXMubUFuY2hvciA9IG5ldyBQb2ludCgnNTAlJywgJzUwJScpO1xuICAgICAgICB0aGlzLm1QaXhlbEFuY2hvciA9IG5ldyBQb2ludCgpO1xuICAgICAgICB0aGlzLm1NYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIHRoaXMubUNhY2hlZE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5tUm90YXRpb24gPSAwO1xuICAgICAgICB0aGlzLm1TY2FsZSA9IDE7XG4gICAgICAgIHRoaXMubURldmljZVNjYWxlID0gMTtcbiAgICAgICAgdGhpcy5tR2xvYmFsU2NhbGUgPSAxO1xuICAgICAgICB0aGlzLm1SZXZpQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5tU2l6ZS5vbihHZW9tZXRyeUV2ZW50cy5HRU9NRVRSWV9WQUxVRV9DSEFOR0VELCB0aGlzLm1TaXplLnNhZmVCaW5kKHRoaXMuX3VwZGF0ZU1hdHJpeCwgdGhpcywgTm9kZS5NQVRSSVhfVVBEQVRFX1NJWkUpKTtcbiAgICAgICAgdGhpcy5tUG9zaXRpb24ub24oR2VvbWV0cnlFdmVudHMuR0VPTUVUUllfVkFMVUVfQ0hBTkdFRCwgdGhpcy5tUG9zaXRpb24uc2FmZUJpbmQodGhpcy5fdXBkYXRlTWF0cml4LCB0aGlzLCBOb2RlLk1BVFJJWF9VUERBVEVfUE9TSVRJT04pKTtcbiAgICAgICAgdGhpcy5tQW5jaG9yLm9uKEdlb21ldHJ5RXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMubUFuY2hvci5zYWZlQmluZCh0aGlzLl91cGRhdGVNYXRyaXgsIHRoaXMsIE5vZGUuTUFUUklYX1VQREFURV9BTkNIT1IpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1SdW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXhpdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcblxuICAgICAgICB0aGlzLm1TaXplLm9mZihHZW9tZXRyeUV2ZW50cy5HRU9NRVRSWV9WQUxVRV9DSEFOR0VELCB0aGlzLl91cGRhdGVNYXRyaXgsIHRoaXMpO1xuICAgICAgICB0aGlzLm1Qb3NpdGlvbi5vZmYoR2VvbWV0cnlFdmVudHMuR0VPTUVUUllfVkFMVUVfQ0hBTkdFRCwgdGhpcy5fdXBkYXRlTWF0cml4LCB0aGlzKTtcbiAgICAgICAgdGhpcy5tQW5jaG9yLm9mZihHZW9tZXRyeUV2ZW50cy5HRU9NRVRSWV9WQUxVRV9DSEFOR0VELCB0aGlzLl91cGRhdGVNYXRyaXgsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMubUJvdW5kaW5nQm94LnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tUG9zaXRpb24ucmVsZWFzZSgpO1xuICAgICAgICB0aGlzLm1TaXplLnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tQW5jaG9yLnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tTWF0cml4LnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tQ2FjaGVkTWF0cml4LnJlbGVhc2UoKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5tUnVubmluZztcbiAgICAgICAgZGVsZXRlIHRoaXMubUNoaWxkcmVuO1xuICAgICAgICBkZWxldGUgdGhpcy5tUGFyZW50O1xuICAgICAgICBkZWxldGUgdGhpcy5tQm91bmRpbmdCb3g7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1Qb3NpdGlvbjtcbiAgICAgICAgZGVsZXRlIHRoaXMubVBpeGVsUG9zaXRpb247XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1TaXplO1xuICAgICAgICBkZWxldGUgdGhpcy5tUGl4ZWxTaXplO1xuICAgICAgICBkZWxldGUgdGhpcy5tQW5jaG9yO1xuICAgICAgICBkZWxldGUgdGhpcy5tUGl4ZWxBbmNob3I7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1NYXRyaXg7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1DYWNoZWRNYXRyaXg7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1Sb3RhdGlvbjtcbiAgICAgICAgZGVsZXRlIHRoaXMubURldmljZVNjYWxlO1xuICAgICAgICBkZWxldGUgdGhpcy5tU2NhbGU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1HbG9iYWxTY2FsZTtcbiAgICAgICAgZGVsZXRlIHRoaXMubVJldmlDb250ZXh0O1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIG5vZGUgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBzY2VuZSBncmFwaCBhbmQgcnVubmluZy5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBydW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tUnVubmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG5vZGUncyBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7Tm9kZXxudWxsfVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1QYXJlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBub2RlJ3MgYm91bmRpbmdCb3ggaW4gbm9uLXNjYWxlZCBzcGFjZS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtCb3VuZGluZ0JveH1cbiAgICAgKi9cbiAgICBnZXQgYm91bmRpbmdCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1Cb3VuZGluZ0JveDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICovXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tUG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uLCBpbiBwaXhlbHMsIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqL1xuICAgIGdldCBwaXhlbFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tUGl4ZWxQb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5jaG9yIHBvaW50IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1BbmNob3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFuY2hvciBwb2ludCwgaW4gcGl4ZWxzLCBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKi9cbiAgICBnZXQgcGl4ZWxBbmNob3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1QaXhlbEFuY2hvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTaXplfVxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSwgaW4gcGl4ZWxzLCBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTaXplfVxuICAgICAqL1xuICAgIGdldCBwaXhlbFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1QaXhlbFNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHJldmkgY29udGV4dCB0aGlzIG5vZGUgYmVsb25ncyB0bywgb3IgbnVsbCBpZiBubyBjb250ZXh0IGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTeW1ib2x8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQgcmV2aUNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1SZXZpQ29udGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1Sb3RhdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXQgcm90YXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5tUm90YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTWF0cml4KE5vZGUuTUFUUklYX1VQREFURV9ST1RBVElPTik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIG9mIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tU2NhbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxlIG9mIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgdmFsdWUuXG4gICAgICovXG4gICAgc2V0IHNjYWxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubVNjYWxlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hdHJpeChOb2RlLk1BVFJJWF9VUERBVEVfU0NBTEUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXZpY2Ugc2NhbGUgdXNlZCB0byByZW5kZXIgdGhpcyBub2RlJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZGV2aWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1EZXZpY2VTY2FsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZXZpY2Ugc2NhbGUgdXNlZCB0byByZW5kZXIgdGhpcyBub2RlJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBkZXZpY2Ugc2NhbGUuXG4gICAgICovXG4gICAgc2V0IGRldmljZVNjYWxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubURldmljZVNjYWxlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubUNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgY2hpbGQuZGV2aWNlU2NhbGUgPSB0aGlzLm1EZXZpY2VTY2FsZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBzY2FsZSBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBnbG9iYWxTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubUdsb2JhbFNjYWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdsb2JhbCBzY2FsZSBvZiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVXN1YWxseSB0aGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgc2V0IG1hbnVhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdGhlIG5ldyBnbG9iYWwgc2NhbGUgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgc2V0IGdsb2JhbFNjYWxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubUdsb2JhbFNjYWxlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubUNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgY2hpbGQuZ2xvYmFsU2NhbGUgPSB0aGlzLm1HbG9iYWxTY2FsZSAqIHRoaXMubVNjYWxlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgZXZlcnkgdGltZSB0aGUgb2JqZWN0IGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBzY2VuZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgb25FbnRlclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSByZXZpQ29udGV4dCAtIEEgdW5pcXVlIHN5bWJvbCB0aGF0IGlkZW50aWZpZXMgdGhlIHJlbmRlcmluZyBjb250ZXh0IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIG9uRW50ZXIocmV2aUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tUmV2aUNvbnRleHQgPSByZXZpQ29udGV4dDtcbiAgICAgICAgdGhpcy5tUnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMubUNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQub25FbnRlcihyZXZpQ29udGV4dCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0cyBpcyByZW1vdmVkIGZyb20gdGhlIHNjZW5lIGdyYXBoLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBvbkV4aXRcbiAgICAgKi9cbiAgICBvbkV4aXQoKSB7XG4gICAgICAgIHRoaXMubVJldmlDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1DaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLm9uRXhpdCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgZXZlcnkgdGljaywgYmVmb3JlIHRoaXMgb2JqZWN0IGlzIGRyYXduLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgLSBUaGUgZGVsdGEgdGltZSBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSB2YXJBcmdzIC0gT3B0aW9uYWwgcGFyYW1ldGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIG5vZGUncyBjaGlsZHJlbiB3aGVuIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIHVwZGF0ZShkZWx0YSwgLi4udmFyQXJncykge1xuICAgICAgICB0aGlzLm1DaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnVwZGF0ZShkZWx0YSwgLi4udmFyQXJncykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSB0aWNrLCBkcmF3aW5nIG9wZXJhdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZCBoZXJlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkcmF3XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IHZhckFyZ3MgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgbm9kZSdzIGNoaWxkcmVuIHdoZW4gZHJhd2luZy5cbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIC4uLnZhckFyZ3MpIHtcbiAgICAgICAgdGhpcy5tQ2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjaGlsZC5fcHVzaFRyYW5zZm9ybShjb250ZXh0KTtcbiAgICAgICAgICAgIGNoaWxkLmRyYXcoY29udGV4dCwgLi4udmFyQXJncyk7XG4gICAgICAgICAgICBjaGlsZC5fcG9wVHJhbnNmb3JtKGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY2hpbGQgbm9kZSB0byB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkQ2hpbGRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkIC0gVGhlIG5vZGUgdG8gYWRkIGFzIGEgY2hpbGQuXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICovXG4gICAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ2hpbGRBdChjaGlsZCwgdGhpcy5tQ2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IG5vZGUgYXMgYSBjaGlsZHJlbiB0byB0aGlzIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkQ2hpbGRBdFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY2hpbGQgLSBUaGUgbm9kZSB0byBhZGQgYXMgYSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIG5vZGUgd2lsbCBiZSBhZGRlZC5cbiAgICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICAgKi9cbiAgICBhZGRDaGlsZEF0KGNoaWxkLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8PSB0aGlzLm1DaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIHJldGFpbiB0aGUgY2hpbGQgKi9cbiAgICAgICAgICAgIGNoaWxkLnJldGFpbigpO1xuXG4gICAgICAgICAgICAvKiBpZiB0aGUgY2hpbGQgbm9kZSBiZWxvbmdzIHRvIGFub3RoZXIgcGFyZW50LCByZW1vdmUgaXQgZnJvbSB0aGF0IHBhcmVudCAqL1xuICAgICAgICAgICAgaWYgKGNoaWxkLm1QYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5tUGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogc2V0IHRoZSBkZXZpY2Ugc2NhbGUgb2YgdGhlIGNoaWxkICovXG4gICAgICAgICAgICBjaGlsZC5kZXZpY2VTY2FsZSA9IHRoaXMubURldmljZVNjYWxlO1xuXG4gICAgICAgICAgICAvKiBzZXQgdGhlIGdsb2JhbCBzY2FsZSBvZiB0aGUgY2hpbGQgKi9cbiAgICAgICAgICAgIGNoaWxkLmdsb2JhbFNjYWxlID0gdGhpcy5tR2xvYmFsU2NhbGUgKiB0aGlzLm1TY2FsZTtcblxuICAgICAgICAgICAgLyogc2V0IHRoaXMgbm9kZSBhcyB0aGUgcGFyZW50IGFuZCBhZGQgdGhlIGNoaWxkIHRvIHRoZSBjaGlsZHJlbiBhcnJheSAqL1xuICAgICAgICAgICAgY2hpbGQubVBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm1DaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkQ2hpbGRBdDogVGhlIGluZGV4ICgnICsgaW5kZXggKyAnKSBzdXBwbGllZCBpcyBvdXQgb2YgYm91bmRzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogdXBkYXRlIHRoZSBjaGlsZCdzIG1hdHJpeCwgaW4gY2FzZSBpdCB1c2VzIHBlcmNlbnRhZ2VzIGZvciBzaXplL3Bvc2l0aW9uICovXG4gICAgICAgIGNoaWxkLl91cGRhdGVNYXRyaXgoTm9kZS5NQVRSSVhfVVBEQVRFX1BBUkVOVF9SRVFVRVNUKTtcblxuICAgICAgICAvKiBpZiB0aGlzIG5vZGUgaXMgcnVubmluZywgY2FsbCBgb25FbnRlcmAgb24gdGhlIGNoaWxkICovXG4gICAgICAgIGlmICh0aGlzLm1SdW5uaW5nKSB7XG4gICAgICAgICAgICBjaGlsZC5vbkVudGVyKHRoaXMubVJldmlDb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIHN0YXJ0IGZvcndhcmRpbmcgdGhlIGNoaWxkIGFkZGVkL3JlbW92ZWQgZXZlbnRzICovXG4gICAgICAgIHRoaXMuZm9yd2FyZChcbiAgICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIEV2ZW50cy5HUkFQSElDU19OT0RFX0NISUxEX0FEREVELFxuICAgICAgICAgICAgICAgIEV2ZW50cy5HUkFQSElDU19OT0RFX0NISUxEX1JFTU9WRUQsXG4gICAgICAgICAgICAgICAgRXZlbnRzLkdSQVBISUNTX05PREVfTkVFRFNfUkVEUkFXLFxuICAgICAgICAgICAgXVxuICAgICAgICApO1xuXG4gICAgICAgIC8qIGVtaXQgdGhlIGNoaWxkIGFkZGVkIGV2ZW50ICovXG4gICAgICAgIHRoaXMuZW1pdChFdmVudHMuR1JBUEhJQ1NfTk9ERV9DSElMRF9BRERFRCwgdGhpcywgY2hpbGQpO1xuICAgICAgICB0aGlzLl9uZWVkc1JlZHJhdyhOb2RlLlJFRFJBV19DSElMRF9BRERFRCk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBub2RlIGZyb20gdGhpcyBub2RlJ3MgY2hpbGRyZW4gbGlzdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkIC0gVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tQ2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNoaWxkQXQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRBdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGlzIGNoaWxkIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZEF0KGluZGV4KSB7XG4gICAgICAgIC8qIGdldCB0aGUgY2hpbGQgdG8gcmVtb3ZlICovXG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fZ2V0Q2hpbGRBdChpbmRleCk7XG5cbiAgICAgICAgLyogc3RvcCBmb3J3YXJkaW5nIHRoaXMgY2hpbGQncyBldmVudHMgKi9cbiAgICAgICAgdGhpcy51bmZvcndhcmQoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBFdmVudHMuR1JBUEhJQ1NfTk9ERV9DSElMRF9BRERFRCxcbiAgICAgICAgICAgICAgICBFdmVudHMuR1JBUEhJQ1NfTk9ERV9DSElMRF9SRU1PVkVELFxuICAgICAgICAgICAgICAgIEV2ZW50cy5HUkFQSElDU19OT0RFX05FRURTX1JFRFJBVyxcbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcblxuICAgICAgICAvKiBpZiB0aGlzIG5vZGUgaXMgcnVubmluZyBjYWxsIGBvbkV4aXRgICovXG4gICAgICAgIGlmICh0aGlzLm1SdW5uaW5nKSB7XG4gICAgICAgICAgICBjaGlsZC5vbkV4aXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIHNldCB0aGUgY2hpbGQncyBwYXJlbnQgdG8gbnVsbCBhbmQgcmVtb3ZlIGZyb20gdGhlIGNoaWxkcmVuIGFycmF5ICovXG4gICAgICAgIGNoaWxkLm1QYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm1DaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgIC8qIGVtaXQgdGhlIGNoaWxkIHJlbW92ZWQgZXZlbnQgKi9cbiAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5HUkFQSElDU19OT0RFX0NISUxEX1JFTU9WRUQsIHRoaXMsIGNoaWxkKTtcbiAgICAgICAgdGhpcy5fbmVlZHNSZWRyYXcoTm9kZS5SRURSQVdfQ0hJTERfUkVNT1ZFRCk7XG5cbiAgICAgICAgLyogcmVsZWFzZSB0aGUgY2hpbGQgKi9cbiAgICAgICAgcmV0dXJuIGNoaWxkLmF1dG9yZWxlYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIGNoaWxkcmVuIG9mIGZyb20gdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW1vdmVDaGlsZHJlblxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkcmVuKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5tQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkQXQodGhpcy5tQ2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgcmVuZGVyaW5nIHN5c3RlbSB0aGF0IHRoaXMgbm9kZSBuZWVkcyB0byBiZSByZWRyYXduIHRvIHByb3Blcmx5IGRpc3BsYXkgaXRzIHVwZGF0ZWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG5lZWRzUmVkcmF3XG4gICAgICovXG4gICAgbmVlZHNSZWRyYXcoKSB7XG4gICAgICAgIHRoaXMuX25lZWRzUmVkcmF3KE5vZGUuUkVEUkFXX0VYVEVSTkFMX1JFUVVFU1QpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2FmZWx5IG1ha2VzIGFsbCBvZiB0aGlzIG5vZGUncyBjaGlsZHJlbiBwZXJmb3JtIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbWV0aG9kIG5hbWUuIElmIHRoZSBgcmVjdXJzaXZlYFxuICAgICAqIGFyZ3VtZW50IGlzIHNldCB0byBgdHJ1ZWAgaXQgbWFrZXMgaW52b2tlcyBgbWFrZUNoaWxkcmVuUGVyZm9ybWAgaW4gaXRzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBtYWtlQ2hpbGRyZW5QZXJmb3JtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHBlcmZvcm0uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZWN1cnNpdmUgLSBTaG91bGQgY2hpbGRyZW4gbWFrZSB0aGVpciBjaGlsZHJlbiBwZXJmb3JtIHRoZSBzcGVjaWZpZWQgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyQXJncyAtIEFyZ3VtZW50cyB0byBiZSBmb3J3YXJkZWQgd2hlbiB0aGUgbWV0aG9kIGlzIHBlcmZvcm1lZC5cbiAgICAgKi9cbiAgICBtYWtlQ2hpbGRyZW5QZXJmb3JtKG1ldGhvZE5hbWUsIHJlY3Vyc2l2ZSwgLi4udmFyQXJncykge1xuICAgICAgICB0aGlzLm1DaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZFttZXRob2ROYW1lXSAmJiB0eXBlb2YgY2hpbGRbbWV0aG9kTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFttZXRob2ROYW1lXSguLi52YXJBcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZSAmJiBjaGlsZC5tYWtlQ2hpbGRyZW5QZXJmb3JtICYmIHR5cGVvZiBjaGlsZC5tYWtlQ2hpbGRyZW5QZXJmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQubWFrZUNoaWxkcmVuUGVyZm9ybShtZXRob2ROYW1lLCByZWN1cnNpdmUsIC4uLnZhckFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHBvaW50IGluIGdsb2JhbCBzcGFjZSB0byBsb2NhbCBzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIGNvbnZlcnQgdG8gbG9jYWwgY29vcmRpbmF0ZXMuXG4gICAgICogQHJldHVybiB7UG9pbnR9XG4gICAgICovXG4gICAgZ2xvYmFsVG9Mb2NhbFBvaW50KHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsb2JhbFRvTG9jYWxDb29yZHMocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgaW4gZ2xvYmFsIHNwYWNlIHRvIGxvY2FsIHNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIHRvIGNvbnZlcnQgdG8gbG9jYWwgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIHRvIGNvbnZlcnQgdG8gbG9jYWwgY29vcmRpbmF0ZXMuXG4gICAgICogQHJldHVybiB7UG9pbnR9XG4gICAgICovXG4gICAgZ2xvYmFsVG9Mb2NhbENvb3Jkcyh4LCB5KSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuaW5zdGFuY2UoeCwgeSk7XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1hdHJpeC5tdWx0aXBseShub2Rlcy5wb3AoKS5tTWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXguYXBwbHlUb1BvaW50SW52ZXJzZShwb2ludCk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG5cbiAgICBsb2NhbFRvR2xvYmFsUG9pbnQocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxUb0dsb2JhbENvb3Jkcyhwb2ludC54LCBwb2ludC55KTtcbiAgICB9XG5cbiAgICBsb2NhbFRvR2xvYmFsQ29vcmRzKHgsIHkpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBQb2ludC5pbnN0YW5jZSh4LCB5KTtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWF0cml4Lm11bHRpcGx5KG5vZGVzLnBvcCgpLm1NYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeC5hcHBseVRvUG9pbnQocG9pbnQpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZ2V0Q2hpbGRBdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgY2hpbGRyZW4gbm9kZSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDaGlsZEF0KGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5tQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldENoaWxkQXQ6IFRoZSBpbmRleCAoJyArIGluZGV4ICsgJykgc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tQ2hpbGRyZW5baW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhpcyBub2RlJ3MgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBzdXBwbGllZCBjb250ZXh0IGFuZCBzYXZlcyBpdHMgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9wdXNoVHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dCB0byB3aGljaCB0aGUgdHJhbnNmb3JtYXRpb25zIHNob3VsZCBiZSBhcHBsaWVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3B1c2hUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgdGhpcy5tTWF0cml4LmFwcGx5VG9Db250ZXh0KGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIGJ5IHRoaXMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9wb3BUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRvIHdoaWNoIHRoZSB0cmFuc2Zvcm1hdGlvbnMgd2VyZSBwcmV2aW91c2x5IGFwcGxpZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcG9wVHJhbnNmb3JtKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdW5kZXJseWluZyBhZmZpbmUgbWF0cml4IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3VwZGF0ZU1hdHJpeFxuICAgICAqIEBwYXJhbSB7U3ltYm9sfG51bGx9IHRyaWdnZXIgLSBBIHN5bWJvbCBkZXNjcmliaW5nIHdoYXQgdHJpZ2dlcmVkIHRoZSB1cGRhdGUgYXMgZGVzY3JpYmVkIGluIHRoZSBOb2RlLk1BVFJJWF9VUERBVEVfKiBjb25zdGFudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlTWF0cml4KHRyaWdnZXIgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLm1QYXJlbnQgJiYgdGhpcy5tUG9zaXRpb24ueFVuaXRzID09PSBQb2ludC5VTklUX1RZUEVfUEVSQ0VOVEFHRSA/IHRoaXMubVBhcmVudC5waXhlbFNpemUud2lkdGggKiB0aGlzLm1Qb3NpdGlvbi54IDogdGhpcy5tUG9zaXRpb24ueDtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMubVBhcmVudCAmJiB0aGlzLm1Qb3NpdGlvbi55VW5pdHMgPT09IFBvaW50LlVOSVRfVFlQRV9QRVJDRU5UQUdFID8gdGhpcy5tUGFyZW50LnBpeGVsU2l6ZS5oZWlnaHQgKiB0aGlzLm1Qb3NpdGlvbi55IDogdGhpcy5tUG9zaXRpb24ueTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLm1QYXJlbnQgJiYgdGhpcy5tU2l6ZS54VW5pdHMgPT09IFBvaW50LlVOSVRfVFlQRV9QRVJDRU5UQUdFID8gdGhpcy5tUGFyZW50LnBpeGVsU2l6ZS53aWR0aCAqIHRoaXMubVNpemUud2lkdGggOiB0aGlzLm1TaXplLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLm1QYXJlbnQgJiYgdGhpcy5tU2l6ZS55VW5pdHMgPT09IFBvaW50LlVOSVRfVFlQRV9QRVJDRU5UQUdFID8gdGhpcy5tUGFyZW50LnBpeGVsU2l6ZS5oZWlnaHQgKiB0aGlzLm1TaXplLmhlaWdodCA6IHRoaXMubVNpemUuaGVpZ2h0O1xuICAgICAgICBjb25zdCB4T2ZmID0gdGhpcy5tQW5jaG9yLnhVbml0cyA9PT0gUG9pbnQuVU5JVF9UWVBFX1BFUkNFTlRBR0UgPyB3aWR0aCAqIHRoaXMubUFuY2hvci54IDogdGhpcy5tQW5jaG9yLng7XG4gICAgICAgIGNvbnN0IHlPZmYgPSB0aGlzLm1BbmNob3IueVVuaXRzID09PSBQb2ludC5VTklUX1RZUEVfUEVSQ0VOVEFHRSA/IGhlaWdodCAqIHRoaXMubUFuY2hvci55IDogdGhpcy5tQW5jaG9yLnk7XG5cbiAgICAgICAgdGhpcy5tUGl4ZWxBbmNob3Iuc2V0KHhPZmYsIHlPZmYpO1xuICAgICAgICB0aGlzLm1QaXhlbFBvc2l0aW9uLnNldCh4LCB5KTtcblxuICAgICAgICB0aGlzLm1NYXRyaXgucmVzZXQoKTtcbiAgICAgICAgdGhpcy5tTWF0cml4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgdGhpcy5tTWF0cml4LnJvdGF0ZSh0aGlzLm1Sb3RhdGlvbik7XG4gICAgICAgIHRoaXMubU1hdHJpeC5zY2FsZSh0aGlzLm1TY2FsZSwgdGhpcy5tU2NhbGUpO1xuICAgICAgICB0aGlzLm1NYXRyaXgudHJhbnNsYXRlKC14T2ZmLCAteU9mZik7XG5cbiAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLm1QaXhlbFNpemUud2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLm1QaXhlbFNpemUuaGVpZ2h0IHx8ICF0aGlzLm1NYXRyaXguaXNFcXVhbCh0aGlzLm1DYWNoZWRNYXRyaXgpKSB7XG4gICAgICAgICAgICB0aGlzLm1QaXhlbFNpemUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5tQ2FjaGVkTWF0cml4LnNldEZyb21NYXRyaXgodGhpcy5tTWF0cml4KTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3guc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5tTWF0cml4LmFwcGx5VG9Cb3VuZGluZ0JveCh0aGlzLmJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIHRoaXMubWFrZUNoaWxkcmVuUGVyZm9ybSgnX3VwZGF0ZU1hdHJpeCcsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVkcmF3KE5vZGUuUkVEUkFXX1RSQU5TRk9STUFUSU9OX0NIQU5HRSwgdHJpZ2dlciB8fCBOb2RlLk1BVFJJWF9VUERBVEVfVU5ERUZJTkVEKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBub2RlIGlzIHJ1bm5pbmcsIHRyaWdnZXJzIHRoZSBldmVudCB0aGF0IHJlcXVlc3RzIGZvciB0aGlzIG9iamVjdCB0byBiZSByZWRyYXduLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfbmVlZHNSZWRyYXdcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gcmVhc29uIC0gVGhlIHJlYXNvbiB3aHkgdGhpcyBub2RlIG5lZWRzIHRvIGJlIHJlZHJhd24uXG4gICAgICogQHBhcmFtIHsuLi4qfSB2YXJBcmdzIC0gRXh0cmEgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIGluIHRoZSByZXF1ZXN0IHRvIGJlIGRyYXduLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25lZWRzUmVkcmF3KHJlYXNvbiwgLi4udmFyQXJncykge1xuICAgICAgICBpZiAodGhpcy5tUnVubmluZykge1xuICAgICAgICAgICAgLyogdGhpcyBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSByZWFzb24gYW5kIGp1c3QgcmVxdWVzdHMgcmVkcmF3ICovXG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkdSQVBISUNTX05PREVfTkVFRFNfUkVEUkFXLCB0aGlzLCByZWFzb24sIC4uLnZhckFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvZ3JhcGhpY3MvTm9kZS5qcyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGEuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXG4gICAgLCBsdCAgICAgPSAnPCdcbiAgICAsIGd0ICAgICA9ICc+J1xuICAgICwgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcbiAgdmFyIHJlc3VsdDtcbiAgaWYoTyAhPT0gbnVsbCl7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMsIHNhZmUpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IElPYmplY3QgZnJvbSAnLi9JT2JqZWN0LmpzJztcblxuY29uc3QgX3NvdXJjZUZ1bmN0aW9uS2V5ID0gU3ltYm9sKCdTb3VyY2VGdW5jdGlvbktleScpO1xuY29uc3QgX3NvdXJjZU93bmVyS2V5ID0gU3ltYm9sKCdTb3VyY2VPd25lcktleScpO1xuXG4vKipcbiAqIEJhc2UgaW50ZXJmYWNlIGNsYXNzIGZvciBvYmplY3RzIHRoYXQgd2lzaCB0byBlbWl0IGV2ZW50cy5cbiAqXG4gKiBAY2xhc3MgSUJpbmRhYmxlXG4gKi9cbmV4cG9ydCBjbGFzcyBJQmluZGFibGUgZXh0ZW5kcyBJT2JqZWN0IHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBJQmluZGFibGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5tT21uaUhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMubUJvdW5kRm9yd2FyZEV2ZW50ID0gdGhpcy5fZm9yd2FyZEV2ZW50LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kcyBhbGwgZXZlbnRzIGJvdW5kIHRvIHRoaXMgSUJpbmRhYmxlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5tSGFuZGxlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1IYW5kbGVyc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tT21uaUhhbmRsZXJzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubUhhbmRsZXJzO1xuICAgICAgICBkZWxldGUgdGhpcy5tT21uaUhhbmRsZXJzO1xuICAgICAgICBkZWxldGUgdGhpcy5tQm91bmRGb3J3YXJkRXZlbnQ7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIGEgbGlzdCBvZiBldmVudHMgdG8gdGhlIHNwZWNpZmllZCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxudWxsfSBldmVudHMgLSBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9yIGFuIEFycmF5IG9mIGV2ZW50cyB0byBsaXN0ZW4gZm9yLiBJZiBudWxsIGlzIHBhc3NlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBmb3IgYWxsIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLiBJZiB0aGlzIGNhbGxiYWNrIHJldHVybnMgdHJ1ZSwgZXZlbnQgYnViYmxpbmcgc3RvcHMuXG4gICAgICovXG4gICAgb24oZXZlbnRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoZXZlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tT21uaUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubU9tbmlIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50QXJyYXkgPSBldmVudHMgaW5zdGFuY2VvZiBBcnJheSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgZXZlbnRBcnJheS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLm1IYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1IYW5kbGVyc1tldmVudF0gPSBoYW5kbGVycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQuIElmIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCBldmVudCBhcmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8bnVsbD19IGV2ZW50cyAtIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb3IgYW4gQXJyYXkgb2YgZXZlbnRzIHRvIGxpc3RlbiBmb3IuIElmIG51bGwgaXMgcGFzc2VkIHRoZSBjYWxsYmFjayB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYWxsLWV2ZW50IGhhbmRsZXIgbGlzdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IG9yIG5vdGhpbmcgdG8gY29tcGxldGVseSBjbGVhciB0aGUgZXZlbnQgY2FsbGJhY2tzLlxuICAgICAqIEBwYXJhbSB7Kn0gb3duZXIgLSBUaGUgb3duZXIgb2YgdGhlIGNhbGxiYWNrLCBuZWVkZWQgd2hlbiB1bnJlZ2lzdGVyaW5nIGNhbGxiYWNrcyBjcmVhdGVkIHdpdGggYHNhZmVCaW5kYC5cbiAgICAgKi9cbiAgICBvZmYoZXZlbnRzID0gbnVsbCwgY2FsbGJhY2sgPSBudWxsLCBvd25lciA9IG51bGwpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMubU9tbmlIYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubU9tbmlIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1PbW5pSGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBldmVudEFycmF5ID0gZXZlbnRzIGluc3RhbmNlb2YgQXJyYXkgPyBldmVudHMgOiBldmVudHMuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGV2ZW50QXJyYXkuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLm1IYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1IYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayA9PT0gaGFuZGxlcnNbaV0gfHwgKGNhbGxiYWNrID09PSBoYW5kbGVyc1tpXVtfc291cmNlRnVuY3Rpb25LZXldICYmIG93bmVyID09PSBoYW5kbGVyc1tpXVtfc291cmNlT3duZXJLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdHMgdGhlIHNwZWNpZmllZCBldmVudCBhbmQgZm9yd2FyZHMgYWxsIHBhc3NlZCBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBlbWl0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQuXG4gICAgICogQHBhcmFtIHsuLi4qfSB2YXJBcmdzIC0gQXJndW1lbnRzIHRvIGZvcndhcmQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrcy5cbiAgICAgKi9cbiAgICBlbWl0KGV2ZW50LCAuLi52YXJBcmdzKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5tSGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICBpZiAoaGFuZGxlcnMgfHwgdGhpcy5tT21uaUhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyc1tpXSguLi52YXJBcmdzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9tbmlIYW5kbGVycyA9IHRoaXMubU9tbmlIYW5kbGVycztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gb21uaUhhbmRsZXJzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChvbW5pSGFuZGxlcnNbaV0oLi4uYXJndW1lbnRzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3J3YXJkcyB0aGUgc3BlY2lmaWVkIGV2ZW50cyB0cmlnZ2VyZWQgYnkgdGhlIGdpdmVuIGBiaW5kYWJsZWAgYXMgaWYgdGhpcyBvYmplY3Qgd2FzIGVtaXR0aW5nIHRoZW0uIElmIG5vIGV2ZW50c1xuICAgICAqIGFyZSBwYXNzZWQsIGFsbCBldmVudHMgYXJlIGZvcndhcmRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZm9yd2FyZFxuICAgICAqIEBwYXJhbSB7SUJpbmRhYmxlfSBiaW5kYWJsZSAtIFRoZSBgSUJpbmRhYmxlYCBpbnN0YW5jZSBmb3Igd2hpY2ggYWxsIGV2ZW50cyB3aWxsIGJlIGZvcndhcmRlZCB0aHJvdWdoIHRoaXMgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8bnVsbD19IGV2ZW50cyAtIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgZXZlbnRzIHRvIGZvcndhcmQgb3IgbnVsbCB0byBmb3J3YXJkIGFsbCB0aGUgZXZlbnRzLlxuICAgICAqL1xuICAgIGZvcndhcmQoYmluZGFibGUsIGV2ZW50cyA9IG51bGwpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYmluZGFibGUub24obnVsbCwgdGhpcy5tQm91bmRGb3J3YXJkRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRBcnJheSA9IGV2ZW50cyBpbnN0YW5jZW9mIEFycmF5ID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBldmVudEFycmF5LmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGJpbmRhYmxlLm9uKGV2ZW50LCB0aGlzLnNhZmVCaW5kKHRoaXMuX2ZvcndhcmRFdmVudCwgdGhpcywgZXZlbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgZm9yd2FyZGluZyB0aGUgZXZlbnRzIG9mIHRoZSBzcGVjaWZpZWQgYGJpbmRhYmxlYFxuICAgICAqXG4gICAgICogQG1ldGhvZCB1bmZvcndhcmRcbiAgICAgKiBAcGFyYW0ge0lCaW5kYWJsZX0gYmluZGFibGUgLSBUaGUgYElCaW5kYWJsZWAgaW5zdGFuY2UgdG8gc3RvcCBmb3J3YXJkaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fG51bGw9fSBldmVudHMgLSBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50cyB0byBzdG9wIGZvcndhcmRpbmcgb3IgbnVsbCB0byBzdG9wIGZvcndhcmRpbmcgYWxsIHRoZSBldmVudHMuXG4gICAgICovXG4gICAgdW5mb3J3YXJkKGJpbmRhYmxlLCBldmVudHMgPSBudWxsKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJpbmRhYmxlLm9mZihudWxsLCB0aGlzLm1Cb3VuZEZvcndhcmRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBldmVudEFycmF5ID0gZXZlbnRzIGluc3RhbmNlb2YgQXJyYXkgPyBldmVudHMgOiBldmVudHMuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGV2ZW50QXJyYXkuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgYmluZGFibGUub2ZmKGV2ZW50LCB0aGlzLl9mb3J3YXJkRXZlbnQsIHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBhIGZ1bmN0aW9uIHNvIGl0IGlzIHNhZmUgdG8gdW5yZWdpc3RlciBpdCB1c2luZyB0aGUgYG9mZmAgbWV0aG9kIHdpdGggb25seSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2FmZUJpbmRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBvd25lciAtIFRoZSBvd25lciBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyQXJncyAtIFRoZSBhcmd1bWVudHMgdXNlZCB0byBiaW5kIHRoaXMgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHNhZmVCaW5kKGZ1bmMsIG93bmVyLCAuLi52YXJBcmdzKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kRnVuY3Rpb24gPSBmdW5jLmJpbmQob3duZXIsIC4uLnZhckFyZ3MpO1xuICAgICAgICBib3VuZEZ1bmN0aW9uW19zb3VyY2VGdW5jdGlvbktleV0gPSBmdW5jO1xuICAgICAgICBib3VuZEZ1bmN0aW9uW19zb3VyY2VPd25lcktleV0gPSBvd25lcjtcbiAgICAgICAgcmV0dXJuIGJvdW5kRnVuY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gZm9yd2FyZCB0aGUgZXZlbnRzIGZyb20gb3RoZXIgYElCaW5kYWJsZWAgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZm9yd2FyZEV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQuXG4gICAgICogQHBhcmFtIHsuLi4qfSB2YXJBcmdzIC0gQXJndW1lbnRzIHRvIGZvcndhcmQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3J3YXJkRXZlbnQoLyogZXZlbnQgKi8gLyogdmFyQXJncyAqLykge1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElCaW5kYWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZXZpL2NvcmUvSUJpbmRhYmxlLmpzIiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJylcbiAgLCBBcnJheVByb3RvICA9IEFycmF5LnByb3RvdHlwZTtcbmlmKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZClyZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAsIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLICA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc3BhY2VzICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgc3BhY2UgICA9ICdbJyArIHNwYWNlcyArICddJ1xuICAsIG5vbiAgICAgPSAnXFx1MjAwYlxcdTAwODUnXG4gICwgbHRyaW0gICA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKVxuICAsIHJ0cmltICAgPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbihLRVksIGV4ZWMsIEFMSUFTKXtcbiAgdmFyIGV4cCAgID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmKEFMSUFTKWV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbihzdHJpbmcsIFRZUEUpe1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYoVFlQRSAmIDEpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYoVFlQRSAmIDIpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vRXZlbnRzLmpzJztcbmltcG9ydCBHZW9tZXRyeUV2ZW50cyBmcm9tICcuLi9nZW9tZXRyeS9FdmVudHMuanMnO1xuXG5jb25zdCBDQU5WQVNfTUFQID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgd3JhcHMgdGhlIEhUTUwgY2FudmFzIGludG8gc28gaXQgYmVoYXZlcyBhcyBhIE5vZGUuXG4gKlxuICogQGNsYXNzIENhbnZhc1xuICovXG5leHBvcnQgY2xhc3MgQ2FudmFzIGV4dGVuZHMgTm9kZSB7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2FudmFzIHJlZ2lzdGVyZWQgZm9yIHRoZSBnaXZlbiByZXZpIGNvbnRleHQuIElmIG5vIGNhbnZhcyBpcyByZWdpc3RlcmVkIGZvciB0aGUgY29udGV4dCwgdGhpcyBtZXRob2QgcmV0dXJucyBudWxsLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDYW52YXNGb3JDb250ZXh0XG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHJldmlDb250ZXh0IC0gVGhlIGNvbnRleHQgZm9yIHdoaWNoIGl0cyBjYW52YXMgd2lsbCBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybnMge0NhbnZhc31cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGdldENhbnZhc0ZvckNvbnRleHQocmV2aUNvbnRleHQpIHtcbiAgICAgICAgaWYgKENBTlZBU19NQVAuaGFzKHJldmlDb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIENBTlZBU19NQVAuZ2V0KHJldmlDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gQSBjYW52YXMgZWxlbWVudCBvciBhbiBlbGVtZW50IGluIHdoaWNoIGEgbmV3IGNhbnZhcyB3aWxsIGJlIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBpbml0aWFsUGl4ZWxEZW5zaXR5IC0gVGhlIGluaXRpYWwgcGl4ZWwgZGVuc2l0eSBvZiB0aGlzIGNhbnZhcywgdGhpcyB2YWx1ZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgbWluUGl4ZWxEZW5zaXR5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gbWluUGl4ZWxEZW5zaXR5IC0gVGhlIG1pbmltdW0gcGl4ZWwgZGVuc2l0eSB0aGF0IGVsZW1lbnRzIHdpbGwgYmUgcmVuZGVyZWQgYXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgaW5pdGlhbFBpeGVsRGVuc2l0eSA9IDAsIG1pblBpeGVsRGVuc2l0eSA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubUFuaW1hdGlvbklEID0gbnVsbDtcbiAgICAgICAgdGhpcy5tUmV2aUNvbnRleHQgPSBTeW1ib2woJ1JFVklfQ09OVEVYVCcpO1xuICAgICAgICB0aGlzLm1NaW5QaXhlbERlbnNpdHkgPSBtaW5QaXhlbERlbnNpdHk7XG4gICAgICAgIHRoaXMubUlkbGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMubUxhc3RUaW1lc3RhbXAgPSAwO1xuXG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMubUNhbnZhcyA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLm1Pd25zQ2FudmFzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMubUNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIHRoaXMubUNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMubUNhbnZhcyk7XG4gICAgICAgICAgICB0aGlzLm1Pd25zQ2FudmFzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYW5jaG9yLnNldCgwLCAwKTtcbiAgICAgICAgdGhpcy5zaXplLnNldCh0aGlzLm1DYW52YXMuc2Nyb2xsV2lkdGgsIHRoaXMubUNhbnZhcy5zY3JvbGxIZWlnaHQpO1xuICAgICAgICB0aGlzLmRldmljZVNjYWxlID0gTWF0aC5tYXgoaW5pdGlhbFBpeGVsRGVuc2l0eSB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCB0aGlzLm1NaW5QaXhlbERlbnNpdHkpO1xuICAgICAgICB0aGlzLm1DYW52YXMud2lkdGggPSB0aGlzLnNpemUud2lkdGggKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgdGhpcy5tQ2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS5oZWlnaHQgKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgdGhpcy5tQm91bmRUaWNrID0gdGhpcy5fdGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1Db250ZXh0ID0gdGhpcy5tQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgLyogcmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgY2hhbmdlcyBpbiB0aGUgZGV2aWNlUGl4ZWxSYXRpbyAqL1xuICAgICAgICB0aGlzLm1NZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoJ3NjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweCknKTtcbiAgICAgICAgdGhpcy5tUGl4ZWxSYXRpb0NoYW5nZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRldmljZVNjYWxlID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgdGhpcy5tTWluUGl4ZWxEZW5zaXR5KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby13YXJuaW5nLWNvbW1lbnRzIC8vIFRPRE86IEFkZCBhIHdheSBmb3IgdXNlcnMgdG8gY29udHJvbCB0aGUgcGl4ZWwgZGVuc2l0eSArIGRldmljZSBzY2FsZS5cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tTWVkaWFRdWVyeS5hZGRMaXN0ZW5lcih0aGlzLm1QaXhlbFJhdGlvQ2hhbmdlZCk7XG5cbiAgICAgICAgLyogcmVnaXN0ZXIgdGhpcyBjYW52YXMgYW5kIGl0cyBjb250ZXh0ICovXG4gICAgICAgIENBTlZBU19NQVAuc2V0KHRoaXMubVJldmlDb250ZXh0LCB0aGlzKTtcblxuICAgICAgICB0aGlzLnNpemUub24oR2VvbWV0cnlFdmVudHMuR0VPTUVUUllfVkFMVUVfQ0hBTkdFRCwgdGhpcy5zaXplLnNhZmVCaW5kKHRoaXMuX2hhbmRsZVNpemVDaGFuZ2VkLCB0aGlzKSk7XG4gICAgICAgIHRoaXMub25FbnRlcih0aGlzLm1SZXZpQ29udGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBvYmplY3QuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGlzIG9iamVjdCByZWFjaGVzIHplcm8uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXhpdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubU93bnNDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMubUVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5tQ2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIENBTlZBU19NQVAuZGVsZXRlKHRoaXMubVJldmlDb250ZXh0KTtcblxuICAgICAgICB0aGlzLnNpemUub2ZmKEdlb21ldHJ5RXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMuX2hhbmRsZVNpemVDaGFuZ2VkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tTWVkaWFRdWVyeS5yZW1vdmVMaXN0ZW5lcih0aGlzLm1QaXhlbFJhdGlvQ2hhbmdlZCk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubUVsZW1lbnQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1BbmltYXRpb25JRDtcbiAgICAgICAgZGVsZXRlIHRoaXMubU1pblBpeGVsRGVuc2l0eTtcbiAgICAgICAgZGVsZXRlIHRoaXMubUlkbGU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1DYW52YXM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1Pd25zQ2FudmFzO1xuICAgICAgICBkZWxldGUgdGhpcy5tQ29udGV4dDtcbiAgICAgICAgZGVsZXRlIHRoaXMubUJvdW5kVGljaztcbiAgICAgICAgZGVsZXRlIHRoaXMubU1lZGlhUXVlcnk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1QaXhlbFJhdGlvQ2hhbmdlZDtcblxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRldmljZSBzY2FsZSB1c2VkIHRvIHJlbmRlciB0aGlzIG5vZGUncyBpbnRlcm5hbCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkZXZpY2VTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRldmljZVNjYWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRldmljZSBzY2FsZSB1c2VkIHRvIHJlbmRlciB0aGlzIG5vZGUncyBpbnRlcm5hbCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IGRldmljZSBzY2FsZS5cbiAgICAgKi9cbiAgICBzZXQgZGV2aWNlU2NhbGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBNYXRoLm1heCh2YWx1ZSwgdGhpcy5tTWluUGl4ZWxEZW5zaXR5KTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSB0aGlzLmRldmljZVNjYWxlKSB7XG4gICAgICAgICAgICBzdXBlci5kZXZpY2VTY2FsZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zaXplLmVtaXQoR2VvbWV0cnlFdmVudHMuR0VPTUVUUllfVkFMVUVfQ0hBTkdFRCwgdGhpcy5zaXplLCB0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuZGV2aWNlU2NhbGUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgY2FudmFzIGRyYXdpbmcgaW4gYW4gaWRsZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBpZGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tSWRsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgZXZlcnkgdGltZSB0aGUgb2JqZWN0IGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50bHkgcnVubmluZyBzY2VuZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgb25FbnRlclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSByZXZpQ29udGV4dCAtIEEgdW5pcXVlIHN5bWJvbCB0aGF0IGlkZW50aWZpZXMgdGhlIHJlbmRlcmluZyBjb250ZXh0IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIG9uRW50ZXIocmV2aUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5vbihFdmVudHMuR1JBUEhJQ1NfTk9ERV9ORUVEU19SRURSQVcsIHRoaXMuc2FmZUJpbmQodGhpcy5uZWVkc1JlZHJhdywgdGhpcykpO1xuICAgICAgICBzdXBlci5vbkVudGVyKHJldmlDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGlzIG9iamVjdHMgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgb25FeGl0XG4gICAgICovXG4gICAgb25FeGl0KCkge1xuICAgICAgICBpZiAodGhpcy5tQW5pbWF0aW9uSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubUFuaW1hdGlvbklEKTtcbiAgICAgICAgICAgIHRoaXMubUFuaW1hdGlvbklEID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZihFdmVudHMuR1JBUEhJQ1NfTk9ERV9ORUVEU19SRURSQVcsIHRoaXMubmVlZHNSZWRyYXcsIHRoaXMpO1xuICAgICAgICBzdXBlci5vbkV4aXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIHN1cGVyIG1ldGhvZCBhbmQgc2NoZWR1bGVzIGEgdGljayBvZiB0aGUgY2FudmFzICh3aGljaCBpbXBsaWVzIGFuIHVwZGF0ZSBhbmQgYSByZWRyYXcpXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG5lZWRzUmVkcmF3XG4gICAgICovXG4gICAgbmVlZHNSZWRyYXcoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcgJiYgdGhpcy5tQW5pbWF0aW9uSUQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubUFuaW1hdGlvbklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMubUJvdW5kVGljayk7XG4gICAgICAgICAgICB0aGlzLl9zZXRJZGxlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgZ2xvYmFsIHNjYWxlIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdXBkYXRlR2xvYmFsU2NhbGVcbiAgICAgKi9cbiAgICB1cGRhdGVHbG9iYWxTY2FsZSgpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxTY2FsZSA9IHRoaXMubVNjYWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBicm93c2VyIGlzIHJlYWR5IHRvIGRyYXcgYSBuZXcgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF90aWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcCAtIFRoZSB0aW1lIHN0YW1wIG9mIHRoaXMgZnVuY3Rpb24gY2FsbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aWNrKHRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IE1hdGgubWF4KE1hdGgubWluKHRpbWVzdGFtcCAtIHRoaXMubUxhc3RUaW1lc3RhbXAsIDMzLjMzMyksIDEpO1xuICAgICAgICB0aGlzLm1MYXN0VGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1BbmltYXRpb25JRCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkdSQVBISUNTX0NBTlZBU19QUkVfVVBEQVRFLCB0aGlzLCBkZWx0YSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkdSQVBISUNTX0NBTlZBU19QT1NUX1VQREFURSwgdGhpcywgZGVsdGEpO1xuICAgICAgICAgICAgdGhpcy5tQ29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLm1Db250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLm1DYW52YXMud2lkdGgsIHRoaXMubUNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5tQ29udGV4dC5zY2FsZSh0aGlzLmRldmljZVNjYWxlLCB0aGlzLmRldmljZVNjYWxlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChFdmVudHMuR1JBUEhJQ1NfQ0FOVkFTX1BSRV9EUkFXLCB0aGlzLCB0aGlzLm1Db250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuZHJhdyh0aGlzLm1Db250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChFdmVudHMuR1JBUEhJQ1NfQ0FOVkFTX1BPU1RfRFJBVywgdGhpcywgdGhpcy5tQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRJZGxlKHRoaXMubUFuaW1hdGlvbklEID09PSBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhpcyBub2RlJ3Mgc2l6ZSBpcyBtb2RpZmllZCwgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGFuZCBhbHNvIGNoYW5nZXMgdGhlIHNpemUgb2YgdGhlIGludGVybmFsIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2hhbmRsZVNpemVDaGFuZ2VkXG4gICAgICogQHBhcmFtIHsqfSBzZW5kZXIgLSBUaGUgaW5zdGFuY2UgdGhhdCBvcmlnaW5hbGx5IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgd2lkdGggb2YgdGhpcyBub2RlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCBvZiB0aGlzIG5vZGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlU2l6ZUNoYW5nZWQoc2VuZGVyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmIChzZW5kZXIgPT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tQ2FudmFzLndpZHRoID0gd2lkdGggKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgICAgIHRoaXMubUNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpZGxlIHN0YXRlIG9mIHRoaXMgY2FudmFzLCB1c2VkIHRvIGtub3cgd2hlbiBhIGNhbnZhcyBpcyBhY3RpdmVseSBiZWluZyByZWRyYXduLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfc2V0SWRsZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWRsZSAtIFRoZSBuZXcgaWRsZSBzdGF0ZSBvZiB0aGlzIGNhbnZhcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRJZGxlKGlkbGUpIHtcbiAgICAgICAgaWYgKGlkbGUgIT09IHRoaXMubUlkbGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1JZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tTGFzdFRpbWVzdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tSWRsZSA9IGlkbGU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkdSQVBISUNTX0NBTlZBU19JRExFX1NUQVRFX0NIQU5HRUQsIHRoaXMsIHRoaXMubUlkbGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9ncmFwaGljcy9DYW52YXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBFdmVudHMgPSB7XG4gICAgR1JBUEhJQ1NfTk9ERV9DSElMRF9BRERFRDogJ0dyYXBoaWNzOjpOb2RlOjpDaGlsZEFkZGVkJyxcbiAgICBHUkFQSElDU19OT0RFX0NISUxEX1JFTU9WRUQ6ICdHcmFwaGljczo6Tm9kZTo6Q2hpbGRSZW1vdmVkJyxcbiAgICBHUkFQSElDU19OT0RFX05FRURTX1JFRFJBVzogJ0dyYXBoaWNzOjpOb2RlOjpOZWVkc1JlZHJhdycsXG5cbiAgICBHUkFQSElDU19DQU5WQVNfUFJFX1VQREFURTogJ0dyYXBoaWNzOjpDYW52YXM6OlByZVVwZGF0ZScsXG4gICAgR1JBUEhJQ1NfQ0FOVkFTX1BPU1RfVVBEQVRFOiAnR3JhcGhpY3M6OkNhbnZhczo6UG9zdFVwZGF0ZScsXG4gICAgR1JBUEhJQ1NfQ0FOVkFTX1BSRV9EUkFXOiAnR3JhcGhpY3M6OkNhbnZhczo6UHJlRHJhdycsXG4gICAgR1JBUEhJQ1NfQ0FOVkFTX1BPU1RfRFJBVzogJ0dyYXBoaWNzOjpDYW52YXM6OlBvc3REcmF3JyxcbiAgICBHUkFQSElDU19DQU5WQVNfSURMRV9TVEFURV9DSEFOR0VEOiAnR3JhcGhpY3M6OkNhbnZhczo6SWRsZVN0YXRlOjpDaGFuZ2VkJyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZXZpL2dyYXBoaWNzL0V2ZW50cy5qcyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gR2VvbWV0cmljIG9iamVjdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmJveCA9IHJlcXVpcmUoJy4vYmJveCcpO1xuXG4vKipcbiAqIEEgYsOpemllciBwYXRoIGNvbnRhaW5pbmcgYSBzZXQgb2YgcGF0aCBjb21tYW5kcyBzaW1pbGFyIHRvIGEgU1ZHIHBhdGguXG4gKiBQYXRocyBjYW4gYmUgZHJhd24gb24gYSBjb250ZXh0IHVzaW5nIGBkcmF3YC5cbiAqIEBleHBvcnRzIG9wZW50eXBlLlBhdGhcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMuZmlsbCA9ICdibGFjayc7XG4gICAgdGhpcy5zdHJva2UgPSBudWxsO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0geFxuICogQHBhcmFtICB7bnVtYmVyfSB5XG4gKi9cblBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnTScsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAqL1xuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdMJyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3cyBjdWJpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBjdXJ2ZVRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgyIC0geCBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geTIgLSB5IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuXG4vKipcbiAqIERyYXdzIGN1YmljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIGJlemllckN1cnZlVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geDIgLSB4IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB5MiAtIHkgb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICogQHNlZSBjdXJ2ZVRvXG4gKi9cblBhdGgucHJvdG90eXBlLmN1cnZlVG8gPSBQYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQycsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkyOiB5MixcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3cyBxdWFkcmF0aWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogcXVhZHJhdGljQ3VydmVUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICovXG5cbi8qKlxuICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIHF1YWRUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICovXG5QYXRoLnByb3RvdHlwZS5xdWFkVG8gPSBQYXRoLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ1EnLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHBhdGhcbiAqIEBmdW5jdGlvbiBjbG9zZVBhdGhcbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICovXG5cbi8qKlxuICogQ2xvc2UgdGhlIHBhdGhcbiAqIEBmdW5jdGlvbiBjbG9zZVxuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKi9cblBhdGgucHJvdG90eXBlLmNsb3NlID0gUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ1onXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gcGF0aCBvciBsaXN0IG9mIGNvbW1hbmRzIHRvIHRoZSBjb21tYW5kcyBvZiB0aGlzIHBhdGguXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aE9yQ29tbWFuZHMgLSBhbm90aGVyIG9wZW50eXBlLlBhdGgsIGFuIG9wZW50eXBlLkJvdW5kaW5nQm94LCBvciBhbiBhcnJheSBvZiBjb21tYW5kcy5cbiAqL1xuUGF0aC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24ocGF0aE9yQ29tbWFuZHMpIHtcbiAgICBpZiAocGF0aE9yQ29tbWFuZHMuY29tbWFuZHMpIHtcbiAgICAgICAgcGF0aE9yQ29tbWFuZHMgPSBwYXRoT3JDb21tYW5kcy5jb21tYW5kcztcbiAgICB9IGVsc2UgaWYgKHBhdGhPckNvbW1hbmRzIGluc3RhbmNlb2YgYmJveC5Cb3VuZGluZ0JveCkge1xuICAgICAgICB2YXIgYm94ID0gcGF0aE9yQ29tbWFuZHM7XG4gICAgICAgIHRoaXMubW92ZVRvKGJveC54MSwgYm94LnkxKTtcbiAgICAgICAgdGhpcy5saW5lVG8oYm94LngyLCBib3gueTEpO1xuICAgICAgICB0aGlzLmxpbmVUbyhib3gueDIsIGJveC55Mik7XG4gICAgICAgIHRoaXMubGluZVRvKGJveC54MSwgYm94LnkyKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5jb21tYW5kcywgcGF0aE9yQ29tbWFuZHMpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgcGF0aC5cbiAqIEByZXR1cm5zIHtvcGVudHlwZS5Cb3VuZGluZ0JveH1cbiAqL1xuUGF0aC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm94ID0gbmV3IGJib3guQm91bmRpbmdCb3goKTtcblxuICAgIHZhciBzdGFydFggPSAwO1xuICAgIHZhciBzdGFydFkgPSAwO1xuICAgIHZhciBwcmV2WCA9IDA7XG4gICAgdmFyIHByZXZZID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIHN3aXRjaCAoY21kLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIGJveC5hZGRQb2ludChjbWQueCwgY21kLnkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0WCA9IHByZXZYID0gY21kLng7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0gcHJldlkgPSBjbWQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIGJveC5hZGRQb2ludChjbWQueCwgY21kLnkpO1xuICAgICAgICAgICAgICAgIHByZXZYID0gY21kLng7XG4gICAgICAgICAgICAgICAgcHJldlkgPSBjbWQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgIGJveC5hZGRRdWFkKHByZXZYLCBwcmV2WSwgY21kLngxLCBjbWQueTEsIGNtZC54LCBjbWQueSk7XG4gICAgICAgICAgICAgICAgcHJldlggPSBjbWQueDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IGNtZC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgYm94LmFkZEJlemllcihwcmV2WCwgcHJldlksIGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgICAgICBwcmV2WCA9IGNtZC54O1xuICAgICAgICAgICAgICAgIHByZXZZID0gY21kLnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICBwcmV2WCA9IHN0YXJ0WDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IHN0YXJ0WTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhdGggY29tbW1hbmQgJyArIGNtZC50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm94LmlzRW1wdHkoKSkge1xuICAgICAgICBib3guYWRkUG9pbnQoMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHBhdGggdG8gYSAyRCBjb250ZXh0LlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LlxuICovXG5QYXRoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gdGhpcy5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZmlsbDtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2U7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBQYXRoIHRvIGEgc3RyaW5nIG9mIHBhdGggZGF0YSBpbnN0cnVjdGlvbnNcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICogQHBhcmFtICB7bnVtYmVyfSBbZGVjaW1hbFBsYWNlcz0yXSAtIFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QYXRoLnByb3RvdHlwZS50b1BhdGhEYXRhID0gZnVuY3Rpb24oZGVjaW1hbFBsYWNlcykge1xuICAgIGRlY2ltYWxQbGFjZXMgPSBkZWNpbWFsUGxhY2VzICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsUGxhY2VzIDogMjtcblxuICAgIGZ1bmN0aW9uIGZsb2F0VG9TdHJpbmcodikge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZCh2KSA9PT0gdikge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgTWF0aC5yb3VuZCh2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvRml4ZWQoZGVjaW1hbFBsYWNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWNrVmFsdWVzKCkge1xuICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHYgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwICYmIGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHMgKz0gZmxvYXRUb1N0cmluZyh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIHZhciBkID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgZCArPSAnTScgKyBwYWNrVmFsdWVzKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgZCArPSAnTCcgKyBwYWNrVmFsdWVzKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgZCArPSAnQycgKyBwYWNrVmFsdWVzKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBkICs9ICdRJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgZCArPSAnWic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgcGF0aCB0byBhbiBTVkcgPHBhdGg+IGVsZW1lbnQsIGFzIGEgc3RyaW5nLlxuICogQHBhcmFtICB7bnVtYmVyfSBbZGVjaW1hbFBsYWNlcz0yXSAtIFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QYXRoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKGRlY2ltYWxQbGFjZXMpIHtcbiAgICB2YXIgc3ZnID0gJzxwYXRoIGQ9XCInO1xuICAgIHN2ZyArPSB0aGlzLnRvUGF0aERhdGEoZGVjaW1hbFBsYWNlcyk7XG4gICAgc3ZnICs9ICdcIic7XG4gICAgaWYgKHRoaXMuZmlsbCAmJiB0aGlzLmZpbGwgIT09ICdibGFjaycpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3ZnICs9ICcgZmlsbD1cIm5vbmVcIic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdmcgKz0gJyBmaWxsPVwiJyArIHRoaXMuZmlsbCArICdcIic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgc3ZnICs9ICcgc3Ryb2tlPVwiJyArIHRoaXMuc3Ryb2tlICsgJ1wiIHN0cm9rZS13aWR0aD1cIicgKyB0aGlzLnN0cm9rZVdpZHRoICsgJ1wiJztcbiAgICB9XG5cbiAgICBzdmcgKz0gJy8+JztcbiAgICByZXR1cm4gc3ZnO1xufTtcblxuUGF0aC5wcm90b3R5cGUudG9ET01FbGVtZW50ID0gZnVuY3Rpb24oZGVjaW1hbFBsYWNlcykge1xuICAgIHZhciB0ZW1wb3JhcnlQYXRoID0gdGhpcy50b1BhdGhEYXRhKGRlY2ltYWxQbGFjZXMpO1xuICAgIHZhciBuZXdQYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG5cbiAgICBuZXdQYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRlbXBvcmFyeVBhdGgpO1xuXG4gICAgcmV0dXJuIG5ld1BhdGg7XG59O1xuXG5leHBvcnRzLlBhdGggPSBQYXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy9wYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcyc7XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgdGhlIHNpemUgb2YgMkQgb2JqZWN0cy5cbiAqXG4gKiBAY2xhc3MgU2l6ZVxuICovXG5leHBvcnQgY2xhc3MgU2l6ZSBleHRlbmRzIFBvaW50IHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3IgU2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhpcyBgc2l6ZWAgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGlzIGBzaXplYCBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGlzIGBzaXplYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGlzIGBzaXplYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy54ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGVpZ2h0IG9mIHRoaXMgYHNpemVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhpcyBgc2l6ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICovXG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpemU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9nZW9tZXRyeS9TaXplLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE5vZGUgZnJvbSAnLi4vTm9kZS5qcyc7XG5cbi8qKlxuICogU3Ryb2tlIHJlbmRlcmluZyB0eXBlcy5cbiAqXG4gKiBAdHlwZSB7e1NUUk9LRV9OT05FOiBudWxsLCBTVFJPS0VfTUlERExFOiBTeW1ib2wsIFNUUk9LRV9JTk5FUjogU3ltYm9sLCBTVFJPS0VfT1VURVI6IFN5bWJvbH19XG4gKi9cbmNvbnN0IFNUUk9LRV9UWVBFUyA9IHtcbiAgICBTVFJPS0VfTk9ORTogbnVsbCxcbiAgICBTVFJPS0VfTUlERExFOiBTeW1ib2woJ1NUUk9LRV9NSURETEUnKSxcbiAgICBTVFJPS0VfSU5ORVI6IFN5bWJvbCgnU1RST0tFX0lOTkVSJyksXG4gICAgU1RST0tFX09VVEVSOiBTeW1ib2woJ1NUUk9LRV9PVVRFUicpLFxufTtcblxuY29uc3QgTElORV9DQVBfVFlQRVMgPSB7XG4gICAgTElORV9DQVBfQlVUVDogJ2J1dHQnLFxuICAgIExJTkVfQ0FQX1JPVU5EOiAncm91bmQnLFxuICAgIExJTkVfQ0FQX1NRVUFSRTogJ3NxdWFyZScsXG59O1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgcmVuZGVyaW5nIGEgcHJpbWl0aXZlIHNoYXBlLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IHByaW1pdGl2ZURlZmF1bHRPcHRpb25zID0ge1xuICAgIGZpbGxFbmFibGVkOiB0cnVlLFxuICAgIGZpbGxDb2xvcjogJyMwMDAwMDAnLFxuICAgIHN0cm9rZTogMSxcbiAgICBzdHJva2VDb2xvcjogJyMwMDAwMDAnLFxuICAgIHN0cm9rZVR5cGU6IFNUUk9LRV9UWVBFUy5TVFJPS0VfTk9ORSxcbiAgICBsaW5lQ2FwVHlwZTogTElORV9DQVBfVFlQRVMuTElORV9DQVBfQlVUVCxcbiAgICBjbG9zZVBhdGg6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgcHJpbWl0aXZlIHNoYXBlcy5cbiAqXG4gKiBAY2xhc3MgUHJpbWl0aXZlXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmltaXRpdmUgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgZGVmYXVsdCByZW5kZXJpbmcgb3B0aW9ucy4gTW9kaWZ5aW5nIHRoaXMgb2JqZWN0IGhhcyBubyBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgZGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcmltaXRpdmVEZWZhdWx0T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIHR5cGUgdXNlZCB0byBub3QgcmVuZGVyIGEgc3Ryb2tlLlxuICAgICAqXG4gICAgICogQHR5cGUge251bGx9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBTVFJPS0VfTk9ORSgpIHtcbiAgICAgICAgcmV0dXJuIFNUUk9LRV9UWVBFUy5TVFJPS0VfTk9ORTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgdHlwZSB1c2VkIHRvIHJlbmRlciB0aGUgc3Ryb2tlIGF0IHRoZSBtaWQgcG9pbnQgb2YgdGhlIGVkZ2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3ltYm9sfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgU1RST0tFX01JRERMRSgpIHtcbiAgICAgICAgcmV0dXJuIFNUUk9LRV9UWVBFUy5TVFJPS0VfTUlERExFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCB0eXBlIHVzZWQgdG8gcmVuZGVyIHRoZSBzdHJva2UgZnJvbSB0aGUgZWRnZSBvZiB0aGUgc2hhcGUgaW53YXJkcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTeW1ib2x9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBTVFJPS0VfSU5ORVIoKSB7XG4gICAgICAgIHJldHVybiBTVFJPS0VfVFlQRVMuU1RST0tFX0lOTkVSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCB0eXBlIHVzZWQgdG8gcmVuZGVyIHRoZSBzdHJva2UgZnJvbSB0aGUgZWRnZSBvZiB0aGUgc2hhcGUgb3V0d2FyZHMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3ltYm9sfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgU1RST0tFX09VVEVSKCkge1xuICAgICAgICByZXR1cm4gU1RST0tFX1RZUEVTLlNUUk9LRV9PVVRFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgdHlwZSB1c2VkIHRvIHJlbmRlciBmbGF0IGVkZ2UgbGluZSBjYXBzLlxuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IExJTkVfQ0FQX0JVVFQoKSB7XG4gICAgICAgIHJldHVybiBMSU5FX0NBUF9UWVBFUy5MSU5FX0NBUF9CVVRUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCB0eXBlIHVzZWQgdG8gcmVuZGVyIHJvdW5kZWQgbGluZSBjYXBzLlxuICAgICAqIE5vdGU6IFRoaXMgbGluZSBjYXAgdHlwZSBtYWtlcyB0aGUgbGluZXMgc2xpZ2h0bHkgbG9uZ2VyLlxuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IExJTkVfQ0FQX1JPVU5EKCkge1xuICAgICAgICByZXR1cm4gTElORV9DQVBfVFlQRVMuTElORV9DQVBfUk9VTkQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIHR5cGUgdXNlZCB0byByZW5kZXIgc3F1YXJlZCBsaW5lIGNhcHMuXG4gICAgICogTm90ZTogVGhpcyBsaW5lIGNhcCB0eXBlIG1ha2VzIHRoZSBsaW5lcyBzbGlnaHRseSBsb25nZXIuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTElORV9DQVBfU1FVQVJFKCkge1xuICAgICAgICByZXR1cm4gTElORV9DQVBfVFlQRVMuTElORV9DQVBfU1FVQVJFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHJlbmRlcmluZyBvcHRpb25zIG9mIHRoaXMgcHJpbWl0aXZlIHNoYXBlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBwcmltaXRpdmVEZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBvYmplY3QuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGlzIG9iamVjdCByZWFjaGVzIHplcm8uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBkZWxldGUgdGhpcy5tT3B0aW9ucztcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBmaWxsIG9mIHRoaXMgc2hhcGUgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBmaWxsRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU9wdGlvbnMuZmlsbEVuYWJsZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBmaWxsIG9mIHRoaXMgc2hhcGUgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZVxuICAgICAqL1xuICAgIHNldCBmaWxsRW5hYmxlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubU9wdGlvbnMuZmlsbEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMubU9wdGlvbnMuZmlsbEVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWxsIGNvbG9yIG9mIHRoaXMgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBmaWxsQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1PcHRpb25zLmZpbGxDb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmaWxsIGNvbG9yIG9mIHRoaXMgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSBUaGUgbmV3IGZpbGwgY29sb3IuXG4gICAgICovXG4gICAgc2V0IGZpbGxDb2xvcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubU9wdGlvbnMuZmlsbENvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLm1PcHRpb25zLmZpbGxDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubU9wdGlvbnMuZmlsbEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHN0cm9rZSBmb3IgdGhpcyBzaGFwZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHN0cm9rZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU9wdGlvbnMuc3Ryb2tlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHdpZHRoIG9mIHRoZSBzdHJva2UgZm9yIHRoaXMgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSBzdHJva2UuXG4gICAgICovXG4gICAgc2V0IHN0cm9rZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubU9wdGlvbnMuc3Ryb2tlKSB7XG4gICAgICAgICAgICB0aGlzLm1PcHRpb25zLnN0cm9rZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubU9wdGlvbnMuc3Ryb2tlVHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJva2UgY29sb3Igb2YgdGhpcyBzaGFwZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHN0cm9rZUNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tT3B0aW9ucy5zdHJva2VDb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJva2UgY29sb3Igb2YgdGhpcyBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIFRoZSBuZXcgY29sb3IuXG4gICAgICovXG4gICAgc2V0IHN0cm9rZUNvbG9yKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tT3B0aW9ucy5zdHJva2VDb2xvcikge1xuICAgICAgICAgICAgdGhpcy5tT3B0aW9ucy5zdHJva2VDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubU9wdGlvbnMuc3Ryb2tlVHlwZSAmJiB0aGlzLm1PcHRpb25zLnN0cm9rZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3Ryb2tlIHR5cGUgb2YgdGhpcyBzaGFwZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTeW1ib2x8bnVsbH1cbiAgICAgKi9cbiAgICBnZXQgc3Ryb2tlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU9wdGlvbnMuc3Ryb2tlVHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJva2UgdHlwZSBvZiB0aGlzIHNoYXBlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N5bWJvbHxudWxsfSB2YWx1ZSAtIFRoZSBuZXcgc3Ryb2tlIHR5cGUuXG4gICAgICovXG4gICAgc2V0IHN0cm9rZVR5cGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLm1PcHRpb25zLnN0cm9rZVR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMubU9wdGlvbnMuc3Ryb2tlVHlwZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubU9wdGlvbnMuc3Ryb2tlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzdHJva2UgaXMgZW5hYmxlZCwgdGhlIGxpbmUgY2FwIHR5cGUgZm9yIHRoaXMgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBsaW5lQ2FwVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU9wdGlvbnMubGluZUNhcFR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGluZSBjYXAgdHlwZSBvZiB0aGlzIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gVGhlIG5ldyBsaW5lIGNhcCB0eXBlLlxuICAgICAqL1xuICAgIHNldCBsaW5lQ2FwVHlwZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubU9wdGlvbnMubGluZUNhcFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMubU9wdGlvbnMubGluZUNhcFR5cGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1PcHRpb25zLnN0cm9rZVR5cGUgJiYgdGhpcy5tT3B0aW9ucy5zdHJva2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoZSBwYXRoIG9mIHRoaXMgc2hhcGUgYWx3YXlzIGJlIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBjbG9zZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1PcHRpb25zLmNsb3NlUGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGlmIHRoZSBwYXRoIG9mIHRoaXMgc2hhcGUgc2hvdWxkIGFsd2F5cyBiZSBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gVGhlIG5ldyBmbGFnLlxuICAgICAqL1xuICAgIHNldCBjbG9zZVBhdGgodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLm1PcHRpb25zLmNsb3NlUGF0aCkge1xuICAgICAgICAgICAgdGhpcy5tT3B0aW9ucy5jbG9zZVBhdGggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSB0aWNrLCBkcmF3aW5nIG9wZXJhdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZCBoZXJlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkcmF3XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IHZhckFyZ3MgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgbm9kZSdzIGNoaWxkcmVuIHdoZW4gZHJhd2luZy5cbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIC4uLnZhckFyZ3MpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyUGF0aChjb250ZXh0LCB0aGlzLm1PcHRpb25zKTtcbiAgICAgICAgdGhpcy5fYXBwbHlSZW5kZXJPcHRpb25zKGNvbnRleHQsIHRoaXMubU9wdGlvbnMpO1xuICAgICAgICBzdXBlci5kcmF3KGNvbnRleHQsIC4uLnZhckFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHBhdGggb2YgdGhpcyBzaGFwZSB0byB0aGUgY29udGV4dC5cbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBtdXN0IGJlIG92ZXJyaWRkZW4gaW4gUHJpbWl0aXZlIHN1YmNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJQYXRoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQYXRoKC8qIGNvbnRleHQsIG9wdGlvbnMgKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfcmVuZGVyUGF0aCBtdXN0IGJlIG92ZXJyaWRkZW4gaW4gc3ViY2xhc3Nlcy4gQ2Fubm90IHJlbmRlciBQcmltaXRpdmUgZGlyZWN0bHkgdG8gY29udGV4dC4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWxsLCBzdHJva2UsIGV0Yy4gYXMgZGVzY3JpYmVkIGluIHRoZSBwcm92aWRlZCBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfYXBwbHlSZW5kZXJPcHRpb25zXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hcHBseVJlbmRlck9wdGlvbnMoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5maWxsRW5hYmxlZCkge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvcjtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlVHlwZSAmJiBvcHRpb25zLnN0cm9rZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcFR5cGU7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5zdHJva2VDb2xvcjtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gb3B0aW9ucy5zdHJva2U7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcmltaXRpdmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9ncmFwaGljcy9wcmltaXRpdmVzL1ByaW1pdGl2ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IEV2ZW50cyA9IHtcbiAgICBJTlBVVF9QT0lOVEVSX0JFR0FOOiAnSW5wdXQ6OlBvaW50ZXI6OkJlZ2FuJyxcbiAgICBJTlBVVF9QT0lOVEVSX01PVkVEOiAnSW5wdXQ6OlBvaW50ZXI6Ok1vdmVkJyxcbiAgICBJTlBVVF9QT0lOVEVSX0VOREVEOiAnSW5wdXQ6OlBvaW50ZXI6OkVuZGVkJyxcbiAgICBJTlBVVF9QT0lOVEVSX0NBTkNFTExFRDogJ0lucHV0OjpQb2ludGVyOjpDYW5jZWxsZWQnLFxuXG4gICAgSU5QVVRfTU9VU0VfU0NST0xMX1VQOiAnSW5wdXQ6Ok1vdXNlOjpTY3JvbGxVcCcsXG4gICAgSU5QVVRfTU9VU0VfU0NST0xMX0RPV046ICdJbnB1dDo6TW91c2U6OlNjcm9sbERvd24nLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvcGx1Z2lucy9pbnB1dC9FdmVudHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgSUJpbmRhYmxlIGZyb20gJy4uLy4uL2NvcmUvSUJpbmRhYmxlLmpzJztcbmltcG9ydCBQb2ludGVyRXZlbnQgZnJvbSAnLi9Qb2ludGVyRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL0V2ZW50cy5qcyc7XG5pbXBvcnQgQ2FudmFzIGZyb20gJy4uLy4uL2dyYXBoaWNzL0NhbnZhcyc7XG5cbmNvbnN0IElucHV0TWFuYWdlckluc3RhbmNlcyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBDbGFzcyB1c2VkIHRvIG1hbmFnZSBpbnB1dCBldmVudHMuIEluY2x1ZGVzIHV0aWxpdHkgZnVuY3Rpb25zIHRvIGFzc29jaWF0ZSBhbiBJbm91dE1hbmFnZXIgdG8gYSBjYW52YXMgYnkgaXRzIHJldmlDb250ZXh0LlxuICpcbiAqIEBjbGFzcyBJbnB1dE1hbmFnZXJcbiAqL1xuZXhwb3J0IGNsYXNzIElucHV0TWFuYWdlciBleHRlbmRzIElCaW5kYWJsZSB7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgcmV2aSBjb250ZXh0IGFuZCBiaW5kcyBhIG5ldyBJbnB1dE1hbmFnZXIgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyQ29udGV4dFxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBjb250ZXh0IC0gVGhlIHJldmkgY29udGV4dCBvZiB0aGUgY2FudmFzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKElucHV0TWFuYWdlckluc3RhbmNlcy5oYXMoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvbnRleHQgaXMgYWxyZWFkeSByZWdpc3RlcmVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2FudmFzID0gQ2FudmFzLmdldENhbnZhc0ZvckNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNhbnZhcyBpcyByZWdpc3RlcmVkIGZvciB0aGUgcHJvdmlkZWQgY29udGV4dCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgSW5wdXRNYW5hZ2VySW5zdGFuY2VzLnNldChjb250ZXh0LCBuZXcgSW5wdXRNYW5hZ2VyKGNhbnZhcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIGEgcmV2aSBjb250ZXh0IGFuZCBkZXN0cm95cyB0aGUgSW5wdXRNYW5hZ2VyIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdW5yZWdpc3RlckNvbnRleHRcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gY29udGV4dCAtIFRoZSByZXZpIGNvbnRleHQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHVucmVnaXN0ZXJDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXJJbnN0YW5jZXMuZ2V0KGNvbnRleHQpO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIElucHV0TWFuYWdlckluc3RhbmNlcy5kZWxldGUoY29udGV4dCk7XG4gICAgICAgICAgICBpbnN0YW5jZS5yZWxlYXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjb250ZXh0IHdhcyBuZXZlciByZWdpc3RlcmVkLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIElucHV0TWFuYWdlciBsaW5rZWQgdG8gdGhlIHByb3ZpZGVkIGNvbnRleHQgYW5kIHJldHVybnMgaXQgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGluc3RhbmNlRm9yQ29udGV4dFxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBjb250ZXh0IC0gVGhlIHJldmkgY29udGV4dCB0byBsb29rIGZvci5cbiAgICAgKiBAcmV0dXJucyB7SW5wdXRNYW5hZ2VyfG51bGx9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBpbnN0YW5jZUZvckNvbnRleHQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gSW5wdXRNYW5hZ2VySW5zdGFuY2VzLmdldChjb250ZXh0KSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXMgLSBUaGUgcmV2aSBjYW52YXMgdGhpcyBJbnB1dE1hbmFnZXIgd2lsbCBiZSBib3VuZCB0by5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tQ2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLm1FbGVtZW50ID0gdGhpcy5tQ2FudmFzLm1DYW52YXM7XG5cbiAgICAgICAgdGhpcy5tUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tVG91Y2hUcmFja2luZ0lEID0gLTE7XG4gICAgICAgIHRoaXMubUFsbG93c011bHRpcGxlUG9pbnRlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tRW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5tTGluZUhlaWdodCA9IDE2OyAvKiAtLi0gKi9cbiAgICAgICAgdGhpcy5tUGFnZUhlaWdodCA9IHRoaXMubUNhbnZhcy5zaXplLmhlaWdodDtcblxuICAgICAgICB0aGlzLm1Cb3VuZE1vdXNlSGFuZGxlciA9IHRoaXMuX21vdXNlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubUJvdW5kTW91c2VIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubUJvdW5kTW91c2VIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5tQm91bmRNb3VzZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMubUJvdW5kTW91c2VIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tQm91bmRNb3VzZUhhbmRsZXIsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLm1Cb3VuZFRvdWNoSGFuZGxlciA9IHRoaXMuX3RvdWNoSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm1Cb3VuZFRvdWNoSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMubUJvdW5kVG91Y2hIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm1Cb3VuZFRvdWNoSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW50ZXInLCB0aGlzLm1Cb3VuZFRvdWNoSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLm1Cb3VuZFRvdWNoSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5tQm91bmRUb3VjaEhhbmRsZXIsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLm1Cb3VuZFdoZWVsSGFuZGxlciA9IHRoaXMuX3doZWVsSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5tQm91bmRXaGVlbEhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1Cb3VuZE1vdXNlSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1Cb3VuZE1vdXNlSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMubUJvdW5kTW91c2VIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm1Cb3VuZE1vdXNlSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubUJvdW5kTW91c2VIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5tQm91bmRUb3VjaEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm1Cb3VuZFRvdWNoSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5tQm91bmRUb3VjaEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVudGVyJywgdGhpcy5tQm91bmRUb3VjaEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgdGhpcy5tQm91bmRUb3VjaEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMubUJvdW5kVG91Y2hIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMubUJvdW5kV2hlZWxIYW5kbGVyKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5tQ2FudmFzO1xuICAgICAgICBkZWxldGUgdGhpcy5tRWxlbWVudDtcbiAgICAgICAgZGVsZXRlIHRoaXMubVBvaW50ZXJEb3duO1xuICAgICAgICBkZWxldGUgdGhpcy5tVG91Y2hUcmFja2luZ0lEO1xuICAgICAgICBkZWxldGUgdGhpcy5tQWxsb3dzTXVsdGlwbGVQb2ludGVycztcbiAgICAgICAgZGVsZXRlIHRoaXMubUVuYWJsZWQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1MaW5lSGVpZ2h0O1xuICAgICAgICBkZWxldGUgdGhpcy5tUGFnZUhlaWdodDtcbiAgICAgICAgZGVsZXRlIHRoaXMubUJvdW5kTW91c2VIYW5kbGVyO1xuICAgICAgICBkZWxldGUgdGhpcy5tQm91bmRUb3VjaEhhbmRsZXI7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1Cb3VuZFdoZWVsSGFuZGxlcjtcblxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBJbnB1dE1hbmFnZXIgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tRW5hYmxlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGlmIHRoaXMgSW5wdXRNYW5hZ2VyIGlzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXQgZW5hYmxlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMubUVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbW91c2UgaW5wdXRzIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX21vdXNlSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SW5wdXRFdmVudH0gaW5wdXRFdmVudCAtIFRoZSBldmVudCB0byBoYW5kbGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91c2VIYW5kbGVyKGlucHV0RXZlbnQpIHtcbiAgICAgICAgaW5wdXRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpbnB1dEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGxldCBldmVudFR5cGUgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKGlucHV0RXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubVBvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gRXZlbnRzLklOUFVUX1BPSU5URVJfQkVHQU47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IEV2ZW50cy5JTlBVVF9QT0lOVEVSX01PVkVEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1Qb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IEV2ZW50cy5JTlBVVF9QT0lOVEVSX0VOREVEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubVBvaW50ZXJEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubVBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IEV2ZW50cy5JTlBVVF9QT0lOVEVSX0NBTkNFTExFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ21vdXNlb3Zlcic6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMubUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gaW5wdXRFdmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgeSA9IGlucHV0RXZlbnQuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlckV2ZW50ID0gUG9pbnRlckV2ZW50Lmluc3RhbmNlKGV2ZW50VHlwZSwgeCwgeSwgMTIzNDU2Nzg5LCBEYXRlLm5vdygpKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudFR5cGUsIHRoaXMsIHBvaW50ZXJFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRvdWNoIGlucHV0IGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3RvdWNoSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SW5wdXRFdmVudH0gaW5wdXRFdmVudCAtIFRoZSBldmVudCB0byBoYW5kbGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG91Y2hIYW5kbGVyKGlucHV0RXZlbnQpIHtcbiAgICAgICAgaW5wdXRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGxldCBzaG91bGRSZXNldFRvdWNoSUQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGV2ZW50VHlwZSA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAoaW5wdXRFdmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0b3VjaHN0YXJ0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IEV2ZW50cy5JTlBVVF9QT0lOVEVSX0JFR0FOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBFdmVudHMuSU5QVVRfUE9JTlRFUl9NT1ZFRDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICAgICAgICAgIHNob3VsZFJlc2V0VG91Y2hJRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gRXZlbnRzLklOUFVUX1BPSU5URVJfRU5ERUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3RvdWNobGVhdmUnOlxuICAgICAgICAgICAgY2FzZSAndG91Y2hjYW5jZWwnOlxuICAgICAgICAgICAgICAgIHNob3VsZFJlc2V0VG91Y2hJRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gRXZlbnRzLklOUFVUX1BPSU5URVJfQ0FOQ0VMTEVEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd0b3VjaGVudGVyJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCB0b3VjaGVzID0gaW5wdXRFdmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoZXNMZW5ndGggPSB0b3VjaGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG91Y2hlc0xlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdWNoSUQgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1BbGxvd3NNdWx0aXBsZVBvaW50ZXJzIHx8IHRoaXMubVRvdWNoVHJhY2tpbmdJRCA9PT0gLTEgfHwgdG91Y2hJRCA9PT0gdGhpcy5tVG91Y2hUcmFja2luZ0lEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubVRvdWNoVHJhY2tpbmdJRCA9IHRvdWNoSUQ7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMubUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBpbnB1dEV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBpbnB1dEV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVyRXZlbnQgPSBQb2ludGVyRXZlbnQuaW5zdGFuY2UoZXZlbnRUeXBlLCB4LCB5LCB0b3VjaC5pZGVudGlmaWVyLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50VHlwZSwgdGhpcywgcG9pbnRlckV2ZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVzZXRUb3VjaElEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1Ub3VjaFRyYWNraW5nSUQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2Nyb2xsIHdoZWVsIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3doZWVsSGFuZGxlclxuICAgICAqIEBwYXJhbSB7V2hlZWxFdmVudH0gd2hlZWxFdmVudCAtIFRoZSBldmVudCB0byBoYW5kbGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfd2hlZWxIYW5kbGVyKHdoZWVsRXZlbnQpIHtcbiAgICAgICAgaWYgKHdoZWVsRXZlbnQuZGVsdGFZICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgd2hlZWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50VHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHdoZWVsRXZlbnQuZGVsdGFZID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBFdmVudHMuSU5QVVRfTU9VU0VfU0NST0xMX1VQO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2hlZWxFdmVudC5kZWx0YVkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IEV2ZW50cy5JTlBVVF9NT1VTRV9TQ1JPTExfRE9XTjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSB3aGVlbEV2ZW50LmxheWVyWDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHdoZWVsRXZlbnQubGF5ZXJZO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YSA9IE1hdGguYWJzKHdoZWVsRXZlbnQuZGVsdGFZKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoZWVsRXZlbnQuZGVsdGFNb2RlID09PSAxKSB7IC8qIHBlci1saW5lIHNjcm9sbGluZyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKj0gdGhpcy5tTGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aGVlbEV2ZW50LmRlbHRhTW9kZSA9PT0gMikgeyAvKiBwZXItcGFnZSBzY3JvbGxpbmcgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICo9IHRoaXMubVBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnRUeXBlLCB0aGlzLCBkZWx0YSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dE1hbmFnZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9wbHVnaW5zL2lucHV0L0lucHV0TWFuYWdlci5qcyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIG1ldGEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkaXRlckRldGVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyAgICA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uKEtFWSl7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSAgICAgICAgICAgICA9IG5ldyBDXG4gICAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgICAsIEhBU05UX0NIQUlOSU5HICAgICAgID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZVxuICAgICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAsIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24oKXsgaW5zdGFuY2UuaGFzKDEpOyB9KVxuICAgICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgICAgLCBBQ0NFUFRfSVRFUkFCTEVTICAgICA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpeyBuZXcgQyhpdGVyKTsgfSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgICAgLCBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpXG4gICAgICAgICAgLCBpbmRleCAgICAgPSA1O1xuICAgICAgICB3aGlsZShpbmRleC0tKSRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICAgIH0pO1xuICAgIGlmKCFBQ0NFUFRfSVRFUkFCTEVTKXsgXG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTyl7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZihCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKWZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZihJU19XRUFLICYmIHByb3RvLmNsZWFyKWRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGZhaWxzICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgd2tzICAgICAgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGxlbmd0aCwgZXhlYyl7XG4gIHZhciBTWU1CT0wgICA9IHdrcyhLRVkpXG4gICAgLCBmbnMgICAgICA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldKVxuICAgICwgc3RyZm4gICAgPSBmbnNbMF1cbiAgICAsIHJ4Zm4gICAgID0gZm5zWzFdO1xuICBpZihmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSkpe1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24oc3RyaW5nLCBhcmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uKHN0cmluZyl7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCAgID0gYW5PYmplY3QodGhpcylcbiAgICAsIHJlc3VsdCA9ICcnO1xuICBpZih0aGF0Lmdsb2JhbCkgICAgIHJlc3VsdCArPSAnZyc7XG4gIGlmKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYodGhhdC5tdWx0aWxpbmUpICByZXN1bHQgKz0gJ20nO1xuICBpZih0aGF0LnVuaWNvZGUpICAgIHJlc3VsdCArPSAndSc7XG4gIGlmKHRoYXQuc3RpY2t5KSAgICAgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBjb2YgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgTUFUQ0ggICAgPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHJldHVybiB7ZG9uZTogc2FmZSA9IHRydWV9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKXx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTtcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovfSk7XG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBUWVBFRCAgPSB1aWQoJ3R5cGVkX2FycmF5JylcbiAgLCBWSUVXICAgPSB1aWQoJ3ZpZXcnKVxuICAsIEFCViAgICA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpXG4gICwgQ09OU1RSID0gQUJWXG4gICwgaSA9IDAsIGwgPSA5LCBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUoaSA8IGwpe1xuICBpZihUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKXtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiAgICBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogIFRZUEVELFxuICBWSUVXOiAgIFZJRVdcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEdseXBoIGVuY29kaW5nXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNmZlN0YW5kYXJkU3RyaW5ncyA9IFtcbiAgICAnLm5vdGRlZicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLFxuICAgICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLCAncXVvdGVkYmxsZWZ0JywgJ2d1aWxsZW1vdGxlZnQnLFxuICAgICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2VuZGFzaCcsICdkYWdnZXInLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3BhcmFncmFwaCcsXG4gICAgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsXG4gICAgJ3F1ZXN0aW9uZG93bicsICdncmF2ZScsICdhY3V0ZScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAncmluZycsXG4gICAgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsICdlbWRhc2gnLCAnQUUnLCAnb3JkZmVtaW5pbmUnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsXG4gICAgJ29yZG1hc2N1bGluZScsICdhZScsICdkb3RsZXNzaScsICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnLCAnb25lc3VwZXJpb3InLCAnbG9naWNhbG5vdCcsICdtdScsXG4gICAgJ3RyYWRlbWFyaycsICdFdGgnLCAnb25laGFsZicsICdwbHVzbWludXMnLCAnVGhvcm4nLCAnb25lcXVhcnRlcicsICdkaXZpZGUnLCAnYnJva2VuYmFyJywgJ2RlZ3JlZScsICd0aG9ybicsXG4gICAgJ3RocmVlcXVhcnRlcnMnLCAndHdvc3VwZXJpb3InLCAncmVnaXN0ZXJlZCcsICdtaW51cycsICdldGgnLCAnbXVsdGlwbHknLCAndGhyZWVzdXBlcmlvcicsICdjb3B5cmlnaHQnLFxuICAgICdBYWN1dGUnLCAnQWNpcmN1bWZsZXgnLCAnQWRpZXJlc2lzJywgJ0FncmF2ZScsICdBcmluZycsICdBdGlsZGUnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ0VjaXJjdW1mbGV4JyxcbiAgICAnRWRpZXJlc2lzJywgJ0VncmF2ZScsICdJYWN1dGUnLCAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdOdGlsZGUnLCAnT2FjdXRlJywgJ09jaXJjdW1mbGV4JyxcbiAgICAnT2RpZXJlc2lzJywgJ09ncmF2ZScsICdPdGlsZGUnLCAnU2Nhcm9uJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsICdVZGllcmVzaXMnLCAnVWdyYXZlJywgJ1lhY3V0ZScsXG4gICAgJ1lkaWVyZXNpcycsICdaY2Fyb24nLCAnYWFjdXRlJywgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhZ3JhdmUnLCAnYXJpbmcnLCAnYXRpbGRlJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsXG4gICAgJ2VjaXJjdW1mbGV4JywgJ2VkaWVyZXNpcycsICdlZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdpZ3JhdmUnLCAnbnRpbGRlJywgJ29hY3V0ZScsXG4gICAgJ29jaXJjdW1mbGV4JywgJ29kaWVyZXNpcycsICdvZ3JhdmUnLCAnb3RpbGRlJywgJ3NjYXJvbicsICd1YWN1dGUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ3VncmF2ZScsXG4gICAgJ3lhY3V0ZScsICd5ZGllcmVzaXMnLCAnemNhcm9uJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAnMjY2IGZmJywgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLCAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsXG4gICAgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJyxcbiAgICAncXVlc3Rpb25zbWFsbCcsICdhc3VwZXJpb3InLCAnYnN1cGVyaW9yJywgJ2NlbnRzdXBlcmlvcicsICdkc3VwZXJpb3InLCAnZXN1cGVyaW9yJywgJ2lzdXBlcmlvcicsICdsc3VwZXJpb3InLFxuICAgICdtc3VwZXJpb3InLCAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICdmZicsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnZXhjbGFtZG93bnNtYWxsJyxcbiAgICAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLCAnQnJldmVzbWFsbCcsICdDYXJvbnNtYWxsJyxcbiAgICAnRG90YWNjZW50c21hbGwnLCAnTWFjcm9uc21hbGwnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJyxcbiAgICAnemVyb3N1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLCAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsXG4gICAgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLFxuICAgICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLCAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsXG4gICAgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLCAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsXG4gICAgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJywgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLFxuICAgICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJyxcbiAgICAnT2FjdXRlc21hbGwnLCAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJyxcbiAgICAnVWFjdXRlc21hbGwnLCAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJywgJzAwMS4wMDAnLFxuICAgICcwMDEuMDAxJywgJzAwMS4wMDInLCAnMDAxLjAwMycsICdCbGFjaycsICdCb2xkJywgJ0Jvb2snLCAnTGlnaHQnLCAnTWVkaXVtJywgJ1JlZ3VsYXInLCAnUm9tYW4nLCAnU2VtaWJvbGQnXTtcblxudmFyIGNmZlN0YW5kYXJkRW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJ2V4Y2xhbWRvd24nLCAnY2VudCcsICdzdGVybGluZycsICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLFxuICAgICdxdW90ZWRibGxlZnQnLCAnZ3VpbGxlbW90bGVmdCcsICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJycsICdlbmRhc2gnLCAnZGFnZ2VyJyxcbiAgICAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJycsICdwYXJhZ3JhcGgnLCAnYnVsbGV0JywgJ3F1b3Rlc2luZ2xiYXNlJywgJ3F1b3RlZGJsYmFzZScsICdxdW90ZWRibHJpZ2h0JyxcbiAgICAnZ3VpbGxlbW90cmlnaHQnLCAnZWxsaXBzaXMnLCAncGVydGhvdXNhbmQnLCAnJywgJ3F1ZXN0aW9uZG93bicsICcnLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsXG4gICAgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAnJywgJ3JpbmcnLCAnY2VkaWxsYScsICcnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsXG4gICAgJ2VtZGFzaCcsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnQUUnLCAnJywgJ29yZGZlbWluaW5lJywgJycsICcnLCAnJyxcbiAgICAnJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLCAnb3JkbWFzY3VsaW5lJywgJycsICcnLCAnJywgJycsICcnLCAnYWUnLCAnJywgJycsICcnLCAnZG90bGVzc2knLCAnJywgJycsXG4gICAgJ2xzbGFzaCcsICdvc2xhc2gnLCAnb2UnLCAnZ2VybWFuZGJscyddO1xuXG52YXIgY2ZmRXhwZXJ0RW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW1zbWFsbCcsICdIdW5nYXJ1bWxhdXRzbWFsbCcsICcnLCAnZG9sbGFyb2xkc3R5bGUnLCAnZG9sbGFyc3VwZXJpb3InLFxuICAgICdhbXBlcnNhbmRzbWFsbCcsICdBY3V0ZXNtYWxsJywgJ3BhcmVubGVmdHN1cGVyaW9yJywgJ3BhcmVucmlnaHRzdXBlcmlvcicsICd0d29kb3RlbmxlYWRlcicsICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnZnJhY3Rpb24nLCAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLFxuICAgICdmb3Vyb2xkc3R5bGUnLCAnZml2ZW9sZHN0eWxlJywgJ3NpeG9sZHN0eWxlJywgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29sb24nLFxuICAgICdzZW1pY29sb24nLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJywgJ3F1ZXN0aW9uc21hbGwnLCAnJywgJ2FzdXBlcmlvcicsXG4gICAgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICcnLCAnJywgJ2lzdXBlcmlvcicsICcnLCAnJywgJ2xzdXBlcmlvcicsICdtc3VwZXJpb3InLFxuICAgICduc3VwZXJpb3InLCAnb3N1cGVyaW9yJywgJycsICcnLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnJywgJ2ZmJywgJ2ZpJywgJ2ZsJywgJ2ZmaScsICdmZmwnLFxuICAgICdwYXJlbmxlZnRpbmZlcmlvcicsICcnLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICdleGNsYW1kb3duc21hbGwnLCAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJycsICcnLCAnU2Nhcm9uc21hbGwnLCAnWmNhcm9uc21hbGwnLCAnRGllcmVzaXNzbWFsbCcsXG4gICAgJ0JyZXZlc21hbGwnLCAnQ2Fyb25zbWFsbCcsICcnLCAnRG90YWNjZW50c21hbGwnLCAnJywgJycsICdNYWNyb25zbWFsbCcsICcnLCAnJywgJ2ZpZ3VyZWRhc2gnLCAnaHlwaGVuaW5mZXJpb3InLFxuICAgICcnLCAnJywgJ09nb25la3NtYWxsJywgJ1JpbmdzbWFsbCcsICdDZWRpbGxhc21hbGwnLCAnJywgJycsICcnLCAnb25lcXVhcnRlcicsICdvbmVoYWxmJywgJ3RocmVlcXVhcnRlcnMnLFxuICAgICdxdWVzdGlvbmRvd25zbWFsbCcsICdvbmVlaWdodGgnLCAndGhyZWVlaWdodGhzJywgJ2ZpdmVlaWdodGhzJywgJ3NldmVuZWlnaHRocycsICdvbmV0aGlyZCcsICd0d290aGlyZHMnLCAnJyxcbiAgICAnJywgJ3plcm9zdXBlcmlvcicsICdvbmVzdXBlcmlvcicsICd0d29zdXBlcmlvcicsICd0aHJlZXN1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLFxuICAgICdzaXhzdXBlcmlvcicsICdzZXZlbnN1cGVyaW9yJywgJ2VpZ2h0c3VwZXJpb3InLCAnbmluZXN1cGVyaW9yJywgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsXG4gICAgJ3RocmVlaW5mZXJpb3InLCAnZm91cmluZmVyaW9yJywgJ2ZpdmVpbmZlcmlvcicsICdzaXhpbmZlcmlvcicsICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLFxuICAgICduaW5laW5mZXJpb3InLCAnY2VudGluZmVyaW9yJywgJ2RvbGxhcmluZmVyaW9yJywgJ3BlcmlvZGluZmVyaW9yJywgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLFxuICAgICdBYWN1dGVzbWFsbCcsICdBY2lyY3VtZmxleHNtYWxsJywgJ0F0aWxkZXNtYWxsJywgJ0FkaWVyZXNpc3NtYWxsJywgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJyxcbiAgICAnRWdyYXZlc21hbGwnLCAnRWFjdXRlc21hbGwnLCAnRWNpcmN1bWZsZXhzbWFsbCcsICdFZGllcmVzaXNzbWFsbCcsICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsXG4gICAgJ0ljaXJjdW1mbGV4c21hbGwnLCAnSWRpZXJlc2lzc21hbGwnLCAnRXRoc21hbGwnLCAnTnRpbGRlc21hbGwnLCAnT2dyYXZlc21hbGwnLCAnT2FjdXRlc21hbGwnLFxuICAgICdPY2lyY3VtZmxleHNtYWxsJywgJ090aWxkZXNtYWxsJywgJ09kaWVyZXNpc3NtYWxsJywgJ09Fc21hbGwnLCAnT3NsYXNoc21hbGwnLCAnVWdyYXZlc21hbGwnLCAnVWFjdXRlc21hbGwnLFxuICAgICdVY2lyY3VtZmxleHNtYWxsJywgJ1VkaWVyZXNpc3NtYWxsJywgJ1lhY3V0ZXNtYWxsJywgJ1Rob3Juc21hbGwnLCAnWWRpZXJlc2lzc21hbGwnXTtcblxudmFyIHN0YW5kYXJkTmFtZXMgPSBbXG4gICAgJy5ub3RkZWYnLCAnLm51bGwnLCAnbm9ubWFya2luZ3JldHVybicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsXG4gICAgJ2FtcGVyc2FuZCcsICdxdW90ZXNpbmdsZScsICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLFxuICAgICd6ZXJvJywgJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJyxcbiAgICAnZXF1YWwnLCAnZ3JlYXRlcicsICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsXG4gICAgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JyxcbiAgICAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsICdncmF2ZScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsXG4gICAgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsXG4gICAgJ0FkaWVyZXNpcycsICdBcmluZycsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnTnRpbGRlJywgJ09kaWVyZXNpcycsICdVZGllcmVzaXMnLCAnYWFjdXRlJywgJ2FncmF2ZScsXG4gICAgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhdGlsZGUnLCAnYXJpbmcnLCAnY2NlZGlsbGEnLCAnZWFjdXRlJywgJ2VncmF2ZScsICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLFxuICAgICdpYWN1dGUnLCAnaWdyYXZlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdudGlsZGUnLCAnb2FjdXRlJywgJ29ncmF2ZScsICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLFxuICAgICdvdGlsZGUnLCAndWFjdXRlJywgJ3VncmF2ZScsICd1Y2lyY3VtZmxleCcsICd1ZGllcmVzaXMnLCAnZGFnZ2VyJywgJ2RlZ3JlZScsICdjZW50JywgJ3N0ZXJsaW5nJywgJ3NlY3Rpb24nLFxuICAgICdidWxsZXQnLCAncGFyYWdyYXBoJywgJ2dlcm1hbmRibHMnLCAncmVnaXN0ZXJlZCcsICdjb3B5cmlnaHQnLCAndHJhZGVtYXJrJywgJ2FjdXRlJywgJ2RpZXJlc2lzJywgJ25vdGVxdWFsJyxcbiAgICAnQUUnLCAnT3NsYXNoJywgJ2luZmluaXR5JywgJ3BsdXNtaW51cycsICdsZXNzZXF1YWwnLCAnZ3JlYXRlcmVxdWFsJywgJ3llbicsICdtdScsICdwYXJ0aWFsZGlmZicsICdzdW1tYXRpb24nLFxuICAgICdwcm9kdWN0JywgJ3BpJywgJ2ludGVncmFsJywgJ29yZGZlbWluaW5lJywgJ29yZG1hc2N1bGluZScsICdPbWVnYScsICdhZScsICdvc2xhc2gnLCAncXVlc3Rpb25kb3duJyxcbiAgICAnZXhjbGFtZG93bicsICdsb2dpY2Fsbm90JywgJ3JhZGljYWwnLCAnZmxvcmluJywgJ2FwcHJveGVxdWFsJywgJ0RlbHRhJywgJ2d1aWxsZW1vdGxlZnQnLCAnZ3VpbGxlbW90cmlnaHQnLFxuICAgICdlbGxpcHNpcycsICdub25icmVha2luZ3NwYWNlJywgJ0FncmF2ZScsICdBdGlsZGUnLCAnT3RpbGRlJywgJ09FJywgJ29lJywgJ2VuZGFzaCcsICdlbWRhc2gnLCAncXVvdGVkYmxsZWZ0JyxcbiAgICAncXVvdGVkYmxyaWdodCcsICdxdW90ZWxlZnQnLCAncXVvdGVyaWdodCcsICdkaXZpZGUnLCAnbG96ZW5nZScsICd5ZGllcmVzaXMnLCAnWWRpZXJlc2lzJywgJ2ZyYWN0aW9uJyxcbiAgICAnY3VycmVuY3knLCAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAncXVvdGVzaW5nbGJhc2UnLFxuICAgICdxdW90ZWRibGJhc2UnLCAncGVydGhvdXNhbmQnLCAnQWNpcmN1bWZsZXgnLCAnRWNpcmN1bWZsZXgnLCAnQWFjdXRlJywgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJyxcbiAgICAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLCAnYXBwbGUnLCAnT2dyYXZlJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsXG4gICAgJ1VncmF2ZScsICdkb3RsZXNzaScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAncmluZycsICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsXG4gICAgJ29nb25laycsICdjYXJvbicsICdMc2xhc2gnLCAnbHNsYXNoJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWmNhcm9uJywgJ3pjYXJvbicsICdicm9rZW5iYXInLCAnRXRoJywgJ2V0aCcsXG4gICAgJ1lhY3V0ZScsICd5YWN1dGUnLCAnVGhvcm4nLCAndGhvcm4nLCAnbWludXMnLCAnbXVsdGlwbHknLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsXG4gICAgJ29uZWhhbGYnLCAnb25lcXVhcnRlcicsICd0aHJlZXF1YXJ0ZXJzJywgJ2ZyYW5jJywgJ0dicmV2ZScsICdnYnJldmUnLCAnSWRvdGFjY2VudCcsICdTY2VkaWxsYScsICdzY2VkaWxsYScsXG4gICAgJ0NhY3V0ZScsICdjYWN1dGUnLCAnQ2Nhcm9uJywgJ2NjYXJvbicsICdkY3JvYXQnXTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBlbmNvZGluZyB1c2VkIGZvciBmb250cyBjcmVhdGVkIGZyb20gc2NyYXRjaC5cbiAqIEl0IGxvb3BzIHRocm91Z2ggYWxsIGdseXBocyBhbmQgZmluZHMgdGhlIGFwcHJvcHJpYXRlIHVuaWNvZGUgdmFsdWUuXG4gKiBTaW5jZSBpdCdzIGxpbmVhciB0aW1lLCBvdGhlciBlbmNvZGluZ3Mgd2lsbCBiZSBmYXN0ZXIuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5EZWZhdWx0RW5jb2RpbmdcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKi9cbmZ1bmN0aW9uIERlZmF1bHRFbmNvZGluZyhmb250KSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbn1cblxuRGVmYXVsdEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBjb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBnbHlwaHMgPSB0aGlzLmZvbnQuZ2x5cGhzO1xuICAgIGlmIChnbHlwaHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoLnVuaWNvZGVzW2pdID09PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQ21hcEVuY29kaW5nXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGNtYXAgLSBhIG9iamVjdCB3aXRoIHRoZSBjbWFwIGVuY29kZWQgZGF0YVxuICovXG5mdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuICAgIHRoaXMuY21hcCA9IGNtYXA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBjIC0gdGhlIGNoYXJhY3RlclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ2x5cGggaW5kZXguXG4gKi9cbkNtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gdGhpcy5jbWFwLmdseXBoSW5kZXhNYXBbYy5jaGFyQ29kZUF0KDApXSB8fCAwO1xufTtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5DZmZFbmNvZGluZ1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyAtIFRoZSBlbmNvZGluZ1xuICogQHBhcmFtIHtBcnJheX0gY2hhcnNldCAtIFRoZSBjaGFyY2F0ZXIgc2V0LlxuICovXG5mdW5jdGlvbiBDZmZFbmNvZGluZyhlbmNvZGluZywgY2hhcnNldCkge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gcyAtIFRoZSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4LlxuICovXG5DZmZFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgY29kZSA9IHMuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgY2hhck5hbWUgPSB0aGlzLmVuY29kaW5nW2NvZGVdO1xuICAgIHJldHVybiB0aGlzLmNoYXJzZXQuaW5kZXhPZihjaGFyTmFtZSk7XG59O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoTmFtZXNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zdFxuICovXG5mdW5jdGlvbiBHbHlwaE5hbWVzKHBvc3QpIHtcbiAgICB2YXIgaTtcbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzLnNsaWNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpXSA8IGV4cG9ydHMuc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IGV4cG9ydHMuc3RhbmRhcmROYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gcG9zdC5uYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldIC0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzLmxlbmd0aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyLjU6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbaV0gPSBleHBvcnRzLnN0YW5kYXJkTmFtZXNbaSArIHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IG9mIGEgZ2x5cGggYnkgbmFtZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAtIFRoZSBnbHlwaCBuYW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleFxuICovXG5HbHlwaE5hbWVzLnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzLmluZGV4T2YobmFtZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gZ2lkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkdseXBoTmFtZXMucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbihnaWQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc1tnaWRdO1xufTtcblxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuYWRkR2x5cGhOYW1lc1xuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBhZGRHbHlwaE5hbWVzKGZvbnQpIHtcbiAgICB2YXIgZ2x5cGg7XG4gICAgdmFyIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG4gICAgdmFyIGNoYXJDb2RlcyA9IE9iamVjdC5rZXlzKGdseXBoSW5kZXhNYXApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFyQ29kZXNbaV07XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgICAgIGdseXBoLmFkZFVuaWNvZGUocGFyc2VJbnQoYykpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChpKTtcbiAgICAgICAgaWYgKGZvbnQuY2ZmRW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGdseXBoLm5hbWUgPSBmb250LmNmZkVuY29kaW5nLmNoYXJzZXRbaV07XG4gICAgICAgIH0gZWxzZSBpZiAoZm9udC5nbHlwaE5hbWVzLm5hbWVzKSB7XG4gICAgICAgICAgICBnbHlwaC5uYW1lID0gZm9udC5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoaSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuY2ZmU3RhbmRhcmRTdHJpbmdzID0gY2ZmU3RhbmRhcmRTdHJpbmdzO1xuZXhwb3J0cy5jZmZTdGFuZGFyZEVuY29kaW5nID0gY2ZmU3RhbmRhcmRFbmNvZGluZztcbmV4cG9ydHMuY2ZmRXhwZXJ0RW5jb2RpbmcgPSBjZmZFeHBlcnRFbmNvZGluZztcbmV4cG9ydHMuc3RhbmRhcmROYW1lcyA9IHN0YW5kYXJkTmFtZXM7XG5leHBvcnRzLkRlZmF1bHRFbmNvZGluZyA9IERlZmF1bHRFbmNvZGluZztcbmV4cG9ydHMuQ21hcEVuY29kaW5nID0gQ21hcEVuY29kaW5nO1xuZXhwb3J0cy5DZmZFbmNvZGluZyA9IENmZkVuY29kaW5nO1xuZXhwb3J0cy5HbHlwaE5hbWVzID0gR2x5cGhOYW1lcztcbmV4cG9ydHMuYWRkR2x5cGhOYW1lcyA9IGFkZEdseXBoTmFtZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL2VuY29kaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBEYXRhIHR5cGVzIHVzZWQgaW4gdGhlIE9wZW5UeXBlIGZvbnQgZmlsZS5cbi8vIEFsbCBPcGVuVHlwZSBmb250cyB1c2UgTW90b3JvbGEtc3R5bGUgYnl0ZSBvcmRlcmluZyAoQmlnIEVuZGlhbilcblxuLyogZ2xvYmFsIFdlYWtNYXAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJyk7XG5cbnZhciBMSU1JVDE2ID0gMzI3Njg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDE2LWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMl4xNVxudmFyIExJTUlUMzIgPSAyMTQ3NDgzNjQ4OyAvLyBUaGUgbGltaXQgYXQgd2hpY2ggYSAzMi1iaXQgbnVtYmVyIHN3aXRjaGVzIHNpZ25zID09IDIgXiAzMVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLmRlY29kZVxuICogQGNsYXNzXG4gKi9cbnZhciBkZWNvZGUgPSB7fTtcbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuZW5jb2RlXG4gKiBAY2xhc3NcbiAqL1xudmFyIGVuY29kZSA9IHt9O1xuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5zaXplT2ZcbiAqIEBjbGFzc1xuICovXG52YXIgc2l6ZU9mID0ge307XG5cbi8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuXG5mdW5jdGlvbiBjb25zdGFudCh2KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xufVxuXG4vLyBPcGVuVHlwZSBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbnZlcnQgYW4gOC1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMSBieXRlLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5CWVRFID0gZnVuY3Rpb24odikge1xuICAgIGNoZWNrLmFyZ3VtZW50KHYgPj0gMCAmJiB2IDw9IDI1NSwgJ0J5dGUgdmFsdWUgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgMjU1LicpO1xuICAgIHJldHVybiBbdl07XG59O1xuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5CWVRFID0gY29uc3RhbnQoMSk7XG5cbi8qKlxuICogQ29udmVydCBhIDgtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkNIQVIgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCldO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5DSEFSID0gY29uc3RhbnQoMSk7XG5cbi8qKlxuICogQ29udmVydCBhbiBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIGJ5dGVzLlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5DSEFSQVJSQVkgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYltpXSA9IHYuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5DSEFSQVJSQVkgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMTYtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDIgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlVTSE9SVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5VU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMTYtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5TSE9SVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBUd28ncyBjb21wbGVtZW50XG4gICAgaWYgKHYgPj0gTElNSVQxNikge1xuICAgICAgICB2ID0gLSgyICogTElNSVQxNiAtIHYpO1xuICAgIH1cblxuICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlNIT1JUID0gY29uc3RhbnQoMik7XG5cbi8qKlxuICogQ29udmVydCBhIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAzIGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VSU5UMjQgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFsodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuVUlOVDI0ID0gY29uc3RhbnQoMyk7XG5cbi8qKlxuICogQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VTE9ORyA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5VTE9ORyA9IGNvbnN0YW50KDQpO1xuXG4vKipcbiAqIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTE9ORyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBUd28ncyBjb21wbGVtZW50XG4gICAgaWYgKHYgPj0gTElNSVQzMikge1xuICAgICAgICB2ID0gLSgyICogTElNSVQzMiAtIHYpO1xuICAgIH1cblxuICAgIHJldHVybiBbKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLkxPTkcgPSBjb25zdGFudCg0KTtcblxuZW5jb2RlLkZJWEVEID0gZW5jb2RlLlVMT05HO1xuc2l6ZU9mLkZJWEVEID0gc2l6ZU9mLlVMT05HO1xuXG5lbmNvZGUuRldPUkQgPSBlbmNvZGUuU0hPUlQ7XG5zaXplT2YuRldPUkQgPSBzaXplT2YuU0hPUlQ7XG5cbmVuY29kZS5VRldPUkQgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLlVGV09SRCA9IHNpemVPZi5VU0hPUlQ7XG5cbi8qKlxuICogQ29udmVydCBhIDMyLWJpdCBBcHBsZSBNYWMgdGltZXN0YW1wIGludGVnZXIgdG8gYSBsaXN0IG9mIDggYnl0ZXMsIDY0LWJpdCB0aW1lc3RhbXAuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkxPTkdEQVRFVElNRSA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWzAsIDAsIDAsIDAsICh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5MT05HREFURVRJTUUgPSBjb25zdGFudCg4KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgNC1jaGFyIHRhZyB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVEFHID0gZnVuY3Rpb24odikge1xuICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSA0LCAnVGFnIHNob3VsZCBiZSBleGFjdGx5IDQgQVNDSUkgY2hhcmFjdGVycy4nKTtcbiAgICByZXR1cm4gW3YuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgzKV07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlRBRyA9IGNvbnN0YW50KDQpO1xuXG4vLyBDRkYgZGF0YSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5lbmNvZGUuQ2FyZDggPSBlbmNvZGUuQllURTtcbnNpemVPZi5DYXJkOCA9IHNpemVPZi5CWVRFO1xuXG5lbmNvZGUuQ2FyZDE2ID0gZW5jb2RlLlVTSE9SVDtcbnNpemVPZi5DYXJkMTYgPSBzaXplT2YuVVNIT1JUO1xuXG5lbmNvZGUuT2ZmU2l6ZSA9IGVuY29kZS5CWVRFO1xuc2l6ZU9mLk9mZlNpemUgPSBzaXplT2YuQllURTtcblxuZW5jb2RlLlNJRCA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuU0lEID0gc2l6ZU9mLlVTSE9SVDtcblxuLy8gQ29udmVydCBhIG51bWVyaWMgb3BlcmFuZCBvciBjaGFyc3RyaW5nIG51bWJlciB0byBhIHZhcmlhYmxlLXNpemUgbGlzdCBvZiBieXRlcy5cbi8qKlxuICogQ29udmVydCBhIG51bWVyaWMgb3BlcmFuZCBvciBjaGFyc3RyaW5nIG51bWJlciB0byBhIHZhcmlhYmxlLXNpemUgbGlzdCBvZiBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTlVNQkVSID0gZnVuY3Rpb24odikge1xuICAgIGlmICh2ID49IC0xMDcgJiYgdiA8PSAxMDcpIHtcbiAgICAgICAgcmV0dXJuIFt2ICsgMTM5XTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gMTA4ICYmIHYgPD0gMTEzMSkge1xuICAgICAgICB2ID0gdiAtIDEwODtcbiAgICAgICAgcmV0dXJuIFsodiA+PiA4KSArIDI0NywgdiAmIDB4RkZdO1xuICAgIH0gZWxzZSBpZiAodiA+PSAtMTEzMSAmJiB2IDw9IC0xMDgpIHtcbiAgICAgICAgdiA9IC12IC0gMTA4O1xuICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjUxLCB2ICYgMHhGRl07XG4gICAgfSBlbHNlIGlmICh2ID49IC0zMjc2OCAmJiB2IDw9IDMyNzY3KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUuTlVNQkVSMTYodik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIzMih2KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLk5VTUJFUiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gZW5jb2RlLk5VTUJFUih2KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLTMyNzY4IGFuZCArMzI3NjcgdG8gYSB0aHJlZS1ieXRlIHZhbHVlLlxuICogVGhpcyBlbnN1cmVzIHdlIGFsd2F5cyB1c2UgdGhyZWUgYnl0ZXMsIGJ1dCBpcyBub3QgdGhlIG1vc3QgY29tcGFjdCBmb3JtYXQuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk5VTUJFUjE2ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbMjgsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5OVU1CRVIxNiA9IGNvbnN0YW50KDMpO1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLSgyXjMxKSBhbmQgKygyXjMxLTEpIHRvIGEgZml2ZS1ieXRlIHZhbHVlLlxuICogVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gYmUgc3VyZSB5b3UgYWx3YXlzIHVzZSBmb3VyIGJ5dGVzLFxuICogYXQgdGhlIGV4cGVuc2Ugb2Ygd2FzdGluZyBhIGZldyBieXRlcyBmb3Igc21hbGxlciBudW1iZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5OVU1CRVIzMiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWzI5LCAodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuTlVNQkVSMzIgPSBjb25zdGFudCg1KTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlJFQUwgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHZhbHVlID0gdi50b1N0cmluZygpO1xuXG4gICAgLy8gU29tZSBudW1iZXJzIHVzZSBhbiBlcHNpbG9uIHRvIGVuY29kZSB0aGUgdmFsdWUuIChlLmcuIEphdmFTY3JpcHQgd2lsbCBzdG9yZSAwLjAwMDAwMDEgYXMgMWUtNylcbiAgICAvLyBUaGlzIGNvZGUgY29udmVydHMgaXQgYmFjayB0byBhIG51bWJlciB3aXRob3V0IHRoZSBlcHNpbG9uLlxuICAgIHZhciBtID0gL1xcLihcXGQqPykoPzo5ezUsMjB9fDB7NSwyMH0pXFxkezAsMn0oPzplKC4rKXwkKS8uZXhlYyh2YWx1ZSk7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgdmFyIGVwc2lsb24gPSBwYXJzZUZsb2F0KCcxZScgKyAoKG1bMl0gPyArbVsyXSA6IDApICsgbVsxXS5sZW5ndGgpKTtcbiAgICAgICAgdmFsdWUgPSAoTWF0aC5yb3VuZCh2ICogZXBzaWxvbikgLyBlcHNpbG9uKS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHZhciBuaWJibGVzID0gJyc7XG4gICAgdmFyIGk7XG4gICAgdmFyIGlpO1xuICAgIGZvciAoaSA9IDAsIGlpID0gdmFsdWUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHZhbHVlW2ldO1xuICAgICAgICBpZiAoYyA9PT0gJ2UnKSB7XG4gICAgICAgICAgICBuaWJibGVzICs9IHZhbHVlWysraV0gPT09ICctJyA/ICdjJyA6ICdiJztcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLicpIHtcbiAgICAgICAgICAgIG5pYmJsZXMgKz0gJ2EnO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgbmliYmxlcyArPSAnZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuaWJibGVzICs9IGM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuaWJibGVzICs9IChuaWJibGVzLmxlbmd0aCAmIDEpID8gJ2YnIDogJ2ZmJztcbiAgICB2YXIgb3V0ID0gWzMwXTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IG5pYmJsZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICBvdXQucHVzaChwYXJzZUludChuaWJibGVzLnN1YnN0cihpLCAyKSwgMTYpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5SRUFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBlbmNvZGUuUkVBTCh2KS5sZW5ndGg7XG59O1xuXG5lbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbmVuY29kZS5TVFJJTkcgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuVVRGOCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtQnl0ZXMpIHtcbiAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgIHZhciBudW1DaGFycyA9IG51bUJ5dGVzO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ2hhcnM7IGorKywgb2Zmc2V0ICs9IDEpIHtcbiAgICAgICAgY29kZVBvaW50c1tqXSA9IGRhdGEuZ2V0VWludDgob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuVVRGMTYgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG51bUJ5dGVzKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICB2YXIgbnVtQ2hhcnMgPSBudW1CeXRlcyAvIDI7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1DaGFyczsgaisrLCBvZmZzZXQgKz0gMikge1xuICAgICAgICBjb2RlUG9pbnRzW2pdID0gZGF0YS5nZXRVaW50MTYob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIFVURjE2LUJFLlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VVEYxNiA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY29kZXBvaW50ID0gdi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBiW2IubGVuZ3RoXSA9IChjb2RlcG9pbnQgPj4gOCkgJiAweEZGO1xuICAgICAgICBiW2IubGVuZ3RoXSA9IGNvZGVwb2ludCAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLlVURjE2ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2Lmxlbmd0aCAqIDI7XG59O1xuXG4vLyBEYXRhIGZvciBjb252ZXJ0aW5nIG9sZCBlaWdodC1iaXQgTWFjaW50b3NoIGVuY29kaW5ncyB0byBVbmljb2RlLlxuLy8gVGhpcyByZXByZXNlbnRhdGlvbiBpcyBvcHRpbWl6ZWQgZm9yIGRlY29kaW5nOyBlbmNvZGluZyBpcyBzbG93ZXJcbi8vIGFuZCBuZWVkcyBtb3JlIG1lbW9yeS4gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCBhbGwgb3BlbnR5cGUuanMgdXNlcnNcbi8vIHdhbnQgdG8gb3BlbiBmb250cywgYnV0IHNhdmluZyBhIGZvbnQgd2lsbCBiZSBjb21wZXJhdGl2ZWx5IHJhcmVcbi8vIHNvIGl0IGNhbiBiZSBtb3JlIGV4cGVuc2l2ZS4gS2V5ZWQgYnkgSUFOQSBjaGFyYWN0ZXIgc2V0IG5hbWUuXG4vL1xuLy8gUHl0aG9uIHNjcmlwdCBmb3IgZ2VuZXJhdGluZyB0aGVzZSBzdHJpbmdzOlxuLy9cbi8vICAgICBzID0gdScnLmpvaW4oW2NocihjKS5kZWNvZGUoJ21hY19ncmVlaycpIGZvciBjIGluIHJhbmdlKDEyOCwgMjU2KV0pXG4vLyAgICAgcHJpbnQocy5lbmNvZGUoJ3V0Zi04JykpXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlaWdodEJpdE1hY0VuY29kaW5ncyA9IHtcbiAgICAneC1tYWMtY3JvYXRpYW4nOiAgLy8gUHl0aG9uOiAnbWFjX2Nyb2F0aWFuJ1xuICAgICAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuxaDihKLCtMKo4omgxb3DmOKInsKx4omk4oml4oiGwrXiiILiiJHiiI/FoeKIq8KqwrrOqcW+w7gnICtcbiAgICAgICAgJ8K/wqHCrOKImsaS4omIxIbCq8SM4oCmwqDDgMODw5XFksWTxJDigJTigJzigJ3igJjigJnDt+KXiu+jv8Kp4oGE4oKs4oC54oC6w4bCu+KAk8K34oCa4oCe4oCww4LEh8OBxI3DiMONw47Dj8OMw5PDlMSRw5LDmsObw5nEscuGy5zCr8+Aw4vLmsK4w4rDpsuHJyxcbiAgICAneC1tYWMtY3lyaWxsaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2N5cmlsbGljJ1xuICAgICAgICAn0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr+KAoMKw0pDCo8Kn4oCiwrbQhsKuwqnihKLQgtGS4omg0IPRk+KInsKx4omk4oml0ZbCtdKR0IjQhNGU0IfRl9CJ0ZnQitGaJyArXG4gICAgICAgICfRmNCFwqziiJrGkuKJiOKIhsKrwrvigKbCoNCL0ZvQjNGc0ZXigJPigJTigJzigJ3igJjigJnDt+KAntCO0Z7Qj9Gf4oSW0IHRkdGP0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y4nLFxuICAgICd4LW1hYy1nYWVsaWMnOlxuICAgICAgICAvLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvR0FFTElDLlRYVFxuICAgICAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOG4gsKx4omk4oml4biDxIrEi+G4iuG4i+G4nuG4n8SgxKHhuYDDpsO4JyArXG4gICAgICAgICfhuYHhuZbhuZfJvMaSxb/huaDCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZ4bmh4bqbw7/FuOG5quKCrOKAueKAusW2xbfhuavCt+G7suG7s+KBisOCw4rDgcOLw4jDjcOOw4/DjMOTw5TimaPDksOaw5vDmcSxw53DvcW0xbXhuoThuoXhuoDhuoHhuoLhuoMnLFxuICAgICd4LW1hYy1ncmVlayc6ICAvLyBQeXRob246ICdtYWNfZ3JlZWsnXG4gICAgICAgICfDhMK5wrLDicKzw5bDnM6Fw6DDosOkzoTCqMOnw6nDqMOqw6vCo+KEosOuw6/igKLCveKAsMO0w7bCpuKCrMO5w7vDvOKAoM6TzpTOmM6bzp7OoMOfwq7Cqc6jzqrCp+KJoMKwwrfOkcKx4omk4omlwqXOks6VzpbOl86ZzprOnM6mzqvOqM6pJyArXG4gICAgICAgICfOrM6dwqzOn86h4omIzqTCq8K74oCmwqDOpc6nzobOiMWT4oCT4oCV4oCc4oCd4oCY4oCZw7fOic6KzozOjs6tzq7Or8+Mzo/Pjc6xzrLPiM60zrXPhs6zzrfOuc6+zrrOu868zr3Ov8+Az47Pgc+Dz4TOuM+Jz4LPh8+FzrbPis+LzpDOsFxcdTAwQUQnLFxuICAgICd4LW1hYy1pY2VsYW5kaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2ljZWxhbmQnXG4gICAgICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O8w53CsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcbiAgICAgICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrMOQw7DDnsO+w73Ct+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuICAgICd4LW1hYy1pbnVpdCc6XG4gICAgICAgIC8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9JTlVJVC5UWFRcbiAgICAgICAgJ+GQg+GQhOGQheGQhuGQiuGQi+GQseGQsuGQs+GQtOGQuOGQueGRieGRjuGRj+GRkOGRkeGRleGRluGRpuGRreGRruGRr+GRsOGRsuGRs+GSg+GSi+GSjOGSjeGSjuGSkOGSkcKw4ZKh4ZKl4ZKm4oCiwrbhkqfCrsKp4oSi4ZKo4ZKq4ZKr4ZK74ZOC4ZOD4ZOE4ZOF4ZOH4ZOI4ZOQ4ZOv4ZOw4ZOx4ZOy4ZO04ZO14ZSF4ZOV4ZOW4ZOXJyArXG4gICAgICAgICfhk5jhk5rhk5vhk6rhlKjhlKnhlKrhlKvhlK3igKbCoOGUruGUvuGVleGVluGVl+KAk+KAlOKAnOKAneKAmOKAmeGVmOGVmeGVmuGVneGVhuGVh+GViOGVieGVi+GVjOGVkOGVv+GWgOGWgeGWguGWg+GWhOGWheGWj+GWkOGWkeGWkuGWk+GWlOGWleGZseGZsuGZs+GZtOGZteGZtuGWluGWoOGWoeGWouGWo+GWpOGWpeGWpuGVvMWBxYInLFxuICAgICd4LW1hYy1jZSc6ICAvLyBQeXRob246ICdtYWNfbGF0aW4yJ1xuICAgICAgICAnw4TEgMSBw4nEhMOWw5zDocSFxIzDpMSNxIbEh8OpxbnFusSOw63Ej8SSxJPElsOzxJfDtMO2w7XDusSaxJvDvOKAoMKwxJjCo8Kn4oCiwrbDn8KuwqnihKLEmcKo4omgxKPErsSvxKriiaTiiaXEq8S24oiC4oiRxYLEu8S8xL3EvsS5xLrFhScgK1xuICAgICAgICAnxYbFg8Ks4oiaxYTFh+KIhsKrwrvigKbCoMWIxZDDlcWRxYzigJPigJTigJzigJ3igJjigJnDt+KXisWNxZTFlcWY4oC54oC6xZnFlsWXxaDigJrigJ7FocWaxZvDgcWkxaXDjcW9xb7FqsOTw5TFq8Wuw5rFr8WwxbHFssWzw53DvcS3xbvFgcW8xKLLhycsXG4gICAgbWFjaW50b3NoOiAgLy8gUHl0aG9uOiAnbWFjX3JvbWFuJ1xuICAgICAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKs4oC54oC676yB76yC4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAneC1tYWMtcm9tYW5pYW4nOiAgLy8gUHl0aG9uOiAnbWFjX3JvbWFuaWFuJ1xuICAgICAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgxILImOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pxIPImScgK1xuICAgICAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKs4oC54oC6yJrIm+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLXR1cmtpc2gnOiAgLy8gUHl0aG9uOiAnbWFjX3R1cmtpc2gnXG4gICAgICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG4gICAgICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjEnsSfxLDEscWexZ/igKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDme+ioMuGy5zCr8uYy5nLmsK4y53Lm8uHJ1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIG9sZC1zdHlsZSBNYWNpbnRvc2ggc3RyaW5nLiBSZXR1cm5zIGVpdGhlciBhIFVuaWNvZGUgSmF2YVNjcmlwdFxuICogc3RyaW5nLCBvciAndW5kZWZpbmVkJyBpZiB0aGUgZW5jb2RpbmcgaXMgdW5zdXBwb3J0ZWQuIEZvciBleGFtcGxlLCB3ZSBkb1xuICogbm90IHN1cHBvcnQgQ2hpbmVzZSwgSmFwYW5lc2Ugb3IgS29yZWFuIGJlY2F1c2UgdGhlc2Ugd291bGQgbmVlZCBsYXJnZVxuICogbWFwcGluZyB0YWJsZXMuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGRhdGFMZW5ndGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZGVjb2RlLk1BQ1NUUklORyA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQsIGRhdGFMZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgdmFyIHRhYmxlID0gZWlnaHRCaXRNYWNFbmNvZGluZ3NbZW5jb2RpbmddO1xuICAgIGlmICh0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG4gICAgICAgIC8vIEluIGFsbCBlaWdodC1iaXQgTWFjIGVuY29kaW5ncywgdGhlIGNoYXJhY3RlcnMgMHgwMC4uMHg3RiBhcmVcbiAgICAgICAgLy8gbWFwcGVkIHRvIFUrMDAwMC4uVSswMDdGOyB3ZSBvbmx5IG5lZWQgdG8gbG9vayB1cCB0aGUgb3RoZXJzLlxuICAgICAgICBpZiAoYyA8PSAweDdGKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0YWJsZVtjICYgMHg3Rl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBlbmNvZGUuTUFDU1RSSU5HLiBSZXR1cm5zIGEgZGljdGlvbmFyeSBmb3IgbWFwcGluZ1xuLy8gVW5pY29kZSBjaGFyYWN0ZXIgY29kZXMgdG8gdGhlaXIgOC1iaXQgTWFjT1MgZXF1aXZhbGVudC4gVGhpcyB0YWJsZVxuLy8gaXMgbm90IGV4YWN0bHkgYSBzdXBlciBjaGVhcCBkYXRhIHN0cnVjdHVyZSwgYnV0IHdlIGRvIG5vdCBjYXJlIGJlY2F1c2Vcbi8vIGVuY29kaW5nIE1hY2ludG9zaCBzdHJpbmdzIGlzIG9ubHkgcmFyZWx5IG5lZWRlZCBpbiB0eXBpY2FsIGFwcGxpY2F0aW9ucy5cbnZhciBtYWNFbmNvZGluZ1RhYmxlQ2FjaGUgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXcgV2Vha01hcCgpO1xudmFyIG1hY0VuY29kaW5nQ2FjaGVLZXlzO1xudmFyIGdldE1hY0VuY29kaW5nVGFibGUgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICAgIC8vIFNpbmNlIHdlIHVzZSBlbmNvZGluZyBhcyBhIGNhY2hlIGtleSBmb3IgV2Vha01hcCwgaXQgaGFzIHRvIGJlXG4gICAgLy8gYSBTdHJpbmcgb2JqZWN0IGFuZCBub3QgYSBsaXRlcmFsLiBBbmQgYXQgbGVhc3Qgb24gTm9kZUpTIDIuMTAuMSxcbiAgICAvLyBXZWFrTWFwIHJlcXVpcmVzIHRoYXQgdGhlIHNhbWUgU3RyaW5nIGluc3RhbmNlIGlzIHBhc3NlZCBmb3IgY2FjaGUgaGl0cy5cbiAgICBpZiAoIW1hY0VuY29kaW5nQ2FjaGVLZXlzKSB7XG4gICAgICAgIG1hY0VuY29kaW5nQ2FjaGVLZXlzID0ge307XG4gICAgICAgIGZvciAodmFyIGUgaW4gZWlnaHRCaXRNYWNFbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIC8qanNoaW50IC1XMDUzICovICAvLyBTdXBwcmVzcyBcIkRvIG5vdCB1c2UgU3RyaW5nIGFzIGEgY29uc3RydWN0b3IuXCJcbiAgICAgICAgICAgIG1hY0VuY29kaW5nQ2FjaGVLZXlzW2VdID0gbmV3IFN0cmluZyhlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjYWNoZUtleSA9IG1hY0VuY29kaW5nQ2FjaGVLZXlzW2VuY29kaW5nXTtcbiAgICBpZiAoY2FjaGVLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IGRvIFwiaWYgKGNhY2hlLmhhcyhrZXkpKSB7cmV0dXJuIGNhY2hlLmdldChrZXkpfVwiIGhlcmU6XG4gICAgLy8gc2luY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIG1heSBydW4gYXQgYW55IHRpbWUsIGl0IGNvdWxkIGFsc28ga2ljayBpblxuICAgIC8vIGJldHdlZW4gdGhlIGNhbGxzIHRvIGNhY2hlLmhhcygpIGFuZCBjYWNoZS5nZXQoKS4gSW4gdGhhdCBjYXNlLFxuICAgIC8vIHdlIHdvdWxkIHJldHVybiAndW5kZWZpbmVkJyBldmVuIHRob3VnaCB3ZSBkbyBzdXBwb3J0IHRoZSBlbmNvZGluZy5cbiAgICBpZiAobWFjRW5jb2RpbmdUYWJsZUNhY2hlKSB7XG4gICAgICAgIHZhciBjYWNoZWRUYWJsZSA9IG1hY0VuY29kaW5nVGFibGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoY2FjaGVkVGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlY29kaW5nVGFibGUgPSBlaWdodEJpdE1hY0VuY29kaW5nc1tlbmNvZGluZ107XG4gICAgaWYgKGRlY29kaW5nVGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBlbmNvZGluZ1RhYmxlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWNvZGluZ1RhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVuY29kaW5nVGFibGVbZGVjb2RpbmdUYWJsZS5jaGFyQ29kZUF0KGkpXSA9IGkgKyAweDgwO1xuICAgIH1cblxuICAgIGlmIChtYWNFbmNvZGluZ1RhYmxlQ2FjaGUpIHtcbiAgICAgICAgbWFjRW5jb2RpbmdUYWJsZUNhY2hlLnNldChjYWNoZUtleSwgZW5jb2RpbmdUYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kaW5nVGFibGU7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYW4gb2xkLXN0eWxlIE1hY2ludG9zaCBzdHJpbmcuIFJldHVybnMgYSBieXRlIGFycmF5IHVwb24gc3VjY2Vzcy5cbiAqIElmIHRoZSByZXF1ZXN0ZWQgZW5jb2RpbmcgaXMgdW5zdXBwb3J0ZWQsIG9yIGlmIHRoZSBpbnB1dCBzdHJpbmcgY29udGFpbnNcbiAqIGEgY2hhcmFjdGVyIHRoYXQgY2Fubm90IGJlIGV4cHJlc3NlZCBpbiB0aGUgZW5jb2RpbmcsIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gKiAndW5kZWZpbmVkJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTUFDU1RSSU5HID0gZnVuY3Rpb24oc3RyLCBlbmNvZGluZykge1xuICAgIHZhciB0YWJsZSA9IGdldE1hY0VuY29kaW5nVGFibGUoZW5jb2RpbmcpO1xuICAgIGlmICh0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgLy8gSW4gYWxsIGVpZ2h0LWJpdCBNYWMgZW5jb2RpbmdzLCB0aGUgY2hhcmFjdGVycyAweDAwLi4weDdGIGFyZVxuICAgICAgICAvLyBtYXBwZWQgdG8gVSswMDAwLi5VKzAwN0Y7IHdlIG9ubHkgbmVlZCB0byBsb29rIHVwIHRoZSBvdGhlcnMuXG4gICAgICAgIGlmIChjID49IDB4ODApIHtcbiAgICAgICAgICAgIGMgPSB0YWJsZVtjXTtcbiAgICAgICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHIgY29udGFpbnMgYSBVbmljb2RlIGNoYXJhY3RlciB0aGF0IGNhbm5vdCBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIHJlcXVlc3RlZCBlbmNvZGluZy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtpXSA9IGM7XG4gICAgICAgIC8vIHJlc3VsdC5wdXNoKGMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLk1BQ1NUUklORyA9IGZ1bmN0aW9uKHN0ciwgZW5jb2RpbmcpIHtcbiAgICB2YXIgYiA9IGVuY29kZS5NQUNTVFJJTkcoc3RyLCBlbmNvZGluZyk7XG4gICAgaWYgKGIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYi5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuLy8gQ29udmVydCBhIGxpc3Qgb2YgdmFsdWVzIHRvIGEgQ0ZGIElOREVYIHN0cnVjdHVyZS5cbi8vIFRoZSB2YWx1ZXMgc2hvdWxkIGJlIG9iamVjdHMgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlLlxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBsXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5JTkRFWCA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgaTtcbiAgICAvL3ZhciBvZmZzZXQsIG9mZnNldHMsIG9mZnNldEVuY29kZXIsIGVuY29kZWRPZmZzZXRzLCBlbmNvZGVkT2Zmc2V0LCBkYXRhLFxuICAgIC8vICAgIGksIHY7XG4gICAgLy8gQmVjYXVzZSB3ZSBoYXZlIHRvIGtub3cgd2hpY2ggZGF0YSB0eXBlIHRvIHVzZSB0byBlbmNvZGUgdGhlIG9mZnNldHMsXG4gICAgLy8gd2UgaGF2ZSB0byBnbyB0aHJvdWdoIHRoZSB2YWx1ZXMgdHdpY2U6IG9uY2UgdG8gZW5jb2RlIHRoZSBkYXRhIGFuZFxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgb2ZmZXRzLCB0aGVuIGFnYWluIHRvIGVuY29kZSB0aGUgb2Zmc2V0cyB1c2luZyB0aGUgZml0dGluZyBkYXRhIHR5cGUuXG4gICAgdmFyIG9mZnNldCA9IDE7IC8vIEZpcnN0IG9mZnNldCBpcyBhbHdheXMgMS5cbiAgICB2YXIgb2Zmc2V0cyA9IFtvZmZzZXRdO1xuICAgIHZhciBkYXRhID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHYgPSBlbmNvZGUuT0JKRUNUKGxbaV0pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkYXRhLCB2KTtcbiAgICAgICAgb2Zmc2V0ICs9IHYubGVuZ3RoO1xuICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG5cbiAgICB2YXIgZW5jb2RlZE9mZnNldHMgPSBbXTtcbiAgICB2YXIgb2ZmU2l6ZSA9ICgxICsgTWF0aC5mbG9vcihNYXRoLmxvZyhvZmZzZXQpIC8gTWF0aC5sb2coMikpIC8gOCkgfCAwO1xuICAgIHZhciBvZmZzZXRFbmNvZGVyID0gW3VuZGVmaW5lZCwgZW5jb2RlLkJZVEUsIGVuY29kZS5VU0hPUlQsIGVuY29kZS5VSU5UMjQsIGVuY29kZS5VTE9OR11bb2ZmU2l6ZV07XG4gICAgZm9yIChpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGVuY29kZWRPZmZzZXQgPSBvZmZzZXRFbmNvZGVyKG9mZnNldHNbaV0pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmNvZGVkT2Zmc2V0cywgZW5jb2RlZE9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoZW5jb2RlLkNhcmQxNihsLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUuT2ZmU2l6ZShvZmZTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRPZmZzZXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuSU5ERVggPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIGVuY29kZS5JTkRFWCh2KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHRvIGEgQ0ZGIERJQ1Qgc3RydWN0dXJlLlxuICogVGhlIGtleXMgc2hvdWxkIGJlIG51bWVyaWMuXG4gKiBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5ESUNUID0gZnVuY3Rpb24obSkge1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhtKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIC8vIE9iamVjdC5rZXlzKCkgcmV0dXJuIHN0cmluZyBrZXlzLCBidXQgb3VyIGtleXMgYXJlIGFsd2F5cyBudW1lcmljLlxuICAgICAgICB2YXIgayA9IHBhcnNlSW50KGtleXNbaV0sIDApO1xuICAgICAgICB2YXIgdiA9IG1ba107XG4gICAgICAgIC8vIFZhbHVlIGNvbWVzIGJlZm9yZSB0aGUga2V5LlxuICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBTkQodi52YWx1ZSwgdi50eXBlKSk7XG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFUT1IoaykpO1xuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5ESUNUID0gZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBlbmNvZGUuRElDVChtKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuT1BFUkFUT1IgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHYgPCAxMjAwKSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMiwgdiAtIDEyMDBdO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gdlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5PUEVSQU5EID0gZnVuY3Rpb24odiwgdHlwZSkge1xuICAgIHZhciBkID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjaGVjay5hcmd1bWVudCh2Lmxlbmd0aCA9PT0gdHlwZS5sZW5ndGgsICdOb3QgZW5vdWdoIGFyZ3VtZW50cyBnaXZlbiBmb3IgdHlwZScgKyB0eXBlKTtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFORCh2W2ldLCB0eXBlW2ldKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSKHYpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgLy8gV2UgbWFrZSBpdCBlYXN5IGZvciBvdXJzZWx2ZXMgYW5kIGFsd2F5cyBlbmNvZGUgb2Zmc2V0cyBhc1xuICAgICAgICAgICAgLy8gNCBieXRlcy4gVGhpcyBtYWtlcyBvZmZzZXQgY2FsY3VsYXRpb24gZm9yIHRoZSB0b3AgZGljdCBlYXNpZXIuXG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUjMyKHYpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIodikpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZWFsJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5SRUFMKHYpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBvcGVyYW5kIHR5cGUgJyArIHR5cGUpO1xuICAgICAgICAgICAgLy8gRklYTUUgQWRkIHN1cHBvcnQgZm9yIGJvb2xlYW5zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbmVuY29kZS5PUCA9IGVuY29kZS5CWVRFO1xuc2l6ZU9mLk9QID0gc2l6ZU9mLkJZVEU7XG5cbi8vIG1lbW9pemUgY2hhcnN0cmluZyBlbmNvZGluZyB1c2luZyBXZWFrTWFwIGlmIGF2YWlsYWJsZVxudmFyIHdtbSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQ29udmVydCBhIGxpc3Qgb2YgQ2hhclN0cmluZyBvcGVyYXRpb25zIHRvIGJ5dGVzLlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkNIQVJTVFJJTkcgPSBmdW5jdGlvbihvcHMpIHtcbiAgICAvLyBTZWUgZW5jb2RlLk1BQ1NUUklORyBmb3Igd2h5IHdlIGRvbid0IGRvIFwiaWYgKHdtbSAmJiB3bW0uaGFzKG9wcykpXCIuXG4gICAgaWYgKHdtbSkge1xuICAgICAgICB2YXIgY2FjaGVkVmFsdWUgPSB3bW0uZ2V0KG9wcyk7XG4gICAgICAgIGlmIChjYWNoZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBsZW5ndGggPSBvcHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgb3AgPSBvcHNbaV07XG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGVbb3AudHlwZV0ob3AudmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAod21tKSB7XG4gICAgICAgIHdtbS5zZXQob3BzLCBkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5DSEFSU1RSSU5HID0gZnVuY3Rpb24ob3BzKSB7XG4gICAgcmV0dXJuIGVuY29kZS5DSEFSU1RSSU5HKG9wcykubGVuZ3RoO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUgdG8gYnl0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk9CSkVDVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgZW5jb2RpbmdGdW5jdGlvbiA9IGVuY29kZVt2LnR5cGVdO1xuICAgIGNoZWNrLmFyZ3VtZW50KGVuY29kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIGVuY29kaW5nIGZ1bmN0aW9uIGZvciB0eXBlICcgKyB2LnR5cGUpO1xuICAgIHJldHVybiBlbmNvZGluZ0Z1bmN0aW9uKHYudmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5PQkpFQ1QgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHNpemVPZkZ1bmN0aW9uID0gc2l6ZU9mW3YudHlwZV07XG4gICAgY2hlY2suYXJndW1lbnQoc2l6ZU9mRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIHNpemVPZiBmdW5jdGlvbiBmb3IgdHlwZSAnICsgdi50eXBlKTtcbiAgICByZXR1cm4gc2l6ZU9mRnVuY3Rpb24odi52YWx1ZSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB0YWJsZSBvYmplY3QgdG8gYnl0ZXMuXG4gKiBBIHRhYmxlIGNvbnRhaW5zIGEgbGlzdCBvZiBmaWVsZHMgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgKG5hbWUsIHR5cGUgYW5kIGRlZmF1bHQgdmFsdWUpLlxuICogVGhlIHRhYmxlIGl0c2VsZiBoYXMgdGhlIGZpZWxkIHZhbHVlcyBzZXQgYXMgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5UQUJMRSA9IGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gdGFibGUuZmllbGRzLmxlbmd0aDtcbiAgICB2YXIgc3VidGFibGVzID0gW107XG4gICAgdmFyIHN1YnRhYmxlT2Zmc2V0cyA9IFtdO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRhYmxlLmZpZWxkc1tpXTtcbiAgICAgICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbZmllbGQudHlwZV07XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KGVuY29kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIGVuY29kaW5nIGZ1bmN0aW9uIGZvciBmaWVsZCB0eXBlICcgKyBmaWVsZC50eXBlICsgJyAoJyArIGZpZWxkLm5hbWUgKyAnKScpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnl0ZXMgPSBlbmNvZGluZ0Z1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICAgICAgc3VidGFibGVPZmZzZXRzLnB1c2goZC5sZW5ndGgpO1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KFswLCAwXSk7XG4gICAgICAgICAgICBzdWJ0YWJsZXMucHVzaChieXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbyA9IHN1YnRhYmxlT2Zmc2V0c1tpXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGQubGVuZ3RoO1xuICAgICAgICBjaGVjay5hcmd1bWVudChvZmZzZXQgPCA2NTUzNiwgJ1RhYmxlICcgKyB0YWJsZS50YWJsZU5hbWUgKyAnIHRvbyBiaWcuJyk7XG4gICAgICAgIGRbb10gPSBvZmZzZXQgPj4gODtcbiAgICAgICAgZFtvICsgMV0gPSBvZmZzZXQgJiAweGZmO1xuICAgICAgICBkID0gZC5jb25jYXQoc3VidGFibGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvcGVudHlwZS5UYWJsZX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5UQUJMRSA9IGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgdmFyIG51bUJ5dGVzID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gdGFibGUuZmllbGRzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuICAgICAgICB2YXIgc2l6ZU9mRnVuY3Rpb24gPSBzaXplT2ZbZmllbGQudHlwZV07XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KHNpemVPZkZ1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBzaXplT2YgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUgKyAnICgnICsgZmllbGQubmFtZSArICcpJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRhYmxlW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG51bUJ5dGVzICs9IHNpemVPZkZ1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICAvLyBTdWJ0YWJsZXMgdGFrZSAyIG1vcmUgYnl0ZXMgZm9yIG9mZnNldHMuXG4gICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnVEFCTEUnKSB7XG4gICAgICAgICAgICBudW1CeXRlcyArPSAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUJ5dGVzO1xufTtcblxuZW5jb2RlLlJFQ09SRCA9IGVuY29kZS5UQUJMRTtcbnNpemVPZi5SRUNPUkQgPSBzaXplT2YuVEFCTEU7XG5cbi8vIE1lcmdlIGluIGEgbGlzdCBvZiBieXRlcy5cbmVuY29kZS5MSVRFUkFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2O1xufTtcblxuc2l6ZU9mLkxJVEVSQUwgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuc2l6ZU9mID0gc2l6ZU9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy90eXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vUHJpbWl0aXZlLmpzJztcblxuY29uc3QgY2lyY2xlUmFkaWFucyA9IE1hdGguUEkgKiAyO1xuXG4vKipcbiAqIERyYXdzIGEgY2lyY2xlLlxuICovXG5leHBvcnQgY2xhc3MgQ2lyY2xlIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaWFucyBuZWVkZWQgdG8gZHJhdyBhIGNpcmNsZS4gMzYwZGVnIG9yIFBJICogMlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBjaXJjbGVSYWRpYW5zKCkge1xuICAgICAgICByZXR1cm4gY2lyY2xlUmFkaWFucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGlzIGNpcmNsZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBUaGUgcmVuZGVyaW5nIG9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJhZGl1cywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5tUmFkaXVzID0gcmFkaXVzO1xuICAgICAgICB0aGlzLnNpemUuc2V0KHJhZGl1cyAqIDIsIHJhZGl1cyAqIDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubVJhZGl1cztcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVJhZGl1cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHJhZGl1cyBvZiB0aGlzIGNpcmNsZS5cbiAgICAgKi9cbiAgICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tUmFkaXVzKSB7XG4gICAgICAgICAgICB0aGlzLm1SYWRpdXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZS5zZXQodGhpcy5tUmFkaXVzICogMiwgdGhpcy5tUmFkaXVzICogMik7XG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwYXRoIG9mIHRoaXMgc2hhcGUgdG8gdGhlIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJQYXRoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQYXRoKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJhZGl1cyA9IHRoaXMubVJhZGl1cztcbiAgICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlVHlwZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlVHlwZSA9PT0gQ2lyY2xlLlNUUk9LRV9JTk5FUikge1xuICAgICAgICAgICAgICAgIHJhZGl1cyAtPSBvcHRpb25zLnN0cm9rZSAqIDAuNTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdHJva2VUeXBlID09PSBDaXJjbGUuU1RST0tFX09VVEVSKSB7XG4gICAgICAgICAgICAgICAgcmFkaXVzICs9IG9wdGlvbnMuc3Ryb2tlICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCAwKTtcblxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmFyYyh0aGlzLm1SYWRpdXMsIHRoaXMubVJhZGl1cywgcmFkaXVzLCAwLCBjaXJjbGVSYWRpYW5zLCBmYWxzZSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaXJjbGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9ncmFwaGljcy9wcmltaXRpdmVzL0NpcmNsZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBJT2JqZWN0IGZyb20gJy4uL2NvcmUvSU9iamVjdC5qcyc7XG5pbXBvcnQgQXNzZXRDYWNoZSBmcm9tICcuLi9jb3JlL0Fzc2V0Q2FjaGUuanMnO1xuaW1wb3J0ICogYXMgT3BlblR5cGUgZnJvbSAnb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzJztcblxuLyoqXG4gKiBWYXJpYWJsZSB0byBob2xkIHRoZSBzaGFyZWQgaW5zdGFuY2Ugb2YgdGhlIEZvbnRNYW5hZ2VyLlxuICpcbiAqIEB0eXBlIHtGb250TWFuYWdlcn1cbiAqL1xubGV0IGZvbnRNYW5hZ2VyU2hhcmVkSW5zdGFuY2UgPSBudWxsO1xuXG4vKipcbiAqIENsYXNzIHVzZWQgdG8gbG9hZCBhbmQgdW5sb2FkIGZvbnQgZmlsZXMuXG4gKlxuICogQGNsYXNzIEZvbnRNYW5hZ2VyXG4gKi9cbmV4cG9ydCBjbGFzcyBGb250TWFuYWdlciBleHRlbmRzIElPYmplY3Qge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaGFyZWQgaW5zdGFuY2Ugb2YgdGhlIEZvbnRNYW5hZ2VyLiBVc2VmdWwgdG8gbWFrZSB0aGUgRm9udE1hbmFnZXIgYmVoYXZlIGFzIGEgc2luZ2xldG9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzaGFyZWRJbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtGb250TWFuYWdlcn1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHNoYXJlZEluc3RhbmNlKCkge1xuICAgICAgICBpZiAoIWZvbnRNYW5hZ2VyU2hhcmVkSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGZvbnRNYW5hZ2VyU2hhcmVkSW5zdGFuY2UgPSBuZXcgRm9udE1hbmFnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9udE1hbmFnZXJTaGFyZWRJbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tRm9udENhY2hlID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBvYmplY3QuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGlzIG9iamVjdCByZWFjaGVzIHplcm8uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBmb250S2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubUZvbnRDYWNoZSk7XG4gICAgICAgIGZvbnRLZXlzLmZvckVhY2goa2V5ID0+IGRlbGV0ZSB0aGlzLm1Gb250Q2FjaGVba2V5XSk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubUZvbnRDYWNoZTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHVuZGVybHlpbmcgY2FjaGUgb2JqZWN0IHVzZWQgYnkgdGhpcyBGb250TWFuYWdlci5cbiAgICAgKlxuICAgICAqIEB0eXBlIHt7fX1cbiAgICAgKi9cbiAgICBnZXQgZm9udENhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tRm9udENhY2hlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgZm9udCBmcm9tIHRoZSBwcm92aWRlZCBVUkwgYW5kIHNhdmVzIGl0IHRvIHRoZSBjYWNoZS4gSWYgdGhlIG9wdGlvbmFsIGBmb250S2V5YCBwYXJhbWV0ZXIgaXMgcGFzc2VkLCB0aGVcbiAgICAgKiBzcGVjaWZpZWQga2V5IGlzIHVzZWQgdG8gc2F2ZSB0aGUgZm9udCB0byB0aGUgY2FjaGUsIHRoZSBVUkwgaXMgdXNlZCBhcyBrZXkgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBsb2FkRm9udFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIGZyb20gd2hpY2ggdGhlIGZvbnQgc2hvdWxkIGJlIGxvYWRlZCBmcm9tLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gZm9udEtleSAtIFRoZSBrZXkgdG8gYmUgdXNlZCB0byBzYXZlIHRoZSBmb250IGludG8gdGhlIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGxvYWRGb250KHVybCwgZm9udEtleSA9IG51bGwpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZm9udEtleSA9PT0gbnVsbCA/IHVybCA6IGZvbnRLZXk7XG4gICAgICAgIGxldCBsb2FkZWRGb250ID0gdGhpcy5tRm9udENhY2hlW2tleV07XG4gICAgICAgIGlmIChsb2FkZWRGb250KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxvYWRlZEZvbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBc3NldENhY2hlLmlzVVJMKHVybCkpIHtcbiAgICAgICAgICAgIGxvYWRlZEZvbnQgPSB0aGlzLmxvYWRGb250QjY0KGtleSwgdXJsKTtcbiAgICAgICAgICAgIGlmIChsb2FkZWRGb250KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2FkZWRGb250KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBc3NldENhY2hlLmxvYWRBcnJheUJ1ZmZlcih1cmwpLnRoZW4oYnVmZmVyID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IE9wZW5UeXBlLnBhcnNlKGJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLm1Gb250Q2FjaGVbZm9udEtleV0gPSBsb2FkZWQ7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxvYWRlZCk7XG4gICAgICAgIH0sIHJlYXNvbiA9PiBQcm9taXNlLnJlamVjdChyZWFzb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGZvbnQgZnJvbSB0aGUgcHJvdmlkZWQgQmFzZTY0IGVuY29kZWQgYGRhdGFgIGFuZCBzYXZlcyBpdCBpbiB0aGUgY2FjaGUgdXNpbmcgdGhlIHNwZWNpZmllZCBgZm9udEtleWAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGxvYWRGb250QjY0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRLZXkgLSBUaGUga2V5IHRvIGJlIHVzZWQgdG8gc2F2ZSB0aGUgZm9udCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSAtIEJhc2U2NCBlbmNvZGVkIGZvbnQgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7Rm9udH1cbiAgICAgKi9cbiAgICBsb2FkRm9udEI2NChmb250S2V5LCBkYXRhKSB7XG4gICAgICAgIGxldCBsb2FkZWRGb250ID0gdGhpcy5tRm9udENhY2hlW2ZvbnRLZXldO1xuICAgICAgICBpZiAobG9hZGVkRm9udCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlZEZvbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gd2luZG93LmF0b2IoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBiaW5hcnlTdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGVuKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvYWRlZEZvbnQgPSBPcGVuVHlwZS5wYXJzZShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLm1Gb250Q2FjaGVbZm9udEtleV0gPSBsb2FkZWRGb250O1xuXG4gICAgICAgICAgICByZXR1cm4gbG9hZGVkRm9udDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZvbnRNYW5hZ2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvdGV4dC9Gb250TWFuYWdlci5qcyIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0luZGV4ICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgYUxlbiAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggID0gdG9JbmRleChhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKVxuICAgICwgZW5kICAgID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWRcbiAgICAsIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlKGVuZFBvcyA+IGluZGV4KU9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XG4gIGlmKGluZGV4IGluIG9iamVjdCkkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoKGUpe1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaChmKXsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHRhcmdldCwgQyl7XG4gIHZhciBQLCBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICBpZihTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKXtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlKXtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm4pe1xuICAgIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkfTtcbiAgICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYoIWhlYWQpe1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBzZWFyY2hTdHJpbmcsIE5BTUUpe1xuICBpZihpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKXRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpe1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpXG4gICAgLCByZXMgPSAnJ1xuICAgICwgbiAgID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYobiA8IDAgfHwgbiA9PSBJbmZpbml0eSl0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvcig7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKWlmKG4gJiAxKXJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190YXNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICR0eXBlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFuSW5zdGFuY2UgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIHRvSW50ZWdlciAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdPUE4gICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgYXJyYXlGaWxsICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBBUlJBWV9CVUZGRVIgICA9ICdBcnJheUJ1ZmZlcidcbiAgLCBEQVRBX1ZJRVcgICAgICA9ICdEYXRhVmlldydcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgV1JPTkdfTEVOR1RIICAgPSAnV3JvbmcgbGVuZ3RoISdcbiAgLCBXUk9OR19JTkRFWCAgICA9ICdXcm9uZyBpbmRleCEnXG4gICwgJEFycmF5QnVmZmVyICAgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXVxuICAsICREYXRhVmlldyAgICAgID0gZ2xvYmFsW0RBVEFfVklFV11cbiAgLCBNYXRoICAgICAgICAgICA9IGdsb2JhbC5NYXRoXG4gICwgUmFuZ2VFcnJvciAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAsIEluZmluaXR5ICAgICAgID0gZ2xvYmFsLkluZmluaXR5XG4gICwgQmFzZUJ1ZmZlciAgICAgPSAkQXJyYXlCdWZmZXJcbiAgLCBhYnMgICAgICAgICAgICA9IE1hdGguYWJzXG4gICwgcG93ICAgICAgICAgICAgPSBNYXRoLnBvd1xuICAsIGZsb29yICAgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGxvZyAgICAgICAgICAgID0gTWF0aC5sb2dcbiAgLCBMTjIgICAgICAgICAgICA9IE1hdGguTE4yXG4gICwgQlVGRkVSICAgICAgICAgPSAnYnVmZmVyJ1xuICAsIEJZVEVfTEVOR1RIICAgID0gJ2J5dGVMZW5ndGgnXG4gICwgQllURV9PRkZTRVQgICAgPSAnYnl0ZU9mZnNldCdcbiAgLCAkQlVGRkVSICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUlxuICAsICRMRU5HVEggICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEhcbiAgLCAkT0ZGU0VUICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxudmFyIHBhY2tJRUVFNzU0ID0gZnVuY3Rpb24odmFsdWUsIG1MZW4sIG5CeXRlcyl7XG4gIHZhciBidWZmZXIgPSBBcnJheShuQnl0ZXMpXG4gICAgLCBlTGVuICAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgID0gZU1heCA+PiAxXG4gICAgLCBydCAgICAgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBzICAgICAgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwXG4gICAgLCBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSlcbiAgaWYodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KXtcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSl7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYodmFsdWUgKiBjID49IDIpe1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZihlICsgZUJpYXMgPj0gZU1heCl7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZihlICsgZUJpYXMgPj0gMSl7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG52YXIgdW5wYWNrSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGVMZW4gID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgLCBlTWF4ICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgPSBlTWF4ID4+IDFcbiAgICAsIG5CaXRzID0gZUxlbiAtIDdcbiAgICAsIGkgICAgID0gbkJ5dGVzIC0gMVxuICAgICwgcyAgICAgPSBidWZmZXJbaS0tXVxuICAgICwgZSAgICAgPSBzICYgMTI3XG4gICAgLCBtO1xuICBzID4+PSA3O1xuICBmb3IoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvcig7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmKGUgPT09IDApe1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZihlID09PSBlTWF4KXtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbnZhciB1bnBhY2tJMzIgPSBmdW5jdGlvbihieXRlcyl7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufTtcbnZhciBwYWNrSTggPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn07XG52YXIgcGFja0kxNiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn07XG52YXIgcGFja0kzMiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59O1xudmFyIHBhY2tGNjQgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufTtcbnZhciBwYWNrRjMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbihDLCBrZXksIGludGVybmFsKXtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfX0pO1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uKHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn07XG52YXIgc2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKXN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufTtcblxudmFyIHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHMgPSBmdW5jdGlvbih0aGF0LCBsZW5ndGgpe1xuICBhbkluc3RhbmNlKHRoYXQsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgdmFyIG51bWJlckxlbmd0aCA9ICtsZW5ndGhcbiAgICAsIGJ5dGVMZW5ndGggICA9IHRvTGVuZ3RoKG51bWJlckxlbmd0aCk7XG4gIGlmKG51bWJlckxlbmd0aCAhPSBieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgcmV0dXJuIGJ5dGVMZW5ndGg7XG59O1xuXG5pZighJHR5cGVkLkFCVil7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzKHRoaXMsIGxlbmd0aCk7XG4gICAgdGhpcy5fYiAgICAgICA9IGFycmF5RmlsbC5jYWxsKEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXVxuICAgICAgLCBvZmZzZXQgICAgICAgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZihvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYoREVTQ1JJUFRPUlMpe1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpe1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZighZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyOyAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3ICRBcnJheUJ1ZmZlciguNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pKXtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpe1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgKXtcbiAgICAgIGlmKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSloaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH07XG4gICAgaWYoIUxJQlJBUlkpQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpXG4gICAgLCAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZih2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSlyZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhlIEdseXBoU2V0IG9iamVjdFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfZ2x5cGggPSByZXF1aXJlKCcuL2dseXBoJyk7XG5cbi8vIERlZmluZSBhIHByb3BlcnR5IG9uIHRoZSBnbHlwaCB0aGF0IGRlcGVuZHMgb24gdGhlIHBhdGggYmVpbmcgbG9hZGVkLlxuZnVuY3Rpb24gZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsIGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdseXBoLCBleHRlcm5hbE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgdGhlIHBhdGggcHJvcGVydHkgdG8gbWFrZSBzdXJlIHRoZSBwYXRoIGlzIGxvYWRlZC5cbiAgICAgICAgICAgIGdseXBoLnBhdGg7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgcmV0dXJuIGdseXBoW2ludGVybmFsTmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGdseXBoW2ludGVybmFsTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG59XG5cbi8qKlxuICogQSBHbHlwaFNldCByZXByZXNlbnRzIGFsbCBnbHlwaHMgYXZhaWxhYmxlIGluIHRoZSBmb250LCBidXQgbW9kZWxsZWQgdXNpbmdcbiAqIGEgZGVmZXJyZWQgZ2x5cGggbG9hZGVyLCBmb3IgcmV0cmlldmluZyBnbHlwaHMgb25seSBvbmNlIHRoZXkgYXJlIGFic29sdXRlbHlcbiAqIG5lY2Vzc2FyeSwgdG8ga2VlcCB0aGUgbWVtb3J5IGZvb3RwcmludCBkb3duLlxuICogQGV4cG9ydHMgb3BlbnR5cGUuR2x5cGhTZXRcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQHBhcmFtIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gR2x5cGhTZXQoZm9udCwgZ2x5cGhzKSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbiAgICB0aGlzLmdseXBocyA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGdseXBocykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2ldID0gZ2x5cGhzW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSAoZ2x5cGhzICYmIGdseXBocy5sZW5ndGgpIHx8IDA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbkdseXBoU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbaW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IHRoaXMuZ2x5cGhzW2luZGV4XSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdseXBoc1tpbmRleF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge09iamVjdH1cbiAqL1xuR2x5cGhTZXQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpbmRleCwgbG9hZGVyKSB7XG4gICAgdGhpcy5nbHlwaHNbaW5kZXhdID0gbG9hZGVyO1xuICAgIHRoaXMubGVuZ3RoKys7XG59O1xuXG4vKipcbiAqIEBhbGlhcyBvcGVudHlwZS5nbHlwaExvYWRlclxuICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbmZ1bmN0aW9uIGdseXBoTG9hZGVyKGZvbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBfZ2x5cGguR2x5cGgoe2luZGV4OiBpbmRleCwgZm9udDogZm9udH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3R1YiBnbHlwaCB0aGF0IGNhbiBiZSBmaWxsZWQgd2l0aCBhbGwgbWV0YWRhdGEgKmV4Y2VwdCpcbiAqIHRoZSBcInBvaW50c1wiIGFuZCBcInBhdGhcIiBwcm9wZXJ0aWVzLCB3aGljaCBtdXN0IGJlIGxvYWRlZCBvbmx5IG9uY2VcbiAqIHRoZSBnbHlwaCdzIHBhdGggaXMgYWN0dWFsbHkgcmVxdWVzdGVkIGZvciB0ZXh0IHNoYXBpbmcuXG4gKiBAYWxpYXMgb3BlbnR5cGUudHRmR2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUdseXBoXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSAge251bWJlcn0gcG9zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBidWlsZFBhdGhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiB0dGZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VHbHlwaCwgZGF0YSwgcG9zaXRpb24sIGJ1aWxkUGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdseXBoID0gbmV3IF9nbHlwaC5HbHlwaCh7aW5kZXg6IGluZGV4LCBmb250OiBmb250fSk7XG5cbiAgICAgICAgZ2x5cGgucGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcGFyc2VHbHlwaChnbHlwaCwgZGF0YSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBidWlsZFBhdGgoZm9udC5nbHlwaHMsIGdseXBoKTtcbiAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneE1pbicsICdfeE1pbicpO1xuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3hNYXgnLCAnX3hNYXgnKTtcbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWluJywgJ195TWluJyk7XG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneU1heCcsICdfeU1heCcpO1xuXG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9O1xufVxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuY2ZmR2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUNGRkNoYXJzdHJpbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gY2hhcnN0cmluZ1xuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbmZ1bmN0aW9uIGNmZkdseXBoTG9hZGVyKGZvbnQsIGluZGV4LCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJzdHJpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2luZGV4OiBpbmRleCwgZm9udDogZm9udH0pO1xuXG4gICAgICAgIGdseXBoLnBhdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjaGFyc3RyaW5nKTtcbiAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9O1xufVxuXG5leHBvcnRzLkdseXBoU2V0ID0gR2x5cGhTZXQ7XG5leHBvcnRzLmdseXBoTG9hZGVyID0gZ2x5cGhMb2FkZXI7XG5leHBvcnRzLnR0ZkdseXBoTG9hZGVyID0gdHRmR2x5cGhMb2FkZXI7XG5leHBvcnRzLmNmZkdseXBoTG9hZGVyID0gY2ZmR2x5cGhMb2FkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL2dseXBoc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBmcyAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBMYXlvdXRFdmVudHMgPSB7XG4gICAgTEFZT1VUX1pPT01fSU5fQ0xJQ0tFRDogJ0xheW91dDo6Wm9vbUNvbnRyb2xzOjpab29tSW4nLFxuICAgIExBWU9VVF9aT09NX09VVF9DTElDS0VEOiAnTGF5b3V0Ojpab29tQ29udHJvbHM6Olpvb21PdXQnLFxuICAgIExBWU9VVF9BVVRPX1pPT01fQ0xJQ0tFRDogJ0xheW91dDo6Wm9vbUNvbnRyb2xzOjpBdXRvWm9vbScsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBMYXlvdXRFdmVudHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGF5b3V0L0V2ZW50cy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IEV2ZW50cyA9IHtcbiAgICBQRVJTT05BX0NMSUNLRUQ6ICdQRVJTT05BOjpDTElDS0VEJywgLy8gZnVuY3Rpb24oc2VuZGVyLCBnbG9iYWxQb2ludCwgbG9jYWxQb2ludClcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50cztcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BlcnNvbmEvRXZlbnRzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IElPYmplY3QgZnJvbSAnLi9JT2JqZWN0LmpzJztcblxuLyoqXG4gKiBTaW1wbGUgc3Vic3RpdHV0ZSBmb3IgU3RvcmFnZSwgdXNlZnVsIHdoZW4gdG8gc2F2ZSBvYmplY3RzIHJhdGhlciB0aGFuIG9ubHkgc3RyaW5ncy5cbiAqXG4gKiBAY2xhc3MgQXNzZXRDYWNoZVN0b3JhZ2VcbiAqL1xuY2xhc3MgQXNzZXRDYWNoZVN0b3JhZ2UgZXh0ZW5kcyBJT2JqZWN0IHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tRGF0YSA9IHt9O1xuICAgICAgICB0aGlzLm1LZXlzID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBvYmplY3QuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGlzIG9iamVjdCByZWFjaGVzIHplcm8uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubURhdGE7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1LZXlzO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGVuZ3RoIHJlYWQtb25seSBwcm9wZXJ0eSBvZiB0aGUgQXNzZXRDYWNoZVN0b3JhZ2UgaW50ZXJmYWNlIHJldHVybnMgYW4gaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZlxuICAgICAqIGRhdGEgaXRlbXMgc3RvcmVkIGluIHRoZSBBc3NldENhY2hlU3RvcmFnZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1LZXlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xlYXIoKSBtZXRob2Qgb2YgdGhlIEFzc2V0Q2FjaGVTdG9yYWdlIGludGVyZmFjZSwgd2hlbiBpbnZva2VkLCB3aWxsIGVtcHR5IGFsbCBrZXlzIG91dCBvZiB0aGUgc3RvcmFnZS5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5tS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tRGF0YVtrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tS2V5cy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkoKSBtZXRob2Qgb2YgdGhlIEFzc2V0Q2FjaGVTdG9yYWdlIGludGVyZmFjZSwgd2hlbiBwYXNzZWQgYSBudW1iZXIgbiwgcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgbnRoIGtleSBpblxuICAgICAqIHRoZSBzdG9yYWdlLiBUaGUgb3JkZXIgb2Yga2V5cyBpcyB1c2VyLWFnZW50IGRlZmluZWQsIHNvIHlvdSBzaG91bGQgbm90IHJlbHkgb24gaXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGtleVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrZXkgLSBBbiBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHRoZSBrZXkgeW91IHdhbnQgdG8gZ2V0IHRoZSBuYW1lIG9mLiBUaGlzIGlzIGEgemVyby1iYXNlZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGtleShrZXkpIHtcbiAgICAgICAgaWYgKGtleSA8IHRoaXMubUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tS2V5c1trZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBnZXRJdGVtKCkgbWV0aG9kIG9mIHRoZSBBc3NldENhY2hlU3RvcmFnZSBpbnRlcmZhY2UsIHdoZW4gcGFzc2VkIGEga2V5IG5hbWUsIHdpbGwgcmV0dXJuIHRoYXQga2V5J3MgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEl0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5TmFtZSAtIEEgRE9NU3RyaW5nIGNvbnRhaW5pbmcgdGhlIG5hbWUgb2YgdGhlIGtleSB5b3Ugd2FudCB0byByZXRyaWV2ZSB0aGUgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0SXRlbShrZXlOYW1lKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLm1LZXlzLmluZGV4T2Yoa2V5TmFtZSk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1EYXRhW2tleU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSByZW1vdmVJdGVtKCkgbWV0aG9kIG9mIHRoZSBBc3NldENhY2hlU3RvcmFnZSBpbnRlcmZhY2UsIHdoZW4gcGFzc2VkIGEga2V5IG5hbWUsIHdpbGwgcmVtb3ZlIHRoYXQga2V5IGZyb20gdGhlIHN0b3JhZ2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUl0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5TmFtZSAtIEEgRE9NU3RyaW5nIGNvbnRhaW5pbmcgdGhlIG5hbWUgb2YgdGhlIGtleSB5b3Ugd2FudCB0byByZW1vdmUuXG4gICAgICovXG4gICAgcmVtb3ZlSXRlbShrZXlOYW1lKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLm1LZXlzLmluZGV4T2Yoa2V5TmFtZSk7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1EYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgdGhpcy5tS2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0SXRlbSgpIG1ldGhvZCBvZiB0aGUgQXNzZXRDYWNoZVN0b3JhZ2UgaW50ZXJmYWNlLCB3aGVuIHBhc3NlZCBhIGtleSBuYW1lIGFuZCB2YWx1ZSwgd2lsbCBhZGQgdGhhdCBrZXkgdG9cbiAgICAgKiB0aGUgc3RvcmFnZSwgb3IgdXBkYXRlIHRoYXQga2V5J3MgdmFsdWUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5TmFtZSAtIEEgRE9NU3RyaW5nIGNvbnRhaW5pbmcgdGhlIG5hbWUgb2YgdGhlIGtleSB5b3Ugd2FudCB0byBjcmVhdGUvdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5VmFsdWUgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gZ2l2ZSB0aGUga2V5IHlvdSBhcmUgY3JlYXRpbmcvdXBkYXRpbmcuXG4gICAgICovXG4gICAgc2V0SXRlbShrZXlOYW1lLCBrZXlWYWx1ZSkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5tS2V5cy5pbmRleE9mKGtleU5hbWUpO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubUtleXMucHVzaChrZXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1EYXRhW2tleU5hbWVdID0ga2V5VmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIGRldGVjdCBpZiBzdHJpbmdzIGFyZSBVUkxzLlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IFVSTFBhdHRlcm4gPSBuZXcgUmVnRXhwKCdeKGh0dHBzPyk6Ly9bXlxccy8kLj8jXS5bXlxcc10qJywgJ2knKTtcblxuLyoqXG4gKiBDbGFzcyB0byBsb2FkIGFuZCBob2xkIGFzc2V0cyBpbiB0aGUgY2FjaGUsIHNwZWNpYWxseSB1c2VmdWwgd2hlbiBsb2FkaW5nIHRoaW5ncyB3aXRoaW4gcG93ZXIgYmkncyBvd24gbG9hZGVyIHdoaWNoXG4gKiBieXBhc3NlcyB0aGUgYnJvd3NlciBjYWNoZSAocHJvYmFibHkgYnkgYWRkaW5nIHBhcmFtZXRlcnMgdG8gdGhlIGVuZCBvZiB0aGUgVVJMLiBTb21ldGhpbmcgbGlrZSBhIHJlcXVlc3QgdG8gbG9hZFxuICogYGltYWdlLnBuZ2AgYmVjb21lIGEgcmVxdWVzdCB0byBsb2FkIGBodHRwczovL3Bvd2VyYmkuY29tL2xvYWQvP3VybD1pbWFnZS5wbmcmaWQ9c29tZXRoaW5nVW5pcXVlJnRpbWVzdGFtcD10aW1lYC5cbiAqXG4gKiBAY2xhc3MgQXNzZXRDYWNoZVxuICovXG5jbGFzcyBBc3NldENhY2hlIGV4dGVuZHMgSU9iamVjdCB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubVN0b3JhZ2UgPSBuZXcgQXNzZXRDYWNoZVN0b3JhZ2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKiBOT1RFOiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBjYW5ub3QgYmUgZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGluc3RhbmNlIGNhbm5vdCBiZSBkZXN0cm95ZWQuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gaW1hZ2UgZnJvbSB0aGUgcHJvdmlkZWQgVVJMIGFuZCBzYXZlcyBpdCB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGxvYWRJbWFnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIGZyb20gd2hpY2ggdGhlIGltYWdlIHNob3VsZCBiZSBsb2FkZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgbG9hZEltYWdlKHVybCkge1xuICAgICAgICBjb25zdCBsb2FkZWQgPSB0aGlzLm1TdG9yYWdlLmdldEl0ZW0odXJsKTtcbiAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2FkZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1TdG9yYWdlLnNldEl0ZW0odXJsLCBpbWFnZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tU3RvcmFnZS5zZXRJdGVtKHVybCwgcHJvbWlzZSk7XG4gICAgICAgIGltYWdlLnNyYyA9IHVybDtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBBcnJheSBCdWZmZXIgZnJvbSB0aGUgcHJvdmlkZWQgVVJMIGFuZCBzYXZlcyBpdCB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGxvYWRBcnJheUJ1ZmZlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIGZyb20gd2hpY2ggdGhlIGJ1ZmZlciBzaG91bGQgYmUgbG9hZGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGxvYWRBcnJheUJ1ZmZlcih1cmwpIHtcbiAgICAgICAgY29uc3QgbG9hZGVkID0gdGhpcy5tU3RvcmFnZS5nZXRJdGVtKHVybCk7XG4gICAgICAgIGlmIChsb2FkZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobG9hZGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChgQXJyYXkgQnVmZmVyICgke3VybH0pIGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICR7cmVxdWVzdC5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubVN0b3JhZ2Uuc2V0SXRlbSh1cmwsIHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1TdG9yYWdlLnNldEl0ZW0odXJsLCBwcm9taXNlKTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgYSBzdHJpbmcgb2YgdGV4dCBpcyBhIFVSTC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNVUkxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIHRlc3QuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNVUkwodGV4dCkge1xuICAgICAgICByZXR1cm4gVVJMUGF0dGVybi50ZXN0KHRleHQpO1xuICAgIH1cblxufVxuXG4vKipcbiAqIERvbid0IHlvdSBsb3ZlIHlvdXJzZWxmIGEgbmljZSBoYWNrP1xuICogQSBhIGhhY2sgYSBkYXkga2VlcHMgdGhlIGFyY2hpdGVjdCBhd2F5LlxuICovXG4vKiBmaW5kIGlmIHRoZSBzZXNzaW9uIHN0b3JhZ2UgaXMgYXZhaWxhYmxlICovXG5sZXQgc3RvcmFnZSA9IG51bGw7XG50cnkge1xuICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fRVNTRVhfU1RPUkFHRV9DSEVDS19fJywgQm9vbGVhbihzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX0VTU0VYX1NUT1JBR0VfQ0hFQ0tfXycpKSB8fCB0cnVlKTtcbiAgICBzdG9yYWdlID0gc2Vzc2lvblN0b3JhZ2U7XG59IGNhdGNoIChlKSB7XG4gICAgLyogc2Vzc2lvbiBzdG9yYWdlIG5vdCBhdmFpbGFibGUgKi9cbn1cblxuLyogaWYgdGhlIHN0b3JhZ2UgaXMgYXZhaWxhYmxlIHRyeSB0byBmaW5kIGEgcmVnaXN0ZXJlZCBhc3NldCBjYWNoZSwgb3IgcmVnaXN0ZXIgYSBuZXcgb25lICovXG5sZXQgY2FjaGUgPSBudWxsO1xuaWYgKHN0b3JhZ2UpIHtcbiAgICBsZXQgdmFyTmFtZSA9IHN0b3JhZ2UuZ2V0SXRlbSgnX19FU1NFWF9BU1NFVF9DQUNIRV9WQVJfTkFNRV9fJyk7XG4gICAgaWYgKHZhck5hbWUgJiYgd2luZG93W3Zhck5hbWVdIGluc3RhbmNlb2YgQXNzZXRDYWNoZSkge1xuICAgICAgICBjYWNoZSA9IHdpbmRvd1t2YXJOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZSA9IG5ldyBBc3NldENhY2hlKCk7XG4gICAgICAgIGNvbnN0IHZhck5hbWVCYXNlID0gJ19fRVNTRVhfU0hBUkVEX0FTU0VUX0NBQ0hFX18nO1xuICAgICAgICB2YXJOYW1lID0gdmFyTmFtZUJhc2U7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSh2YXJOYW1lKSkge1xuICAgICAgICAgICAgdmFyTmFtZSA9IHZhck5hbWVCYXNlICsgKGkrKyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5zZXRJdGVtKCdfX0VTU0VYX0FTU0VUX0NBQ0hFX1ZBUl9OQU1FX18nLCB2YXJOYW1lKTtcbiAgICAgICAgd2luZG93W3Zhck5hbWVdID0gY2FjaGU7XG4gICAgfVxufSBlbHNlIHtcbiAgICBjYWNoZSA9IG5ldyBBc3NldENhY2hlKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhY2hlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvY29yZS9Bc3NldENhY2hlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBJbnRlcmZhY2UgY2xhc3MgdG8gY3JlYXRlIHRhc2sgcXVldWVzLlxuICovXG5jbGFzcyBJVGFza1F1ZXVlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgXCJkb3VibGUgYnVmZmVyZWRcIiBxdWV1ZSBwb29sLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubVF1ZXVlUG9vbCA9IFtbXSwgW11dO1xuICAgICAgICB0aGlzLm1RdWV1ZVBvb2xJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubVRpY2tDYWxsYmFjayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSB0YXNrIHF1ZXVlcy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubVF1ZXVlUG9vbFswXS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm1RdWV1ZVBvb2xbMV0ubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5tUXVldWVQb29sLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRhc2sgdG8gdGhlIHF1ZXVlIGFuZCBzY2hlZHVsZXMgYSBxdWV1ZSBkcmFpbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZW5xdWV1ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2sgLSB0aGUgdGFzayB0byBlbnF1ZXVlLlxuICAgICAqL1xuICAgIGVucXVldWUodGFzaykge1xuICAgICAgICB0aGlzLm1RdWV1ZVBvb2xbdGhpcy5tUXVldWVQb29sSW5kZXhdLnB1c2godGFzayk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVEcmFpbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIHF1ZXVlIGRyYWluIGFzIGR1cmluZyB0aGUgc2NoZWR1bGVkIHRpY2suIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24sIGl0IHNjaGVkdWxlcyBhIHF1ZXVlIGRyYWluIGZvciB0aGUgbmV4dCB0aWNrLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0aWNrXG4gICAgICovXG4gICAgdGljaygpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLm1RdWV1ZVBvb2xbdGhpcy5tUXVldWVQb29sSW5kZXhdO1xuICAgICAgICBsZXQgdGFzayA9IG51bGw7XG4gICAgICAgIHRoaXMubVF1ZXVlUG9vbEluZGV4ID0gKCsrdGhpcy5tUXVldWVQb29sSW5kZXggJSAyKTtcblxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXNrID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFzaygpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVF1ZXVlID0gdGhpcy5tUXVldWVQb29sW3RoaXMubVF1ZXVlUG9vbEluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLm1RdWV1ZVBvb2xJbmRleCA9ICgrK3RoaXMubVF1ZXVlUG9vbEluZGV4ICUgMik7XG5cbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKC4uLmFjdGl2ZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBhY3RpdmVRdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZURyYWluKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHF1ZXVlIGRyYWluIGJhc2VkIG9uIHRoZSB1bmRlcmx5aW5nIHN5c3RlbS5cbiAgICAgKiBUaGlzIG1ldGhvZCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgaW5oZXJpdGluZyBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZURyYWluXG4gICAgICovXG4gICAgc2NoZWR1bGVEcmFpbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQuJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRhc2sgcXVldWUgYmFzZWQgb24gTXV0YXRpb25PYnNlcnZlcnMuXG4gKi9cbmNsYXNzIE9ic2VydmVyVGFza1F1ZXVlIGV4dGVuZHMgSVRhc2tRdWV1ZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgYSBtdXRhdGlvbiBvYnNlcnZlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgT2JzZXJ2ZXJDbGFzcy5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Y29uc3RydWN0b3J9IE9ic2VydmVyQ2xhc3MgLSBDb25zdHJ1Y3RvciBvZiB0aGUgb2JzZXJ2ZXIgY2xhc3MgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKE9ic2VydmVyQ2xhc3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tVGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgIHRoaXMubVRleHROb2RlRGF0YSA9IDA7XG4gICAgICAgIHRoaXMubU9ic2VydmVyID0gbmV3IE9ic2VydmVyQ2xhc3ModGhpcy5tVGlja0NhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5tRHJhaW5RdWV1ZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLm1PYnNlcnZlci5vYnNlcnZlKHRoaXMubVRleHROb2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhlIG9ic2VydmVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIHRoZSBkcmFpbiBmbGFnIGFuZCBjYWxscyB0aGUgc3VwZXIgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0aWNrXG4gICAgICovXG4gICAgdGljaygpIHtcbiAgICAgICAgdGhpcy5tRHJhaW5RdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgc3VwZXIudGljaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHF1ZXVlIGRyYWluLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZURyYWluXG4gICAgICovXG4gICAgc2NoZWR1bGVEcmFpbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1EcmFpblF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5tRHJhaW5RdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tVGV4dE5vZGVEYXRhID0gKyt0aGlzLm1UZXh0Tm9kZURhdGEgJSAyO1xuICAgICAgICAgICAgdGhpcy5tVGV4dE5vZGUuZGF0YSA9IHRoaXMubVRleHROb2RlRGF0YTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBDbGFzcyB0byBjcmVhdGUgYSB0YXNrIHF1ZXVlIGJhc2VkIG9uIHRoZSBgc2V0SW1tZWRpYXRlYCBtZXRob2RcbiAqL1xuY2xhc3MgSW1tZWRpYXRlVGFza1F1ZXVlIGV4dGVuZHMgSVRhc2tRdWV1ZSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubUltbWVkaWF0ZUhhbmRsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgc2V0LCBpbnZhbGlkYXRlcyB0aGUgc2NoZWR1bGVkIHF1ZXVlIGRyYWluLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubUltbWVkaWF0ZUhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUodGhpcy5tSW1tZWRpYXRlSGFuZGxlKTtcbiAgICAgICAgICAgIHRoaXMubUltbWVkaWF0ZUhhbmRsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIHRoZSBkcmFpbiBmbGFnIGFuZCBjYWxscyB0aGUgc3VwZXIgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0aWNrXG4gICAgICovXG4gICAgdGljaygpIHtcbiAgICAgICAgdGhpcy5tSW1tZWRpYXRlSGFuZGxlID0gbnVsbDtcbiAgICAgICAgc3VwZXIudGljaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHF1ZXVlIGRyYWluLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZURyYWluXG4gICAgICovXG4gICAgc2NoZWR1bGVEcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMubUltbWVkaWF0ZUhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tSW1tZWRpYXRlSGFuZGxlID0gc2V0SW1tZWRpYXRlKHRoaXMubVRpY2tDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2xhc3MgdG8gY3JlYXRlIGEgdGFzayBxdWV1ZSBiYXNlZCBvbiB0aGUgYHNldFRpbWVvdXRgIG1ldGhvZFxuICovXG5jbGFzcyBUaW1lb3V0VGFza1F1ZXVlIGV4dGVuZHMgSVRhc2tRdWV1ZSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubVRpbWVvdXRIYW5kbGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHNldCwgaW52YWxpZGF0ZXMgdGhlIHNjaGVkdWxlZCBxdWV1ZSBkcmFpbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1UaW1lb3V0SGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tVGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLm1UaW1lb3V0SGFuZGxlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dpdGNoZXMgdGhlIGRyYWluIGZsYWcgYW5kIGNhbGxzIHRoZSBzdXBlciBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRpY2tcbiAgICAgKi9cbiAgICB0aWNrKCkge1xuICAgICAgICB0aGlzLm1UaW1lb3V0SGFuZGxlID0gbnVsbDtcbiAgICAgICAgc3VwZXIudGljaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIHF1ZXVlIGRyYWluLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZURyYWluXG4gICAgICovXG4gICAgc2NoZWR1bGVEcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMubVRpbWVvdXRIYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubVRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMubVRpY2tDYWxsYmFjaywgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogRXhwb3J0cyBhIHNpbmdsZSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhlIG1vc3QgdmlhYmxlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgbmV4dFRpY2tgIGZ1bmN0aW9uYWxpdHkgb3IgYSBmdW5jdGlvbiB0aGF0XG4gKiB0aHJvd3MgYW4gZXJyb3IgaWYgbm8gdmlhYmxlIGltcGxlbWVudGF0aW9uIGlzIGZvdW5kLlxuICpcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgKCgpID0+IHtcbiAgICAvKiBOb2RlLmpzICovXG4gICAgaWYgKCh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpICYmIHByb2Nlc3MgJiYgKHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljaztcbiAgICB9XG5cbiAgICBsZXQgdGFza1F1ZXVlID0gbnVsbDtcblxuICAgIC8qIE11dGF0aW9uT2JzZXJ2ZXIgKi9cbiAgICBpZiAoKHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcpICYmIGRvY3VtZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGFza1F1ZXVlID0gbmV3IE9ic2VydmVyVGFza1F1ZXVlKE11dGF0aW9uT2JzZXJ2ZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGFza1F1ZXVlID0gbmV3IE9ic2VydmVyVGFza1F1ZXVlKHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIGZhbGxiYWNrICovXG4gICAgaWYgKCF0YXNrUXVldWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRhc2tRdWV1ZSA9IG5ldyBJbW1lZGlhdGVUYXNrUXVldWUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRhc2tRdWV1ZSA9IG5ldyBUaW1lb3V0VGFza1F1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBpZiBhIHRhc2sgcXVldWUgd2FzIGNyZWF0ZWQsIHJldHVybiBhIGZ1bmN0aW9uIHdyYXBwaW5nIGl0ICovXG4gICAgaWYgKHRhc2tRdWV1ZSkge1xuICAgICAgICByZXR1cm4gdGFzayA9PiB7XG4gICAgICAgICAgICB0YXNrUXVldWUuZW5xdWV1ZSh0YXNrKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiBpZiBubyB2aWFibGUgaW1wbGVtZW50YXRpb24gaXMgZm91bmQsIHRocm93IGFuIGVycm9yIGV2ZXJ5IHRpbWUgYG5leHRUaWNrYCBpcyBjYWxsZWQgKi9cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25leHRUaWNrIGNhbm5vdCBiZSBpbXBsZW1lbnRlZCBvbiB0aGlzIHN5c3RlbS4nKTtcbiAgICB9O1xufSkoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZXZpL2NvcmUvbmV4dFRpY2suanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL0V2ZW50cy5qcyc7XG5pbXBvcnQgR2VvbWV0cnlFdmVudHMgZnJvbSAnLi4vZ2VvbWV0cnkvRXZlbnRzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbm9kZSB0aGF0IHVzZXMgYW4gb2Zmc2NyZWVuIGJ1ZmZlciB0byByZW5kZXIgaXRzIGNvbnRlbnQsIHNpZ25pZmljYW50bHkgaW1wcm92aW5nIHJlbmRlcmluZyBzcGVlZC5cbiAqIFRoZSBjb250ZW50IGlzIG9ubHkgcmVkcmF3biB3aGVuIHRoZXJlJ3MgYSBwaXhlbCBjaGFuZ2UuXG4gKlxuICogQGNsYXNzIENhY2hlZE5vZGVcbiAqL1xuZXhwb3J0IGNsYXNzIENhY2hlZE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENhY2hlZE5vZGUuXG4gICAgICogU2luY2UgYSBiYWNraW5nIGJ1ZmZlciBpcyB1c2VkLCB0aGUgc2l6ZSBvZiB0aGlzIG5vZGUgbmVlZHMgdG8gYmUga25vd24gYXQgYWxsIHRpbWVzLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGlzIG5vZGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLm1PZmZzY3JlZW5DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5tT2Zmc2NyZWVuQ29udGV4dCA9IHRoaXMubU9mZnNjcmVlbkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLm1EaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc2l6ZS5vbihHZW9tZXRyeUV2ZW50cy5HRU9NRVRSWV9WQUxVRV9DSEFOR0VELCB0aGlzLnNpemUuc2FmZUJpbmQodGhpcy5faGFuZGxlU2l6ZUNoYW5nZWQsIHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2l6ZS5vZmYoR2VvbWV0cnlFdmVudHMuR0VPTUVUUllfVkFMVUVfQ0hBTkdFRCwgdGhpcy5faGFuZGxlU2l6ZUNoYW5nZWQsIHRoaXMpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1PZmZzY3JlZW5DYW52YXM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1PZmZzY3JlZW5Db250ZXh0O1xuICAgICAgICBkZWxldGUgdGhpcy5tRGlydHk7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXZpY2Ugc2NhbGUgdXNlZCB0byByZW5kZXIgdGhpcyBub2RlJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZGV2aWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5kZXZpY2VTY2FsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZXZpY2Ugc2NhbGUgdXNlZCB0byByZW5kZXIgdGhpcyBub2RlJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBkZXZpY2Ugc2NhbGUuXG4gICAgICovXG4gICAgc2V0IGRldmljZVNjYWxlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5kZXZpY2VTY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5tRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRldmljZVNjYWxlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBzY2FsZSBvZiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBnbG9iYWxTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdsb2JhbFNjYWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdsb2JhbCBzY2FsZSBvZiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVXN1YWxseSB0aGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgc2V0IG1hbnVhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdGhlIG5ldyBnbG9iYWwgc2NhbGUgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgc2V0IGdsb2JhbFNjYWxlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5nbG9iYWxTY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5tRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmdsb2JhbFNjYWxlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIG9iamVjdCBpcyBhZGRlZCB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgc2NlbmUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG9uRW50ZXJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gcmV2aUNvbnRleHQgLSBBIHVuaXF1ZSBzeW1ib2wgdGhhdCBpZGVudGlmaWVzIHRoZSByZW5kZXJpbmcgY29udGV4dCBvZiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBvbkVudGVyKHJldmlDb250ZXh0KSB7XG4gICAgICAgIHRoaXMub24oRXZlbnRzLkdSQVBISUNTX05PREVfTkVFRFNfUkVEUkFXLCB0aGlzLnNhZmVCaW5kKHRoaXMuX2hhbmRsZU5lZWRzUmVkcmF3LCB0aGlzKSk7XG4gICAgICAgIHRoaXMubURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIub25FbnRlcihyZXZpQ29udGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhpcyBvYmplY3RzIGlzIHJlbW92ZWQgZnJvbSB0aGUgc2NlbmUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG9uRXhpdFxuICAgICAqL1xuICAgIG9uRXhpdCgpIHtcbiAgICAgICAgdGhpcy5vZmYoRXZlbnRzLkdSQVBISUNTX05PREVfTkVFRFNfUkVEUkFXLCB0aGlzLl9oYW5kbGVOZWVkc1JlZHJhdywgdGhpcyk7XG4gICAgICAgIHN1cGVyLm9uRXhpdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSB0aWNrLCBkcmF3aW5nIG9wZXJhdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZCBoZXJlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkcmF3XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IHZhckFyZ3MgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgbm9kZSdzIGNoaWxkcmVuIHdoZW4gZHJhd2luZy5cbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIC4uLnZhckFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubURpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLm1EaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tT2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gdGhpcy5waXhlbFNpemUud2lkdGggKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgICAgIHRoaXMubU9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgPSB0aGlzLnBpeGVsU2l6ZS5oZWlnaHQgKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgICAgIHRoaXMubU9mZnNjcmVlbkNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5tT2Zmc2NyZWVuQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5tT2Zmc2NyZWVuQ2FudmFzLndpZHRoLCB0aGlzLm1PZmZzY3JlZW5DYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMubU9mZnNjcmVlbkNvbnRleHQuc2NhbGUodGhpcy5kZXZpY2VTY2FsZSAqIHRoaXMuZ2xvYmFsU2NhbGUsIHRoaXMuZGV2aWNlU2NhbGUgKiB0aGlzLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGUodGhpcy5tT2Zmc2NyZWVuQ29udGV4dCwgY29udGV4dCwgLi4udmFyQXJncyk7XG4gICAgICAgICAgICB0aGlzLm1DaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fcHVzaFRyYW5zZm9ybSh0aGlzLm1PZmZzY3JlZW5Db250ZXh0KTtcbiAgICAgICAgICAgICAgICBjaGlsZC5kcmF3KHRoaXMubU9mZnNjcmVlbkNvbnRleHQsIC4uLnZhckFyZ3MpO1xuICAgICAgICAgICAgICAgIGNoaWxkLl9wb3BUcmFuc2Zvcm0odGhpcy5tT2Zmc2NyZWVuQ29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdDYWNoZSh0aGlzLm1PZmZzY3JlZW5DYW52YXMsIGNvbnRleHQsIC4uLnZhckFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSB0aW1lIHRoZSBjYWNoZSBuZWVkcyB0byBiZSB1cGRhdGVkLCBsb2NhbCBkcmF3aW5nIG9wZXJhdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZCBoZXJlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1cGRhdGVDYWNoZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNhbnZhcyBjb250ZXh0IGluIHdoaWNoIHRoZSBkcmF3aW5nIG9wZXJhdGlvbnMgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IHBhcmVudENvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleCB0byB3aGljaCB0aGlzIGNhY2hlZCBub2RlIGlzIGJlaW5nIGRyYXduIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyQXJncyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW4gd2hlbiBkcmF3aW5nLlxuICAgICAqL1xuICAgIHVwZGF0ZUNhY2hlKC8qIGNvbnRleHQsIHBhcmVudENvbnRleHQsIC4uLnZhckFyZ3MgKi8pIHtcbiAgICAgICAgLyogb3ZlcnJpZGUgKi9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgZXZlcnkgdGltZSB0aGUgY2FjaGUgbmVlZHMgdG8gYmUgZHJhd24gb250byBhbm90aGVyIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRyYXdDYWNoZVxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGxvY2FsQ2FudmFzIC0gVGhlIGxvY2FsIGNhbnZhcyB0aGF0IGhvbGRzIHRoZSBwaXhlbCBidWZmZXIgdG8gZHJhdy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjYW52YXMgY29udGV4dCBpbiB3aGljaCB0aGUgZHJhd2luZyBvcGVyYXRpb25zIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyQXJncyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW4gd2hlbiBkcmF3aW5nLlxuICAgICAqL1xuICAgIGRyYXdDYWNoZShsb2NhbENhbnZhcywgY29udGV4dC8qICwgLi4udmFyQXJncyAqLykge1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShsb2NhbENhbnZhcywgMCwgMCwgdGhpcy5waXhlbFNpemUud2lkdGgsIHRoaXMucGl4ZWxTaXplLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGlzIG5vZGUgbmVlZHMgdG8gYmUgcmVkcmF3biwgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGFuZCBkZXRlY3RzIGlmIHRoZSBpbnRlcm5hbCBjYWNoZSBzaG91bGQgYmUgdXBkYXRlZCBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaGFuZGxlTmVlZHNSZWRyYXdcbiAgICAgKiBAcGFyYW0ge0lCaW5kYWJsZX0gc2VuZGVyIC0gVGhlIGluc3RhbmNlIHRoYXQgb3JpZ2luYWxseSB0cmlnZ2VyZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gcmVhc29uIC0gVGhlIHJlYXNvbiB3aHkgYSByZWRyYXcgaXMgbmVlZGVkLCBhcyBkZXNjcmliZWQgaW4gdGhlIE5vZGUuUkVEUkFXXyogY29uc3RhbnRzLlxuICAgICAqIEBwYXJhbSB7U3ltYm9sfG51bGx9IHR5cGUgLSBUaGUgdHlwZSBvZiB1cGRhdGUgcGVyZm9ybWVkIGZvciB0aGUgcmVkcmF3IHRvIGJlIG5lZWRlZCwgYXMgZGVzY3JpYmVkIGluIHRoZSBOb2RlLk1BVFJJWF9VUERBVEVfKiBjb25zdGFudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlTmVlZHNSZWRyYXcoc2VuZGVyLCByZWFzb24sIHR5cGUgPSBudWxsKSB7XG4gICAgICAgIGlmIChzZW5kZXIgIT09IHRoaXMgfHxcbiAgICAgICAgICAgIHJlYXNvbiA9PT0gTm9kZS5SRURSQVdfRVhURVJOQUxfUkVRVUVTVCB8fFxuICAgICAgICAgICAgcmVhc29uID09PSBOb2RlLlJFRFJBV19DSElMRF9BRERFRCB8fFxuICAgICAgICAgICAgcmVhc29uID09PSBOb2RlLlJFRFJBV19DSElMRF9SRU1PVkVEKSB7XG4gICAgICAgICAgICB0aGlzLm1EaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocmVhc29uID09PSBOb2RlLlJFRFJBV19UUkFOU0ZPUk1BVElPTl9DSEFOR0UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBOb2RlLk1BVFJJWF9VUERBVEVfU0NBTEUgfHwgdHlwZSA9PT0gTm9kZS5NQVRSSVhfVVBEQVRFX1NJWkUgfHwgdHlwZSA9PT0gTm9kZS5NQVRSSVhfVVBEQVRFX1BBUkVOVF9SRVFVRVNUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGlzIG5vZGUncyBzaXplIGlzIG1vZGlmaWVkLCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYW5kIGFsc28gY2hhbmdlcyB0aGUgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaGFuZGxlU2l6ZUNoYW5nZWRcbiAgICAgKiBAcGFyYW0geyp9IHNlbmRlciAtIFRoZSBpbnN0YW5jZSB0aGF0IG9yaWdpbmFsbHkgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlU2l6ZUNoYW5nZWQoc2VuZGVyKSB7XG4gICAgICAgIGlmIChzZW5kZXIgPT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tT2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gdGhpcy5waXhlbFNpemUud2lkdGggKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgICAgIHRoaXMubU9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgPSB0aGlzLnBpeGVsU2l6ZS5oZWlnaHQgKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1EaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYWNoZWROb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvZ3JhcGhpY3MvQ2FjaGVkTm9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBQb2x5bGluZSBmcm9tICcuL1BvbHlsaW5lLmpzJztcblxuLyoqXG4gKiBDbGFzcyB1c2VkIHRvIGRyYXcgYSBsaW5lIGZyb20gcG9pbnQgQSB0byBwb2ludCBCLlxuICpcbiAqIEBjbGFzcyBMaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBMaW5lIGV4dGVuZHMgUG9seWxpbmUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGZyb20gLSBUaGUgcG9pbnQgZnJvbSB3aGljaCB0aGlzIGxpbmUgd2lsbCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSB0byAtIFRoZSBwb2ludCB0byB3aGljaCB0aGlzIGxpbmUgd2lsbCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgZnJvbSwgdG8pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZXZpL2dyYXBoaWNzL3ByaW1pdGl2ZXMvTGluZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBQcmltaXRpdmUgZnJvbSAnLi9QcmltaXRpdmUuanMnO1xuXG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgdG8gZHJhdyBhIHJlY3RhbmdsZS5cbiAqXG4gKiBAY2xhc3MgUmVjdGFuZ2xlXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBQcmltaXRpdmUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucyB0byBkcmF3IHRoaXMgcHJpbWl0aXZlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgcGF0aCBvZiB0aGlzIHNoYXBlIHRvIHRoZSBjb250ZXh0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfcmVuZGVyUGF0aFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNhbnZhcyBjb250ZXh0IGluIHdoaWNoIHRoZSBkcmF3aW5nIG9wZXJhdGlvbnMgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcmVuZGVyaW5nIG9wdGlvbnMgZm9yIHRoaXMgc2hhcGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyUGF0aChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VUeXBlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VUeXBlID09PSBSZWN0YW5nbGUuU1RST0tFX0lOTkVSKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9wdGlvbnMuc3Ryb2tlICogMC41O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnN0cm9rZVR5cGUgPT09IFJlY3RhbmdsZS5TVFJPS0VfT1VURVIpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gb3B0aW9ucy5zdHJva2UgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LnJlY3QoLW9mZnNldCwgLW9mZnNldCwgdGhpcy5waXhlbFNpemUud2lkdGggKyAob2Zmc2V0ICogMiksIHRoaXMucGl4ZWxTaXplLmhlaWdodCArIChvZmZzZXQgKiAyKSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZWN0YW5nbGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9ncmFwaGljcy9wcmltaXRpdmVzL1JlY3RhbmdsZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBJT2JqZWN0IGZyb20gJy4uL2NvcmUvSU9iamVjdC5qcyc7XG5pbXBvcnQgQ2FudmFzIGZyb20gJy4uL2dyYXBoaWNzL0NhbnZhcy5qcyc7XG5pbXBvcnQgR3JhcGhpY0V2ZW50cyBmcm9tICcuLi9ncmFwaGljcy9FdmVudHMuanMnO1xuXG5jb25zdCBfX0lOU1RBTkNFU19fID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIFBsdWdpbiB1c2VkIHRvIHNjaGVkdWxlIGZ1bmN0aW9ucywgZXF1aXZhbGVudCB0byBgc2V0SW50ZXJ2YWxgIGFuZCBgc2V0VGltZW91dGAgYnV0IHRoaXMgY2xhc3MgbWFrZXMgc3VyZSB0aGF0IHRoZVxuICogc2NoZWR1bGVkIGZ1bmN0aW9uIHRpbWVycyBhcmUgaW4gc3luYyB3aXRoIHRoZSByZW5kZXJpbmcgZW5naW5lLlxuICpcbiAqIEBjbGFzcyBTY2hlZHVsZXJcbiAqL1xuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciBleHRlbmRzIElPYmplY3Qge1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHJldmkgY29udGV4dCBhbmQgYmluZHMgYSBuZXcgSW5wdXRNYW5hZ2VyIHRvIGl0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZWdpc3RlckNvbnRleHRcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gY29udGV4dCAtIFRoZSByZXZpIGNvbnRleHQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChfX0lOU1RBTkNFU19fLmhhcyhjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY29udGV4dCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYW52YXMgPSBDYW52YXMuZ2V0Q2FudmFzRm9yQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY2FudmFzIGlzIHJlZ2lzdGVyZWQgZm9yIHRoZSBwcm92aWRlZCBjb250ZXh0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBfX0lOU1RBTkNFU19fLnNldChjb250ZXh0LCBuZXcgU2NoZWR1bGVyKGNhbnZhcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXJzIGEgcmV2aSBjb250ZXh0IGFuZCBkZXN0cm95cyB0aGUgSW5wdXRNYW5hZ2VyIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdW5yZWdpc3RlckNvbnRleHRcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gY29udGV4dCAtIFRoZSByZXZpIGNvbnRleHQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHVucmVnaXN0ZXJDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBfX0lOU1RBTkNFU19fLmdldChjb250ZXh0KTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBfX0lOU1RBTkNFU19fLmRlbGV0ZShjb250ZXh0KTtcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbGVhc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvbnRleHQgd2FzIG5ldmVyIHJlZ2lzdGVyZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgSW5wdXRNYW5hZ2VyIGxpbmtlZCB0byB0aGUgcHJvdmlkZWQgY29udGV4dCBhbmQgcmV0dXJucyBpdCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5zdGFuY2VGb3JDb250ZXh0XG4gICAgICogQHBhcmFtIHtTeW1ib2x9IGNvbnRleHQgLSBUaGUgcmV2aSBjb250ZXh0IHRvIGxvb2sgZm9yLlxuICAgICAqIEByZXR1cm5zIHtJbnB1dE1hbmFnZXJ8bnVsbH1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIGluc3RhbmNlRm9yQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX0lOU1RBTkNFU19fLmdldChjb250ZXh0KSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXMgLSBUaGUgY2FudmFzIHRvIHdoaWNoIHRoZSBzY2hlZHVsZWQgZnVuY3Rpb25zIHNob3VsZCBiZSBzeW5jZWQgdG8uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FudmFzKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5tQ3VycmVudFRpbWVyID0gMDtcbiAgICAgICAgdGhpcy5tQ2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLm1NZXRob2RzID0gW107XG4gICAgICAgIHRoaXMubU1ldGhvZHNTY2hlZHVsZWQgPSAwO1xuICAgICAgICB0aGlzLm1UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tVGltZW91dFN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMubVRpbWVvdXRIYW5kbGVyID0gdGhpcy5faGFuZGxlVGltZW91dC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMubUNhbnZhcy5vbihHcmFwaGljRXZlbnRzLkdSQVBISUNTX0NBTlZBU19JRExFX1NUQVRFX0NIQU5HRUQsIHRoaXMubUNhbnZhcy5zYWZlQmluZCh0aGlzLl9oYW5kbGVJZGxlU3RhdGVDaGFuZ2UsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5tQ2FudmFzLm9uKEdyYXBoaWNFdmVudHMuR1JBUEhJQ1NfQ0FOVkFTX1BSRV9VUERBVEUsIHRoaXMubUNhbnZhcy5zYWZlQmluZCh0aGlzLl9oYW5kbGVDYW52YXNVcGRhdGUsIHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBSZXR1cm5zIGEgdW5pcXVlIGlkZW50aWZpZXIgdGhhdCBjYW4gYmUgdXNlZCB0b1xuICAgICAqIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGZ1bmN0aW9uIGJlZm9yZSBpdCBmaXJlcy5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVUaW1lb3V0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRoZSBkZWxheSBhZnRlciB3aGljaCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBzY2hlZHVsZVRpbWVvdXQoZnVuYywgZGVsYXkgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZUZ1bmN0aW9uKGZ1bmMsIGRlbGF5LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgZnVuY3Rpb24gdG8gYmUgcmVwZWF0ZWRseSBjYWxsZWQgYXQgdGhlIHNwZWNpZmllZCBpbnRlcnZhbC4gUmV0dXJucyBhIHVuaXF1ZSBpZGVudGlmaWVyIHRoYXQgY2FuIGJlXG4gICAgICogdXNlZCB0byBjYW5jZWwgdGhlIHNjaGVkdWxlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVJbnRlcnZhbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWwgLSBUaGUgdGltZSBpbnRlcnZhbCBhdCB3aGljaCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBzY2hlZHVsZUludGVydmFsKGZ1bmMsIGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZUZ1bmN0aW9uKGZ1bmMsIGludGVydmFsLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIHRoZSBmdW5jdGlvbiBzY2hlZHVsZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGlkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjYW5jZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgLSBUaGUgaWQgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbmNlbC5cbiAgICAgKi9cbiAgICBjYW5jZWwoaWQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1NZXRob2RzLmZpbmRJbmRleChtZXRob2QgPT4gbWV0aG9kLmlkID09PSBpZCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMubU1ldGhvZHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgY29uc3QgaWRsZSA9IHRoaXMubUNhbnZhcy5pZGxlO1xuICAgICAgICAgICAgaWYgKGlkbGUgJiYgdGhpcy5tVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLm1UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tTWV0aG9kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tQ3VycmVudFRpbWVyICs9IERhdGUubm93KCkgLSB0aGlzLm1UaW1lb3V0U3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1DdXJyZW50VGltZXIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kIHRvIHNjaGVkdWxlIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIGEgZGVsYXkuIFJldHVybnMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNjaGVkdWxlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NjaGVkdWxlRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIHNjaGVkdWxlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRoZSBkZWxheSBhZnRlciB3aGljaCB0aGUgZnVuY3Rpb24gd2lsbCBmaXJlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVwZWF0cyAtIFNob3VsZCB0aGlzIGZ1bmN0aW9uIGJlIHJlLXNjaGVkdWxlZCBhZnRlciBpdCBmaXJlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGlkIC0gVGhlIGlkIHVzZWQgdG8gc2NoZWR1bGUgdGhlIGZ1bmN0aW9uLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NjaGVkdWxlRnVuY3Rpb24oZnVuYywgZGVsYXksIHJlcGVhdHMsIGlkID0gbnVsbCkge1xuICAgICAgICBjb25zdCBpZGxlID0gdGhpcy5tQ2FudmFzLmlkbGU7XG4gICAgICAgIGlmIChpZGxlICYmIHRoaXMubVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubUN1cnJlbnRUaW1lciArPSBEYXRlLm5vdygpIC0gdGhpcy5tVGltZW91dFN0YXJ0VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBkZWxheSArIHRoaXMubUN1cnJlbnRUaW1lcjtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0ge1xuICAgICAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgICAgIHRhcmdldFRpbWU6IHRhcmdldFRpbWUsXG4gICAgICAgICAgICByZXBlYXRzOiByZXBlYXRzLFxuICAgICAgICAgICAgaWQ6IGlkICE9PSBudWxsID8gaWQgOiB0aGlzLm1NZXRob2RzU2NoZWR1bGVkKyssXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IHRoaXMubU1ldGhvZHM7XG4gICAgICAgIGlmICghbWV0aG9kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1ldGhvZHMucHVzaChjb250YWluZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pbiA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4ID0gbWV0aG9kcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IG1pZCA9IDA7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRUaW1lIDw9IG1ldGhvZHNbbWF4XS50YXJnZXRUaW1lKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kcy5wdXNoKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFRpbWUgPj0gbWV0aG9kc1ttaW5dLnRhcmdldFRpbWUpIHtcbiAgICAgICAgICAgICAgICBtZXRob2RzLnVuc2hpZnQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG1pbiA8IG1heCAmJiBtaW4gKyAxICE9PSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlkID0gbWluICsgTWF0aC5mbG9vcigobWF4IC0gbWluKSAqIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRUaW1lIDwgbWV0aG9kc1ttaWRdLnRhcmdldFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IG1pZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG1pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2RzLnNwbGljZShtYXgsIDAsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250YWluZXIuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgdGltZW91dCB0byBiZSBmaXJlZCBhcyBzb29uIGFzIHRoZSBuZXh0IGZ1bmN0aW9uIGluIHRoZSBxdWV1ZSBzaG91bGQgZmlyZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3NjaGVkdWxlVGltZW91dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NjaGVkdWxlVGltZW91dCgpIHtcbiAgICAgICAgY29uc3QgbmV4dFRhcmdldFRpbWUgPSB0aGlzLm1NZXRob2RzW3RoaXMubU1ldGhvZHMubGVuZ3RoIC0gMV0udGFyZ2V0VGltZTtcbiAgICAgICAgdGhpcy5tVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5tVGltZW91dEhhbmRsZXIsIG5leHRUYXJnZXRUaW1lIC0gdGhpcy5tQ3VycmVudFRpbWVyKTtcbiAgICAgICAgdGhpcy5tVGltZW91dFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBjaGFuZ2VzIG9mIHRoZSBpZGxlIHN0YXRlIG9mIHRoZSBjYW52YXMgbGlua2VkIHRvIHRoaXMgc2NoZWR1bGVyLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaGFuZGxlSWRsZVN0YXRlQ2hhbmdlXG4gICAgICogQHBhcmFtIHtDYW52YXN9IHNlbmRlciAtIFRoZSBjYW52YXMgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWRsZSAtIElzIHRoZSBjYW52YXMgaWRsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVJZGxlU3RhdGVDaGFuZ2Uoc2VuZGVyLCBpZGxlKSB7XG4gICAgICAgIGlmICh0aGlzLm1NZXRob2RzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpZGxlICYmIHRoaXMubVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5tQ3VycmVudFRpbWVyICs9IERhdGUubm93KCkgLSB0aGlzLm1UaW1lb3V0U3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVGdW5jdGlvbnMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWRsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgY2FudmFzIHVwZGF0ZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2hhbmRsZUNhbnZhc1VwZGF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzfSBzZW5kZXIgLSBUaGUgY2FudmFzIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgLSBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlQ2FudmFzVXBkYXRlKHNlbmRlciwgZGVsdGEpIHtcbiAgICAgICAgaWYgKHRoaXMubU1ldGhvZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm1DdXJyZW50VGltZXIgKz0gTWF0aC5mbG9vcihkZWx0YSk7XG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlRnVuY3Rpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgdGltZW91dCBzY2hlZHVsZWQgYnkgdGhpcyBzY2hlZHVsZXIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVUaW1lb3V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlVGltZW91dCgpIHtcbiAgICAgICAgdGhpcy5tVGltZW91dCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLm1DdXJyZW50VGltZXIgKz0gdGltZSAtIHRoaXMubVRpbWVvdXRTdGFydFRpbWU7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGVGdW5jdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tQ3VycmVudFRpbWVyICs9IERhdGUubm93KCkgLSB0aW1lO1xuICAgICAgICBpZiAodGhpcy5tTWV0aG9kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYWxsIHRpbWVkIG91dCBmdW5jdGlvbnMgc2luY2UgdGhlIGxhc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGdvdCBjYWxsZWQuIFVzZXMgdGhlIGludGVybmFsIHRpbWVyIHZhcmlhYmxlIHRvXG4gICAgICogY2FsY3VsYXRlIHRpbWUgb3V0cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2V4ZWN1dGVGdW5jdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9leGVjdXRlRnVuY3Rpb25zKCkge1xuICAgICAgICBjb25zdCBlbGFwc2VkVGltZSA9IHRoaXMubUN1cnJlbnRUaW1lcjtcbiAgICAgICAgd2hpbGUgKHRoaXMubU1ldGhvZHMubGVuZ3RoICYmIHRoaXMubU1ldGhvZHNbdGhpcy5tTWV0aG9kcy5sZW5ndGggLSAxXS50YXJnZXRUaW1lIDw9IGVsYXBzZWRUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLm1NZXRob2RzLnBvcCgpO1xuICAgICAgICAgICAgY29udGFpbmVyLmZ1bmMoKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIucmVwZWF0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlRnVuY3Rpb24oY29udGFpbmVyLmZ1bmMsIGNvbnRhaW5lci5kZWxheSwgY29udGFpbmVyLnJlcGVhdHMsIGNvbnRhaW5lci5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubU1ldGhvZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm1DdXJyZW50VGltZXIgPSAwO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY2hlZHVsZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9wbHVnaW5zL1NjaGVkdWxlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBJQkluZGFibGUgZnJvbSAnLi4vLi4vY29yZS9JQmluZGFibGUuanMnO1xuaW1wb3J0IEVhc2luZ1R5cGVzIGZyb20gJy4vRWFzaW5nVHlwZXMuanMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL0V2ZW50cy5qcyc7XG5pbXBvcnQgQ2FudmFzIGZyb20gJy4uLy4uL2dyYXBoaWNzL0NhbnZhcy5qcyc7XG5pbXBvcnQgR3JhcGhpY3NFdmVudHMgZnJvbSAnLi4vLi4vZ3JhcGhpY3MvRXZlbnRzLmpzJztcblxuY29uc3QgX19DT05URVhUU19fID0gbmV3IE1hcCgpO1xuXG5jb25zdCBFQVNJTkdfT1BUSU9OU19ERUZBVUxUUyA9IHtcbiAgICB0eXBlOiBFYXNpbmdUeXBlcy5MaW5lYXIsXG4gICAgZHVyYXRpb246IDEwMDAsXG4gICAgc3RhcnRWYWx1ZTogMCxcbiAgICBlbmRWYWx1ZTogMSxcbiAgICBhbXBsaXR1ZGU6IDEsXG4gICAgcGVyaW9kOiAwLjMsXG4gICAgb3ZlcnNob290OiAxLjcwMTU4LFxufTtcblxuLyoqXG4gKiBTaW1wbGUgZWFzaW5nIGNsYXNzLiBVc2VkIGFzIHRoZSBiYXNlIG9mIG1vcmUgY29tcGxleCBlYXNpbmcgY2xhc3Nlcy5cbiAqXG4gKiBAY2xhc3MgRWFzaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBFYXNpbmcgZXh0ZW5kcyBJQkluZGFibGUge1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHJldmkgY29udGV4dCBhbmQgc3RhcnRzIGV4ZWN1dGluZyBlYXNpbmcgZnVuY3Rpb25zIHdpdGhpbiBpdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJDb250ZXh0XG4gICAgICogQHBhcmFtIHtTeW1ib2x9IGNvbnRleHQgLSBUaGUgcmV2aSBjb250ZXh0IG9mIHRoZSBjYW52YXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckNvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoX19DT05URVhUU19fLmhhcyhjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY29udGV4dCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYW52YXMgPSBDYW52YXMuZ2V0Q2FudmFzRm9yQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY2FudmFzIGlzIHJlZ2lzdGVyZWQgZm9yIHRoZSBwcm92aWRlZCBjb250ZXh0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBfX0NPTlRFWFRTX18uc2V0KGNvbnRleHQsIG5ldyBTZXQoKSk7XG5cbiAgICAgICAgY2FudmFzLm9uKEdyYXBoaWNzRXZlbnRzLkdSQVBISUNTX0NBTlZBU19QUkVfVVBEQVRFLCBFYXNpbmcudXBkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVycyBhIHJldmkgY29udGV4dCBhbmQgcmVtb3ZlcyBhbGwgZWFzaW5nIGZ1bmN0aW9ucyBmcm9tIGl0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyQ29udGV4dFxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBjb250ZXh0IC0gVGhlIHJldmkgY29udGV4dCBvZiB0aGUgY2FudmFzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBzdGF0aWMgdW5yZWdpc3RlckNvbnRleHQoY29udGV4dCkge1xuICAgICAgICBpZiAoX19DT05URVhUU19fLmhhcyhjb250ZXh0KSkge1xuICAgICAgICAgICAgY29uc3QgZWFzaW5ncyA9IF9fQ09OVEVYVFNfXy5nZXQoY29udGV4dCk7XG4gICAgICAgICAgICBlYXNpbmdzLmNsZWFyKCk7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBDYW52YXMuZ2V0Q2FudmFzRm9yQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMub2ZmKEdyYXBoaWNzRXZlbnRzLkdSQVBISUNTX0NBTlZBU19QUkVfVVBEQVRFLCBFYXNpbmcudXBkYXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19DT05URVhUU19fLmRlbGV0ZShjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvbnRleHQgd2FzIG5ldmVyIHJlZ2lzdGVyZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgdGhlIHNwZWNpZmllZCBlYXNpbmcgdG8gYmUgdXBkYXRlZCBkdXJpbmcgdGhlIG5leHQgY29udGV4dCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlRWFzaW5nXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IGNvbnRleHQgLSBUaGUgY29udGV4dCB0byB3aGljaCB0aGUgZWFzaW5nIHdpbGwgYmUgYWRkZWQuXG4gICAgICogQHBhcmFtIHtFYXNpbmd9IGVhc2luZyAtIEVhc2luZyB0byBhZGQuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBzY2hlZHVsZUVhc2luZyhjb250ZXh0LCBlYXNpbmcpIHtcbiAgICAgICAgaWYgKF9fQ09OVEVYVFNfXy5oYXMoY29udGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVhc2luZ3MgPSBfX0NPTlRFWFRTX18uZ2V0KGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKCFlYXNpbmdzLmhhcyhlYXNpbmcpKSB7XG4gICAgICAgICAgICAgICAgZWFzaW5ncy5hZGQoZWFzaW5nKTtcbiAgICAgICAgICAgICAgICBlYXNpbmcucmV0YWluKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlYXNpbmcgZnJvbSB0aGUgcHJvdmlkZWQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlRWFzaW5nXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IGNvbnRleHQgLSB0aGUgY29udGV4dCBmcm9tIHdoaWNoIHRoZSBlYXNpbmcgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7RWFzaW5nfSBlYXNpbmcgLSB0aGUgZWFzaW5nIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUVhc2luZyhjb250ZXh0LCBlYXNpbmcpIHtcbiAgICAgICAgaWYgKF9fQ09OVEVYVFNfXy5oYXMoY29udGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVhc2luZ3MgPSBfX0NPTlRFWFRTX18uZ2V0KGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGVhc2luZ3MuaGFzKGVhc2luZykpIHtcbiAgICAgICAgICAgICAgICBlYXNpbmdzLmRlbGV0ZShlYXNpbmcpO1xuICAgICAgICAgICAgICAgIGVhc2luZy5hdXRvcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgZWFzaW5nIGZ1bmN0aW9ucyBhdHRhY2hlZCB0byB0aGUgc3BlY2lmaWVkIGNhbnZhcyBieSBkZWx0YSB0aW1lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzIC0gVGhlIGNhbnZhcyB0byB3aGljaCB0aGUgZWFzaW5nIGZ1bmN0aW9ucyBhcmUgYXR0YWNoZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIC0gRGVsdGEgdGltZSB0byBhZHZhbmNlIHRoZSBlYXNpbmcgZnVuY3Rpb24gYnkuXG4gICAgICovXG4gICAgc3RhdGljIHVwZGF0ZShjYW52YXMsIGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlcyA9IF9fQ09OVEVYVFNfXy5nZXQoY2FudmFzLnJldmlDb250ZXh0KTtcbiAgICAgICAgaW5zdGFuY2VzLmZvckVhY2goZWFzaW5nID0+IHtcbiAgICAgICAgICAgIGVhc2luZy51cGRhdGUoZGVsdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRoaXMgZWFzaW5nIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBbiBvYmplY3Qgd2l0aCBvcHRpb25zIGZvciB0aGlzIGVhc2luZyBpbnN0YW5jZS5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghX19DT05URVhUU19fLmhhcyhjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCByZWdpc3RlciB0aGUgZWFzaW5nIHBsdWdpbiBmaXJzdCBieSBjYWxsaW5nOiBFYXNpbmcucmVnaXN0ZXJDb250ZXh0KHJldmlDb250ZXh0KScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBFQVNJTkdfT1BUSU9OU19ERUZBVUxUUywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubUVsYXBzZWQgPSAwO1xuICAgICAgICB0aGlzLm1Qcm9ncmVzcyA9IDA7XG4gICAgICAgIHRoaXMubUFyZ3VtZW50cyA9IHRoaXMuX2J1aWxkQXJndW1lbnRzKHRoaXMubU9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKF9fQ09OVEVYVFNfXy5oYXModGhpcy5tQ29udGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVhc2luZ3MgPSBfX0NPTlRFWFRTX18uZ2V0KHRoaXMubUNvbnRleHQpO1xuICAgICAgICAgICAgZWFzaW5ncy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5tQ29udGV4dDtcbiAgICAgICAgZGVsZXRlIHRoaXMubU9wdGlvbnM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1FbGFwc2VkO1xuICAgICAgICBkZWxldGUgdGhpcy5tQXJndW1lbnRzO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGV4dCBvZiB0aGlzIGVhc2luZyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3ltYm9sfVxuICAgICAqL1xuICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tQ29udGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoaXMgZWFzaW5nIHdhcyBzdGFydGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZWxhcHNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubUVsYXBzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHByb2dyZXNzIG9mIHRoaXMgZWFzaW5nLCByZWZsZWN0cyB0aGUgZWFzaW5nIHR5cGUgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHByb2dyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tUHJvZ3Jlc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHVwZGF0aW5nIHRoaXMgZWFzaW5nIHdpdGhpbiBpdHMgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc3RhcnRcbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKEVhc2luZy5zY2hlZHVsZUVhc2luZyh0aGlzLm1Db250ZXh0LCB0aGlzKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubUVsYXBzZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkVBU0lOR19TVEFSVCwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubVByb2dyZXNzID0gdGhpcy5tT3B0aW9ucy50eXBlKHRoaXMubUVsYXBzZWQsIC4uLnRoaXMubUFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5FQVNJTkdfQ09OVElOVUUsIHRoaXMsIHRoaXMubVByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHVwZGF0aW5nIHRoaXMgZWFzaW5nIHdpdGhpbiBpdHMgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmIChFYXNpbmcucmVtb3ZlRWFzaW5nKHRoaXMubUNvbnRleHQsIHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkVBU0lOR19TVE9QLCB0aGlzLCB0aGlzLm1Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhpcyBlYXNpbmcgc28gaXQgY2FuIGJlIHJldXNlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVzZXQuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubVByb2dyZXNzID0gMDtcbiAgICAgICAgdGhpcy5tRWxhcHNlZCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGV2ZXJ5IHRpY2sgdGhpcyBlYXNpbmcgbmVlZHMgdG8gYmUgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIC0gVGhlIGRlbHRhIHRpbWUgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdXBkYXRlKGRlbHRhKSB7XG4gICAgICAgIGlmICh0aGlzLm1FbGFwc2VkIDwgdGhpcy5tT3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tRWxhcHNlZCA9IE1hdGgubWluKHRoaXMubUVsYXBzZWQgKyBkZWx0YSwgdGhpcy5tT3B0aW9ucy5kdXJhdGlvbik7XG4gICAgICAgICAgICB0aGlzLm1Qcm9ncmVzcyA9IHRoaXMubU9wdGlvbnMudHlwZSh0aGlzLm1FbGFwc2VkLCAuLi50aGlzLm1Bcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZSh0aGlzLm1Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5tRWxhcHNlZCA9PT0gdGhpcy5tT3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIEVhc2luZy5yZW1vdmVFYXNpbmcodGhpcy5tQ29udGV4dCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5FQVNJTkdfRU5ELCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgZXZlcnkgdGltZSB0aGUgZWFzaW5nIGlzIHVwZGF0ZWQgYW5kIHNob3VsZCBwZXJmb3JtIGFueSBjb21wbGV4IHRhc2tzIGFzc2lnbmVkIHRvIHRoaXMgZWFzaW5nLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfcGVyZm9ybVVwZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAtIFRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoaXMgZWFzaW5nLCByZXByZXNlbnRzIHRoZSByZXN1bHQgb2YgdGhlIGVhc2luZyBmdW5jdGlvbiBjb25maWd1cmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BlcmZvcm1VcGRhdGUocHJvZ3Jlc3MpIHtcbiAgICAgICAgY29uc3QgdmFsdWVDaGFuZ2UgPSB0aGlzLm1PcHRpb25zLmVuZFZhbHVlIC0gdGhpcy5tT3B0aW9ucy5zdGFydFZhbHVlO1xuICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkVBU0lOR19VUERBVEUsIHRoaXMsIHByb2dyZXNzLCB0aGlzLm1PcHRpb25zLnN0YXJ0VmFsdWUgKyAodmFsdWVDaGFuZ2UgKiBwcm9ncmVzcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgYXJndW1lbnRzIG5lZWRlZCBmb3IgdGhlIGVhc2luZyBmdW5jdGlvbiBjb25maWd1cmVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfYnVpbGRBcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoaXMgZWFzaW5nJ3Mgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYnVpbGRBcmd1bWVudHMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcmdzID0gW107XG5cbiAgICAgICAgYXJncy5wdXNoKG9wdGlvbnMuZHVyYXRpb24pO1xuICAgICAgICBhcmdzLnB1c2goMCk7XG4gICAgICAgIGFyZ3MucHVzaCgxKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPT09IEVhc2luZ1R5cGVzLkVsYXN0aWMuRWFzZUluIHx8XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPT09IEVhc2luZ1R5cGVzLkVsYXN0aWMuRWFzZU91dCB8fFxuICAgICAgICAgICAgb3B0aW9ucy50eXBlID09PSBFYXNpbmdUeXBlcy5FbGFzdGljLkVhc2VJbk91dFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChvcHRpb25zLmFtcGxpdHVkZSk7XG4gICAgICAgICAgICBhcmdzLnB1c2gob3B0aW9ucy5wZXJpb2QpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgb3B0aW9ucy50eXBlID09PSBFYXNpbmdUeXBlcy5CYWNrLkVhc2VJbiB8fFxuICAgICAgICAgICAgb3B0aW9ucy50eXBlID09PSBFYXNpbmdUeXBlcy5CYWNrLkVhc2VPdXQgfHxcbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9PT0gRWFzaW5nVHlwZXMuQmFjay5FYXNlSW5PdXRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gob3B0aW9ucy5vdmVyc2hvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFYXNpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9wbHVnaW5zL2Vhc2luZy9FYXNpbmcuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBQSV9UXzIgPSA2LjI4MzE4NTMwNzE3OTU5OyAvKiBQSSAqIDIgKi9cblxuLyoqIFRISVMgTUVUSE9EUyBBUkUgQ1JBRlRFRCBGT1IgUEVSRk9STUFOQ0UsIE5PVCBUTyBCRSBQUkVUVFkgQ09ERSA6KCAqKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRpZmZlcmVudCBlYXNpbmcgdHlwZXMgc3VwcG9ydGVkIGJ5IHJldmkncyBlYXNpbmcgcGx1Z2luLlxuICogTk9URTogVGhpcyBmdW5jdGlvbnMgZG9uJ3QgcmVhbGx5IG5lZWQgYSBgc3RhcnRgIGFuZCBgY2hhbmdlYCBwYXJhbWV0ZXJzIHNpbmNlIHRoZSBlYXNpbmcgcGx1Z2luIGFsd2F5cyB1c2VzIDAgYW5kIDFcbiAqIHJlc3BlY3RpdmVseSwgYnV0IEkgbGVmdCB0aGUgYXJndW1lbnRzIGZvciByZXVzYWJpbGl0eSdzIHNha2UuIFRoYXQgYmVpbmcgc2FpZCBhIGJpdCBvZiBwZXJmb3JtYW5jZSBjYW4gYmUgc3F1ZWV6ZWRcbiAqIGJ5IHJlbW92aW5nIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgaW1wbGVtZW50YXRpb24uIERvbid0IGV4cGVjeSBodWdlIGdhaW5zIHRob3VnaCwgdW5sZXNzIGVhc2luZyBpcyBiZWluZyBoZWF2aWx5IHVzZWRcbiAqIGluIHRoZSBwcm9qZWN0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBFYXNpbmdUeXBlcyA9IHtcbiAgICBMaW5lYXI6IGZ1bmN0aW9uIExpbmVhckVhc2luZyh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICByZXR1cm4gY2hhbmdlICogdGltZSAvIGR1cmF0aW9uICsgc3RhcnQ7XG4gICAgfSxcblxuICAgIFF1YWRyYXRpYzoge1xuICAgICAgICBFYXNlSW46IGZ1bmN0aW9uIFF1YWRyYXRpY0Vhc2VJbih0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgdGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2UgKiB0aW1lICogdGltZSArIHN0YXJ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEVhc2VPdXQ6IGZ1bmN0aW9uIFF1YWRyYXRpY0Vhc2VPdXQodGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UpIHtcbiAgICAgICAgICAgIHRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gLWNoYW5nZSAqIHRpbWUgKiAodGltZSAtIDIpICsgc3RhcnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRWFzZUluT3V0OiBmdW5jdGlvbiBxdWFkcmF0aWNFYXNlSW5PdXQodGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmICgodGltZSAvPSBkdXJhdGlvbiAqIDAuNSkgPCAxKSByZXR1cm4gY2hhbmdlICogMC41ICogdGltZSAqIHRpbWUgKyBzdGFydDtcbiAgICAgICAgICAgIC0tdGltZTtcbiAgICAgICAgICAgIHJldHVybiAtY2hhbmdlICogMC41ICogKHRpbWUgKiAodGltZSAtIDIpIC0gMSkgKyBzdGFydDtcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgQ3ViaWM6IHtcbiAgICAgICAgRWFzZUluOiBmdW5jdGlvbiBDdWJpY0Vhc2VJbih0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgdGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2UgKiB0aW1lICogdGltZSAqIHRpbWUgKyBzdGFydDtcbiAgICAgICAgfSxcblxuICAgICAgICBFYXNlT3V0OiBmdW5jdGlvbiBDdWJpY0Vhc2VPdXQodGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UpIHtcbiAgICAgICAgICAgIHRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICAtLXRpbWU7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlICogKHRpbWUgKiB0aW1lICogdGltZSArIDEpICsgc3RhcnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRWFzZUluT3V0OiBmdW5jdGlvbiBDdWJpY0Vhc2VJbk91dCh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgdGltZSAvPSBkdXJhdGlvbiAvIDI7XG4gICAgICAgICAgICBpZiAodGltZSA8IDEpIHJldHVybiBjaGFuZ2UgLyAyICogdGltZSAqIHRpbWUgKiB0aW1lICsgc3RhcnQ7XG4gICAgICAgICAgICB0aW1lIC09IDI7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlIC8gMiAqICh0aW1lICogdGltZSAqIHRpbWUgKyAyKSArIHN0YXJ0O1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBRdWFydGljOiB7XG4gICAgICAgIEVhc2VJbjogZnVuY3Rpb24gUXVhcnRpY0Vhc2VJbih0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgdGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2UgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lICsgc3RhcnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRWFzZU91dDogZnVuY3Rpb24gUXVhcnRpY0Vhc2VPdXQodGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UpIHtcbiAgICAgICAgICAgIHRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICAtLXRpbWU7XG4gICAgICAgICAgICByZXR1cm4gLWNoYW5nZSAqICh0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lIC0gMSkgKyBzdGFydDtcbiAgICAgICAgfSxcblxuICAgICAgICBFYXNlSW5PdXQ6IGZ1bmN0aW9uIFF1YXJ0aWNFYXNlSW5PdXQodGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UpIHtcbiAgICAgICAgICAgIHRpbWUgLz0gZHVyYXRpb24gLyAyO1xuICAgICAgICAgICAgaWYgKHRpbWUgPCAxKSByZXR1cm4gY2hhbmdlIC8gMiAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKyBzdGFydDtcbiAgICAgICAgICAgIHRpbWUgLT0gMjtcbiAgICAgICAgICAgIHJldHVybiAtY2hhbmdlIC8gMiAqICh0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lIC0gMikgKyBzdGFydDtcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgUXVpbnRpYzoge1xuICAgICAgICBFYXNlSW46IGZ1bmN0aW9uIFF1aW50aWNFYXNlSW4odGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UpIHtcbiAgICAgICAgICAgIHRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKyBzdGFydDtcbiAgICAgICAgfSxcblxuICAgICAgICBFYXNlT3V0OiBmdW5jdGlvbiBRdWludGljRWFzZU91dCh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgdGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIC0tdGltZTtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2UgKiAodGltZSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKyAxKSArIHN0YXJ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEVhc2VJbk91dDogZnVuY3Rpb24gUXVpbnRpY0Vhc2VJbk91dCh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgdGltZSAvPSBkdXJhdGlvbiAvIDI7XG4gICAgICAgICAgICBpZiAodGltZSA8IDEpIHJldHVybiBjaGFuZ2UgLyAyICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKyBzdGFydDtcbiAgICAgICAgICAgIHRpbWUgLT0gMjtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2UgLyAyICogKHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lICsgMikgKyBzdGFydDtcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgU2ludXNvaWRhbDoge1xuICAgICAgICBFYXNlSW46IGZ1bmN0aW9uIFNpbnVzb2lkYWxFYXNlSW4odGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiAtY2hhbmdlICogTWF0aC5jb3ModGltZSAvIGR1cmF0aW9uICogKE1hdGguUEkgLyAyKSkgKyBjaGFuZ2UgKyBzdGFydDtcbiAgICAgICAgfSxcblxuICAgICAgICBFYXNlT3V0OiBmdW5jdGlvbiBTaW51c29pZGFsRWFzZU91dCh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZSAqIE1hdGguc2luKHRpbWUgLyBkdXJhdGlvbiAqIChNYXRoLlBJIC8gMikpICsgc3RhcnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRWFzZUluT3V0OiBmdW5jdGlvbiBTaW51c29pZGFsRWFzZUluT3V0KHRpbWUsIGR1cmF0aW9uLCBzdGFydCwgY2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gLWNoYW5nZSAvIDIgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHRpbWUgLyBkdXJhdGlvbikgLSAxKSArIHN0YXJ0O1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBFeHBvbmVudGlhbDoge1xuICAgICAgICBFYXNlSW46IGZ1bmN0aW9uIEV4cG9uZW50aWFsRWFzZUluKHRpbWUsIGR1cmF0aW9uLCBzdGFydCwgY2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlICogTWF0aC5wb3coMi4wLCAxMC4wICogKHRpbWUgLyBkdXJhdGlvbiAtIDEpKSArIHN0YXJ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEVhc2VPdXQ6IGZ1bmN0aW9uIEV4cG9uZW50aWFsRWFzZU91dCh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZSAqICgtTWF0aC5wb3coMi4wLCAtMTAuMCAqIHRpbWUgLyBkdXJhdGlvbikgKyAxLjApICsgc3RhcnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRWFzZUluT3V0OiBmdW5jdGlvbiBFeHBvbmVudGlhbEVhc2VJbk91dCh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgdGltZSAvPSBkdXJhdGlvbiAvIDI7XG4gICAgICAgICAgICBpZiAodGltZSA8IDEpIHJldHVybiBjaGFuZ2UgLyAyICogTWF0aC5wb3coMi4wLCAxMC4wICogKHRpbWUgLSAxLjApKSArIHN0YXJ0O1xuICAgICAgICAgICAgLS10aW1lO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZSAvIDIgKiAoLU1hdGgucG93KDIuMCwgLTEwLjAgKiB0aW1lKSArIDIuMCkgKyBzdGFydDtcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgQ2lyY3VsYXI6IHtcbiAgICAgICAgRWFzZUluOiBmdW5jdGlvbiBDaXJjdWxhckVhc2VJbih0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgdGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiAtY2hhbmdlICogKE1hdGguc3FydCgxIC0gdGltZSAqIHRpbWUpIC0gMSkgKyBzdGFydDtcbiAgICAgICAgfSxcblxuICAgICAgICBFYXNlT3V0OiBmdW5jdGlvbiBDaXJjdWxhckVhc2VPdXQodGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UpIHtcbiAgICAgICAgICAgIHRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICAtLXRpbWU7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlICogTWF0aC5zcXJ0KDEgLSB0aW1lICogdGltZSkgKyBzdGFydDtcbiAgICAgICAgfSxcblxuICAgICAgICBFYXNlSW5PdXQ6IGZ1bmN0aW9uIENpcmN1bGFyRWFzZUluT3V0KHRpbWUsIGR1cmF0aW9uLCBzdGFydCwgY2hhbmdlKSB7XG4gICAgICAgICAgICB0aW1lIC89IGR1cmF0aW9uIC8gMjtcbiAgICAgICAgICAgIGlmICh0aW1lIDwgMSkgcmV0dXJuIC1jaGFuZ2UgLyAyICogKE1hdGguc3FydCgxIC0gdGltZSAqIHRpbWUpIC0gMSkgKyBzdGFydDtcbiAgICAgICAgICAgIHRpbWUgLT0gMjtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2UgLyAyICogKE1hdGguc3FydCgxIC0gdGltZSAqIHRpbWUpICsgMSkgKyBzdGFydDtcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgRWxhc3RpYzoge1xuICAgICAgICBFYXNlSW46IGZ1bmN0aW9uIEVsYXN0aWNFYXNlSW4odGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UsIGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgICAgICAgICBsZXQgcztcbiAgICAgICAgICAgIGlmICh0aW1lID09PSAwKSByZXR1cm4gc3RhcnQ7IGlmICgodGltZSAvPSBkdXJhdGlvbikgPT09IDEpIHJldHVybiBzdGFydCArIGNoYW5nZTsgaWYgKCFwZXJpb2QpIHBlcmlvZCA9IGR1cmF0aW9uICogMC4zO1xuICAgICAgICAgICAgaWYgKCFhbXBsaXR1ZGUgfHwgKGNoYW5nZSA+IDAgJiYgYW1wbGl0dWRlIDwgY2hhbmdlKSB8fCAoY2hhbmdlIDwgMCAmJiBhbXBsaXR1ZGUgPCAtY2hhbmdlKSkgeyBhbXBsaXR1ZGUgPSBjaGFuZ2U7IHMgPSBwZXJpb2QgLyA0OyB9XG4gICAgICAgICAgICBlbHNlIHMgPSBwZXJpb2QgLyBQSV9UXzIgKiBNYXRoLmFzaW4oY2hhbmdlIC8gYW1wbGl0dWRlKTtcbiAgICAgICAgICAgIHRpbWUgLT0gMTtcbiAgICAgICAgICAgIHJldHVybiAtKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogdGltZSkgKiBNYXRoLnNpbigodGltZSAqIGR1cmF0aW9uIC0gcykgKiBQSV9UXzIgLyBwZXJpb2QpKSArIHN0YXJ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEVhc2VPdXQ6IGZ1bmN0aW9uIEVsYXN0aWNFYXNlT3V0KHRpbWUsIGR1cmF0aW9uLCBzdGFydCwgY2hhbmdlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICAgICAgICAgICAgbGV0IHM7XG4gICAgICAgICAgICBpZiAodGltZSA9PT0gMCkgcmV0dXJuIHN0YXJ0OyBpZiAoKHRpbWUgLz0gZHVyYXRpb24pID09PSAxKSByZXR1cm4gc3RhcnQgKyBjaGFuZ2U7IGlmICghcGVyaW9kKSBwZXJpb2QgPSBkdXJhdGlvbiAqIDAuMztcbiAgICAgICAgICAgIGlmICghYW1wbGl0dWRlIHx8IChjaGFuZ2UgPiAwICYmIGFtcGxpdHVkZSA8IGNoYW5nZSkgfHwgKGNoYW5nZSA8IDAgJiYgYW1wbGl0dWRlIDwgLWNoYW5nZSkpIHsgYW1wbGl0dWRlID0gY2hhbmdlOyBzID0gcGVyaW9kIC8gNDsgfVxuICAgICAgICAgICAgZWxzZSBzID0gcGVyaW9kIC8gUElfVF8yICogTWF0aC5hc2luKGNoYW5nZSAvIGFtcGxpdHVkZSk7XG4gICAgICAgICAgICByZXR1cm4gKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIC0xMCAqIHRpbWUpICogTWF0aC5zaW4oKHRpbWUgKiBkdXJhdGlvbiAtIHMpICogUElfVF8yIC8gcGVyaW9kKSArIGNoYW5nZSArIHN0YXJ0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBFYXNlSW5PdXQ6IGZ1bmN0aW9uIEVsYXN0aWNFYXNlSW5PdXQodGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UsIGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgICAgICAgICBsZXQgcztcbiAgICAgICAgICAgIGlmICh0aW1lID09PSAwKSByZXR1cm4gc3RhcnQ7IGlmICgodGltZSAvPSBkdXJhdGlvbiAqIDAuNSkgPT09IDIpIHJldHVybiBzdGFydCArIGNoYW5nZTsgaWYgKCFwZXJpb2QpIHBlcmlvZCA9IGR1cmF0aW9uICogKDAuMyAqIDEuNSk7XG4gICAgICAgICAgICBpZiAoIWFtcGxpdHVkZSB8fCAoY2hhbmdlID4gMCAmJiBhbXBsaXR1ZGUgPCBjaGFuZ2UpIHx8IChjaGFuZ2UgPCAwICYmIGFtcGxpdHVkZSA8IC1jaGFuZ2UpKSB7IGFtcGxpdHVkZSA9IGNoYW5nZTsgcyA9IHBlcmlvZCAvIDQ7IH1cbiAgICAgICAgICAgIGVsc2UgcyA9IHBlcmlvZCAvIFBJX1RfMiAqIE1hdGguYXNpbihjaGFuZ2UgLyBhbXBsaXR1ZGUpO1xuICAgICAgICAgICAgaWYgKHRpbWUgPCAxKSB7XG4gICAgICAgICAgICAgICAgLS10aW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIDEwICogdGltZSkgKiBNYXRoLnNpbigodGltZSAqIGR1cmF0aW9uIC0gcykgKiBQSV9UXzIgLyBwZXJpb2QpKSArIHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLS10aW1lO1xuICAgICAgICAgICAgcmV0dXJuIGFtcGxpdHVkZSAqIE1hdGgucG93KDIsIC0xMCAqIHRpbWUpICogTWF0aC5zaW4oKHRpbWUgKiBkdXJhdGlvbiAtIHMpICogUElfVF8yIC8gcGVyaW9kKSAqIDAuNSArIGNoYW5nZSArIHN0YXJ0O1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBCYWNrOiB7XG4gICAgICAgIEVhc2VJbjogZnVuY3Rpb24gQmFja0Vhc2VJbih0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSwgb3ZlcnNob290KSB7XG4gICAgICAgICAgICB0aW1lIC89IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZSAqIHRpbWUgKiB0aW1lICogKChvdmVyc2hvb3QgKyAxKSAqIHRpbWUgLSBvdmVyc2hvb3QpICsgc3RhcnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRWFzZU91dDogZnVuY3Rpb24gQmFja0Vhc2VPdXQodGltZSwgZHVyYXJ0aW9uLCBzdGFydCwgY2hhbmdlLCBvdmVyc2hvb3QpIHtcbiAgICAgICAgICAgIHRpbWUgPSB0aW1lIC8gZHVyYXJ0aW9uIC0gMTtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2UgKiAodGltZSAqIHRpbWUgKiAoKG92ZXJzaG9vdCArIDEpICogdGltZSArIG92ZXJzaG9vdCkgKyAxKSArIHN0YXJ0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEVhc2VJbk91dDogZnVuY3Rpb24gQmFja0Vhc2VJbk91dCh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSwgb3ZlcnNob290KSB7XG4gICAgICAgICAgICBpZiAoKHRpbWUgLz0gZHVyYXRpb24gKiAwLjUpIDwgMSkge1xuICAgICAgICAgICAgICAgIG92ZXJzaG9vdCAqPSAoMS41MjUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2UgKiAwLjUgKiAodGltZSAqIHRpbWUgKiAoKChvdmVyc2hvb3QpICsgMSkgKiB0aW1lIC0gb3ZlcnNob290KSkgKyBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG92ZXJzaG9vdCAqPSAoMS41MjUpO1xuICAgICAgICAgICAgdGltZSAtPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZSAvIDIgKiAodGltZSAqIHRpbWUgKiAoKChvdmVyc2hvb3QpICsgMSkgKiB0aW1lICsgb3ZlcnNob290KSArIDIpICsgc3RhcnQ7XG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIEJvdW5jZToge1xuICAgICAgICBFYXNlSW46IGZ1bmN0aW9uICh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZSAtIEVhc2luZ1R5cGVzLkJvdW5jZS5FYXNlT3V0KGR1cmF0aW9uIC0gdGltZSwgMCwgY2hhbmdlLCBkdXJhdGlvbikgKyBzdGFydDtcbiAgICAgICAgfSxcblxuICAgICAgICBFYXNlT3V0OiBmdW5jdGlvbiAodGltZSwgZHVyYXRpb24sIHN0YXJ0LCBjaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmICgodGltZSAvPSBkdXJhdGlvbikgPCAoMSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZSAqICg3LjU2MjUgKiB0aW1lICogdGltZSkgKyBzdGFydDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZSA8ICgyIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlICogKDcuNTYyNSAqICh0aW1lIC09ICgxLjUgLyAyLjc1KSkgKiB0aW1lICsgMC43NSkgKyBzdGFydDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZSA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2UgKiAoNy41NjI1ICogKHRpbWUgLT0gKDIuMjUgLyAyLjc1KSkgKiB0aW1lICsgMC45Mzc1KSArIHN0YXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlICogKDcuNTYyNSAqICh0aW1lIC09ICgyLjYyNSAvIDIuNzUpKSAqIHRpbWUgKyAwLjk4NDM3NSkgKyBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBFYXNlSW5PdXQ6IGZ1bmN0aW9uICh0aW1lLCBkdXJhdGlvbiwgc3RhcnQsIGNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKHRpbWUgPCBkdXJhdGlvbiAvIDIpIHJldHVybiBFYXNpbmdUeXBlcy5Cb3VuY2UuRWFzZUluKHRpbWUgKiAyLCAwLCBjaGFuZ2UsIGR1cmF0aW9uKSAqIDAuNSArIHN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIEVhc2luZ1R5cGVzLkJvdW5jZS5FYXNlT3V0KHRpbWUgKiAyIC0gZHVyYXRpb24sIDAsIGNoYW5nZSwgZHVyYXRpb24pICogMC41ICsgY2hhbmdlICogMC41ICsgc3RhcnQ7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbi8qKiBUSElTIE1FVEhPRFMgQVJFIENSQUZURUQgRk9SIFBFUkZPUk1BTkNFLCBOT1QgVE8gQkUgUFJFVFRZIENPREUgOiggKiovXG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbmV4cG9ydCBkZWZhdWx0IEVhc2luZ1R5cGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvcGx1Z2lucy9lYXNpbmcvRWFzaW5nVHlwZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBFdmVudHMgPSB7XG4gICAgRUFTSU5HX1VQREFURTogJ0Vhc2luZzo6VXBkYXRlJyxcbiAgICBFQVNJTkdfU1RBUlQ6ICdFYXNpbmc6OlN0YXJ0JyxcbiAgICBFQVNJTkdfQ09OVElOVUU6ICdFYXNpbmc6OkNvbnRpbnVlJyxcbiAgICBFQVNJTkdfRU5EOiAnRWFzaW5nOjpFbmQnLFxuICAgIEVBU0lOR19TVE9QOiAnRWFzaW5nOjpTdG9wJyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZXZpL3BsdWdpbnMvZWFzaW5nL0V2ZW50cy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IEV2ZW50cyA9IHtcbiAgICBURVhUX0xBQkVMX1dJTExfUkVOREVSOiAnVGV4dDo6TGFiZWxXaWxsUmVuZGVyJyxcbiAgICBURVhUX0xBQkVMX1JFTkRFUkVEOiAnVGV4dDo6TGFiZWxSZW5kZXJlZCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBFdmVudHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS90ZXh0L0V2ZW50cy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBDYWNoZWROb2RlIGZyb20gJy4uL2dyYXBoaWNzL0NhY2hlZE5vZGUuanMnO1xuaW1wb3J0IEZvbnRNYW5hZ2VyIGZyb20gJy4vRm9udE1hbmFnZXIuanMnO1xuaW1wb3J0IEdlb21ldHJ5RXZlbnRzIGZyb20gJy4uL2dlb21ldHJ5L0V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vRXZlbnRzLmpzJztcbmltcG9ydCBTaXplIGZyb20gJy4uL2dlb21ldHJ5L1NpemUuanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50LmpzJztcbmltcG9ydCBMaW5lIGZyb20gJy4vTGluZS5qcyc7XG5pbXBvcnQgV29yZCBmcm9tICcuL1dvcmQuanMnO1xuaW1wb3J0ICogYXMgT3BlblR5cGUgZnJvbSAnb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzJztcbmltcG9ydCBuZXh0VGljayBmcm9tICcuLi9jb3JlL25leHRUaWNrLmpzJztcblxuLyoqXG4gKiBUZXh0IGFsaWdubWVudCB0eXBlcy5cbiAqXG4gKiBAdHlwZSB7e0xFRlQ6IFN5bWJvbCwgQ0VOVEVSOiBTeW1ib2wsIFJJR0hUOiBTeW1ib2x9fVxuICovXG5jb25zdCBURVhUX0FMSUdOTUVOVCA9IHtcbiAgICAnTEVGVCc6IFN5bWJvbCgnTEVGVCcpLFxuICAgICdDRU5URVInOiBTeW1ib2woJ0NFTlRFUicpLFxuICAgICdSSUdIVCc6IFN5bWJvbCgnUklHSFQnKSxcbn07XG5PYmplY3QuZnJlZXplKFRFWFRfQUxJR05NRU5UKTtcblxuLyoqXG4gKiBUZXh0IHRydW5jYXRpbmcgdHlwZXMuXG4gKlxuICogQHR5cGUge3tUUlVOQ0FURTogU3ltYm9sLCBBVVRPX0ZJVDogU3ltYm9sLCBFTExJUFNFUzogU3ltYm9sfX1cbiAqL1xuY29uc3QgVEVYVF9UUlVOQ0FUSU5HX01PREUgPSB7XG4gICAgJ1RSVU5DQVRFJzogU3ltYm9sKCdUUlVOQ0FURScpLFxuICAgICdBVVRPX0ZJVCc6IFN5bWJvbCgnQVVUT19GSVQnKSxcbiAgICAnRUxMSVBTRVMnOiBTeW1ib2woJ0VMTElQU0VTJyksXG59O1xuT2JqZWN0LmZyZWV6ZShURVhUX1RSVU5DQVRJTkdfTU9ERSk7XG5cbi8qKlxuICogTXVsdGktbGluZSB0ZXh0IHR5cGVzLlxuICpcbiAqIEB0eXBlIHt7QVNfSVM6IFN5bWJvbCwgQVVUT19MSU5FUzogU3ltYm9sLCBTSU5HTEVfTElORTogU3ltYm9sfX1cbiAqL1xuY29uc3QgVEVYVF9NVUxUSV9MSU5FX01PREUgPSB7XG4gICAgJ0FTX0lTJzogU3ltYm9sKCdBU19JUycpLFxuICAgICdBVVRPX0xJTkVTJzogU3ltYm9sKCdBVVRPX0xJTkVTJyksXG4gICAgJ1NJTkdMRV9MSU5FJzogU3ltYm9sKCdTSU5HTEVfTElORScpLFxufTtcbk9iamVjdC5mcmVlemUoVEVYVF9NVUxUSV9MSU5FX01PREUpO1xuXG4vKipcbiAqIFRleHQgcmVuZGVyaW5nIGJhY2tlbmQuXG4gKlxuICogQHR5cGUge3tDQU5WQVM6IFN5bWJvbCwgU1ZHOiBTeW1ib2wsIFNWR19PUFRJTUlaRV9TUEVFRDogU3ltYm9sLCBTVkdfQ1JJU1BfRURHRVM6IFN5bWJvbCwgU1ZHX0dFT01FVFJJQ19QUkVDSVNJT046IFN5bWJvbH19XG4gKi9cbmNvbnN0IFRFWFRfUkVOREVSSU5HX0JBQ0tFTkQgPSB7XG4gICAgJ0NBTlZBUyc6IFN5bWJvbCgnQ0FOVkFTJyksXG4gICAgJ1NWRyc6IFN5bWJvbCgnU1ZHJyksXG4gICAgJ1NWR19PUFRJTUlaRV9TUEVFRCc6IFN5bWJvbCgnU1ZHX09QVElNSVpFX1NQRUVEJyksXG4gICAgJ1NWR19DUklTUF9FREdFUyc6IFN5bWJvbCgnU1ZHX0NSSVNQX0VER0VTJyksXG4gICAgJ1NWR19HRU9NRVRSSUNfUFJFQ0lTSU9OJzogU3ltYm9sKCdTVkdfR0VPTUVUUklDX1BSRUNJU0lPTicpLFxufTtcbk9iamVjdC5mcmVlemUoVEVYVF9SRU5ERVJJTkdfQkFDS0VORCk7XG5cbi8qKlxuICogRGVmYXVsdCBsYWJlbCByZW5kZXJpbmcgdHlwZXMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuY29uc3QgRGVmYXVsdExhYmVsT3B0aW9ucyA9IHtcbiAgICBmb250U2l6ZTogMTAsXG4gICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICBhbGlnbm1lbnQ6IFRFWFRfQUxJR05NRU5ULkxFRlQsXG4gICAgbXVsdGlMaW5lTW9kZTogVEVYVF9NVUxUSV9MSU5FX01PREUuQVNfSVMsXG4gICAgdHJ1bmNhdGVNb2RlOiBURVhUX1RSVU5DQVRJTkdfTU9ERS5UUlVOQ0FURSxcbiAgICB0cmFja2luZzogMCxcbiAgICBhdXRvU2l6ZTogZmFsc2UsXG4gICAgcmVuZGVyU2hhZG93OiBmYWxzZSxcbiAgICBzaGFkb3dDb2xvcjogJyMwMDAwMDAnLFxuICAgIHNoYWRvd09mZnNldFg6IDAsXG4gICAgc2hhZG93T2Zmc2V0WTogMCxcbiAgICBzaGFkb3dCbHVyOiA1LFxuICAgIHJlbmRlcmluZ0JhY2tlbmQ6IFRFWFRfUkVOREVSSU5HX0JBQ0tFTkQuQ0FOVkFTLFxufTtcbk9iamVjdC5mcmVlemUoRGVmYXVsdExhYmVsT3B0aW9ucyk7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGFuZCByZW5kZXJzIHRleHQgaW4gaXRzIGRldGVybWluZWQgbGFiZWwgc3BhY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYWJlbCBleHRlbmRzIENhY2hlZE5vZGUge1xuICAgIC8qKlxuICAgICAqIFRleHQgYWxpZ25tZW50IHR5cGVzLlxuICAgICAqXG4gICAgICogQHR5cGUge3tMRUZUOiBTeW1ib2wsIENFTlRFUjogU3ltYm9sLCBSSUdIVDogU3ltYm9sfX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFRFWFRfQUxJR05NRU5UKCkge1xuICAgICAgICByZXR1cm4gVEVYVF9BTElHTk1FTlQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGV4dCB0cnVuY2F0aW5nIHR5cGVzLlxuICAgICAqXG4gICAgICogQHR5cGUge3tUUlVOQ0FURTogU3ltYm9sLCBBVVRPX0ZJVDogU3ltYm9sLCBFTExJUFNFUzogU3ltYm9sfX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFRFWFRfVFJVTkNBVElOR19NT0RFKCkge1xuICAgICAgICByZXR1cm4gVEVYVF9UUlVOQ0FUSU5HX01PREU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGktbGluZSB0ZXh0IHR5cGVzLlxuICAgICAqXG4gICAgICogQHR5cGUge3tBU19JUzogU3ltYm9sLCBBVVRPX0xJTkVTOiBTeW1ib2wsIFNJTkdMRV9MSU5FOiBTeW1ib2x9fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgVEVYVF9NVUxUSV9MSU5FX01PREUoKSB7XG4gICAgICAgIHJldHVybiBURVhUX01VTFRJX0xJTkVfTU9ERTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXh0IHJlbmRlcmluZyBiYWNrZW5kLlxuICAgICAqXG4gICAgICogQHR5cGUge3tDQU5WQVM6IFN5bWJvbCwgU1ZHOiBTeW1ib2wsIFNWR19PUFRJTUlaRV9TUEVFRDogU3ltYm9sLCBTVkdfQ1JJU1BfRURHRVM6IFN5bWJvbCwgU1ZHX0dFT01FVFJJQ19QUkVDSVNJT046IFN5bWJvbH19XG4gICAgICovXG4gICAgc3RhdGljIGdldCBURVhUX1JFTkRFUklOR19CQUNLRU5EKCkge1xuICAgICAgICByZXR1cm4gVEVYVF9SRU5ERVJJTkdfQkFDS0VORDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgZGVmYXVsdCByZW5kZXJpbmcgb3B0aW9ucyBmb3IgbGFiZWxzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRMYWJlbE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBEZWZhdWx0TGFiZWxPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgbWF4IHdpZHRoIG9mIHRoaXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBtYXggaGVpZ2h0IG9mIHRoaXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byByZW5kZXIgb24gdGhpcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udEtleSAtIFRoZSBrZXksIGluIHRoZSBmb250IG1hbmFnZXIsIG9mIHRoZSBmb250IHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IGZvbnRVUkwgLSBUaGUgZm9udCB0byBsb2FkLCBpZiBpdCBoYXNuJ3QgYmVlbiBsb2FkZWQgeWV0LiBVUkwgb3IgQmFzZTY0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBsYWJlbC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB0ZXh0LCBmb250S2V5LCBmb250VVJMID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoMCwgMCk7XG4gICAgICAgIHRoaXMubU1heFNpemUgPSBuZXcgU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5tRWZmZWN0c1NpemUgPSBuZXcgU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5tRWZmZWN0c09mZnNldCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy5tVGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubUZvbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm1PcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgRGVmYXVsdExhYmVsT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubU1pbkRldmljZVNjYWxlID0gMjtcblxuICAgICAgICBpZiAoIXRoaXMubU9wdGlvbnMuYXV0b1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXhTaXplLm9uKEdlb21ldHJ5RXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMubWF4U2l6ZS5zYWZlQmluZCh0aGlzLl9oYW5kbGVNYXhTaXplQ2hhbmdlZCwgdGhpcykpO1xuICAgICAgICB0aGlzLl9sb2FkRm9udChmb250S2V5LCBmb250VVJMKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubWF4U2l6ZS5vZmYoR2VvbWV0cnlFdmVudHMuR0VPTUVUUllfVkFMVUVfQ0hBTkdFRCwgdGhpcy5faGFuZGxlTWF4U2l6ZUNoYW5nZWQsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMubU1heFNpemUucmVsZWFzZSgpO1xuICAgICAgICB0aGlzLm1FZmZlY3RzU2l6ZS5yZWxlYXNlKCk7XG4gICAgICAgIHRoaXMubUVmZmVjdHNPZmZzZXQucmVsZWFzZSgpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1NYXhTaXplO1xuICAgICAgICBkZWxldGUgdGhpcy5tRWZmZWN0c1NpemU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1FZmZlY3RzT2Zmc2V0O1xuICAgICAgICBkZWxldGUgdGhpcy5tVGV4dDtcbiAgICAgICAgZGVsZXRlIHRoaXMubUZvbnQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1PcHRpb25zO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9udCB1c2VkIHRvIHJlbmRlciB0aGlzIGxhYmVsLlxuICAgICAqXG4gICAgICogQHR5cGUge0ZvbnR9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGZvbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1Gb250O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmb250IHNpemUgdXNlZCB0byByZW5kZXIgdGhpcyBsYWJlbC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGZvbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tT3B0aW9ucy5mb250U2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmb250IHNpemUgdXNlZCB0byByZW5kZXIgdGhpcyBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgZm9udCBzaXplLlxuICAgICAqL1xuICAgIHNldCBmb250U2l6ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubU9wdGlvbnMuZm9udFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubU9wdGlvbnMuZm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhc2NlbmRlciBvZiB0aGlzIGxhYmVsIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGFzY2VuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tRm9udC50YWJsZXMuaGhlYS5hc2NlbmRlciAqICh0aGlzLmZvbnRTaXplIC8gdGhpcy5tRm9udC51bml0c1BlckVtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY2VuZGVyIG9mIHRoaXMgbGFiZWwgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgZGVzY2VuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tRm9udC50YWJsZXMuaGhlYS5kZXNjZW5kZXIgKiAodGhpcy5mb250U2l6ZSAvIHRoaXMubUZvbnQudW5pdHNQZXJFbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRyYWNraW5nIG9mIHRoaXMgbGFiZWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCB0cmFja2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU9wdGlvbnMudHJhY2tpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gc2l6ZSBvZiB0aGlzIGxhYmVsLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1NpemV9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IG1heFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1NYXhTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXZpY2Ugc2NhbGUgdXNlZCB0byByZW5kZXIgdGhpcyBub2RlJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZGV2aWNlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5kZXZpY2VTY2FsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZXZpY2Ugc2NhbGUgdXNlZCB0byByZW5kZXIgdGhpcyBub2RlJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBkZXZpY2Ugc2NhbGUuXG4gICAgICovXG4gICAgc2V0IGRldmljZVNjYWxlKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmRldmljZVNjYWxlID0gTWF0aC5tYXgodmFsdWUsIHRoaXMubU1pbkRldmljZVNjYWxlKTsgLy8gZm9yY2UgdG8gcmVuZGVyIGF0IHRoZSBtaW5pbXVtIGRldmljZSBzY2FsZSByZXNvbHV0aW9uIHRvIHJlZHVjZSBhbnRpLWFsaWFzaW5nXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgb2YgdGhpcyBsYWJlbC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1UZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRleHQgb2YgdGhpcyBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIFRoZSBuZXdcbiAgICAgKi9cbiAgICBzZXQgdGV4dCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubVRleHQpIHtcbiAgICAgICAgICAgIHRoaXMubVRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSByZW5kZXJpbmcgc3lzdGVtIHRoYXQgdGhpcyBub2RlIG5lZWRzIHRvIGJlIHJlZHJhd24gdG8gcHJvcGVybHkgZGlzcGxheSBpdHMgdXBkYXRlZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbmVlZHNSZWRyYXdcbiAgICAgKi9cbiAgICBuZWVkc1JlZHJhdygpIHtcbiAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5URVhUX0xBQkVMX1dJTExfUkVOREVSLCB0aGlzKTtcbiAgICAgICAgc3VwZXIubmVlZHNSZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgZXZlcnkgdGltZSB0aGUgY2FjaGUgbmVlZHMgdG8gYmUgdXBkYXRlZCwgbG9jYWwgZHJhd2luZyBvcGVyYXRpb25zIHNob3VsZCBiZSBwZXJmb3JtZWQgaGVyZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdXBkYXRlQ2FjaGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjYW52YXMgY29udGV4dCBpbiB3aGljaCB0aGUgZHJhd2luZyBvcGVyYXRpb25zIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBwYXJlbnRDb250ZXh0IC0gVGhlIGNhbnZhcyBjb250ZXh0IHRvIHdoaWNoIHRoaXMgY2FjaGVkIG5vZGUgaXMgYmVpbmcgZHJhd24gdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSB2YXJBcmdzIC0gT3B0aW9uYWwgcGFyYW1ldGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIG5vZGUncyBjaGlsZHJlbiB3aGVuIGRyYXdpbmcuXG4gICAgICovXG4gICAgdXBkYXRlQ2FjaGUoY29udGV4dCwgcGFyZW50Q29udGV4dCwgLi4udmFyQXJncykge1xuICAgICAgICBpZiAodGhpcy5tRm9udCAmJiB0aGlzLm1UZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5tT3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGZvbnQgPSB0aGlzLm1Gb250O1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSBvcHRpb25zLmZvbnRTaXplO1xuICAgICAgICAgICAgY29uc3QgdHJhY2tpbmcgPSBvcHRpb25zLnRyYWNraW5nO1xuXG4gICAgICAgICAgICBjb25zdCBoaGVhID0gZm9udC50YWJsZXMuaGhlYTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTY2FsZSA9IChmb250U2l6ZSAvIGZvbnQudW5pdHNQZXJFbSk7XG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMuX2V4dHJhY3RXb3JkcygpO1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VXaWR0aCA9IChmb250LmNoYXJUb0dseXBoKCcgJykuYWR2YW5jZVdpZHRoICsgdHJhY2tpbmcpO1xuICAgICAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IChoaGVhLmFzY2VuZGVyIC0gaGhlYS5kZXNjZW5kZXIpO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSB0aGlzLl9idWlsZExpbmVzKGxpbmVIZWlnaHQsIGZvbnRTY2FsZSwgd29yZHMsIHNwYWNlV2lkdGgpO1xuXG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBvcHRpb25zLmFsaWdubWVudDtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBURVhUX0FMSUdOTUVOVC5MRUZUO1xuICAgICAgICAgICAgY29uc3QgY2VudGVyID0gVEVYVF9BTElHTk1FTlQuQ0VOVEVSO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBURVhUX0FMSUdOTUVOVC5SSUdIVDtcbiAgICAgICAgICAgIGNvbnN0IHRleHRQYXRoID0gbmV3IE9wZW5UeXBlLlBhdGgoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRYID0gMTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRZID0gbGluZXMubGVuZ3RoID8gKGxpbmVzWzBdLm1pbkJhc2VsaW5lICogZm9udFNjYWxlKSA6IDE7XG5cbiAgICAgICAgICAgIHRleHRQYXRoLmZpbGwgPSBudWxsO1xuICAgICAgICAgICAgdGV4dFBhdGguc3Ryb2tlID0gbnVsbDtcblxuICAgICAgICAgICAgLyogYmxhaC4uLiAqL1xuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRXaWR0aCA9IE1hdGgubWluKHRoaXMubU1heFNpemUud2lkdGgsIGxpbmVzLnJlZHVjZSgod2lkdGgsIGxpbmUpID0+IE1hdGgubWF4KHdpZHRoLCBsaW5lLmVtV2lkdGgpLCAwKSAqIGZvbnRTY2FsZSk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMuYXV0b1NpemUgPyBjb21wdXRlZFdpZHRoIDogdGhpcy5tTWF4U2l6ZS53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0NlbnRlciA9IHdpZHRoICogMC41O1xuXG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IGxpbmUuZW1XaWR0aCAqIGZvbnRTY2FsZTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQgPT09IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IChsaW5lLm9mZnNldExlZnQgKiBmb250U2NhbGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxpZ25tZW50ID09PSBjZW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9IChjYW52YXNDZW50ZXIgLSAoKGxpbmUuZW1XaWR0aCAtIGxpbmUub2Zmc2V0TGVmdCkgKiBmb250U2NhbGUgKiAwLjUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFsaWdubWVudCA9PT0gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCA9ICh3aWR0aCAtIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluZS5hZGRUb1BhdGgodGV4dFBhdGgsIGZvbnRTaXplLCBmb250U2NhbGUsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgICAgICAgIG9mZnNldFkgKz0gbGluZUhlaWdodCAqIGZvbnRTY2FsZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBiYiA9IHRleHRQYXRoLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICBjb25zdCBiYldpZHRoID0gYmIueDIgLSBiYi54MTtcbiAgICAgICAgICAgIGNvbnN0IGJiSGVpZ2h0ID0gYmIueTIgLSBiYi55MTtcbiAgICAgICAgICAgIHRoaXMubUJvdW5kaW5nQm94LnNldChiYi54MSwgYmIueTEsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvU2l6ZShiYldpZHRoICsgMiwgYmJIZWlnaHQgKyAyLCBjb250ZXh0LCBwYXJlbnRDb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclBhdGgodGV4dFBhdGgsIGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KEV2ZW50cy5URVhUX0xBQkVMX1JFTkRFUkVELCB0aGlzLCBjb250ZXh0LCBwYXJlbnRDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci51cGRhdGVDYWNoZShjb250ZXh0LCAuLi52YXJBcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgZXZlcnkgdGltZSB0aGUgY2FjaGUgbmVlZHMgdG8gYmUgZHJhd24gb250byBhbm90aGVyIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRyYXdDYWNoZVxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGxvY2FsQ2FudmFzIC0gVGhlIGxvY2FsIGNhbnZhcyB0aGF0IGhvbGRzIHRoZSBwaXhlbCBidWZmZXIgdG8gZHJhdy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjYW52YXMgY29udGV4dCBpbiB3aGljaCB0aGUgZHJhd2luZyBvcGVyYXRpb25zIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyQXJncyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW4gd2hlbiBkcmF3aW5nLlxuICAgICAqL1xuICAgIGRyYXdDYWNoZShsb2NhbENhbnZhcywgY29udGV4dC8qICwgLi4udmFyQXJncyAqLykge1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShsb2NhbENhbnZhcywgLXRoaXMubUVmZmVjdHNPZmZzZXQueCwgLXRoaXMubUVmZmVjdHNPZmZzZXQueSwgdGhpcy5tRWZmZWN0c1NpemUud2lkdGgsIHRoaXMubUVmZmVjdHNTaXplLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBjb25maWd1cmVkLCBhdXRvc2l6ZXMgdGhpcyBsYWJlbCB0byBmaXQgaXQncyBjb250ZW50cyBhbmQgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2F1dG9TaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyBleHBlY3RlZCB3aWR0aCBvZiB0aGUgbGFiZWwuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIHRoZSBleHBlY3RlZCBoZWlnaHQgb2YgdGhlIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIGNvbnRleHQgd2hlcmUgdGhlIGxhYmVsIHdpbGwgYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IHBhcmVudENvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgdG8gd2hpY2ggdGhpcyBjYWNoZWQgbm9kZSBpcyBiZWluZyBkcmF3biB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBkcmF3aW5nIG9wdGlvbnMgb2YgdGhpcyBsYWJlbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdXRvU2l6ZSh3aWR0aCwgaGVpZ2h0LCBjb250ZXh0LCBwYXJlbnRDb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHJlc2l6ZSB0aGUgZWxlbWVudCAqL1xuICAgICAgICB0aGlzLl9wb3BUcmFuc2Zvcm0ocGFyZW50Q29udGV4dCk7XG4gICAgICAgIHRoaXMuc2l6ZS52YWx1ZTEgPSB3aWR0aDtcbiAgICAgICAgdGhpcy5zaXplLnZhbHVlMiA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fdXBkYXRlTWF0cml4KCk7XG4gICAgICAgIHRoaXMuX3B1c2hUcmFuc2Zvcm0ocGFyZW50Q29udGV4dCk7XG5cbiAgICAgICAgLyogY2FsY3VsYXRlIHRoZSBuZXcgY2FudmFzIHNpemUgKi9cbiAgICAgICAgdGhpcy5tRWZmZWN0c1NpemUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJlbmRlclNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5tRWZmZWN0c09mZnNldC54ID0gTWF0aC5tYXgob3B0aW9ucy5zaGFkb3dCbHVyIC0gb3B0aW9ucy5zaGFkb3dPZmZzZXRYLCAwKTtcbiAgICAgICAgICAgIHRoaXMubUVmZmVjdHNTaXplLndpZHRoICs9IG9wdGlvbnMuc2hhZG93Qmx1ciArIE1hdGgubWF4KG9wdGlvbnMuc2hhZG93Qmx1ciwgTWF0aC5hYnMob3B0aW9ucy5zaGFkb3dPZmZzZXRYKSk7XG5cbiAgICAgICAgICAgIHRoaXMubUVmZmVjdHNPZmZzZXQueSA9IE1hdGgubWF4KG9wdGlvbnMuc2hhZG93Qmx1ciAtIG9wdGlvbnMuc2hhZG93T2Zmc2V0WSwgMCk7XG4gICAgICAgICAgICB0aGlzLm1FZmZlY3RzU2l6ZS5oZWlnaHQgKz0gb3B0aW9ucy5zaGFkb3dCbHVyICsgTWF0aC5tYXgob3B0aW9ucy5zaGFkb3dCbHVyLCBNYXRoLmFicyhvcHRpb25zLnNoYWRvd09mZnNldFkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubUVmZmVjdHNPZmZzZXQuc2V0KDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tT2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gdGhpcy5tRWZmZWN0c1NpemUud2lkdGggKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgdGhpcy5tT2Zmc2NyZWVuQ2FudmFzLmhlaWdodCA9IHRoaXMubUVmZmVjdHNTaXplLmhlaWdodCAqIHRoaXMuZGV2aWNlU2NhbGUgKiB0aGlzLmdsb2JhbFNjYWxlO1xuXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLm1PZmZzY3JlZW5DYW52YXMud2lkdGgsIHRoaXMubU9mZnNjcmVlbkNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHRoaXMuZGV2aWNlU2NhbGUgKiB0aGlzLmdsb2JhbFNjYWxlLCB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZSk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHRoaXMubUVmZmVjdHNPZmZzZXQueCwgdGhpcy5tRWZmZWN0c09mZnNldC55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgd29yZHMgZnJvbSB0aGUgZ2l2ZW4gdGV4dCwgdXNpbmcgdGhlIGZvbnQgYW5kIHRyYWNraW5nIHByb3ZpZGVkLlxuICAgICAqIE5PVEU6IFRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBhdXRvcmVsZWFzZWQgYFdvcmRgIGluc3RhbmNlcy4gSWYgdGhlIHdvcmRzIHdpbGwgYmUgc2F2ZWQgZm9yIGxhdGVyIHVzZSwgY2FsbFxuICAgICAqIGByZXRhaW5gIG9uIGVhY2ggb25lIG9mIHRoZW0uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9leHRyYWN0V29yZHNcbiAgICAgKiBAcmV0dXJucyB7V29yZFtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4dHJhY3RXb3JkcygpIHtcbiAgICAgICAgY29uc3QgZm9udCA9IHRoaXMubUZvbnQ7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLm1UZXh0O1xuICAgICAgICBjb25zdCB0cmFja2luZyA9IHRoaXMubU9wdGlvbnMudHJhY2tpbmc7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGxldCBjaGFyO1xuICAgICAgICBsZXQgd29yZFRleHQgPSAnJztcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRleHQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBpZiAod29yZFRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goV29yZC5pbnN0YW5jZSh3b3JkVGV4dCwgZm9udCwgdHJhY2tpbmcpKTtcbiAgICAgICAgICAgICAgICAgICAgd29yZFRleHQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd29yZHMucHVzaChXb3JkLlNQQUNFX1dPUkQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnXFxuJyB8fCBjaGFyID09PSAnXFxyJyB8fCBjaGFyID09PSAnXFx1MDAwMycpIHtcbiAgICAgICAgICAgICAgICBpZiAod29yZFRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goV29yZC5pbnN0YW5jZSh3b3JkVGV4dCwgZm9udCwgdHJhY2tpbmcpKTtcbiAgICAgICAgICAgICAgICAgICAgd29yZFRleHQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd29yZHMucHVzaChXb3JkLkxJTkVfQlJFQUtfV09SRCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdvcmRUZXh0ICs9IGNoYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod29yZFRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKFdvcmQuaW5zdGFuY2Uod29yZFRleHQsIGZvbnQsIHRyYWNraW5nKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd29yZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSB0ZXh0IGxpbmVzIGZvciB0aGlzIGxhYmVsIHVzaW5nIHRoZSBvcHRpb25zIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfYnVpbGRMaW5lc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IC0gVGhlIGhlaWdodCwgaW4gZW1zLCBvZiBhIGxpbmUgb2YgdGV4dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgZGVzaXJlZCBmb250IHNpemUgc2NhbGUuXG4gICAgICogQHBhcmFtIHtXb3JkW119IHdvcmRzIC0gQW4gYXJyYXkgb2Ygd29yZHMgdG8gZGlzdHJpYnV0ZSBpbiBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3BhY2VXaWR0aCAtIFRoZSB3aWR0aCwgaW4gZW1zLCBvZiBhIHNwYWNlIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJucyB7TGluZVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2J1aWxkTGluZXMobGluZUhlaWdodCwgc2NhbGUsIHdvcmRzLCBzcGFjZVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm1PcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy50cnVuY2F0ZU1vZGUgPT09IFRFWFRfVFJVTkNBVElOR19NT0RFLkFVVE9fRklUKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RydW5jYXRpbmcgbW9kZSBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMubU1heFNpemUud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMubU1heFNpemUuaGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgICAgIGNvbnN0IGFzSXNMaW5lQnJlYWsgPSBvcHRpb25zLm11bHRpTGluZU1vZGUgPT09IFRFWFRfTVVMVElfTElORV9NT0RFLkFTX0lTO1xuICAgICAgICBjb25zdCBzaW5nbGVMaW5lID0gb3B0aW9ucy5tdWx0aUxpbmVNb2RlID09PSBURVhUX01VTFRJX0xJTkVfTU9ERS5TSU5HTEVfTElORTtcbiAgICAgICAgY29uc3QgYWRkRWxsaXBzZXMgPSBvcHRpb25zLnRydW5jYXRlTW9kZSA9PT0gVEVYVF9UUlVOQ0FUSU5HX01PREUuRUxMSVBTRVM7XG4gICAgICAgIGNvbnN0IHRhcmdldEVtV2lkdGggPSB3aWR0aCAvIHNjYWxlO1xuICAgICAgICBjb25zdCB0YXJnZXRFbUhlaWdodCA9IGhlaWdodCAvIHNjYWxlO1xuICAgICAgICBsZXQgZW1IZWlnaHQgPSAwO1xuICAgICAgICBsZXQgbGluZSA9IG51bGw7XG4gICAgICAgIGxldCB3b3JkID0gbnVsbDtcbiAgICAgICAgbGV0IGlzTGFzdExpbmUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHdvcmRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgZW1IZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBpc0xhc3RMaW5lID0gc2luZ2xlTGluZSB8fCBlbUhlaWdodCArIGxpbmVIZWlnaHQgPiB0YXJnZXRFbUhlaWdodDtcbiAgICAgICAgICAgICAgICBsaW5lID0gTGluZS5pbnN0YW5jZShzcGFjZVdpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd29yZCA9IHdvcmRzW2ldO1xuICAgICAgICAgICAgaWYgKHdvcmQgPT09IFdvcmQuTElORV9CUkVBS19XT1JEICYmIHNpbmdsZUxpbmUpIHtcbiAgICAgICAgICAgICAgICB3b3JkID0gV29yZC5TUEFDRV9XT1JEO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod29yZCA9PT0gV29yZC5MSU5FX0JSRUFLX1dPUkQgfHwgKCghYXNJc0xpbmVCcmVhayB8fCBpc0xhc3RMaW5lKSAmJiB3b3JkICE9PSBXb3JkLlNQQUNFX1dPUkQgJiYgKGxpbmUuZW1XaWR0aCArIHdvcmQuZW1XaWR0aCkgPiB0YXJnZXRFbVdpZHRoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0xhc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRFbGxpcHNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyaW9kR2x5cGggPSB0aGlzLm1Gb250LmNoYXJUb0dseXBoKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGxpcHNlc0VtV2lkdGggPSAocGVyaW9kR2x5cGguYWR2YW5jZVdpZHRoICogMykgKyAob3B0aW9ucy50cmFja2luZyAqIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuZW1XaWR0aCArIGVsbGlwc2VzRW1XaWR0aCA8IHRhcmdldEVtV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lLmFkZFdvcmQod29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLmFkZEVsbGlwc2VzKHRhcmdldEVtV2lkdGgsIHRoaXMubUZvbnQsIG9wdGlvbnMudHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUudHJpbUJsYW5rU3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGkgPSB3b3JkID09PSBXb3JkLkxJTkVfQlJFQUtfV09SRCA/IGkgOiBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lLmFkZFdvcmQod29yZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgbGluZS50cmltQmxhbmtTcGFjZSgpO1xuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGZvbnQgZnJvbS9pbnRvIHRoZSBmb250IG1hbmFnZXIgYW5kIHRyaWdnZXJzIGEgcmUtcmVuZGVyIG9mIHRoaXMgbGFiZWwgd2hlbiBkb25lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfbG9hZGZvbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udEtleSAtIFRoZSBrZXkgb2YgdGhlIGZvbnQgaW4gdGhlIGZvbnQgbWFuYWdlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udFVSTCAtIFRoZSBVUkwgb3IgQmFzZTY0IGVuY29kZWQgc3RyaW5nIGZyb20gd2hpY2ggdGhlIGZvbnQgc2hvdWxkIGJlIGxvYWRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9sb2FkRm9udChmb250S2V5LCBmb250VVJMKSB7XG4gICAgICAgIGNvbnN0IGZvbnRNYW5hZ2VyID0gRm9udE1hbmFnZXIuc2hhcmVkSW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5tRm9udCA9IGZvbnRNYW5hZ2VyLmZvbnRDYWNoZVtmb250S2V5XTtcbiAgICAgICAgaWYgKHRoaXMubUZvbnQpIHtcbiAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb250VVJMICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9udE1hbmFnZXIubG9hZEZvbnQoZm9udFVSTCwgZm9udEtleSkudGhlbihmb250ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBvYmplY3QgY291bGQgaGF2ZSBiZWVuIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGZvbnQgd2FzIGxvYWRlZCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXRhaW5Db3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubUZvbnQgPSBmb250O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZvbnQgJyArIGZvbnRLZXkgKyAnIGhhcyBub3QgYmVlbiBsb2FkZWQgbG9hZGVkIGFuZCBhIFVSTCB3YXMgbm90IHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZ2l2ZW4gdGV4dCBwYXRoIGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IHVzaW5nIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3JlbmRlclBhdGhcbiAgICAgKiBAcGFyYW0ge1BhdGh9IHBhdGggLSBUaGUgcGF0aCB0byByZW5kZXIuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dCB0byB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHJlbmRlcmluZyBvcHRpb25zIG9mIHRoaXMgbGFiZWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyUGF0aChwYXRoLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlbmRlcmluZ0JhY2tlbmQgPT09IFRFWFRfUkVOREVSSU5HX0JBQ0tFTkQuQ0FOVkFTKSB7XG4gICAgICAgICAgICBwYXRoLmRyYXcoY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbmRlclNoYWRvdykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBvcHRpb25zLnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IG9wdGlvbnMuc2hhZG93T2Zmc2V0WCAqIHRoaXMuZGV2aWNlU2NhbGUgKiB0aGlzLmdsb2JhbFNjYWxlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IG9wdGlvbnMuc2hhZG93T2Zmc2V0WSAqIHRoaXMuZGV2aWNlU2NhbGUgKiB0aGlzLmdsb2JhbFNjYWxlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IG9wdGlvbnMuc2hhZG93Qmx1ciAqIHRoaXMuZGV2aWNlU2NhbGUgKiB0aGlzLmdsb2JhbFNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzaGFwZVJlbmRlcmluZyA9ICdhdXRvJztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbmRlcmluZ0JhY2tlbmQgPT09IFRFWFRfUkVOREVSSU5HX0JBQ0tFTkQuU1ZHX09QVElNSVpFX1NQRUVEKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVSZW5kZXJpbmcgPSAnb3B0aW1pemVTcGVlZCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVuZGVyaW5nQmFja2VuZCA9PT0gVEVYVF9SRU5ERVJJTkdfQkFDS0VORC5TVkdfQ1JJU1BfRURHRVMpIHtcbiAgICAgICAgICAgICAgICBzaGFwZVJlbmRlcmluZyA9ICdjcmlzcEVkZ2VzJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZW5kZXJpbmdCYWNrZW5kID09PSBURVhUX1JFTkRFUklOR19CQUNLRU5ELlNWR19HRU9NRVRSSUNfUFJFQ0lTSU9OKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVSZW5kZXJpbmcgPSAnZ2VvbWV0cmljUHJlY2lzaW9uJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0aC5maWxsID0gJ3doaXRlJztcblxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHBhdGgudG9TVkcoKTtcbiAgICAgICAgICAgIGNvbnN0IHN2Z1N0cmluZyA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uPVwiMS4xXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XCIke3RoaXMuc2l6ZS53aWR0aCAqIHRoaXMuZGV2aWNlU2NhbGUgKiB0aGlzLmdsb2JhbFNjYWxlfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD1cIiR7dGhpcy5zaXplLmhlaWdodCAqIHRoaXMuZGV2aWNlU2NhbGUgKiB0aGlzLmdsb2JhbFNjYWxlfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgJHt0aGlzLnNpemUud2lkdGh9ICR7dGhpcy5zaXplLmhlaWdodH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS1yZW5kZXJpbmc9XCIke3NoYXBlUmVuZGVyaW5nfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID4ke2NvbnRlbnR9PC9zdmc+YDtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWFnZS5zcmMgPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwnICsgd2luZG93LmJ0b2Eoc3ZnU3RyaW5nKTtcblxuICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLWluJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB0aGlzLnNpemUud2lkdGgsIHRoaXMuc2l6ZS5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVuZGVyU2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBvcHRpb25zLnNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBvcHRpb25zLnNoYWRvd09mZnNldFggKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gb3B0aW9ucy5zaGFkb3dPZmZzZXRZICogdGhpcy5kZXZpY2VTY2FsZSAqIHRoaXMuZ2xvYmFsU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IG9wdGlvbnMuc2hhZG93Qmx1ciAqIHRoaXMuZGV2aWNlU2NhbGUgKiB0aGlzLmdsb2JhbFNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJztcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1JlZHJhdyhMYWJlbC5SRURSQVdfQ0FDSEVfUkVGUkVTSCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhpcyBub2RlJ3Mgc2l6ZSBpcyBtb2RpZmllZCwgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGFuZCBhbHNvIGNoYW5nZXMgdGhlIHNpemUgb2YgdGhlIGludGVybmFsIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2hhbmRsZVNpemVDaGFuZ2VkXG4gICAgICogQHBhcmFtIHsqfSBzZW5kZXIgLSBUaGUgaW5zdGFuY2UgdGhhdCBvcmlnaW5hbGx5IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgd2lkdGggb2YgdGhpcyBub2RlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCBvZiB0aGlzIG5vZGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlU2l6ZUNoYW5nZWQoc2VuZGVyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmIChzZW5kZXIgPT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tYXhTaXplLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5faGFuZGxlU2l6ZUNoYW5nZWQoc2VuZGVyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoaXMgbGFiZWwncyBtYXggc2l6ZSBpcyBtb2RpZmllZCwgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGFuZCBhbHNvIGNoYW5nZXMgdGhlIHNpemUgb2YgdGhlIGludGVybmFsIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2hhbmRsZU1heFNpemVDaGFuZ2VkXG4gICAgICogQHBhcmFtIHsqfSBzZW5kZXIgLSBUaGUgaW5zdGFuY2UgdGhhdCBvcmlnaW5hbGx5IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZU1heFNpemVDaGFuZ2VkKHNlbmRlcikge1xuICAgICAgICBpZiAoc2VuZGVyID09PSB0aGlzLm1heFNpemUgJiYgdGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm1EaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExhYmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvdGV4dC9MYWJlbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBJT2JqZWN0IGZyb20gJy4uL2NvcmUvSU9iamVjdC5qcyc7XG5cbmNvbnN0IExJTkVfQlJFQUtfV09SRCA9IFN5bWJvbCgnTElORV9CUkVBS19XT1JEJyk7XG5jb25zdCBTUEFDRV9XT1JEID0gU3ltYm9sKCdTUEFDRV9XT1JEJyk7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgd29yZCBvZiB0ZXh0LlxuICpcbiAqIEBjbGFzcyBXb3JkXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JkIGV4dGVuZHMgSU9iamVjdCB7XG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIHR5cGUgdXNlZCB0byByZWNvZ25pemUgbGluZSBicmVha3MuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3ltYm9sfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTElORV9CUkVBS19XT1JEKCkge1xuICAgICAgICByZXR1cm4gTElORV9CUkVBS19XT1JEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCB0eXBlIHVzZWQgdG8gcmVjb2duaXplIHNwYWNlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTeW1ib2x9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgc3RhdGljIGdldCBTUEFDRV9XT1JEKCkge1xuICAgICAgICByZXR1cm4gU1BBQ0VfV09SRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHdvcmQgdXNpbmcgdGhlIGdpdmVuIGB3b3JkYCBhcyBhIGJhc2Ugd2l0aCBhZGRlZCBlbGxpcHNlcyB0byB0aGUgZW5kLCB0aGlzIGZ1bmN0aW9uIHJlcGxhY2VzIHRoZVxuICAgICAqIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgd29yZCBzbyBpdCBmaXRzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGBtYXhFbVdpZHRoYC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgd29yZFdpdGhFbGxpcHNlc1xuICAgICAqIEBwYXJhbSB7V29yZH0gd29yZCAtIFRoZSB3b3JkIHRvIHVzZSBhcyBhIGJhc2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heEVtV2lkdGggLSBUaGUgbWF4aW11bSB3aWR0aCwgaW4gZW1zLCB0aGF0IHRoaXMgd29yZCBjYW4gdGFrZSwgaW5jbHVkaW5nIHRoZSBlbGxpcHNlcy5cbiAgICAgKiBAcmV0dXJucyB7V29yZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZFdpdGhFbGxpcHNlcyh3b3JkLCBtYXhFbVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGVsbGlwc2VzV29yZCA9IFdvcmQuaW5zdGFuY2UoJy4uLicsIHdvcmQubUZvbnQsIHdvcmQubVRyYWNraW5nKTtcbiAgICAgICAgY29uc3QgZWxsaXBzZXNXaWR0aCA9IGVsbGlwc2VzV29yZC5lbVdpZHRoO1xuICAgICAgICBjb25zdCBvZmZzZXRzID0gd29yZC5vZmZzZXRzO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gb2Zmc2V0cy5sZW5ndGggLSAxOyBpID49IDAgJiYgb2Zmc2V0c1tpXSArIGVsbGlwc2VzV2lkdGggPiBtYXhFbVdpZHRoOyAtLWkpIHtcbiAgICAgICAgICAgIC8vIGVtcHR5XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29yZFRleHQgPSB3b3JkLm1UZXh0LnN1YnN0cigwLCBpKSArICcuLi4nO1xuICAgICAgICByZXR1cm4gV29yZC5pbnN0YW5jZSh3b3JkVGV4dCwgd29yZC5tRm9udCwgd29yZC5tVHJhY2tpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgb2YgdGhpcyB3b3JkLlxuICAgICAqIEBwYXJhbSB7Rm9udH0gZm9udCAtIFRoZSBmb250IHRvIHVzZSB0byByZW5kZXIgdGhpcyB3b3JkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0cmFja2luZyAtIFRoZSB0cmFja2luZyBmb3IgdGhlIGNoYXJhY3RlcnMgaW4gdGhpcyB3b3JkLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQgPSBudWxsLCBmb250ID0gbnVsbCwgdHJhY2tpbmcgPSAwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubUdseXBocyA9IG51bGw7XG4gICAgICAgIHRoaXMubU9mZnNldHMgPSBbXTtcbiAgICAgICAgdGhpcy5tRW1XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubUVtSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5tQXNjZW5kaW5nID0gMDtcbiAgICAgICAgdGhpcy5tRGVzY2VuZGluZyA9IDA7XG4gICAgICAgIHRoaXMubVRyYWNraW5nID0gdHJhY2tpbmc7XG4gICAgICAgIHRoaXMubU9mZnNldExlZnQgPSAwO1xuICAgICAgICB0aGlzLm1UZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5tRm9udCA9IGZvbnQ7XG4gICAgICAgIHRoaXMubU9mZnNldExlZnQgPSAwO1xuXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZU1ldHJpY3MoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1HbHlwaHMpIHtcbiAgICAgICAgICAgIHRoaXMubUdseXBocy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubU9mZnNldHMubGVuZ3RoID0gMDtcblxuICAgICAgICBkZWxldGUgdGhpcy5tR2x5cGhzO1xuICAgICAgICBkZWxldGUgdGhpcy5tT2Zmc2V0cztcbiAgICAgICAgZGVsZXRlIHRoaXMubUVtV2lkdGg7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1FbUhlaWdodDtcbiAgICAgICAgZGVsZXRlIHRoaXMubUFzY2VuZGluZztcbiAgICAgICAgZGVsZXRlIHRoaXMubURlc2NlbmRpbmc7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1PZmZzZXRMZWZ0O1xuICAgICAgICBkZWxldGUgdGhpcy5tVGV4dDtcbiAgICAgICAgZGVsZXRlIHRoaXMubUZvbnQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1PZmZzZXRMZWZ0O1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBnbHlwaHMgcmVwcmVzZW50aW5nIHRoZSBjaGFyYWN0ZXJzIG9mIHRoaXMgd29yZC5cbiAgICAgKiBAdHlwZSB7bnVsbHxHbHlwaFtdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBnbHlwaHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1HbHlwaHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgd2l0aCB0aGUgb2Zmc2V0cyBvZiBlYWNoIGNoYXJhdGVjciBpbiB0aGlzIHdvcmQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IG9mZnNldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1PZmZzZXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCB3aWR0aCwgaW4gZW1zLCBvZiB0aGlzIHdvcmQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBlbVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tRW1XaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgaGVpZ2h0LCBpbiBlbXMsIG9mIHRoaXMgd29yZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGVtSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tRW1IZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1heCBhc2NlbmRpbmcgZGlzdGFuY2Ugb2YgdGhpcyB3b3JkLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgYXNjZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tQXNjZW5kaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXggZGVzY2VuZGluZyBkaXN0YW5jZSBvZiB0aGlzIHdvcmQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBkZXNjZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tRGVzY2VuZGluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGVmdCBzaWRlIG9mZnNldCBmb3IgdGhpcyB3b3JkLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgb2Zmc2V0TGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU9mZnNldExlZnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGlzIHdvcmQgdG8gdGhlIGdpdmVuIHBhdGggZm9yIHJlbmRlcmluZyBhbmQgcmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHJlbmRlcmVkIHdvcmQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFRvUGF0aFxuICAgICAqIEBwYXJhbSB7UGF0aH0gcGF0aCAtIFRoZSBPcGVuVHlwZSBwYXRoIHRvIHdoaWNoIHRoaXMgd29yZCB3aWxsIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIC0gVGhlIGRlc2lyZWQgZm9udCBzaXplIGZvciB0aGlzIHdvcmQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gVGhlIHNjYWxlIG9mIHRoaXMgZm9udCBzaXplLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSBmb3IgdGhpcyB3b3JkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBmb3IgdGhpcyB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgYWRkVG9QYXRoKHBhdGgsIHNpemUsIHNjYWxlLCB4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMubU9mZnNldHM7XG4gICAgICAgIHRoaXMubUdseXBocy5mb3JFYWNoKChnbHlwaCwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2x5cGhQYXRoID0gZ2x5cGguZ2V0UGF0aCh4ICsgKG9mZnNldHNbaV0gKiBzY2FsZSksIHksIHNpemUpO1xuICAgICAgICAgICAgcGF0aC5leHRlbmQoZ2x5cGhQYXRoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubUVtV2lkdGggKiBzY2FsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBtZXRyaWNzIG9mIHRoaXMgd29yZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2NhbGN1bGF0ZU1ldHJpY3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVNZXRyaWNzKCkge1xuICAgICAgICBpZiAodGhpcy5tRm9udCAmJiB0aGlzLm1UZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5tT2Zmc2V0cztcbiAgICAgICAgICAgIGNvbnN0IHRyYWNraW5nID0gdGhpcy5tVHJhY2tpbmc7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhc2NlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRlc2NlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZXQgZ2x5cGhNZXRyaWNzO1xuXG4gICAgICAgICAgICB0aGlzLm1PZmZzZXRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLm1HbHlwaHMgPSB0aGlzLm1Gb250LnN0cmluZ1RvR2x5cGhzKHRoaXMubVRleHQpO1xuICAgICAgICAgICAgdGhpcy5tR2x5cGhzLmZvckVhY2goKGdseXBoLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgZ2x5cGhNZXRyaWNzID0gZ2x5cGguZ2V0TWV0cmljcygpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaC5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGdseXBoLmFkdmFuY2VXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHRyYWNraW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhc2NlbmRpbmcgPT09IG51bGwgfHwgZ2x5cGhNZXRyaWNzLnlNYXggPiBhc2NlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNjZW5kaW5nID0gZ2x5cGhNZXRyaWNzLnlNYXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlc2NlbmRpbmcgPT09IG51bGwgfHwgZ2x5cGhNZXRyaWNzLnlNaW4gPCBkZXNjZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmRpbmcgPSBnbHlwaE1ldHJpY3MueU1pbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0ID09PSBudWxsIHx8IChhc2NlbmRpbmcgLSBkZXNjZW5kaW5nKSA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSAoYXNjZW5kaW5nIC0gZGVzY2VuZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tT2Zmc2V0TGVmdCA9IC1nbHlwaE1ldHJpY3MueE1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tRW1XaWR0aCA9IG9mZnNldDtcbiAgICAgICAgICAgIHRoaXMubUVtSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5tQXNjZW5kaW5nID0gYXNjZW5kaW5nO1xuICAgICAgICAgICAgdGhpcy5tRGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdvcmQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS90ZXh0L1dvcmQuanMiLCJ2YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBtc2cpe1xuICBpZih0eXBlb2YgaXQgIT0gJ251bWJlcicgJiYgY29mKGl0KSAhPSAnTnVtYmVyJyl0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0Lyo9IDAqLywgc3RhcnQvKj0gMCwgZW5kID0gQGxlbmd0aCovKXtcbiAgdmFyIE8gICAgID0gdG9PYmplY3QodGhpcylcbiAgICAsIGxlbiAgID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCB0byAgICA9IHRvSW5kZXgodGFyZ2V0LCBsZW4pXG4gICAgLCBmcm9tICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAsIGVuZCAgID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWRcbiAgICAsIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9JbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pXG4gICAgLCBpbmMgICA9IDE7XG4gIGlmKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCl7XG4gICAgaW5jICA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICAgKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlKGNvdW50LS0gPiAwKXtcbiAgICBpZihmcm9tIGluIE8pT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICAgKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXIsIElURVJBVE9SKXtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KXtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhhdClcbiAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgLCBpICAgICAgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZihhTGVuIDwgMilmb3IoOzspe1xuICAgIGlmKGluZGV4IGluIHNlbGYpe1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvcig7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSlpZihpbmRleCBpbiBzZWxmKXtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGlzT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGludm9rZSAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFycmF5U2xpY2UgPSBbXS5zbGljZVxuICAsIGZhY3RvcmllcyAgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uKEYsIGxlbiwgYXJncyl7XG4gIGlmKCEobGVuIGluIGZhY3Rvcmllcykpe1xuICAgIGZvcih2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKW5baV0gPSAnYVsnICsgaSArICddJztcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiwgYXJncy4uLiAqLyl7XG4gIHZhciBmbiAgICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24oLyogYXJncy4uLiAqLyl7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgY3JlYXRlICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKVxuICAsIHN0ZXAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBzZXRTcGVjaWVzICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBmYXN0S2V5ICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5XG4gICwgU0laRSAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uKHRoYXQsIGtleSl7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xuICBpZihpbmRleCAhPT0gJ0YnKXJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvcihlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpe1xuICAgICAgICBmb3IodmFyIHRoYXQgPSB0aGlzLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgICAsIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYoZW50cnkpe1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkublxuICAgICAgICAgICAgLCBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmKHRoYXQuX2YgPT0gZW50cnkpdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYodGhhdC5fbCA9PSBlbnRyeSl0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgJ2ZvckVhY2gnKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKWRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdC5fZil0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHRoaXMuX3QgPSBpdGVyYXRlZDsgIC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAsIGtpbmQgID0gdGhhdC5fa1xuICAgICAgICAsIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIGZyb20gICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZ2V0V2VhayAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2Vha1xuICAsIGFuT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpXG4gICwgJGhhcyAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIGFycmF5RmluZCAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgLCBhcnJheUZpbmRJbmRleCAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpXG4gICwgaWQgICAgICAgICAgICAgICAgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24odGhhdCl7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uKHN0b3JlLCBrZXkpe1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSlyZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSllbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZih+aW5kZXgpdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYoZGF0YSA9PT0gdHJ1ZSl1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZsb29yICAgID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KXtcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgUDtcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BOICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGlzRW51bSAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc0VudHJpZXMpe1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoaXQpXG4gICAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBbXVxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKXtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBSZWZsZWN0ICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpe1xuICB2YXIga2V5cyAgICAgICA9IGdPUE4uZihhbk9iamVjdChpdCkpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VGbG9hdFxuICAsICR0cmltICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDEgLyAkcGFyc2VGbG9hdChyZXF1aXJlKCcuL19zdHJpbmctd3MnKSArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cil7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMylcbiAgICAsIHJlc3VsdCA9ICRwYXJzZUZsb2F0KHN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludFxuICAsICR0cmltICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIHdzICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgaGV4ICAgICAgID0gL15bXFwtK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCl7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpe1xuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHJlcGVhdCAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nLCBsZWZ0KXtcbiAgdmFyIFMgICAgICAgICAgICA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICwgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGhcbiAgICAsIGZpbGxTdHIgICAgICA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKVxuICAgICwgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgaWYoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKXJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aFxuICAgICwgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICBpZihzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbilzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ01hcCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCByZWRlZmluZSAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgbWV0YSAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgYXNzaWduICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpXG4gICwgd2VhayAgICAgICAgID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGdldFdlYWsgICAgICA9IG1ldGEuZ2V0V2Vha1xuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGVcbiAgLCB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlXG4gICwgdG1wICAgICAgICAgID0ge31cbiAgLCBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpe1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgaWYoaXNPYmplY3Qoa2V5KSl7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmKGRhdGEgPT09IHRydWUpcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhpcykuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHRoaXMsIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1dlYWtNYXAnLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYobmV3ICRXZWFrTWFwKCkuc2V0KChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkodG1wKSwgNykuZ2V0KHRtcCkgIT0gNyl7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgcHJvdG8gID0gJFdlYWtNYXAucHJvdG90eXBlXG4gICAgICAsIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpe1xuICAgICAgICBpZighdGhpcy5fZil0aGlzLl9mID0gbmV3IEludGVybmFsTWFwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhlIEJvdW5kaW5nIEJveCBvYmplY3RcblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBkZXJpdmUodjAsIHYxLCB2MiwgdjMsIHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMSAtIHQsIDMpICogdjAgK1xuICAgICAgICAzICogTWF0aC5wb3coMSAtIHQsIDIpICogdCAqIHYxICtcbiAgICAgICAgMyAqICgxIC0gdCkgKiBNYXRoLnBvdyh0LCAyKSAqIHYyICtcbiAgICAgICAgTWF0aC5wb3codCwgMykgKiB2Mztcbn1cbi8qKlxuICogQSBib3VuZGluZyBib3ggaXMgYW4gZW5jbG9zaW5nIGJveCB0aGF0IGRlc2NyaWJlcyB0aGUgc21hbGxlc3QgbWVhc3VyZSB3aXRoaW4gd2hpY2ggYWxsIHRoZSBwb2ludHMgbGllLlxuICogSXQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiBhIGdseXBoIG9yIHRleHQgcGF0aC5cbiAqXG4gKiBPbiBpbml0aWFsaXphdGlvbiwgeDEveTEveDIveTIgd2lsbCBiZSBOYU4uIENoZWNrIGlmIHRoZSBib3VuZGluZyBib3ggaXMgZW1wdHkgdXNpbmcgYGlzRW1wdHkoKWAuXG4gKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQm91bmRpbmdCb3hcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJvdW5kaW5nQm94KCkge1xuICAgIHRoaXMueDEgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMueTEgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMueDIgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMueTIgPSBOdW1iZXIuTmFOO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYm91bmRpbmcgYm94IGlzIGVtcHR5LCB0aGF0IGlzLCBubyBwb2ludHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBib3ggeWV0LlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLngyKSB8fCBpc05hTih0aGlzLnkyKTtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBwb2ludCB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhlIHgxL3kxL3gyL3kyIGNvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGluZyBib3ggd2lsbCBub3cgZW5jb21wYXNzIHRoZSBnaXZlbiBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy54MikpIHtcbiAgICAgICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICAgICAgdGhpcy54MiA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPCB0aGlzLngxKSB7XG4gICAgICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA+IHRoaXMueDIpIHtcbiAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMueTEpIHx8IGlzTmFOKHRoaXMueTIpKSB7XG4gICAgICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgICAgIHRoaXMueTIgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5IDwgdGhpcy55MSkge1xuICAgICAgICAgICAgdGhpcy55MSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPiB0aGlzLnkyKSB7XG4gICAgICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgWCBjb29yZGluYXRlIHRvIHRoZSBib3VuZGluZyBib3guXG4gKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBYIGNvb3JkaW5hdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW50ZXJuYWxseSBpbnNpZGUgb2YgYWRkQmV6aWVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFggPSBmdW5jdGlvbih4KSB7XG4gICAgdGhpcy5hZGRQb2ludCh4LCBudWxsKTtcbn07XG5cbi8qKlxuICogQWRkIGEgWSBjb29yZGluYXRlIHRvIHRoZSBib3VuZGluZyBib3guXG4gKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBZIGNvb3JkaW5hdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW50ZXJuYWxseSBpbnNpZGUgb2YgYWRkQmV6aWVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFkgPSBmdW5jdGlvbih5KSB7XG4gICAgdGhpcy5hZGRQb2ludChudWxsLCB5KTtcbn07XG5cbi8qKlxuICogQWRkIGEgQsOpemllciBjdXJ2ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgZW50aXJlIELDqXppZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geDAgLSBUaGUgc3RhcnRpbmcgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkwIC0gVGhlIHN0YXJ0aW5nIFkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHgyIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGVuZGluZyBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBlbmRpbmcgWSBjb29yZGluYXRlLlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkQmV6aWVyID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIC8vIFRoaXMgY29kZSBpcyBiYXNlZCBvbiBodHRwOi8vbmlzaGlvaGlyb2thenUuYmxvZ3Nwb3QuY29tLzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcbiAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2ljb25zOC9zdmctcGF0aC1ib3VuZGluZy1ib3hcblxuICAgIHZhciBwMCA9IFt4MCwgeTBdO1xuICAgIHZhciBwMSA9IFt4MSwgeTFdO1xuICAgIHZhciBwMiA9IFt4MiwgeTJdO1xuICAgIHZhciBwMyA9IFt4LCB5XTtcblxuICAgIHRoaXMuYWRkUG9pbnQoeDAsIHkwKTtcbiAgICB0aGlzLmFkZFBvaW50KHgsIHkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBiID0gNiAqIHAwW2ldIC0gMTIgKiBwMVtpXSArIDYgKiBwMltpXTtcbiAgICAgICAgdmFyIGEgPSAtMyAqIHAwW2ldICsgOSAqIHAxW2ldIC0gOSAqIHAyW2ldICsgMyAqIHAzW2ldO1xuICAgICAgICB2YXIgYyA9IDMgKiBwMVtpXSAtIDMgKiBwMFtpXTtcblxuICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGIgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHQgPSAtYyAvIGI7XG4gICAgICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgdGhpcy5hZGRYKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCkpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB0aGlzLmFkZFkoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiMmFjID0gTWF0aC5wb3coYiwgMikgLSA0ICogYyAqIGE7XG4gICAgICAgIGlmIChiMmFjIDwgMCkgY29udGludWU7XG4gICAgICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHRoaXMuYWRkWChkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQxKSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkgdGhpcy5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDEpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB0aGlzLmFkZFgoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0MikpO1xuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHRoaXMuYWRkWShkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQyKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIHF1YWRyYXRpYyBjdXJ2ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgZW50aXJlIHF1YWRyYXRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MCAtIFRoZSBzdGFydGluZyBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geTAgLSBUaGUgc3RhcnRpbmcgWSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHgxIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBlbmRpbmcgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgZW5kaW5nIFkgY29vcmRpbmF0ZS5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFF1YWQgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeCwgeSkge1xuICAgIHZhciBjcDF4ID0geDAgKyAyIC8gMyAqICh4MSAtIHgwKTtcbiAgICB2YXIgY3AxeSA9IHkwICsgMiAvIDMgKiAoeTEgLSB5MCk7XG4gICAgdmFyIGNwMnggPSBjcDF4ICsgMSAvIDMgKiAoeCAtIHgwKTtcbiAgICB2YXIgY3AyeSA9IGNwMXkgKyAxIC8gMyAqICh5IC0geTApO1xuICAgIHRoaXMuYWRkQmV6aWVyKHgwLCB5MCwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG59O1xuXG5leHBvcnRzLkJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL2Jib3guanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgR2x5cGggb2JqZWN0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpO1xudmFyIGRyYXcgPSByZXF1aXJlKCcuL2RyYXcnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi9wYXRoJyk7XG5cbmZ1bmN0aW9uIGdldFBhdGhEZWZpbml0aW9uKGdseXBoLCBwYXRoKSB7XG4gICAgdmFyIF9wYXRoID0gcGF0aCB8fCB7IGNvbW1hbmRzOiBbXSB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfcGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIF9wYXRoID0gX3BhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgX3BhdGggPSBwO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYgR2x5cGhPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgZ2x5cGggbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt1bmljb2RlXVxuICogQHByb3BlcnR5IHtBcnJheX0gW3VuaWNvZGVzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthZHZhbmNlV2lkdGhdXG4gKi9cblxuLy8gQSBHbHlwaCBpcyBhbiBpbmRpdmlkdWFsIG1hcmsgdGhhdCBvZnRlbiBjb3JyZXNwb25kcyB0byBhIGNoYXJhY3Rlci5cbi8vIFNvbWUgZ2x5cGhzLCBzdWNoIGFzIGxpZ2F0dXJlcywgYXJlIGEgY29tYmluYXRpb24gb2YgbWFueSBjaGFyYWN0ZXJzLlxuLy8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cbi8vXG4vLyBUaGUgYEdseXBoYCBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIGRyYXdpbmcgdGhlIHBhdGggYW5kIGl0cyBwb2ludHMuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7R2x5cGhPcHRpb25zfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEdseXBoKG9wdGlvbnMpIHtcbiAgICAvLyBCeSBwdXR0aW5nIGFsbCB0aGUgY29kZSBvbiBhIHByb3RvdHlwZSBmdW5jdGlvbiAod2hpY2ggaXMgb25seSBkZWNsYXJlZCBvbmNlKVxuICAgIC8vIHdlIHJlZHVjZSB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgbGFyZ2VyIGZvbnRzIGJ5IHNvbWUgMiVcbiAgICB0aGlzLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtHbHlwaE9wdGlvbnN9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5iaW5kQ29uc3RydWN0b3JWYWx1ZXMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcblxuICAgIC8vIFRoZXNlIHRocmVlIHZhbHVlcyBjYW5ubm90IGJlIGRlZmVycmVkIGZvciBtZW1vcnkgb3B0aW1pemF0aW9uOlxuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBudWxsO1xuICAgIHRoaXMudW5pY29kZSA9IG9wdGlvbnMudW5pY29kZSB8fCB1bmRlZmluZWQ7XG4gICAgdGhpcy51bmljb2RlcyA9IG9wdGlvbnMudW5pY29kZXMgfHwgb3B0aW9ucy51bmljb2RlICE9PSB1bmRlZmluZWQgPyBbb3B0aW9ucy51bmljb2RlXSA6IFtdO1xuXG4gICAgLy8gQnV0IGJ5IGJpbmRpbmcgdGhlc2UgdmFsdWVzIG9ubHkgd2hlbiBuZWNlc3NhcnksIHdlIHJlZHVjZSBjYW5cbiAgICAvLyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBieSBhbG1vc3QgMyUgZm9yIGxhcmdlciBmb250cy5cbiAgICBpZiAob3B0aW9ucy54TWluKSB7XG4gICAgICAgIHRoaXMueE1pbiA9IG9wdGlvbnMueE1pbjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy55TWluKSB7XG4gICAgICAgIHRoaXMueU1pbiA9IG9wdGlvbnMueU1pbjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy54TWF4KSB7XG4gICAgICAgIHRoaXMueE1heCA9IG9wdGlvbnMueE1heDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy55TWF4KSB7XG4gICAgICAgIHRoaXMueU1heCA9IG9wdGlvbnMueU1heDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlV2lkdGggPSBvcHRpb25zLmFkdmFuY2VXaWR0aDtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGF0aCBmb3IgYSBnbHlwaCBpcyB0aGUgbW9zdCBtZW1vcnkgaW50ZW5zaXZlLCBhbmQgaXMgYm91bmQgYXMgYSB2YWx1ZVxuICAgIC8vIHdpdGggYSBnZXR0ZXIvc2V0dGVyIHRvIGVuc3VyZSB3ZSBhY3R1YWxseSBkbyBwYXRoIHBhcnNpbmcgb25seSBvbmNlIHRoZVxuICAgIC8vIHBhdGggaXMgYWN0dWFsbHkgbmVlZGVkIGJ5IGFueXRoaW5nLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGF0aCcsIGdldFBhdGhEZWZpbml0aW9uKHRoaXMsIG9wdGlvbnMucGF0aCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmFkZFVuaWNvZGUgPSBmdW5jdGlvbih1bmljb2RlKSB7XG4gICAgaWYgKHRoaXMudW5pY29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMudW5pY29kZSA9IHVuaWNvZGU7XG4gICAgfVxuXG4gICAgdGhpcy51bmljb2Rlcy5wdXNoKHVuaWNvZGUpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYm91bmRpbmcgYm94IGZvciB0aGlzIGdseXBoLlxuICogQHJldHVybiB7b3BlbnR5cGUuQm91bmRpbmdCb3h9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGguZ2V0Qm91bmRpbmdCb3goKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2x5cGggdG8gYSBQYXRoIHdlIGNhbiBkcmF3IG9uIGEgZHJhd2luZyBjb250ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zIC0geFNjYWxlLCB5U2NhbGUgdG8gc3RyZWNoIHRoZSBnbHlwaC5cbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGh9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge3hTY2FsZTogMS4wLCB5U2NhbGU6IDEuMH07XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiA3MjtcbiAgICB2YXIgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICB2YXIgeFNjYWxlID0gb3B0aW9ucy54U2NhbGUgKiBzY2FsZTtcbiAgICB2YXIgeVNjYWxlID0gb3B0aW9ucy55U2NhbGUgKiBzY2FsZTtcblxuICAgIHZhciBwID0gbmV3IHBhdGguUGF0aCgpO1xuICAgIHZhciBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIHAubGluZVRvKHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyh4ICsgKGNtZC54MSAqIHhTY2FsZSksIHkgKyAoLWNtZC55MSAqIHlTY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgcC5jdXJ2ZVRvKHggKyAoY21kLngxICogeFNjYWxlKSwgeSArICgtY21kLnkxICogeVNjYWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54MiAqIHhTY2FsZSksIHkgKyAoLWNtZC55MiAqIHlTY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgZ2x5cGggaW50byBjb250b3Vycy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB0b1xuICogcHJvdmlkZSByYXcgYWNjZXNzIHRvIHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lcy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0Q29udG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wb2ludHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbnRvdXJzID0gW107XG4gICAgdmFyIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrLmFyZ3VtZW50KGN1cnJlbnRDb250b3VyLmxlbmd0aCA9PT0gMCwgJ1RoZXJlIGFyZSBzdGlsbCBwb2ludHMgbGVmdCBpbiB0aGUgY3VycmVudCBjb250b3VyLicpO1xuICAgIHJldHVybiBjb250b3Vycztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB4TWluL3lNaW4veE1heC95TWF4L2xzYi9yc2IgZm9yIGEgR2x5cGguXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgIHZhciB4Q29vcmRzID0gW107XG4gICAgdmFyIHlDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlICE9PSAnWicpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueCk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScgfHwgY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54MSk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngyKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1ldHJpY3MgPSB7XG4gICAgICAgIHhNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeENvb3JkcyksXG4gICAgICAgIHlNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlDb29yZHMpLFxuICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IHRoaXMubGVmdFNpZGVCZWFyaW5nXG4gICAgfTtcblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWluKSkge1xuICAgICAgICBtZXRyaWNzLnhNaW4gPSAwO1xuICAgIH1cblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWF4KSkge1xuICAgICAgICBtZXRyaWNzLnhNYXggPSB0aGlzLmFkdmFuY2VXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1pbikpIHtcbiAgICAgICAgbWV0cmljcy55TWluID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1heCkpIHtcbiAgICAgICAgbWV0cmljcy55TWF4ID0gMDtcbiAgICB9XG5cbiAgICBtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcgPSB0aGlzLmFkdmFuY2VXaWR0aCAtIG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nIC0gKG1ldHJpY3MueE1heCAtIG1ldHJpY3MueE1pbik7XG4gICAgcmV0dXJuIG1ldHJpY3M7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIGdseXBoIG9uIHRoZSBnaXZlbiBjb250ZXh0LlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJlY2ggdGhlIGdseXBoLlxuICovXG5HbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmdldFBhdGgoeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpLmRyYXcoY3R4KTtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgcG9pbnRzIG9mIHRoZSBnbHlwaC5cbiAqIE9uLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIGJsdWUsIG9mZi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiByZWQuXG4gKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICovXG5HbHlwaC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcblxuICAgIGZ1bmN0aW9uIGRyYXdDaXJjbGVzKGwsIHgsIHksIHNjYWxlKSB7XG4gICAgICAgIHZhciBQSV9TUSA9IE1hdGguUEkgKiAyO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSksIDIsIDAsIFBJX1NRLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuXG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDI0O1xuICAgIHZhciBzY2FsZSA9IDEgLyB0aGlzLnBhdGgudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgdmFyIGJsdWVDaXJjbGVzID0gW107XG4gICAgdmFyIHJlZENpcmNsZXMgPSBbXTtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGguY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibHVlQ2lyY2xlcy5wdXNoKHt4OiBjbWQueCwgeTogLWNtZC55fSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLngxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngxLCB5OiAtY21kLnkxfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLngyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngyLCB5OiAtY21kLnkyfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgIGRyYXdDaXJjbGVzKGJsdWVDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGRyYXdDaXJjbGVzKHJlZENpcmNsZXMsIHgsIHksIHNjYWxlKTtcbn07XG5cbi8qKlxuICogRHJhdyBsaW5lcyBpbmRpY2F0aW5nIGltcG9ydGFudCBmb250IG1lYXN1cmVtZW50cy5cbiAqIEJsYWNrIGxpbmVzIGluZGljYXRlIHRoZSBvcmlnaW4gb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIChwb2ludCAwLDApLlxuICogQmx1ZSBsaW5lcyBpbmRpY2F0ZSB0aGUgZ2x5cGggYm91bmRpbmcgYm94LlxuICogR3JlZW4gbGluZSBpbmRpY2F0ZXMgdGhlIGFkdmFuY2Ugd2lkdGggb2YgdGhlIGdseXBoLlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqL1xuR2x5cGgucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSkge1xuICAgIHZhciBzY2FsZTtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG4gICAgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgIC8vIERyYXcgdGhlIG9yaWdpblxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCwgLTEwMDAwLCB4LCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5LCAxMDAwMCwgeSk7XG5cbiAgICAvLyBUaGlzIGNvZGUgaXMgaGVyZSBkdWUgdG8gbWVtb3J5IG9wdGltaXphdGlvbjogYnkgbm90IHVzaW5nXG4gICAgLy8gZGVmYXVsdHMgaW4gdGhlIGNvbnN0cnVjdG9yLCB3ZSBzYXZlIGEgbm90YWJsZSBhbW91bnQgb2YgbWVtb3J5LlxuICAgIHZhciB4TWluID0gdGhpcy54TWluIHx8IDA7XG4gICAgdmFyIHlNaW4gPSB0aGlzLnlNaW4gfHwgMDtcbiAgICB2YXIgeE1heCA9IHRoaXMueE1heCB8fCAwO1xuICAgIHZhciB5TWF4ID0gdGhpcy55TWF4IHx8IDA7XG4gICAgdmFyIGFkdmFuY2VXaWR0aCA9IHRoaXMuYWR2YW5jZVdpZHRoIHx8IDA7XG5cbiAgICAvLyBEcmF3IHRoZSBnbHlwaCBib3hcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh4TWluICogc2NhbGUpLCAtMTAwMDAsIHggKyAoeE1pbiAqIHNjYWxlKSwgMTAwMDApO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAoeE1heCAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKHhNYXggKiBzY2FsZSksIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXlNaW4gKiBzY2FsZSksIDEwMDAwLCB5ICsgKC15TWluICogc2NhbGUpKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXlNYXggKiBzY2FsZSksIDEwMDAwLCB5ICsgKC15TWF4ICogc2NhbGUpKTtcblxuICAgIC8vIERyYXcgdGhlIGFkdmFuY2Ugd2lkdGhcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAoYWR2YW5jZVdpZHRoICogc2NhbGUpLCAtMTAwMDAsIHggKyAoYWR2YW5jZVdpZHRoICogc2NhbGUpLCAxMDAwMCk7XG59O1xuXG5leHBvcnRzLkdseXBoID0gR2x5cGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL2dseXBoLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gb3BlbnR5cGUuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlYm94L29wZW50eXBlLmpzXG4vLyAoYykgMjAxNSBGcmVkZXJpayBEZSBCbGVzZXJcbi8vIG9wZW50eXBlLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4vKiBnbG9iYWwgRGF0YVZpZXcsIFVpbnQ4QXJyYXksIFhNTEh0dHBSZXF1ZXN0ICAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmZsYXRlID0gcmVxdWlyZSgndGlueS1pbmZsYXRlJyk7XG5cbnZhciBlbmNvZGluZyA9IHJlcXVpcmUoJy4vZW5jb2RpbmcnKTtcbnZhciBfZm9udCA9IHJlcXVpcmUoJy4vZm9udCcpO1xudmFyIGdseXBoID0gcmVxdWlyZSgnLi9nbHlwaCcpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIGJib3ggPSByZXF1aXJlKCcuL2Jib3gnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi9wYXRoJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgY21hcCA9IHJlcXVpcmUoJy4vdGFibGVzL2NtYXAnKTtcbnZhciBjZmYgPSByZXF1aXJlKCcuL3RhYmxlcy9jZmYnKTtcbnZhciBmdmFyID0gcmVxdWlyZSgnLi90YWJsZXMvZnZhcicpO1xudmFyIGdseWYgPSByZXF1aXJlKCcuL3RhYmxlcy9nbHlmJyk7XG52YXIgZ3BvcyA9IHJlcXVpcmUoJy4vdGFibGVzL2dwb3MnKTtcbnZhciBnc3ViID0gcmVxdWlyZSgnLi90YWJsZXMvZ3N1YicpO1xudmFyIGhlYWQgPSByZXF1aXJlKCcuL3RhYmxlcy9oZWFkJyk7XG52YXIgaGhlYSA9IHJlcXVpcmUoJy4vdGFibGVzL2hoZWEnKTtcbnZhciBobXR4ID0gcmVxdWlyZSgnLi90YWJsZXMvaG10eCcpO1xudmFyIGtlcm4gPSByZXF1aXJlKCcuL3RhYmxlcy9rZXJuJyk7XG52YXIgbHRhZyA9IHJlcXVpcmUoJy4vdGFibGVzL2x0YWcnKTtcbnZhciBsb2NhID0gcmVxdWlyZSgnLi90YWJsZXMvbG9jYScpO1xudmFyIG1heHAgPSByZXF1aXJlKCcuL3RhYmxlcy9tYXhwJyk7XG52YXIgX25hbWUgPSByZXF1aXJlKCcuL3RhYmxlcy9uYW1lJyk7XG52YXIgb3MyID0gcmVxdWlyZSgnLi90YWJsZXMvb3MyJyk7XG52YXIgcG9zdCA9IHJlcXVpcmUoJy4vdGFibGVzL3Bvc3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi90YWJsZXMvbWV0YScpO1xuXG4vKipcbiAqIFRoZSBvcGVudHlwZSBsaWJyYXJ5LlxuICogQG5hbWVzcGFjZSBvcGVudHlwZVxuICovXG5cbi8vIEZpbGUgbG9hZGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogTG9hZHMgYSBmb250IGZyb20gYSBmaWxlLiBUaGUgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yIG1lc3NhZ2UgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciBpZiBpdCBmYWlsc1xuICogYW5kIHRoZSBmb250IGFzIGFuIEFycmF5QnVmZmVyIGluIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlmIGl0IHN1Y2NlZWRzLlxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZvbnQgbG9hZCBjb21wbGV0ZXNcbiAqL1xuZnVuY3Rpb24gbG9hZEZyb21GaWxlKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICBmcy5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbihlcnIsIGJ1ZmZlcikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdXRpbC5ub2RlQnVmZmVyVG9BcnJheUJ1ZmZlcihidWZmZXIpKTtcbiAgICB9KTtcbn1cbi8qKlxuICogTG9hZHMgYSBmb250IGZyb20gYSBVUkwuIFRoZSBjYWxsYmFjayB0aHJvd3MgYW4gZXJyb3IgbWVzc2FnZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGlmIGl0IGZhaWxzXG4gKiBhbmQgdGhlIGZvbnQgYXMgYW4gQXJyYXlCdWZmZXIgaW4gdGhlIHNlY29uZCBwYXJhbWV0ZXIgaWYgaXQgc3VjY2VlZHMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIGZvbnQgZmlsZS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZvbnQgbG9hZCBjb21wbGV0ZXNcbiAqL1xuZnVuY3Rpb24gbG9hZEZyb21VcmwodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICcgKyByZXF1ZXN0LnN0YXR1c1RleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2UpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0LnNlbmQoKTtcbn1cblxuLy8gVGFibGUgRGlyZWN0b3J5IEVudHJpZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBQYXJzZXMgT3BlblR5cGUgdGFibGUgZW50cmllcy5cbiAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICogQHBhcmFtICB7TnVtYmVyfVxuICogQHJldHVybiB7T2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKSB7XG4gICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgIHZhciBwID0gMTI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdGFnID0gcGFyc2UuZ2V0VGFnKGRhdGEsIHApO1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgNCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgMTIpO1xuICAgICAgICB0YWJsZUVudHJpZXMucHVzaCh7dGFnOiB0YWcsIGNoZWNrc3VtOiBjaGVja3N1bSwgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogbGVuZ3RoLCBjb21wcmVzc2lvbjogZmFsc2V9KTtcbiAgICAgICAgcCArPSAxNjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGVFbnRyaWVzO1xufVxuXG4vKipcbiAqIFBhcnNlcyBXT0ZGIHRhYmxlIGVudHJpZXMuXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge051bWJlcn1cbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICovXG5mdW5jdGlvbiBwYXJzZVdPRkZUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKSB7XG4gICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgIHZhciBwID0gNDQ7IC8vIG9mZnNldCB0byB0aGUgZmlyc3QgdGFibGUgZGlyZWN0b3J5IGVudHJ5LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFibGVzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA0KTtcbiAgICAgICAgdmFyIGNvbXBMZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG4gICAgICAgIHZhciBvcmlnTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDEyKTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uO1xuICAgICAgICBpZiAoY29tcExlbmd0aCA8IG9yaWdMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gJ1dPRkYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlRW50cmllcy5wdXNoKHt0YWc6IHRhZywgb2Zmc2V0OiBvZmZzZXQsIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvbixcbiAgICAgICAgICAgIGNvbXByZXNzZWRMZW5ndGg6IGNvbXBMZW5ndGgsIG9yaWdpbmFsTGVuZ3RoOiBvcmlnTGVuZ3RofSk7XG4gICAgICAgIHAgKz0gMjA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlRW50cmllcztcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBUYWJsZURhdGFcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtEYXRhVmlld30gZGF0YSAtIFRoZSBEYXRhVmlld1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCAtIFRoZSBkYXRhIG9mZnNldC5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICogQHBhcmFtICB7T2JqZWN0fVxuICogQHJldHVybiB7VGFibGVEYXRhfVxuICovXG5mdW5jdGlvbiB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSkge1xuICAgIGlmICh0YWJsZUVudHJ5LmNvbXByZXNzaW9uID09PSAnV09GRicpIHtcbiAgICAgICAgdmFyIGluQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIHRhYmxlRW50cnkub2Zmc2V0ICsgMiwgdGFibGVFbnRyeS5jb21wcmVzc2VkTGVuZ3RoIC0gMik7XG4gICAgICAgIHZhciBvdXRCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0YWJsZUVudHJ5Lm9yaWdpbmFsTGVuZ3RoKTtcbiAgICAgICAgaW5mbGF0ZShpbkJ1ZmZlciwgb3V0QnVmZmVyKTtcbiAgICAgICAgaWYgKG91dEJ1ZmZlci5ieXRlTGVuZ3RoICE9PSB0YWJsZUVudHJ5Lm9yaWdpbmFsTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29tcHJlc3Npb24gZXJyb3I6ICcgKyB0YWJsZUVudHJ5LnRhZyArICcgZGVjb21wcmVzc2VkIGxlbmd0aCBkb2VzblxcJ3QgbWF0Y2ggcmVjb3JkZWQgbGVuZ3RoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyLCAwKTtcbiAgICAgICAgcmV0dXJuIHtkYXRhOiB2aWV3LCBvZmZzZXQ6IDB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7ZGF0YTogZGF0YSwgb2Zmc2V0OiB0YWJsZUVudHJ5Lm9mZnNldH07XG4gICAgfVxufVxuXG4vLyBQdWJsaWMgQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUGFyc2UgdGhlIE9wZW5UeXBlIGZpbGUgZGF0YSAoYXMgYW4gQXJyYXlCdWZmZXIpIGFuZCByZXR1cm4gYSBGb250IG9iamVjdC5cbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgZm9udCBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBwYXJzZUJ1ZmZlcihidWZmZXIpIHtcbiAgICB2YXIgaW5kZXhUb0xvY0Zvcm1hdDtcbiAgICB2YXIgbHRhZ1RhYmxlO1xuXG4gICAgLy8gU2luY2UgdGhlIGNvbnN0cnVjdG9yIGNhbiBhbHNvIGJlIGNhbGxlZCB0byBjcmVhdGUgbmV3IGZvbnRzIGZyb20gc2NyYXRjaCwgd2UgaW5kaWNhdGUgdGhpc1xuICAgIC8vIHNob3VsZCBiZSBhbiBlbXB0eSBmb250IHRoYXQgd2UnbGwgZmlsbCB3aXRoIG91ciBvd24gZGF0YS5cbiAgICB2YXIgZm9udCA9IG5ldyBfZm9udC5Gb250KHtlbXB0eTogdHJ1ZX0pO1xuXG4gICAgLy8gT3BlblR5cGUgZm9udHMgdXNlIGJpZyBlbmRpYW4gYnl0ZSBvcmRlcmluZy5cbiAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHR5cGVkIGFycmF5IHZpZXcgdHlwZXMsIGJlY2F1c2UgdGhleSBvcGVyYXRlIHdpdGggdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGhvc3QgY29tcHV0ZXIuXG4gICAgLy8gSW5zdGVhZCB3ZSB1c2UgRGF0YVZpZXdzIHdoZXJlIHdlIGNhbiBzcGVjaWZ5IGVuZGlhbm5lc3MuXG4gICAgdmFyIGRhdGEgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLCAwKTtcbiAgICB2YXIgbnVtVGFibGVzO1xuICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICB2YXIgc2lnbmF0dXJlID0gcGFyc2UuZ2V0VGFnKGRhdGEsIDApO1xuICAgIGlmIChzaWduYXR1cmUgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkpIHtcbiAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICd0cnVldHlwZSc7XG4gICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCA0KTtcbiAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSAnT1RUTycpIHtcbiAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICdjZmYnO1xuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gJ3dPRkYnKSB7XG4gICAgICAgIHZhciBmbGF2b3IgPSBwYXJzZS5nZXRUYWcoZGF0YSwgNCk7XG4gICAgICAgIGlmIChmbGF2b3IgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkpIHtcbiAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgICAgICB9IGVsc2UgaWYgKGZsYXZvciA9PT0gJ09UVE8nKSB7XG4gICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ2NmZic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIGZsYXZvciAnICsgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCAxMik7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgc2lnbmF0dXJlICcgKyBzaWduYXR1cmUpO1xuICAgIH1cblxuICAgIHZhciBjZmZUYWJsZUVudHJ5O1xuICAgIHZhciBmdmFyVGFibGVFbnRyeTtcbiAgICB2YXIgZ2x5ZlRhYmxlRW50cnk7XG4gICAgdmFyIGdwb3NUYWJsZUVudHJ5O1xuICAgIHZhciBnc3ViVGFibGVFbnRyeTtcbiAgICB2YXIgaG10eFRhYmxlRW50cnk7XG4gICAgdmFyIGtlcm5UYWJsZUVudHJ5O1xuICAgIHZhciBsb2NhVGFibGVFbnRyeTtcbiAgICB2YXIgbmFtZVRhYmxlRW50cnk7XG4gICAgdmFyIG1ldGFUYWJsZUVudHJ5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdGFibGVFbnRyeSA9IHRhYmxlRW50cmllc1tpXTtcbiAgICAgICAgdmFyIHRhYmxlO1xuICAgICAgICBzd2l0Y2ggKHRhYmxlRW50cnkudGFnKSB7XG4gICAgICAgICAgICBjYXNlICdjbWFwJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5jbWFwID0gY21hcC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQuZW5jb2RpbmcgPSBuZXcgZW5jb2RpbmcuQ21hcEVuY29kaW5nKGZvbnQudGFibGVzLmNtYXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnZhcic6XG4gICAgICAgICAgICAgICAgZnZhclRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuaGVhZCA9IGhlYWQucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnVuaXRzUGVyRW0gPSBmb250LnRhYmxlcy5oZWFkLnVuaXRzUGVyRW07XG4gICAgICAgICAgICAgICAgaW5kZXhUb0xvY0Zvcm1hdCA9IGZvbnQudGFibGVzLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hoZWEnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmhoZWEgPSBoaGVhLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5hc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuYXNjZW5kZXI7XG4gICAgICAgICAgICAgICAgZm9udC5kZXNjZW5kZXIgPSBmb250LnRhYmxlcy5oaGVhLmRlc2NlbmRlcjtcbiAgICAgICAgICAgICAgICBmb250Lm51bWJlck9mSE1ldHJpY3MgPSBmb250LnRhYmxlcy5oaGVhLm51bWJlck9mSE1ldHJpY3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdobXR4JzpcbiAgICAgICAgICAgICAgICBobXR4VGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsdGFnJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBsdGFnVGFibGUgPSBsdGFnLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtYXhwJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5tYXhwID0gbWF4cC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQubnVtR2x5cGhzID0gZm9udC50YWJsZXMubWF4cC5udW1HbHlwaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICBuYW1lVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdPUy8yJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5vczIgPSBvczIucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Bvc3QnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLnBvc3QgPSBwb3N0LnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5nbHlwaE5hbWVzID0gbmV3IGVuY29kaW5nLkdseXBoTmFtZXMoZm9udC50YWJsZXMucG9zdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnbHlmJzpcbiAgICAgICAgICAgICAgICBnbHlmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsb2NhJzpcbiAgICAgICAgICAgICAgICBsb2NhVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDRkYgJzpcbiAgICAgICAgICAgICAgICBjZmZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tlcm4nOlxuICAgICAgICAgICAgICAgIGtlcm5UYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dQT1MnOlxuICAgICAgICAgICAgICAgIGdwb3NUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dTVUInOlxuICAgICAgICAgICAgICAgIGdzdWJUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICAgICAgICAgIG1ldGFUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuYW1lVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbmFtZVRhYmxlRW50cnkpO1xuICAgIGZvbnQudGFibGVzLm5hbWUgPSBfbmFtZS5wYXJzZShuYW1lVGFibGUuZGF0YSwgbmFtZVRhYmxlLm9mZnNldCwgbHRhZ1RhYmxlKTtcbiAgICBmb250Lm5hbWVzID0gZm9udC50YWJsZXMubmFtZTtcblxuICAgIGlmIChnbHlmVGFibGVFbnRyeSAmJiBsb2NhVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgc2hvcnRWZXJzaW9uID0gaW5kZXhUb0xvY0Zvcm1hdCA9PT0gMDtcbiAgICAgICAgdmFyIGxvY2FUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBsb2NhVGFibGVFbnRyeSk7XG4gICAgICAgIHZhciBsb2NhT2Zmc2V0cyA9IGxvY2EucGFyc2UobG9jYVRhYmxlLmRhdGEsIGxvY2FUYWJsZS5vZmZzZXQsIGZvbnQubnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pO1xuICAgICAgICB2YXIgZ2x5ZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdseWZUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC5nbHlwaHMgPSBnbHlmLnBhcnNlKGdseWZUYWJsZS5kYXRhLCBnbHlmVGFibGUub2Zmc2V0LCBsb2NhT2Zmc2V0cywgZm9udCk7XG4gICAgfSBlbHNlIGlmIChjZmZUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBjZmZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBjZmZUYWJsZUVudHJ5KTtcbiAgICAgICAgY2ZmLnBhcnNlKGNmZlRhYmxlLmRhdGEsIGNmZlRhYmxlLm9mZnNldCwgZm9udCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb250IGRvZXNuXFwndCBjb250YWluIFRydWVUeXBlIG9yIENGRiBvdXRsaW5lcy4nKTtcbiAgICB9XG5cbiAgICB2YXIgaG10eFRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGhtdHhUYWJsZUVudHJ5KTtcbiAgICBobXR4LnBhcnNlKGhtdHhUYWJsZS5kYXRhLCBobXR4VGFibGUub2Zmc2V0LCBmb250Lm51bWJlck9mSE1ldHJpY3MsIGZvbnQubnVtR2x5cGhzLCBmb250LmdseXBocyk7XG4gICAgZW5jb2RpbmcuYWRkR2x5cGhOYW1lcyhmb250KTtcblxuICAgIGlmIChrZXJuVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIga2VyblRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGtlcm5UYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSBrZXJuLnBhcnNlKGtlcm5UYWJsZS5kYXRhLCBrZXJuVGFibGUub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChncG9zVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZ3Bvc1RhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdwb3NUYWJsZUVudHJ5KTtcbiAgICAgICAgZ3Bvcy5wYXJzZShncG9zVGFibGUuZGF0YSwgZ3Bvc1RhYmxlLm9mZnNldCwgZm9udCk7XG4gICAgfVxuXG4gICAgaWYgKGdzdWJUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBnc3ViVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ3N1YlRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5nc3ViID0gZ3N1Yi5wYXJzZShnc3ViVGFibGUuZGF0YSwgZ3N1YlRhYmxlLm9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKGZ2YXJUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBmdmFyVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZnZhclRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5mdmFyID0gZnZhci5wYXJzZShmdmFyVGFibGUuZGF0YSwgZnZhclRhYmxlLm9mZnNldCwgZm9udC5uYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGFUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBtZXRhVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbWV0YVRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5tZXRhID0gbWV0YS5wYXJzZShtZXRhVGFibGUuZGF0YSwgbWV0YVRhYmxlLm9mZnNldCk7XG4gICAgICAgIGZvbnQubWV0YXMgPSBmb250LnRhYmxlcy5tZXRhO1xuICAgIH1cblxuICAgIHJldHVybiBmb250O1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGxvYWQgdGhlIGZvbnQgZnJvbSBhIFVSTCBvciBhIGZpbGVzeXN0ZW0uIFdoZW4gZG9uZSwgY2FsbCB0aGUgY2FsbGJhY2tcbiAqIHdpdGggdHdvIGFyZ3VtZW50cyBgKGVyciwgZm9udClgLiBUaGUgYGVycmAgd2lsbCBiZSBudWxsIG9uIHN1Y2Nlc3MsXG4gKiB0aGUgYGZvbnRgIGlzIGEgRm9udCBvYmplY3QuXG4gKiBXZSB1c2UgdGhlIG5vZGUuanMgY2FsbGJhY2sgY29udmVudGlvbiBzbyB0aGF0XG4gKiBvcGVudHlwZS5qcyBjYW4gaW50ZWdyYXRlIHdpdGggZnJhbWV3b3JrcyBsaWtlIGFzeW5jLmpzLlxuICogQGFsaWFzIG9wZW50eXBlLmxvYWRcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgZm9udCB0byBsb2FkLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBsb2FkKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGxvYWRGbiA9IGlzTm9kZSA/IGxvYWRGcm9tRmlsZSA6IGxvYWRGcm9tVXJsO1xuICAgIGxvYWRGbih1cmwsIGZ1bmN0aW9uKGVyciwgYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb250ID0gcGFyc2VCdWZmZXIoYXJyYXlCdWZmZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZvbnQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZm9udCBmcm9tIGEgVVJMIG9yIGZpbGUuXG4gKiBXaGVuIGRvbmUsIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0IG9yIHRocm93cyBhbiBlcnJvci5cbiAqIEBhbGlhcyBvcGVudHlwZS5sb2FkU3luY1xuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IHRvIGxvYWQuXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBsb2FkU3luYyh1cmwpIHtcbiAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgIHZhciBidWZmZXIgPSBmcy5yZWFkRmlsZVN5bmModXJsKTtcbiAgICByZXR1cm4gcGFyc2VCdWZmZXIodXRpbC5ub2RlQnVmZmVyVG9BcnJheUJ1ZmZlcihidWZmZXIpKTtcbn1cblxuZXhwb3J0cy5fcGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuRm9udCA9IF9mb250LkZvbnQ7XG5leHBvcnRzLkdseXBoID0gZ2x5cGguR2x5cGg7XG5leHBvcnRzLlBhdGggPSBwYXRoLlBhdGg7XG5leHBvcnRzLkJvdW5kaW5nQm94ID0gYmJveC5Cb3VuZGluZ0JveDtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZUJ1ZmZlcjtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhlIGBDRkZgIHRhYmxlIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2ZmLmh0bVxuLy8gaHR0cDovL2Rvd25sb2FkLm1pY3Jvc29mdC5jb20vZG93bmxvYWQvOC8wLzEvODAxYTE5MWMtMDI5ZC00YWYzLTk2NDItNTU1ZjZmZTUxNGVlL2NmZi5wZGZcbi8vIGh0dHA6Ly9kb3dubG9hZC5taWNyb3NvZnQuY29tL2Rvd25sb2FkLzgvMC8xLzgwMWExOTFjLTAyOWQtNGFmMy05NjQyLTU1NWY2ZmU1MTRlZS90eXBlMi5wZGZcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5jb2RpbmcgPSByZXF1aXJlKCcuLi9lbmNvZGluZycpO1xudmFyIGdseXBoc2V0ID0gcmVxdWlyZSgnLi4vZ2x5cGhzZXQnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL3BhdGgnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIEN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gdGhhdCBjYW4gYWxzbyBjaGVjayBsaXN0cy5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgSU5ERVggYXJyYXkuXG4vLyBBbiBpbmRleCBhcnJheSBjb25zaXN0cyBvZiBhIGxpc3Qgb2Ygb2Zmc2V0cywgdGhlbiBhIGxpc3Qgb2Ygb2JqZWN0cyBhdCB0aG9zZSBvZmZzZXRzLlxuZnVuY3Rpb24gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCwgY29udmVyc2lvbkZuKSB7XG4gICAgLy92YXIgaSwgb2JqZWN0T2Zmc2V0LCBlbmRPZmZzZXQ7XG4gICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIHZhciBjb3VudCA9IHBhcnNlLmdldENhcmQxNihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIG9iamVjdE9mZnNldDtcbiAgICB2YXIgZW5kT2Zmc2V0O1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoKGNvdW50ICsgMSkgKiBvZmZzZXRTaXplKSArIDI7XG4gICAgICAgIHZhciBwb3MgPSBzdGFydCArIDM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudCArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlLmdldE9mZnNldChkYXRhLCBwb3MsIG9mZnNldFNpemUpKTtcbiAgICAgICAgICAgIHBvcyArPSBvZmZzZXRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGluZGV4IGFycmF5IGlzIDQgaGVhZGVyIGJ5dGVzICsgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IG9mZnNldC5cbiAgICAgICAgZW5kT2Zmc2V0ID0gb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tjb3VudF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gc3RhcnQgKyAyO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZS5nZXRCeXRlcyhkYXRhLCBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2ldLCBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kgKyAxXSk7XG4gICAgICAgIGlmIChjb252ZXJzaW9uRm4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVyc2lvbkZuKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtvYmplY3RzOiBvYmplY3RzLCBzdGFydE9mZnNldDogc3RhcnQsIGVuZE9mZnNldDogZW5kT2Zmc2V0fTtcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIHJlYWwgdmFsdWUuXG5mdW5jdGlvbiBwYXJzZUZsb2F0T3BlcmFuZChwYXJzZXIpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIHZhciBlb2YgPSAxNTtcbiAgICB2YXIgbG9va3VwID0gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJy4nLCAnRScsICdFLScsIG51bGwsICctJ107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHZhciBuMSA9IGIgPj4gNDtcbiAgICAgICAgdmFyIG4yID0gYiAmIDE1O1xuXG4gICAgICAgIGlmIChuMSA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gbG9va3VwW24xXTtcblxuICAgICAgICBpZiAobjIgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9IGxvb2t1cFtuMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocyk7XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCBvcGVyYW5kLlxuZnVuY3Rpb24gcGFyc2VPcGVyYW5kKHBhcnNlciwgYjApIHtcbiAgICB2YXIgYjE7XG4gICAgdmFyIGIyO1xuICAgIHZhciBiMztcbiAgICB2YXIgYjQ7XG4gICAgaWYgKGIwID09PSAyOCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiBiMSA8PCA4IHwgYjI7XG4gICAgfVxuXG4gICAgaWYgKGIwID09PSAyOSkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIzID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiNCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIGIxIDw8IDI0IHwgYjIgPDwgMTYgfCBiMyA8PCA4IHwgYjQ7XG4gICAgfVxuXG4gICAgaWYgKGIwID09PSAzMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMzIgJiYgYjAgPD0gMjQ2KSB7XG4gICAgICAgIHJldHVybiBiMCAtIDEzOTtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMjQ3ICYmIGIwIDw9IDI1MCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIChiMCAtIDI0NykgKiAyNTYgKyBiMSArIDEwODtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIC0oYjAgLSAyNTEpICogMjU2IC0gYjEgLSAxMDg7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGIwICcgKyBiMCk7XG59XG5cbi8vIENvbnZlcnQgdGhlIGVudHJpZXMgcmV0dXJuZWQgYnkgYHBhcnNlRGljdGAgdG8gYSBwcm9wZXIgZGljdGlvbmFyeS5cbi8vIElmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIG9uZSwgaXQgaXMgdW5wYWNrZWQuXG5mdW5jdGlvbiBlbnRyaWVzVG9PYmplY3QoZW50cmllcykge1xuICAgIHZhciBvID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyaWVzW2ldWzBdO1xuICAgICAgICB2YXIgdmFsdWVzID0gZW50cmllc1tpXVsxXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0ICcgKyBvICsgJyBhbHJlYWR5IGhhcyBrZXkgJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICBzdGFydCA9IHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IDA7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgdmFyIG9wZXJhbmRzID0gW107XG4gICAgc2l6ZSA9IHNpemUgIT09IHVuZGVmaW5lZCA/IHNpemUgOiBkYXRhLmxlbmd0aDtcblxuICAgIHdoaWxlIChwYXJzZXIucmVsYXRpdmVPZmZzZXQgPCBzaXplKSB7XG4gICAgICAgIHZhciBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgYnl0ZSBmb3IgZWFjaCBkaWN0IGl0ZW0gZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIG9wZXJhdG9yIChrZXkpIGFuZCBvcGVyYW5kICh2YWx1ZSkuXG4gICAgICAgIC8vIFZhbHVlcyA8PSAyMSBhcmUgb3BlcmF0b3JzLlxuICAgICAgICBpZiAob3AgPD0gMjEpIHtcbiAgICAgICAgICAgIC8vIFR3by1ieXRlIG9wZXJhdG9ycyBoYXZlIGFuIGluaXRpYWwgZXNjYXBlIGJ5dGUgb2YgMTIuXG4gICAgICAgICAgICBpZiAob3AgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgb3AgPSAxMjAwICsgcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW29wLCBvcGVyYW5kc10pO1xuICAgICAgICAgICAgb3BlcmFuZHMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBvcGVyYW5kcyAodmFsdWVzKSBjb21lIGJlZm9yZSB0aGUgb3BlcmF0b3JzIChrZXlzKSwgd2Ugc3RvcmUgYWxsIG9wZXJhbmRzIGluIGEgbGlzdFxuICAgICAgICAgICAgLy8gdW50aWwgd2UgZW5jb3VudGVyIGFuIG9wZXJhdG9yLlxuICAgICAgICAgICAgb3BlcmFuZHMucHVzaChwYXJzZU9wZXJhbmQocGFyc2VyLCBvcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcbn1cblxuLy8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbi8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuZnVuY3Rpb24gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDw9IDM5MCkge1xuICAgICAgICBpbmRleCA9IGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbi8vIEludGVycHJldCBhIGRpY3Rpb25hcnkgYW5kIHJldHVybiBhIG5ldyBkaWN0aW9uYXJ5IHdpdGggcmVhZGFibGUga2V5cyBhbmQgdmFsdWVzIGZvciBtaXNzaW5nIGVudHJpZXMuXG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGBtZXRhYCB3aGljaCBpcyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIGBvcGVyYW5kYCwgYG5hbWVgIGFuZCBgZGVmYXVsdGAuXG5mdW5jdGlvbiBpbnRlcnByZXREaWN0KGRpY3QsIG1ldGEsIHN0cmluZ3MpIHtcbiAgICB2YXIgbmV3RGljdCA9IHt9O1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhbHNvIHdhbnQgdG8gaW5jbHVkZSBtaXNzaW5nIHZhbHVlcywgd2Ugc3RhcnQgb3V0IGZyb20gdGhlIG1ldGEgbGlzdFxuICAgIC8vIGFuZCBsb29rdXAgdmFsdWVzIGluIHRoZSBkaWN0LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbSA9IG1ldGFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGRpY3RbbS5vcF07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG0udmFsdWUgIT09IHVuZGVmaW5lZCA/IG0udmFsdWUgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdEaWN0O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGhlYWRlci5cbmZ1bmN0aW9uIHBhcnNlQ0ZGSGVhZGVyKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGhlYWRlciA9IHt9O1xuICAgIGhlYWRlci5mb3JtYXRNYWpvciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkZXIuZm9ybWF0TWlub3IgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDEpO1xuICAgIGhlYWRlci5zaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICBoZWFkZXIub2Zmc2V0U2l6ZSA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMyk7XG4gICAgaGVhZGVyLnN0YXJ0T2Zmc2V0ID0gc3RhcnQ7XG4gICAgaGVhZGVyLmVuZE9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICByZXR1cm4gaGVhZGVyO1xufVxuXG52YXIgVE9QX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3ZlcnNpb24nLCBvcDogMCwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnbm90aWNlJywgb3A6IDEsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2NvcHlyaWdodCcsIG9wOiAxMjAwLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdmdWxsTmFtZScsIG9wOiAyLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdmYW1pbHlOYW1lJywgb3A6IDMsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ3dlaWdodCcsIG9wOiA0LCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdpc0ZpeGVkUGl0Y2gnLCBvcDogMTIwMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2l0YWxpY0FuZ2xlJywgb3A6IDEyMDIsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIG9wOiAxMjAzLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IC0xMDB9LFxuICAgIHtuYW1lOiAndW5kZXJsaW5lVGhpY2tuZXNzJywgb3A6IDEyMDQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogNTB9LFxuICAgIHtuYW1lOiAncGFpbnRUeXBlJywgb3A6IDEyMDUsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaGFyc3RyaW5nVHlwZScsIG9wOiAxMjA2LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDJ9LFxuICAgIHtuYW1lOiAnZm9udE1hdHJpeCcsIG9wOiAxMjA3LCB0eXBlOiBbJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJ10sIHZhbHVlOiBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXX0sXG4gICAge25hbWU6ICd1bmlxdWVJZCcsIG9wOiAxMywgdHlwZTogJ251bWJlcid9LFxuICAgIHtuYW1lOiAnZm9udEJCb3gnLCBvcDogNSwgdHlwZTogWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInXSwgdmFsdWU6IFswLCAwLCAwLCAwXX0sXG4gICAge25hbWU6ICdzdHJva2VXaWR0aCcsIG9wOiAxMjA4LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAneHVpZCcsIG9wOiAxNCwgdHlwZTogW10sIHZhbHVlOiBudWxsfSxcbiAgICB7bmFtZTogJ2NoYXJzZXQnLCBvcDogMTUsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdlbmNvZGluZycsIG9wOiAxNiwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJTdHJpbmdzJywgb3A6IDE3LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAncHJpdmF0ZScsIG9wOiAxOCwgdHlwZTogWydudW1iZXInLCAnb2Zmc2V0J10sIHZhbHVlOiBbMCwgMF19XG5dO1xuXG52YXIgUFJJVkFURV9ESUNUX01FVEEgPSBbXG4gICAge25hbWU6ICdzdWJycycsIG9wOiAxOSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2RlZmF1bHRXaWR0aFgnLCBvcDogMjAsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdub21pbmFsV2lkdGhYJywgb3A6IDIxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9XG5dO1xuXG4vLyBQYXJzZSB0aGUgQ0ZGIHRvcCBkaWN0aW9uYXJ5LiBBIENGRiB0YWJsZSBjYW4gY29udGFpbiBtdWx0aXBsZSBmb250cywgZWFjaCB3aXRoIHRoZWlyIG93biB0b3AgZGljdGlvbmFyeS5cbi8vIFRoZSB0b3AgZGljdGlvbmFyeSBjb250YWlucyB0aGUgZXNzZW50aWFsIG1ldGFkYXRhIGZvciB0aGUgZm9udCwgdG9nZXRoZXIgd2l0aCB0aGUgcHJpdmF0ZSBkaWN0aW9uYXJ5LlxuZnVuY3Rpb24gcGFyc2VDRkZUb3BEaWN0KGRhdGEsIHN0cmluZ3MpIHtcbiAgICB2YXIgZGljdCA9IHBhcnNlQ0ZGRGljdChkYXRhLCAwLCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFRPUF9ESUNUX01FVEEsIHN0cmluZ3MpO1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIHByaXZhdGUgZGljdGlvbmFyeS4gV2UgZG9uJ3QgZnVsbHkgcGFyc2Ugb3V0IGFsbCB0aGUgdmFsdWVzLCBvbmx5IHRoZSBvbmVzIHdlIG5lZWQuXG5mdW5jdGlvbiBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHN0YXJ0LCBzaXplLCBzdHJpbmdzKSB7XG4gICAgdmFyIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFBSSVZBVEVfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2lkO1xuICAgIHZhciBjb3VudDtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cbiAgICAvLyBUaGUgLm5vdGRlZiBnbHlwaCBpcyBub3QgaW5jbHVkZWQsIHNvIHN1YnRyYWN0IDEuXG4gICAgbkdseXBocyAtPSAxO1xuICAgIHZhciBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gY291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgICAgICAgICAgc2lkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB3aGlsZSAoY2hhcnNldC5sZW5ndGggPD0gbkdseXBocykge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjb3VudCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFyc2V0IGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnNldDtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBlbmNvZGluZyBkYXRhLiBPbmx5IG9uZSBlbmNvZGluZyBjYW4gYmUgc3BlY2lmaWVkIHBlciBmb250LlxuLy8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTIsIFwiRW5jb2RpbmdzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0LCBjaGFyc2V0KSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGNvZGU7XG4gICAgdmFyIGVuYyA9IHt9O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIHZhciBuQ29kZXMgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbkNvZGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvZGUgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZW5jW2NvZGVdID0gaTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgY29kZSA9IDE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuUmFuZ2VzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICB2YXIgbkxlZnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGZpcnN0OyBqIDw9IGZpcnN0ICsgbkxlZnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGVuY1tqXSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IGVuY29kaW5nLkNmZkVuY29kaW5nKGVuYywgY2hhcnNldCk7XG59XG5cbi8vIFRha2UgaW4gY2hhcnN0cmluZyBjb2RlIGFuZCByZXR1cm4gYSBHbHlwaCBvYmplY3QuXG4vLyBUaGUgZW5jb2RpbmcgaXMgZGVzY3JpYmVkIGluIHRoZSBUeXBlIDIgQ2hhcnN0cmluZyBGb3JtYXRcbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcnN0cjIuaHRtXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzdHJpbmcoZm9udCwgZ2x5cGgsIGNvZGUpIHtcbiAgICB2YXIgYzF4O1xuICAgIHZhciBjMXk7XG4gICAgdmFyIGMyeDtcbiAgICB2YXIgYzJ5O1xuICAgIHZhciBwID0gbmV3IHBhdGguUGF0aCgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBuU3RlbXMgPSAwO1xuICAgIHZhciBoYXZlV2lkdGggPSBmYWxzZTtcbiAgICB2YXIgd2lkdGggPSBmb250LmRlZmF1bHRXaWR0aFg7XG4gICAgdmFyIG9wZW4gPSBmYWxzZTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuXG4gICAgZnVuY3Rpb24gbmV3Q29udG91cih4LCB5KSB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIG9wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RlbXMoKSB7XG4gICAgICAgIHZhciBoYXNXaWR0aEFyZztcblxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHN0ZW0gb3BlcmF0b3JzIG9uIHRoZSBzdGFjayBpcyBhbHdheXMgZXZlbi5cbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIHVuZXZlbiwgdGhhdCBtZWFucyBhIHdpZHRoIGlzIHNwZWNpZmllZC5cbiAgICAgICAgaGFzV2lkdGhBcmcgPSBzdGFjay5sZW5ndGggJSAyICE9PSAwO1xuICAgICAgICBpZiAoaGFzV2lkdGhBcmcgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICB9XG5cbiAgICAgICAgblN0ZW1zICs9IHN0YWNrLmxlbmd0aCA+PiAxO1xuICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUpIHtcbiAgICAgICAgdmFyIGIxO1xuICAgICAgICB2YXIgYjI7XG4gICAgICAgIHZhciBiMztcbiAgICAgICAgdmFyIGI0O1xuICAgICAgICB2YXIgY29kZUluZGV4O1xuICAgICAgICB2YXIgc3VickNvZGU7XG4gICAgICAgIHZhciBqcHg7XG4gICAgICAgIHZhciBqcHk7XG4gICAgICAgIHZhciBjM3g7XG4gICAgICAgIHZhciBjM3k7XG4gICAgICAgIHZhciBjNHg7XG4gICAgICAgIHZhciBjNHk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIGhzdGVtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiAvLyB2c3RlbVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogLy8gdm1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBmb250Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiAvLyBybGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy8gaGxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiAvLyB2bGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6IC8vIHJyY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogLy8gY2FsbHN1YnJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gc3RhY2sucG9wKCkgKyBmb250LnN1YnJzQmlhcztcbiAgICAgICAgICAgICAgICAgICAgc3VickNvZGUgPSBmb250LnN1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogLy8gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiAvLyBmbGV4IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzU6IC8vIGZsZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZHg2IGR5NiBmZCBmbGV4ICgxMiAzNSkgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgICAgICAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzR5ICsgc3RhY2suc2hpZnQoKTsgICAgICAvLyBkeTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpOyAgICAgICAgICAgICAgICAvLyBmbGV4IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNDogLy8gaGZsZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeDYgaGZsZXggKDEyIDM0KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzY6IC8vIGhmbGV4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeTUgZHg2IGhmbGV4MSAoMTIgMzYpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzogLy8gZmxleDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZDYgZmxleDEgKDEyIDM3KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjNHggLSB4KSA+IE1hdGguYWJzKGM0eSAtIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjNHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dseXBoICcgKyBnbHlwaC5pbmRleCArICc6IHVua25vd24gb3BlcmF0b3IgJyArIDEyMDAgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IC8vIGVuZGNoYXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxODogLy8gaHN0ZW1obVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6IC8vIGhpbnRtYXNrXG4gICAgICAgICAgICAgICAgY2FzZSAyMDogLy8gY250cm1hc2tcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IChuU3RlbXMgKyA3KSA+PiAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIxOiAvLyBybW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAyICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzOiAvLyB2c3RlbWhtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDogLy8gcmN1cnZlbGluZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI1OiAvLyBybGluZWN1cnZlXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjogLy8gdnZjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIGhoY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI4OiAvLyBzaG9ydGludFxuICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpKSA+PiAxNik7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOTogLy8gY2FsbGdzdWJyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5nc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgICAgICBzdWJyQ29kZSA9IGZvbnQuZ3N1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gdmhjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMxOiAvLyBodmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2IDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbHlwaCAnICsgZ2x5cGguaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjQ3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHYgLSAxMzkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goLSh2IC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiMyA9IGNvZGVbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpIHwgKGIzIDw8IDgpIHwgYjQpIC8gNjU1MzYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZShjb2RlKTtcblxuICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBwO1xufVxuXG4vLyBTdWJyb3V0aW5lcyBhcmUgZW5jb2RlZCB1c2luZyB0aGUgbmVnYXRpdmUgaGFsZiBvZiB0aGUgbnVtYmVyIHNwYWNlLlxuLy8gU2VlIHR5cGUgMiBjaGFwdGVyIDQuNyBcIlN1YnJvdXRpbmUgb3BlcmF0b3JzXCIuXG5mdW5jdGlvbiBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoc3VicnMpIHtcbiAgICB2YXIgYmlhcztcbiAgICBpZiAoc3VicnMubGVuZ3RoIDwgMTI0MCkge1xuICAgICAgICBiaWFzID0gMTA3O1xuICAgIH0gZWxzZSBpZiAoc3VicnMubGVuZ3RoIDwgMzM5MDApIHtcbiAgICAgICAgYmlhcyA9IDExMzE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmlhcyA9IDMyNzY4O1xuICAgIH1cblxuICAgIHJldHVybiBiaWFzO1xufVxuXG4vLyBQYXJzZSB0aGUgYENGRmAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cbmZ1bmN0aW9uIHBhcnNlQ0ZGVGFibGUoZGF0YSwgc3RhcnQsIGZvbnQpIHtcbiAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcbiAgICB2YXIgaGVhZGVyID0gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBuYW1lSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIGhlYWRlci5lbmRPZmZzZXQsIHBhcnNlLmJ5dGVzVG9TdHJpbmcpO1xuICAgIHZhciB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuICAgIHZhciBzdHJpbmdJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgdG9wRGljdEluZGV4LmVuZE9mZnNldCwgcGFyc2UuYnl0ZXNUb1N0cmluZyk7XG4gICAgdmFyIGdsb2JhbFN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RyaW5nSW5kZXguZW5kT2Zmc2V0KTtcbiAgICBmb250LmdzdWJycyA9IGdsb2JhbFN1YnJJbmRleC5vYmplY3RzO1xuICAgIGZvbnQuZ3N1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LmdzdWJycyk7XG5cbiAgICB2YXIgdG9wRGljdERhdGEgPSBuZXcgRGF0YVZpZXcobmV3IFVpbnQ4QXJyYXkodG9wRGljdEluZGV4Lm9iamVjdHNbMF0pLmJ1ZmZlcik7XG4gICAgdmFyIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQudGFibGVzLmNmZi50b3BEaWN0ID0gdG9wRGljdDtcblxuICAgIHZhciBwcml2YXRlRGljdE9mZnNldCA9IHN0YXJ0ICsgdG9wRGljdFsncHJpdmF0ZSddWzFdO1xuICAgIHZhciBwcml2YXRlRGljdCA9IHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgcHJpdmF0ZURpY3RPZmZzZXQsIHRvcERpY3RbJ3ByaXZhdGUnXVswXSwgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG4gICAgZm9udC5kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICBmb250Lm5vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuXG4gICAgaWYgKHByaXZhdGVEaWN0LnN1YnJzICE9PSAwKSB7XG4gICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgdmFyIHN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3Vick9mZnNldCk7XG4gICAgICAgIGZvbnQuc3VicnMgPSBzdWJySW5kZXgub2JqZWN0cztcbiAgICAgICAgZm9udC5zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5zdWJycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5zdWJycyA9IFtdO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gT2Zmc2V0cyBpbiB0aGUgdG9wIGRpY3QgYXJlIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIENGRiBkYXRhLCBzbyBhZGQgdGhlIENGRiBzdGFydCBvZmZzZXQuXG4gICAgdmFyIGNoYXJTdHJpbmdzSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5ncyk7XG4gICAgZm9udC5uR2x5cGhzID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzLmxlbmd0aDtcblxuICAgIHZhciBjaGFyc2V0ID0gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyc2V0LCBmb250Lm5HbHlwaHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7IC8vIFN0YW5kYXJkIGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgZW5jb2RpbmcuQ2ZmRW5jb2RpbmcoZW5jb2RpbmcuY2ZmU3RhbmRhcmRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7IC8vIEV4cGVydCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IGVuY29kaW5nLkNmZkVuY29kaW5nKGVuY29kaW5nLmNmZkV4cGVydEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCArIHRvcERpY3QuZW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH1cblxuICAgIC8vIFByZWZlciB0aGUgQ01BUCBlbmNvZGluZyB0byB0aGUgQ0ZGIGVuY29kaW5nLlxuICAgIGZvbnQuZW5jb2RpbmcgPSBmb250LmVuY29kaW5nIHx8IGZvbnQuY2ZmRW5jb2Rpbmc7XG5cbiAgICBmb250LmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnQubkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGFyU3RyaW5nID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzW2ldO1xuICAgICAgICBmb250LmdseXBocy5wdXNoKGksIGdseXBoc2V0LmNmZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhclN0cmluZykpO1xuICAgIH1cbn1cblxuLy8gQ29udmVydCBhIHN0cmluZyB0byBhIFN0cmluZyBJRCAoU0lEKS5cbi8vIFRoZSBsaXN0IG9mIHN0cmluZ3MgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG5mdW5jdGlvbiBlbmNvZGVTdHJpbmcocywgc3RyaW5ncykge1xuICAgIHZhciBzaWQ7XG5cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGluIHRoZSBDRkYgc3RhbmRhcmQgc3RyaW5ncz9cbiAgICB2YXIgaSA9IGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGFscmVhZHkgaW4gdGhlIHN0cmluZyBpbmRleD9cbiAgICBpID0gc3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaSArIGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2lkID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmxlbmd0aCArIHN0cmluZ3MubGVuZ3RoO1xuICAgICAgICBzdHJpbmdzLnB1c2gocyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZDtcbn1cblxuZnVuY3Rpb24gbWFrZUhlYWRlcigpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlJlY29yZCgnSGVhZGVyJywgW1xuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ21pbm9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2hkclNpemUnLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogNH0sXG4gICAgICAgIHtuYW1lOiAnbWFqb3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVJbmRleChmb250TmFtZXMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ05hbWUgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnbmFtZXMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5uYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQubmFtZXMucHVzaCh7bmFtZTogJ25hbWVfJyArIGksIHR5cGU6ICdOQU1FJywgdmFsdWU6IGZvbnROYW1lc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG4vLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5mdW5jdGlvbiBtYWtlRGljdChtZXRhLCBhdHRycywgc3RyaW5ncykge1xuICAgIHZhciBtID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG1ldGFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2VudHJ5Lm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWxzKHZhbHVlLCBlbnRyeS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZW5jb2RlU3RyaW5nKHZhbHVlLCBzdHJpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbVtlbnRyeS5vcF0gPSB7bmFtZTogZW50cnkubmFtZSwgdHlwZTogZW50cnkudHlwZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBUaGUgVG9wIERJQ1QgaG91c2VzIHRoZSBnbG9iYWwgZm9udCBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ1RvcCBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChUT1BfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnVG9wIERJQ1QgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAndG9wRGljdHMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC50b3BEaWN0cyA9IFt7bmFtZTogJ3RvcERpY3RfMCcsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiB0b3BEaWN0fV07XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdHJpbmdJbmRleChzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdTdHJpbmcgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnc3RyaW5ncycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5zdHJpbmdzLnB1c2goe25hbWU6ICdzdHJpbmdfJyArIGksIHR5cGU6ICdTVFJJTkcnLCB2YWx1ZTogc3RyaW5nc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlR2xvYmFsU3VickluZGV4KCkge1xuICAgIC8vIEN1cnJlbnRseSB3ZSBkb24ndCB1c2Ugc3Vicm91dGluZXMuXG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ0dsb2JhbCBTdWJyIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3N1YnJzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2hhcnNldHMoZ2x5cGhOYW1lcywgc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnQ2hhcnNldHMnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE5hbWUgPSBnbHlwaE5hbWVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhTSUQgPSBlbmNvZGVTdHJpbmcoZ2x5cGhOYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnU0lEJywgdmFsdWU6IGdseXBoU0lEfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGdseXBoVG9PcHMoZ2x5cGgpIHtcbiAgICB2YXIgb3BzID0gW107XG4gICAgdmFyIHBhdGggPSBnbHlwaC5wYXRoO1xuICAgIG9wcy5wdXNoKHtuYW1lOiAnd2lkdGgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGdseXBoLmFkdmFuY2VXaWR0aH0pO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBkeDtcbiAgICAgICAgdmFyIGR5O1xuICAgICAgICB2YXIgY21kID0gcGF0aC5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIC8vIENGRiBvbmx5IHN1cHBvcnRzIGLDqXppZXIgY3VydmVzLCBzbyBjb252ZXJ0IHRoZSBxdWFkIHRvIGEgYsOpemllci5cbiAgICAgICAgICAgIHZhciBfMTMgPSAxIC8gMztcbiAgICAgICAgICAgIHZhciBfMjMgPSAyIC8gMztcblxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gY3JlYXRlIGEgbmV3IGNvbW1hbmQgc28gd2UgZG9uJ3QgY2hhbmdlIHRoZSBvcmlnaW5hbCBwYXRoLlxuICAgICAgICAgICAgY21kID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDJyxcbiAgICAgICAgICAgICAgICB4OiBjbWQueCxcbiAgICAgICAgICAgICAgICB5OiBjbWQueSxcbiAgICAgICAgICAgICAgICB4MTogXzEzICogeCArIF8yMyAqIGNtZC54MSxcbiAgICAgICAgICAgICAgICB5MTogXzEzICogeSArIF8yMyAqIGNtZC55MSxcbiAgICAgICAgICAgICAgICB4MjogXzEzICogY21kLnggKyBfMjMgKiBjbWQueDEsXG4gICAgICAgICAgICAgICAgeTI6IF8xMyAqIGNtZC55ICsgXzIzICogY21kLnkxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIHgpO1xuICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0geSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAncm1vdmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiAyMX0pO1xuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIHgpO1xuICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0geSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAncmxpbmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiA1fSk7XG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChjbWQueCk7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgdmFyIGR4MSA9IE1hdGgucm91bmQoY21kLngxIC0geCk7XG4gICAgICAgICAgICB2YXIgZHkxID0gTWF0aC5yb3VuZChjbWQueTEgLSB5KTtcbiAgICAgICAgICAgIHZhciBkeDIgPSBNYXRoLnJvdW5kKGNtZC54MiAtIGNtZC54MSk7XG4gICAgICAgICAgICB2YXIgZHkyID0gTWF0aC5yb3VuZChjbWQueTIgLSBjbWQueTEpO1xuICAgICAgICAgICAgZHggPSBNYXRoLnJvdW5kKGNtZC54IC0gY21kLngyKTtcbiAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIGNtZC55Mik7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4MScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHgxfSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5MScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHkxfSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4MicsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHgyfSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5MicsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHkyfSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAncnJjdXJ2ZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDh9KTtcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKGNtZC54KTtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKGNtZC55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnRvdXJzIGFyZSBjbG9zZWQgYXV0b21hdGljYWxseS5cblxuICAgIH1cblxuICAgIG9wcy5wdXNoKHtuYW1lOiAnZW5kY2hhcicsIHR5cGU6ICdPUCcsIHZhbHVlOiAxNH0pO1xuICAgIHJldHVybiBvcHM7XG59XG5cbmZ1bmN0aW9uIG1ha2VDaGFyU3RyaW5nc0luZGV4KGdseXBocykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnQ2hhclN0cmluZ3MgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICB2YXIgb3BzID0gZ2x5cGhUb09wcyhnbHlwaCk7XG4gICAgICAgIHQuY2hhclN0cmluZ3MucHVzaCh7bmFtZTogZ2x5cGgubmFtZSwgdHlwZTogJ0NIQVJTVFJJTkcnLCB2YWx1ZTogb3BzfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcml2YXRlRGljdChhdHRycywgc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnUHJpdmF0ZSBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChQUklWQVRFX0RJQ1RfTUVUQSwgYXR0cnMsIHN0cmluZ3MpO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlQ0ZGVGFibGUoZ2x5cGhzLCBvcHRpb25zKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ0NGRiAnLCBbXG4gICAgICAgIHtuYW1lOiAnaGVhZGVyJywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ25hbWVJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICd0b3BEaWN0SW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnc3RyaW5nSW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnZ2xvYmFsU3VickluZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ2NoYXJzZXRzJywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ2NoYXJTdHJpbmdzSW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAncHJpdmF0ZURpY3QnLCB0eXBlOiAnUkVDT1JEJ31cbiAgICBdKTtcblxuICAgIHZhciBmb250U2NhbGUgPSAxIC8gb3B0aW9ucy51bml0c1BlckVtO1xuICAgIC8vIFdlIHVzZSBub24temVybyB2YWx1ZXMgZm9yIHRoZSBvZmZzZXRzIHNvIHRoYXQgdGhlIERJQ1QgZW5jb2RlcyB0aGVtLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIHNpemUgb2YgdGhlIFRvcCBESUNUIHBsYXlzIGEgcm9sZSBpbiBvZmZzZXQgY2FsY3VsYXRpb24sXG4gICAgLy8gYW5kIHRoZSBzaXplIHNob3VsZG4ndCBjaGFuZ2UgYWZ0ZXIgd2UndmUgd3JpdHRlbiBjb3JyZWN0IG9mZnNldHMuXG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgICAgIGZ1bGxOYW1lOiBvcHRpb25zLmZ1bGxOYW1lLFxuICAgICAgICBmYW1pbHlOYW1lOiBvcHRpb25zLmZhbWlseU5hbWUsXG4gICAgICAgIHdlaWdodDogb3B0aW9ucy53ZWlnaHROYW1lLFxuICAgICAgICBmb250QkJveDogb3B0aW9ucy5mb250QkJveCB8fCBbMCwgMCwgMCwgMF0sXG4gICAgICAgIGZvbnRNYXRyaXg6IFtmb250U2NhbGUsIDAsIDAsIGZvbnRTY2FsZSwgMCwgMF0sXG4gICAgICAgIGNoYXJzZXQ6IDk5OSxcbiAgICAgICAgZW5jb2Rpbmc6IDAsXG4gICAgICAgIGNoYXJTdHJpbmdzOiA5OTksXG4gICAgICAgIHByaXZhdGU6IFswLCA5OTldXG4gICAgfTtcblxuICAgIHZhciBwcml2YXRlQXR0cnMgPSB7fTtcblxuICAgIHZhciBnbHlwaE5hbWVzID0gW107XG4gICAgdmFyIGdseXBoO1xuXG4gICAgLy8gU2tpcCBmaXJzdCBnbHlwaCAoLm5vdGRlZilcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGdseXBoTmFtZXMucHVzaChnbHlwaC5uYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5ncyA9IFtdO1xuXG4gICAgdC5oZWFkZXIgPSBtYWtlSGVhZGVyKCk7XG4gICAgdC5uYW1lSW5kZXggPSBtYWtlTmFtZUluZGV4KFtvcHRpb25zLnBvc3RTY3JpcHROYW1lXSk7XG4gICAgdmFyIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuICAgIHQuZ2xvYmFsU3VickluZGV4ID0gbWFrZUdsb2JhbFN1YnJJbmRleCgpO1xuICAgIHQuY2hhcnNldHMgPSBtYWtlQ2hhcnNldHMoZ2x5cGhOYW1lcywgc3RyaW5ncyk7XG4gICAgdC5jaGFyU3RyaW5nc0luZGV4ID0gbWFrZUNoYXJTdHJpbmdzSW5kZXgoZ2x5cGhzKTtcbiAgICB0LnByaXZhdGVEaWN0ID0gbWFrZVByaXZhdGVEaWN0KHByaXZhdGVBdHRycywgc3RyaW5ncyk7XG5cbiAgICAvLyBOZWVkcyB0byBjb21lIGF0IHRoZSBlbmQsIHRvIGVuY29kZSBhbGwgY3VzdG9tIHN0cmluZ3MgdXNlZCBpbiB0aGUgZm9udC5cbiAgICB0LnN0cmluZ0luZGV4ID0gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpO1xuXG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdC5oZWFkZXIuc2l6ZU9mKCkgK1xuICAgICAgICB0Lm5hbWVJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQudG9wRGljdEluZGV4LnNpemVPZigpICtcbiAgICAgICAgdC5zdHJpbmdJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQuZ2xvYmFsU3VickluZGV4LnNpemVPZigpO1xuICAgIGF0dHJzLmNoYXJzZXQgPSBzdGFydE9mZnNldDtcblxuICAgIC8vIFdlIHVzZSB0aGUgQ0ZGIHN0YW5kYXJkIGVuY29kaW5nOyBwcm9wZXIgZW5jb2Rpbmcgd2lsbCBiZSBoYW5kbGVkIGluIGNtYXAuXG4gICAgYXR0cnMuZW5jb2RpbmcgPSAwO1xuICAgIGF0dHJzLmNoYXJTdHJpbmdzID0gYXR0cnMuY2hhcnNldCArIHQuY2hhcnNldHMuc2l6ZU9mKCk7XG4gICAgYXR0cnMucHJpdmF0ZVsxXSA9IGF0dHJzLmNoYXJTdHJpbmdzICsgdC5jaGFyU3RyaW5nc0luZGV4LnNpemVPZigpO1xuXG4gICAgLy8gUmVjcmVhdGUgdGhlIFRvcCBESUNUIElOREVYIHdpdGggdGhlIGNvcnJlY3Qgb2Zmc2V0cy5cbiAgICB0b3BEaWN0ID0gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpO1xuICAgIHQudG9wRGljdEluZGV4ID0gbWFrZVRvcERpY3RJbmRleCh0b3BEaWN0KTtcblxuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VDRkZUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VDRkZUYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2NmZi5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSBgY21hcGAgdGFibGUgc3RvcmVzIHRoZSBtYXBwaW5ncyBmcm9tIGNoYXJhY3RlcnMgdG8gZ2x5cGhzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jbWFwLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4uL2NoZWNrJyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGVGb3JtYXQxMihjbWFwLCBwKSB7XG4gICAgdmFyIGk7XG5cbiAgICAvL1NraXAgcmVzZXJ2ZWQuXG4gICAgcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY21hcC5sYW5ndWFnZSA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgdmFyIGdyb3VwQ291bnQ7XG4gICAgY21hcC5ncm91cENvdW50ID0gZ3JvdXBDb3VudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNtYXAuZ2x5cGhJbmRleE1hcCA9IHt9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc3RhcnRDaGFyQ29kZSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgZW5kQ2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIHN0YXJ0R2x5cGhJZCA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSBzdGFydENoYXJDb2RlOyBjIDw9IGVuZENoYXJDb2RlOyBjICs9IDEpIHtcbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IHN0YXJ0R2x5cGhJZDtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhJZCsrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCkge1xuICAgIHZhciBpO1xuXG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICAvLyBzZWdDb3VudCBpcyBzdG9yZWQgeCAyLlxuICAgIHZhciBzZWdDb3VudDtcbiAgICBjbWFwLnNlZ0NvdW50ID0gc2VnQ291bnQgPSBwLnBhcnNlVVNob3J0KCkgPj4gMTtcblxuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcblxuICAgIC8vIFRoZSBcInVucm9sbGVkXCIgbWFwcGluZyBmcm9tIGNoYXJhY3RlciBjb2RlcyB0byBnbHlwaCBpbmRpY2VzLlxuICAgIGNtYXAuZ2x5cGhJbmRleE1hcCA9IHt9O1xuICAgIHZhciBlbmRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNCk7XG4gICAgdmFyIHN0YXJ0Q291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDIpO1xuICAgIHZhciBpZERlbHRhUGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA0KTtcbiAgICB2YXIgaWRSYW5nZU9mZnNldFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNik7XG4gICAgdmFyIGdseXBoSW5kZXhPZmZzZXQgPSBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA4O1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdDb3VudCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhJbmRleDtcbiAgICAgICAgdmFyIGVuZENvdW50ID0gZW5kQ291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHN0YXJ0Q291bnQgPSBzdGFydENvdW50UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBpZERlbHRhID0gaWREZWx0YVBhcnNlci5wYXJzZVNob3J0KCk7XG4gICAgICAgIHZhciBpZFJhbmdlT2Zmc2V0ID0gaWRSYW5nZU9mZnNldFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBmb3IgKHZhciBjID0gc3RhcnRDb3VudDsgYyA8PSBlbmRDb3VudDsgYyArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaWRSYW5nZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBpZFJhbmdlT2Zmc2V0IGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIC8vIFRha2UgdGhlIGN1cnJlbnQgb2Zmc2V0IGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgPSAoaWRSYW5nZU9mZnNldFBhcnNlci5vZmZzZXQgKyBpZFJhbmdlT2Zmc2V0UGFyc2VyLnJlbGF0aXZlT2Zmc2V0IC0gMik7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZhbHVlIG9mIHRoZSBpZFJhbmdlT2Zmc2V0LCB3aGljaCB3aWxsIG1vdmUgdXMgaW50byB0aGUgZ2x5cGhJbmRleCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IGlkUmFuZ2VPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCB0aGUgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSBjdXJyZW50IHNlZ21lbnQsIG11bHRpcGxpZWQgYnkgMiBmb3IgVVNIT1JUcy5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IChjIC0gc3RhcnRDb3VudCkgKiAyO1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgZ2x5cGhJbmRleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChnbHlwaEluZGV4ICsgaWREZWx0YSkgJiAweEZGRkY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGMgKyBpZERlbHRhKSAmIDB4RkZGRjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY21hcC5nbHlwaEluZGV4TWFwW2NdID0gZ2x5cGhJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gUGFyc2UgdGhlIGBjbWFwYCB0YWJsZS4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG4vLyBUaGVyZSBhcmUgbWFueSBhdmFpbGFibGUgZm9ybWF0cywgYnV0IHdlIG9ubHkgc3VwcG9ydCB0aGUgV2luZG93cyBmb3JtYXQgNCBhbmQgMTIuXG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBgQ21hcEVuY29kaW5nYCBvYmplY3Qgb3IgbnVsbCBpZiBubyBzdXBwb3J0ZWQgZm9ybWF0IGNvdWxkIGJlIGZvdW5kLlxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgY21hcCA9IHt9O1xuICAgIGNtYXAudmVyc2lvbiA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCk7XG4gICAgY2hlY2suYXJndW1lbnQoY21hcC52ZXJzaW9uID09PSAwLCAnY21hcCB0YWJsZSB2ZXJzaW9uIHNob3VsZCBiZSAwLicpO1xuXG4gICAgLy8gVGhlIGNtYXAgdGFibGUgY2FuIGNvbnRhaW4gbWFueSBzdWItdGFibGVzLCBlYWNoIHdpdGggdGhlaXIgb3duIGZvcm1hdC5cbiAgICAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gYSBcInBsYXRmb3JtIDNcIiB0YWJsZS4gVGhpcyBpcyBhIFdpbmRvd3MgZm9ybWF0LlxuICAgIGNtYXAubnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgdmFyIG9mZnNldCA9IC0xO1xuICAgIGZvciAoaSA9IGNtYXAubnVtVGFibGVzIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgdmFyIHBsYXRmb3JtSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSk7XG4gICAgICAgIHZhciBlbmNvZGluZ0lkID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgNCArIChpICogOCkgKyAyKTtcbiAgICAgICAgaWYgKHBsYXRmb3JtSWQgPT09IDMgJiYgKGVuY29kaW5nSWQgPT09IDAgfHwgZW5jb2RpbmdJZCA9PT0gMSB8fCBlbmNvZGluZ0lkID09PSAxMCkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHN0YXJ0ICsgNCArIChpICogOCkgKyA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gY21hcCB0YWJsZSBpbiB0aGUgZm9udCB0aGF0IHdlIHN1cHBvcnQsIHNvIHJldHVybiBudWxsLlxuICAgICAgICAvLyBUaGlzIGZvbnQgd2lsbCBiZSBtYXJrZWQgYXMgdW5zdXBwb3J0ZWQuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCk7XG4gICAgY21hcC5mb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICBpZiAoY21hcC5mb3JtYXQgPT09IDEyKSB7XG4gICAgICAgIHBhcnNlQ21hcFRhYmxlRm9ybWF0MTIoY21hcCwgcCk7XG4gICAgfSBlbHNlIGlmIChjbWFwLmZvcm1hdCA9PT0gNCkge1xuICAgICAgICBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGZvcm1hdCA0IGFuZCAxMiBjbWFwIHRhYmxlcyBhcmUgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjbWFwO1xufVxuXG5mdW5jdGlvbiBhZGRTZWdtZW50KHQsIGNvZGUsIGdseXBoSW5kZXgpIHtcbiAgICB0LnNlZ21lbnRzLnB1c2goe1xuICAgICAgICBlbmQ6IGNvZGUsXG4gICAgICAgIHN0YXJ0OiBjb2RlLFxuICAgICAgICBkZWx0YTogLShjb2RlIC0gZ2x5cGhJbmRleCksXG4gICAgICAgIG9mZnNldDogMFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUZXJtaW5hdG9yU2VnbWVudCh0KSB7XG4gICAgdC5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgZW5kOiAweEZGRkYsXG4gICAgICAgIHN0YXJ0OiAweEZGRkYsXG4gICAgICAgIGRlbHRhOiAxLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUNtYXBUYWJsZShnbHlwaHMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnY21hcCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDN9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAxMn0sXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA0fSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWdDb3VudFgyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWFyY2hSYW5nZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZW50cnlTZWxlY3RvcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmFuZ2VTaGlmdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdKTtcblxuICAgIHQuc2VnbWVudHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGgudW5pY29kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFkZFNlZ21lbnQodCwgZ2x5cGgudW5pY29kZXNbal0sIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdC5zZWdtZW50cyA9IHQuc2VnbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpO1xuXG4gICAgdmFyIHNlZ0NvdW50O1xuICAgIHNlZ0NvdW50ID0gdC5zZWdtZW50cy5sZW5ndGg7XG4gICAgdC5zZWdDb3VudFgyID0gc2VnQ291bnQgKiAyO1xuICAgIHQuc2VhcmNoUmFuZ2UgPSBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKHNlZ0NvdW50KSAvIE1hdGgubG9nKDIpKSkgKiAyO1xuICAgIHQuZW50cnlTZWxlY3RvciA9IE1hdGgubG9nKHQuc2VhcmNoUmFuZ2UgLyAyKSAvIE1hdGgubG9nKDIpO1xuICAgIHQucmFuZ2VTaGlmdCA9IHQuc2VnQ291bnRYMiAtIHQuc2VhcmNoUmFuZ2U7XG5cbiAgICAvLyBTZXQgdXAgcGFyYWxsZWwgc2VnbWVudCBhcnJheXMuXG4gICAgdmFyIGVuZENvdW50cyA9IFtdO1xuICAgIHZhciBzdGFydENvdW50cyA9IFtdO1xuICAgIHZhciBpZERlbHRhcyA9IFtdO1xuICAgIHZhciBpZFJhbmdlT2Zmc2V0cyA9IFtdO1xuICAgIHZhciBnbHlwaElkcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0LnNlZ21lbnRzW2ldO1xuICAgICAgICBlbmRDb3VudHMgPSBlbmRDb3VudHMuY29uY2F0KHtuYW1lOiAnZW5kXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZW5kfSk7XG4gICAgICAgIHN0YXJ0Q291bnRzID0gc3RhcnRDb3VudHMuY29uY2F0KHtuYW1lOiAnc3RhcnRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5zdGFydH0pO1xuICAgICAgICBpZERlbHRhcyA9IGlkRGVsdGFzLmNvbmNhdCh7bmFtZTogJ2lkRGVsdGFfJyArIGksIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmRlbHRhfSk7XG4gICAgICAgIGlkUmFuZ2VPZmZzZXRzID0gaWRSYW5nZU9mZnNldHMuY29uY2F0KHtuYW1lOiAnaWRSYW5nZU9mZnNldF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50Lm9mZnNldH0pO1xuICAgICAgICBpZiAoc2VnbWVudC5nbHlwaElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGdseXBoSWRzID0gZ2x5cGhJZHMuY29uY2F0KHtuYW1lOiAnZ2x5cGhfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5nbHlwaElkfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChlbmRDb3VudHMpO1xuICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdyZXNlcnZlZFBhZCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0pO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KHN0YXJ0Q291bnRzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChpZERlbHRhcyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoaWRSYW5nZU9mZnNldHMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGdseXBoSWRzKTtcblxuICAgIHQubGVuZ3RoID0gMTQgKyAvLyBTdWJ0YWJsZSBoZWFkZXJcbiAgICAgICAgZW5kQ291bnRzLmxlbmd0aCAqIDIgK1xuICAgICAgICAyICsgLy8gcmVzZXJ2ZWRQYWRcbiAgICAgICAgc3RhcnRDb3VudHMubGVuZ3RoICogMiArXG4gICAgICAgIGlkRGVsdGFzLmxlbmd0aCAqIDIgK1xuICAgICAgICBpZFJhbmdlT2Zmc2V0cy5sZW5ndGggKiAyICtcbiAgICAgICAgZ2x5cGhJZHMubGVuZ3RoICogMjtcblxuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VDbWFwVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlQ21hcFRhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy90YWJsZXMvY21hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSBgR1NVQmAgdGFibGUgY29udGFpbnMgbGlnYXR1cmVzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2dzdWIuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciBQYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZScpLlBhcnNlcjtcbnZhciBzdWJ0YWJsZVBhcnNlcnMgPSBuZXcgQXJyYXkoOSk7ICAgICAgICAgLy8gc3VidGFibGVQYXJzZXJzWzBdIGlzIHVudXNlZFxudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNTU1xuc3VidGFibGVQYXJzZXJzWzFdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAxKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgZGVsdGFHbHlwaElkOiB0aGlzLnBhcnNlVVNob3J0KClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMixcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgc3Vic3RpdHV0ZTogdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDEgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNNU1xuc3VidGFibGVQYXJzZXJzWzJdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAyKCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgTXVsdGlwbGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIHNlcXVlbmNlczogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKClcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNBU1xuc3VidGFibGVQYXJzZXJzWzNdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAzKCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgQWx0ZXJuYXRlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBhbHRlcm5hdGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoKVxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0xTXG5zdWJ0YWJsZVBhcnNlcnNbNF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDQoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBsaWdhdHVyZSB0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBsaWdhdHVyZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGlnR2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlVVNob3J0KCkgLSAxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICB9O1xufTtcblxudmFyIGxvb2t1cFJlY29yZERlc2MgPSB7XG4gICAgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCxcbiAgICBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnRcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQ1NGXG5zdWJ0YWJsZVBhcnNlcnNbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblxuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBydWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdChnbHlwaENvdW50IC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBjbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGNsYXNzU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGdseXBoQ291bnQgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3Qoc3Vic3RDb3VudCwgbG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlczogdGhpcy5wYXJzZUxpc3QoZ2x5cGhDb3VudCwgUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSA1IGZvcm1hdCBtdXN0IGJlIDEsIDIgb3IgMy4nKTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQ0NcbnN1YnRhYmxlUGFyc2Vyc1s2XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGNoYWluUnVsZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYWNrdHJhY2s6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGJhY2t0cmFja0NsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgaW5wdXRDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGxvb2thaGVhZENsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgY2hhaW5DbGFzc1NldDogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMyxcbiAgICAgICAgICAgIGJhY2t0cmFja0NvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGlucHV0Q292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgNiBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJyk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0VTXG5zdWJ0YWJsZVBhcnNlcnNbN10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDcoKSB7XG4gICAgLy8gRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZVxuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICB2YXIgZXh0ZW5zaW9uTG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgZXh0ZW5zaW9uUGFyc2VyID0gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5wYXJzZVVMb25nKCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBsb29rdXBUeXBlOiBleHRlbnNpb25Mb29rdXBUeXBlLFxuICAgICAgICBleHRlbnNpb246IHN1YnRhYmxlUGFyc2Vyc1tleHRlbnNpb25Mb29rdXBUeXBlXS5jYWxsKGV4dGVuc2lvblBhcnNlcilcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNSQ0NTXG5zdWJ0YWJsZVBhcnNlcnNbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBSZXZlcnNlIENoYWluaW5nIENvbnRleHR1YWwgU2luZ2xlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgc3Vic3RpdHV0ZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KClcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9nc3ViLmh0bVxuZnVuY3Rpb24gcGFyc2VHc3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBHU1VCIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycylcbiAgICB9O1xufVxuXG4vLyBHU1VCIFdyaXRpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xudmFyIHN1YnRhYmxlTWFrZXJzID0gbmV3IEFycmF5KDkpO1xuXG5zdWJ0YWJsZU1ha2Vyc1sxXSA9IGZ1bmN0aW9uIG1ha2VMb29rdXAxKHN1YnRhYmxlKSB7XG4gICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3N1YnN0aXR1dGlvblRhYmxlJywgW1xuICAgICAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9LFxuICAgICAgICAgICAge25hbWU6ICdkZWx0YUdseXBoSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHN1YnRhYmxlLmRlbHRhR2x5cGhJZH1cbiAgICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX1cbiAgICAgICAgXS5jb25jYXQodGFibGUudXNob3J0TGlzdCgnc3Vic3RpdHV0ZScsIHN1YnRhYmxlLnN1YnN0aXR1dGUpKSk7XG4gICAgfVxuICAgIGNoZWNrLmZhaWwoJ0xvb2t1cCB0eXBlIDEgc3Vic3RGb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG5zdWJ0YWJsZU1ha2Vyc1szXSA9IGZ1bmN0aW9uIG1ha2VMb29rdXAzKHN1YnRhYmxlKSB7XG4gICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxLCAnTG9va3VwIHR5cGUgMyBzdWJzdEZvcm1hdCBtdXN0IGJlIDEuJyk7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG4gICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdhbHRTZXQnLCBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzLCBmdW5jdGlvbihhbHRlcm5hdGVTZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnYWx0ZXJuYXRlU2V0VGFibGUnLCB0YWJsZS51c2hvcnRMaXN0KCdhbHRlcm5hdGUnLCBhbHRlcm5hdGVTZXQpKTtcbiAgICB9KSkpO1xufTtcblxuc3VidGFibGVNYWtlcnNbNF0gPSBmdW5jdGlvbiBtYWtlTG9va3VwNChzdWJ0YWJsZSkge1xuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSwgJ0xvb2t1cCB0eXBlIDQgc3Vic3RGb3JtYXQgbXVzdCBiZSAxLicpO1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3N1YnN0aXR1dGlvblRhYmxlJywgW1xuICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuICAgIF0uY29uY2F0KHRhYmxlLnRhYmxlTGlzdCgnbGlnU2V0Jywgc3VidGFibGUubGlnYXR1cmVTZXRzLCBmdW5jdGlvbihsaWdhdHVyZVNldCkge1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdsaWdhdHVyZVNldFRhYmxlJywgdGFibGUudGFibGVMaXN0KCdsaWdhdHVyZScsIGxpZ2F0dXJlU2V0LCBmdW5jdGlvbihsaWdhdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbGlnYXR1cmVUYWJsZScsXG4gICAgICAgICAgICAgICAgW3tuYW1lOiAnbGlnR2x5cGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxpZ2F0dXJlLmxpZ0dseXBofV1cbiAgICAgICAgICAgICAgICAuY29uY2F0KHRhYmxlLnVzaG9ydExpc3QoJ2NvbXBvbmVudCcsIGxpZ2F0dXJlLmNvbXBvbmVudHMsIGxpZ2F0dXJlLmNvbXBvbmVudHMubGVuZ3RoICsgMSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KSk7XG4gICAgfSkpKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VHc3ViVGFibGUoZ3N1Yikge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ0dTVUInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdzY3JpcHRzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5TY3JpcHRMaXN0KGdzdWIuc2NyaXB0cyl9LFxuICAgICAgICB7bmFtZTogJ2ZlYXR1cmVzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5GZWF0dXJlTGlzdChnc3ViLmZlYXR1cmVzKX0sXG4gICAgICAgIHtuYW1lOiAnbG9va3VwcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuTG9va3VwTGlzdChnc3ViLmxvb2t1cHMsIHN1YnRhYmxlTWFrZXJzKX1cbiAgICBdKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlR3N1YlRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUdzdWJUYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dzdWIuanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgYGhlYWRgIHRhYmxlIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaGVhZC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBoZWFkZXIgYGhlYWRgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhlYWRUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhlYWQuZm9udFJldmlzaW9uID0gTWF0aC5yb3VuZChwLnBhcnNlRml4ZWQoKSAqIDEwMDApIC8gMTAwMDtcbiAgICBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGhlYWQubWFnaWNOdW1iZXIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudChoZWFkLm1hZ2ljTnVtYmVyID09PSAweDVGMEYzQ0Y1LCAnRm9udCBoZWFkZXIgaGFzIHdyb25nIG1hZ2ljIG51bWJlci4nKTtcbiAgICBoZWFkLmZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQudW5pdHNQZXJFbSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmNyZWF0ZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC5tb2RpZmllZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLnhNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLm1hY1N0eWxlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQubG93ZXN0UmVjUFBFTSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmZvbnREaXJlY3Rpb25IaW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5pbmRleFRvTG9jRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5nbHlwaERhdGFGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICByZXR1cm4gaGVhZDtcbn1cblxuZnVuY3Rpb24gbWFrZUhlYWRUYWJsZShvcHRpb25zKSB7XG4gICAgLy8gQXBwbGUgTWFjIHRpbWVzdGFtcCBlcG9jaCBpcyAwMS8wMS8xOTA0IG5vdCAwMS8wMS8xOTcwXG4gICAgdmFyIHRpbWVzdGFtcCA9IE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKSArIDIwODI4NDQ4MDA7XG4gICAgdmFyIGNyZWF0ZWRUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVkVGltZXN0YW1wKSB7XG4gICAgICAgIGNyZWF0ZWRUaW1lc3RhbXAgPSBvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXAgKyAyMDgyODQ0ODAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hlYWQnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdmb250UmV2aXNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW1BZGp1c3RtZW50JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hZ2ljTnVtYmVyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4NUYwRjNDRjV9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bml0c1BlckVtJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMDAwfSxcbiAgICAgICAge25hbWU6ICdjcmVhdGVkJywgdHlwZTogJ0xPTkdEQVRFVElNRScsIHZhbHVlOiBjcmVhdGVkVGltZXN0YW1wfSxcbiAgICAgICAge25hbWU6ICdtb2RpZmllZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogdGltZXN0YW1wfSxcbiAgICAgICAge25hbWU6ICd4TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lNaW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneE1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5TWF4JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hY1N0eWxlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdsb3dlc3RSZWNQUEVNJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdmb250RGlyZWN0aW9uSGludCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyfSxcbiAgICAgICAge25hbWU6ICdpbmRleFRvTG9jRm9ybWF0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2dseXBoRGF0YUZvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VIZWFkVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlSGVhZFRhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy90YWJsZXMvaGVhZC5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9oaGVhLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgaG9yaXpvbnRhbCBoZWFkZXIgYGhoZWFgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoaGVhID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmRlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhoZWEubWluTGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUmlzZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHJldHVybiBoaGVhO1xufVxuXG5mdW5jdGlvbiBtYWtlSGhlYVRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoaGVhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnYXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZGVzY2VuZGVyJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xpbmVHYXAnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYWR2YW5jZVdpZHRoTWF4JywgdHlwZTogJ1VGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5MZWZ0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluUmlnaHRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWF4RXh0ZW50JywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSaXNlJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSdW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQxJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDMnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQ0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21ldHJpY0RhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtYmVyT2ZITWV0cmljcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSGhlYVRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhoZWFUYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2hoZWEuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgYGhtdHhgIHRhYmxlIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2htdHguaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBgaG10eGAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIGF1Z21lbnRzIHRoZSBnbHlwaCBhcnJheSwgYWRkaW5nIHRoZSBhZHZhbmNlV2lkdGggYW5kIGxlZnRTaWRlQmVhcmluZyB0byBlYWNoIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VIbXR4VGFibGUoZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzKSB7XG4gICAgdmFyIGFkdmFuY2VXaWR0aDtcbiAgICB2YXIgbGVmdFNpZGVCZWFyaW5nO1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgZm9udCBpcyBtb25vc3BhY2VkLCBvbmx5IG9uZSBlbnRyeSBpcyBuZWVkZWQuIFRoaXMgbGFzdCBlbnRyeSBhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IGdseXBocy5cbiAgICAgICAgaWYgKGkgPCBudW1NZXRyaWNzKSB7XG4gICAgICAgICAgICBhZHZhbmNlV2lkdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IGFkdmFuY2VXaWR0aDtcbiAgICAgICAgZ2x5cGgubGVmdFNpZGVCZWFyaW5nID0gbGVmdFNpZGVCZWFyaW5nO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZUhtdHhUYWJsZShnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnaG10eCcsIFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICB2YXIgYWR2YW5jZVdpZHRoID0gZ2x5cGguYWR2YW5jZVdpZHRoIHx8IDA7XG4gICAgICAgIHZhciBsZWZ0U2lkZUJlYXJpbmcgPSBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgfHwgMDtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2FkdmFuY2VXaWR0aF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBhZHZhbmNlV2lkdGh9KTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlZnRTaWRlQmVhcmluZ18nICsgaSwgdHlwZTogJ1NIT1JUJywgdmFsdWU6IGxlZnRTaWRlQmVhcmluZ30pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VIbXR4VGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlSG10eFRhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy90YWJsZXMvaG10eC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSBgbHRhZ2AgdGFibGUgc3RvcmVzIElFVEYgQkNQLTQ3IGxhbmd1YWdlIHRhZ3MuIEl0IGFsbG93cyBzdXBwb3J0aW5nXG4vLyBsYW5ndWFnZXMgZm9yIHdoaWNoIFRydWVUeXBlIGRvZXMgbm90IGFzc2lnbiBhIG51bWVyaWMgY29kZS5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDYvQ2hhcDZsdGFnLmh0bWxcbi8vIGh0dHA6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvYXJ0aWNsZXMvbGFuZ3VhZ2UtdGFncy9cbi8vIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5L2xhbmd1YWdlLXN1YnRhZy1yZWdpc3RyeVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4uL2NoZWNrJyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuZnVuY3Rpb24gbWFrZUx0YWdUYWJsZSh0YWdzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyB0YWJsZS5UYWJsZSgnbHRhZycsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ251bVRhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogdGFncy5sZW5ndGh9XG4gICAgXSk7XG5cbiAgICB2YXIgc3RyaW5nUG9vbCA9ICcnO1xuICAgIHZhciBzdHJpbmdQb29sT2Zmc2V0ID0gMTIgKyB0YWdzLmxlbmd0aCAqIDQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwb3MgPSBzdHJpbmdQb29sLmluZGV4T2YodGFnc1tpXSk7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgICBwb3MgPSBzdHJpbmdQb29sLmxlbmd0aDtcbiAgICAgICAgICAgIHN0cmluZ1Bvb2wgKz0gdGFnc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ29mZnNldCAnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdHJpbmdQb29sT2Zmc2V0ICsgcG9zfSk7XG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlbmd0aCAnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiB0YWdzW2ldLmxlbmd0aH0pO1xuICAgIH1cblxuICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ3N0cmluZ1Bvb2wnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6IHN0cmluZ1Bvb2x9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUx0YWdUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIGx0YWcgdGFibGUgdmVyc2lvbi4nKTtcbiAgICAvLyBUaGUgJ2x0YWcnIHNwZWNpZmljYXRpb24gZG9lcyBub3QgZGVmaW5lIGFueSBmbGFnczsgc2tpcCB0aGUgZmllbGQuXG4gICAgcC5za2lwKCd1TG9uZycsIDEpO1xuICAgIHZhciBudW1UYWdzID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICB2YXIgdGFncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFnczsgaSsrKSB7XG4gICAgICAgIHZhciB0YWcgPSAnJztcbiAgICAgICAgdmFyIG9mZnNldCA9IHN0YXJ0ICsgcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBmb3IgKHZhciBqID0gb2Zmc2V0OyBqIDwgb2Zmc2V0ICsgbGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGEuZ2V0SW50OChqKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YWdzLnB1c2godGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFncztcbn1cblxuZXhwb3J0cy5tYWtlID0gbWFrZUx0YWdUYWJsZTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZUx0YWdUYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2x0YWcuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgYG1heHBgIHRhYmxlIGVzdGFibGlzaGVzIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGZvciB0aGUgZm9udC5cbi8vIFdlIG5lZWQgaXQganVzdCB0byBnZXQgdGhlIG51bWJlciBvZiBnbHlwaHMgaW4gdGhlIGZvbnQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL21heHAuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBtYXhpbXVtIHByb2ZpbGUgYG1heHBgIHRhYmxlLlxuZnVuY3Rpb24gcGFyc2VNYXhwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgbWF4cCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgbWF4cC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBtYXhwLm51bUdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAobWF4cC52ZXJzaW9uID09PSAxLjApIHtcbiAgICAgICAgbWF4cC5tYXhQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlUG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvc2l0ZUNvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFpvbmVzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFR3aWxpZ2h0UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0b3JhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4RnVuY3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heEluc3RydWN0aW9uRGVmcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTdGFja0VsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFNpemVPZkluc3RydWN0aW9ucyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb25lbnRFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb25lbnREZXB0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4cDtcbn1cblxuZnVuY3Rpb24gbWFrZU1heHBUYWJsZShudW1HbHlwaHMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdtYXhwJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAwNTAwMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtR2x5cGhzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBudW1HbHlwaHN9XG4gICAgXSk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZU1heHBUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VNYXhwVGFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9tYXhwLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhlIGBHUE9TYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2dwb3MuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVzID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbnZhciBkZWNvZGUgPSB0eXBlcy5kZWNvZGU7XG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBtZXRhZGF0YSBgbWV0YWAgdGFibGUuXG4vLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2bWV0YS5odG1sXG5mdW5jdGlvbiBwYXJzZU1ldGFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIE1FVEEgdGFibGUgdmVyc2lvbi4nKTtcbiAgICBwLnBhcnNlVUxvbmcoKTsgLy8gZmxhZ3MgLSBjdXJyZW50bHkgdW51c2VkIGFuZCBzZXQgdG8gMFxuICAgIHAucGFyc2VVTG9uZygpOyAvLyB0YWJsZU9mZnNldFxuICAgIHZhciBudW1EYXRhTWFwcyA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgdmFyIHRhZ3MgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFNYXBzOyBpKyspIHtcbiAgICAgICAgdmFyIHRhZyA9IHAucGFyc2VUYWcoKTtcbiAgICAgICAgdmFyIGRhdGFPZmZzZXQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIHRleHQgPSBkZWNvZGUuVVRGOChkYXRhLCBzdGFydCArIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xuXG4gICAgICAgIHRhZ3NbdGFnXSA9IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiBtYWtlTWV0YVRhYmxlKHRhZ3MpIHtcbiAgICB2YXIgbnVtVGFncyA9IE9iamVjdC5rZXlzKHRhZ3MpLmxlbmd0aDtcbiAgICB2YXIgc3RyaW5nUG9vbCA9ICcnO1xuICAgIHZhciBzdHJpbmdQb29sT2Zmc2V0ID0gMTYgKyBudW1UYWdzICogMTI7XG5cbiAgICB2YXIgcmVzdWx0ID0gbmV3IHRhYmxlLlRhYmxlKCdtZXRhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnZmxhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHN0cmluZ1Bvb2xPZmZzZXR9LFxuICAgICAgICB7bmFtZTogJ251bVRhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogbnVtVGFnc31cbiAgICBdKTtcblxuICAgIGZvciAodmFyIHRhZyBpbiB0YWdzKSB7XG4gICAgICAgIHZhciBwb3MgPSBzdHJpbmdQb29sLmxlbmd0aDtcbiAgICAgICAgc3RyaW5nUG9vbCArPSB0YWdzW3RhZ107XG5cbiAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAndGFnICcgKyB0YWcsIHR5cGU6ICdUQUcnLCB2YWx1ZTogdGFnfSk7XG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ29mZnNldCAnICsgdGFnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogc3RyaW5nUG9vbE9mZnNldCArIHBvc30pO1xuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdsZW5ndGggJyArIHRhZywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHRhZ3NbdGFnXS5sZW5ndGh9KTtcbiAgICB9XG5cbiAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdQb29sJywgdHlwZTogJ0NIQVJBUlJBWScsIHZhbHVlOiBzdHJpbmdQb29sfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VNZXRhVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlTWV0YVRhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy90YWJsZXMvbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSBgbmFtZWAgbmFtaW5nIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9uYW1lLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlcyA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG52YXIgZGVjb2RlID0gdHlwZXMuZGVjb2RlO1xudmFyIGVuY29kZSA9IHR5cGVzLmVuY29kZTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBOYW1lSURzIGZvciB0aGUgbmFtZSB0YWJsZS5cbnZhciBuYW1lVGFibGVOYW1lcyA9IFtcbiAgICAnY29weXJpZ2h0JywgICAgICAgICAgICAgIC8vIDBcbiAgICAnZm9udEZhbWlseScsICAgICAgICAgICAgIC8vIDFcbiAgICAnZm9udFN1YmZhbWlseScsICAgICAgICAgIC8vIDJcbiAgICAndW5pcXVlSUQnLCAgICAgICAgICAgICAgIC8vIDNcbiAgICAnZnVsbE5hbWUnLCAgICAgICAgICAgICAgIC8vIDRcbiAgICAndmVyc2lvbicsICAgICAgICAgICAgICAgIC8vIDVcbiAgICAncG9zdFNjcmlwdE5hbWUnLCAgICAgICAgIC8vIDZcbiAgICAndHJhZGVtYXJrJywgICAgICAgICAgICAgIC8vIDdcbiAgICAnbWFudWZhY3R1cmVyJywgICAgICAgICAgIC8vIDhcbiAgICAnZGVzaWduZXInLCAgICAgICAgICAgICAgIC8vIDlcbiAgICAnZGVzY3JpcHRpb24nLCAgICAgICAgICAgIC8vIDEwXG4gICAgJ21hbnVmYWN0dXJlclVSTCcsICAgICAgICAvLyAxMVxuICAgICdkZXNpZ25lclVSTCcsICAgICAgICAgICAgLy8gMTJcbiAgICAnbGljZW5zZScsICAgICAgICAgICAgICAgIC8vIDEzXG4gICAgJ2xpY2Vuc2VVUkwnLCAgICAgICAgICAgICAvLyAxNFxuICAgICdyZXNlcnZlZCcsICAgICAgICAgICAgICAgLy8gMTVcbiAgICAncHJlZmVycmVkRmFtaWx5JywgICAgICAgIC8vIDE2XG4gICAgJ3ByZWZlcnJlZFN1YmZhbWlseScsICAgICAvLyAxN1xuICAgICdjb21wYXRpYmxlRnVsbE5hbWUnLCAgICAgLy8gMThcbiAgICAnc2FtcGxlVGV4dCcsICAgICAgICAgICAgIC8vIDE5XG4gICAgJ3Bvc3RTY3JpcHRGaW5kRm9udE5hbWUnLCAvLyAyMFxuICAgICd3d3NGYW1pbHknLCAgICAgICAgICAgICAgLy8gMjFcbiAgICAnd3dzU3ViZmFtaWx5JyAgICAgICAgICAgIC8vIDIyXG5dO1xuXG52YXIgbWFjTGFuZ3VhZ2VzID0ge1xuICAgIDA6ICdlbicsXG4gICAgMTogJ2ZyJyxcbiAgICAyOiAnZGUnLFxuICAgIDM6ICdpdCcsXG4gICAgNDogJ25sJyxcbiAgICA1OiAnc3YnLFxuICAgIDY6ICdlcycsXG4gICAgNzogJ2RhJyxcbiAgICA4OiAncHQnLFxuICAgIDk6ICdubycsXG4gICAgMTA6ICdoZScsXG4gICAgMTE6ICdqYScsXG4gICAgMTI6ICdhcicsXG4gICAgMTM6ICdmaScsXG4gICAgMTQ6ICdlbCcsXG4gICAgMTU6ICdpcycsXG4gICAgMTY6ICdtdCcsXG4gICAgMTc6ICd0cicsXG4gICAgMTg6ICdocicsXG4gICAgMTk6ICd6aC1IYW50JyxcbiAgICAyMDogJ3VyJyxcbiAgICAyMTogJ2hpJyxcbiAgICAyMjogJ3RoJyxcbiAgICAyMzogJ2tvJyxcbiAgICAyNDogJ2x0JyxcbiAgICAyNTogJ3BsJyxcbiAgICAyNjogJ2h1JyxcbiAgICAyNzogJ2VzJyxcbiAgICAyODogJ2x2JyxcbiAgICAyOTogJ3NlJyxcbiAgICAzMDogJ2ZvJyxcbiAgICAzMTogJ2ZhJyxcbiAgICAzMjogJ3J1JyxcbiAgICAzMzogJ3poJyxcbiAgICAzNDogJ25sLUJFJyxcbiAgICAzNTogJ2dhJyxcbiAgICAzNjogJ3NxJyxcbiAgICAzNzogJ3JvJyxcbiAgICAzODogJ2N6JyxcbiAgICAzOTogJ3NrJyxcbiAgICA0MDogJ3NpJyxcbiAgICA0MTogJ3lpJyxcbiAgICA0MjogJ3NyJyxcbiAgICA0MzogJ21rJyxcbiAgICA0NDogJ2JnJyxcbiAgICA0NTogJ3VrJyxcbiAgICA0NjogJ2JlJyxcbiAgICA0NzogJ3V6JyxcbiAgICA0ODogJ2trJyxcbiAgICA0OTogJ2F6LUN5cmwnLFxuICAgIDUwOiAnYXotQXJhYicsXG4gICAgNTE6ICdoeScsXG4gICAgNTI6ICdrYScsXG4gICAgNTM6ICdtbycsXG4gICAgNTQ6ICdreScsXG4gICAgNTU6ICd0ZycsXG4gICAgNTY6ICd0aycsXG4gICAgNTc6ICdtbi1DTicsXG4gICAgNTg6ICdtbicsXG4gICAgNTk6ICdwcycsXG4gICAgNjA6ICdrcycsXG4gICAgNjE6ICdrdScsXG4gICAgNjI6ICdzZCcsXG4gICAgNjM6ICdibycsXG4gICAgNjQ6ICduZScsXG4gICAgNjU6ICdzYScsXG4gICAgNjY6ICdtcicsXG4gICAgNjc6ICdibicsXG4gICAgNjg6ICdhcycsXG4gICAgNjk6ICdndScsXG4gICAgNzA6ICdwYScsXG4gICAgNzE6ICdvcicsXG4gICAgNzI6ICdtbCcsXG4gICAgNzM6ICdrbicsXG4gICAgNzQ6ICd0YScsXG4gICAgNzU6ICd0ZScsXG4gICAgNzY6ICdzaScsXG4gICAgNzc6ICdteScsXG4gICAgNzg6ICdrbScsXG4gICAgNzk6ICdsbycsXG4gICAgODA6ICd2aScsXG4gICAgODE6ICdpZCcsXG4gICAgODI6ICd0bCcsXG4gICAgODM6ICdtcycsXG4gICAgODQ6ICdtcy1BcmFiJyxcbiAgICA4NTogJ2FtJyxcbiAgICA4NjogJ3RpJyxcbiAgICA4NzogJ29tJyxcbiAgICA4ODogJ3NvJyxcbiAgICA4OTogJ3N3JyxcbiAgICA5MDogJ3J3JyxcbiAgICA5MTogJ3JuJyxcbiAgICA5MjogJ255JyxcbiAgICA5MzogJ21nJyxcbiAgICA5NDogJ2VvJyxcbiAgICAxMjg6ICdjeScsXG4gICAgMTI5OiAnZXUnLFxuICAgIDEzMDogJ2NhJyxcbiAgICAxMzE6ICdsYScsXG4gICAgMTMyOiAncXUnLFxuICAgIDEzMzogJ2duJyxcbiAgICAxMzQ6ICdheScsXG4gICAgMTM1OiAndHQnLFxuICAgIDEzNjogJ3VnJyxcbiAgICAxMzc6ICdkeicsXG4gICAgMTM4OiAnanYnLFxuICAgIDEzOTogJ3N1JyxcbiAgICAxNDA6ICdnbCcsXG4gICAgMTQxOiAnYWYnLFxuICAgIDE0MjogJ2JyJyxcbiAgICAxNDM6ICdpdScsXG4gICAgMTQ0OiAnZ2QnLFxuICAgIDE0NTogJ2d2JyxcbiAgICAxNDY6ICdnYScsXG4gICAgMTQ3OiAndG8nLFxuICAgIDE0ODogJ2VsLXBvbHl0b24nLFxuICAgIDE0OTogJ2tsJyxcbiAgICAxNTA6ICdheicsXG4gICAgMTUxOiAnbm4nXG59O1xuXG4vLyBNYWNPUyBsYW5ndWFnZSBJRCDihpIgTWFjT1Mgc2NyaXB0IElEXG4vL1xuLy8gTm90ZSB0aGF0IHRoZSBzY3JpcHQgSUQgaXMgbm90IHN1ZmZpY2llbnQgdG8gZGV0ZXJtaW5lIHdoYXQgZW5jb2Rpbmdcbi8vIHRvIHVzZSBpbiBUcnVlVHlwZSBmaWxlcy4gRm9yIHNvbWUgbGFuZ3VhZ2VzLCBNYWNPUyB1c2VkIGEgbW9kaWZpY2F0aW9uXG4vLyBvZiBhIG1haW5zdHJlYW0gc2NyaXB0LiBGb3IgZXhhbXBsZSwgYW4gSWNlbGFuZGljIG5hbWUgd291bGQgYmUgc3RvcmVkXG4vLyB3aXRoIHNtUm9tYW4gaW4gdGhlIFRydWVUeXBlIG5hbWluZyB0YWJsZSwgYnV0IHRoZSBhY3R1YWwgZW5jb2Rpbmdcbi8vIGlzIGEgc3BlY2lhbCBJY2VsYW5kaWMgdmVyc2lvbiBvZiB0aGUgbm9ybWFsIE1hY2ludG9zaCBSb21hbiBlbmNvZGluZy5cbi8vIEFzIGFub3RoZXIgZXhhbXBsZSwgSW51a3RpdHV0IHVzZXMgYW4gOC1iaXQgZW5jb2RpbmcgZm9yIENhbmFkaWFuIEFib3JpZ2luYWxcbi8vIFN5bGxhYmxlcyBidXQgTWFjT1MgaGFkIHJ1biBvdXQgb2YgYXZhaWxhYmxlIHNjcmlwdCBjb2Rlcywgc28gdGhpcyB3YXNcbi8vIGRvbmUgYXMgYSAocHJldHR5IHJhZGljYWwpIFwibW9kaWZpY2F0aW9uXCIgb2YgRXRoaW9waWMuXG4vL1xuLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL1JlYWRtZS50eHRcbnZhciBtYWNMYW5ndWFnZVRvU2NyaXB0ID0ge1xuICAgIDA6IDAsICAvLyBsYW5nRW5nbGlzaCDihpIgc21Sb21hblxuICAgIDE6IDAsICAvLyBsYW5nRnJlbmNoIOKGkiBzbVJvbWFuXG4gICAgMjogMCwgIC8vIGxhbmdHZXJtYW4g4oaSIHNtUm9tYW5cbiAgICAzOiAwLCAgLy8gbGFuZ0l0YWxpYW4g4oaSIHNtUm9tYW5cbiAgICA0OiAwLCAgLy8gbGFuZ0R1dGNoIOKGkiBzbVJvbWFuXG4gICAgNTogMCwgIC8vIGxhbmdTd2VkaXNoIOKGkiBzbVJvbWFuXG4gICAgNjogMCwgIC8vIGxhbmdTcGFuaXNoIOKGkiBzbVJvbWFuXG4gICAgNzogMCwgIC8vIGxhbmdEYW5pc2gg4oaSIHNtUm9tYW5cbiAgICA4OiAwLCAgLy8gbGFuZ1BvcnR1Z3Vlc2Ug4oaSIHNtUm9tYW5cbiAgICA5OiAwLCAgLy8gbGFuZ05vcndlZ2lhbiDihpIgc21Sb21hblxuICAgIDEwOiA1LCAgLy8gbGFuZ0hlYnJldyDihpIgc21IZWJyZXdcbiAgICAxMTogMSwgIC8vIGxhbmdKYXBhbmVzZSDihpIgc21KYXBhbmVzZVxuICAgIDEyOiA0LCAgLy8gbGFuZ0FyYWJpYyDihpIgc21BcmFiaWNcbiAgICAxMzogMCwgIC8vIGxhbmdGaW5uaXNoIOKGkiBzbVJvbWFuXG4gICAgMTQ6IDYsICAvLyBsYW5nR3JlZWsg4oaSIHNtR3JlZWtcbiAgICAxNTogMCwgIC8vIGxhbmdJY2VsYW5kaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE2OiAwLCAgLy8gbGFuZ01hbHRlc2Ug4oaSIHNtUm9tYW5cbiAgICAxNzogMCwgIC8vIGxhbmdUdXJraXNoIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxODogMCwgIC8vIGxhbmdDcm9hdGlhbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTk6IDIsICAvLyBsYW5nVHJhZENoaW5lc2Ug4oaSIHNtVHJhZENoaW5lc2VcbiAgICAyMDogNCwgIC8vIGxhbmdVcmR1IOKGkiBzbUFyYWJpY1xuICAgIDIxOiA5LCAgLy8gbGFuZ0hpbmRpIOKGkiBzbURldmFuYWdhcmlcbiAgICAyMjogMjEsICAvLyBsYW5nVGhhaSDihpIgc21UaGFpXG4gICAgMjM6IDMsICAvLyBsYW5nS29yZWFuIOKGkiBzbUtvcmVhblxuICAgIDI0OiAyOSwgIC8vIGxhbmdMaXRodWFuaWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyNTogMjksICAvLyBsYW5nUG9saXNoIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyNjogMjksICAvLyBsYW5nSHVuZ2FyaWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyNzogMjksICAvLyBsYW5nRXN0b25pYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI4OiAyOSwgIC8vIGxhbmdMYXR2aWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyOTogMCwgIC8vIGxhbmdTYW1pIOKGkiBzbVJvbWFuXG4gICAgMzA6IDAsICAvLyBsYW5nRmFyb2VzZSDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMzE6IDQsICAvLyBsYW5nRmFyc2kg4oaSIHNtQXJhYmljIChtb2RpZmllZClcbiAgICAzMjogNywgIC8vIGxhbmdSdXNzaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgMzM6IDI1LCAgLy8gbGFuZ1NpbXBDaGluZXNlIOKGkiBzbVNpbXBDaGluZXNlXG4gICAgMzQ6IDAsICAvLyBsYW5nRmxlbWlzaCDihpIgc21Sb21hblxuICAgIDM1OiAwLCAgLy8gbGFuZ0lyaXNoR2FlbGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAzNjogMCwgIC8vIGxhbmdBbGJhbmlhbiDihpIgc21Sb21hblxuICAgIDM3OiAwLCAgLy8gbGFuZ1JvbWFuaWFuIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAzODogMjksICAvLyBsYW5nQ3plY2gg4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDM5OiAyOSwgIC8vIGxhbmdTbG92YWsg4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDQwOiAwLCAgLy8gbGFuZ1Nsb3ZlbmlhbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgNDE6IDUsICAvLyBsYW5nWWlkZGlzaCDihpIgc21IZWJyZXdcbiAgICA0MjogNywgIC8vIGxhbmdTZXJiaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNDM6IDcsICAvLyBsYW5nTWFjZWRvbmlhbiDihpIgc21DeXJpbGxpY1xuICAgIDQ0OiA3LCAgLy8gbGFuZ0J1bGdhcmlhbiDihpIgc21DeXJpbGxpY1xuICAgIDQ1OiA3LCAgLy8gbGFuZ1VrcmFpbmlhbiDihpIgc21DeXJpbGxpYyAobW9kaWZpZWQpXG4gICAgNDY6IDcsICAvLyBsYW5nQnllbG9ydXNzaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNDc6IDcsICAvLyBsYW5nVXpiZWsg4oaSIHNtQ3lyaWxsaWNcbiAgICA0ODogNywgIC8vIGxhbmdLYXpha2gg4oaSIHNtQ3lyaWxsaWNcbiAgICA0OTogNywgIC8vIGxhbmdBemVyYmFpamFuaSDihpIgc21DeXJpbGxpY1xuICAgIDUwOiA0LCAgLy8gbGFuZ0F6ZXJiYWlqYW5BciDihpIgc21BcmFiaWNcbiAgICA1MTogMjQsICAvLyBsYW5nQXJtZW5pYW4g4oaSIHNtQXJtZW5pYW5cbiAgICA1MjogMjMsICAvLyBsYW5nR2VvcmdpYW4g4oaSIHNtR2VvcmdpYW5cbiAgICA1MzogNywgIC8vIGxhbmdNb2xkYXZpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA1NDogNywgIC8vIGxhbmdLaXJnaGl6IOKGkiBzbUN5cmlsbGljXG4gICAgNTU6IDcsICAvLyBsYW5nVGFqaWtpIOKGkiBzbUN5cmlsbGljXG4gICAgNTY6IDcsICAvLyBsYW5nVHVya21lbiDihpIgc21DeXJpbGxpY1xuICAgIDU3OiAyNywgIC8vIGxhbmdNb25nb2xpYW4g4oaSIHNtTW9uZ29saWFuXG4gICAgNTg6IDcsICAvLyBsYW5nTW9uZ29saWFuQ3lyIOKGkiBzbUN5cmlsbGljXG4gICAgNTk6IDQsICAvLyBsYW5nUGFzaHRvIOKGkiBzbUFyYWJpY1xuICAgIDYwOiA0LCAgLy8gbGFuZ0t1cmRpc2gg4oaSIHNtQXJhYmljXG4gICAgNjE6IDQsICAvLyBsYW5nS2FzaG1pcmkg4oaSIHNtQXJhYmljXG4gICAgNjI6IDQsICAvLyBsYW5nU2luZGhpIOKGkiBzbUFyYWJpY1xuICAgIDYzOiAyNiwgIC8vIGxhbmdUaWJldGFuIOKGkiBzbVRpYmV0YW5cbiAgICA2NDogOSwgIC8vIGxhbmdOZXBhbGkg4oaSIHNtRGV2YW5hZ2FyaVxuICAgIDY1OiA5LCAgLy8gbGFuZ1NhbnNrcml0IOKGkiBzbURldmFuYWdhcmlcbiAgICA2NjogOSwgIC8vIGxhbmdNYXJhdGhpIOKGkiBzbURldmFuYWdhcmlcbiAgICA2NzogMTMsICAvLyBsYW5nQmVuZ2FsaSDihpIgc21CZW5nYWxpXG4gICAgNjg6IDEzLCAgLy8gbGFuZ0Fzc2FtZXNlIOKGkiBzbUJlbmdhbGlcbiAgICA2OTogMTEsICAvLyBsYW5nR3VqYXJhdGkg4oaSIHNtR3VqYXJhdGlcbiAgICA3MDogMTAsICAvLyBsYW5nUHVuamFiaSDihpIgc21HdXJtdWtoaVxuICAgIDcxOiAxMiwgIC8vIGxhbmdPcml5YSDihpIgc21Pcml5YVxuICAgIDcyOiAxNywgIC8vIGxhbmdNYWxheWFsYW0g4oaSIHNtTWFsYXlhbGFtXG4gICAgNzM6IDE2LCAgLy8gbGFuZ0thbm5hZGEg4oaSIHNtS2FubmFkYVxuICAgIDc0OiAxNCwgIC8vIGxhbmdUYW1pbCDihpIgc21UYW1pbFxuICAgIDc1OiAxNSwgIC8vIGxhbmdUZWx1Z3Ug4oaSIHNtVGVsdWd1XG4gICAgNzY6IDE4LCAgLy8gbGFuZ1NpbmhhbGVzZSDihpIgc21TaW5oYWxlc2VcbiAgICA3NzogMTksICAvLyBsYW5nQnVybWVzZSDihpIgc21CdXJtZXNlXG4gICAgNzg6IDIwLCAgLy8gbGFuZ0tobWVyIOKGkiBzbUtobWVyXG4gICAgNzk6IDIyLCAgLy8gbGFuZ0xhbyDihpIgc21MYW9cbiAgICA4MDogMzAsICAvLyBsYW5nVmlldG5hbWVzZSDihpIgc21WaWV0bmFtZXNlXG4gICAgODE6IDAsICAvLyBsYW5nSW5kb25lc2lhbiDihpIgc21Sb21hblxuICAgIDgyOiAwLCAgLy8gbGFuZ1RhZ2Fsb2cg4oaSIHNtUm9tYW5cbiAgICA4MzogMCwgIC8vIGxhbmdNYWxheVJvbWFuIOKGkiBzbVJvbWFuXG4gICAgODQ6IDQsICAvLyBsYW5nTWFsYXlBcmFiaWMg4oaSIHNtQXJhYmljXG4gICAgODU6IDI4LCAgLy8gbGFuZ0FtaGFyaWMg4oaSIHNtRXRoaW9waWNcbiAgICA4NjogMjgsICAvLyBsYW5nVGlncmlueWEg4oaSIHNtRXRoaW9waWNcbiAgICA4NzogMjgsICAvLyBsYW5nT3JvbW8g4oaSIHNtRXRoaW9waWNcbiAgICA4ODogMCwgIC8vIGxhbmdTb21hbGkg4oaSIHNtUm9tYW5cbiAgICA4OTogMCwgIC8vIGxhbmdTd2FoaWxpIOKGkiBzbVJvbWFuXG4gICAgOTA6IDAsICAvLyBsYW5nS2lueWFyd2FuZGEg4oaSIHNtUm9tYW5cbiAgICA5MTogMCwgIC8vIGxhbmdSdW5kaSDihpIgc21Sb21hblxuICAgIDkyOiAwLCAgLy8gbGFuZ055YW5qYSDihpIgc21Sb21hblxuICAgIDkzOiAwLCAgLy8gbGFuZ01hbGFnYXN5IOKGkiBzbVJvbWFuXG4gICAgOTQ6IDAsICAvLyBsYW5nRXNwZXJhbnRvIOKGkiBzbVJvbWFuXG4gICAgMTI4OiAwLCAgLy8gbGFuZ1dlbHNoIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxMjk6IDAsICAvLyBsYW5nQmFzcXVlIOKGkiBzbVJvbWFuXG4gICAgMTMwOiAwLCAgLy8gbGFuZ0NhdGFsYW4g4oaSIHNtUm9tYW5cbiAgICAxMzE6IDAsICAvLyBsYW5nTGF0aW4g4oaSIHNtUm9tYW5cbiAgICAxMzI6IDAsICAvLyBsYW5nUXVlY2h1YSDihpIgc21Sb21hblxuICAgIDEzMzogMCwgIC8vIGxhbmdHdWFyYW5pIOKGkiBzbVJvbWFuXG4gICAgMTM0OiAwLCAgLy8gbGFuZ0F5bWFyYSDihpIgc21Sb21hblxuICAgIDEzNTogNywgIC8vIGxhbmdUYXRhciDihpIgc21DeXJpbGxpY1xuICAgIDEzNjogNCwgIC8vIGxhbmdVaWdodXIg4oaSIHNtQXJhYmljXG4gICAgMTM3OiAyNiwgIC8vIGxhbmdEem9uZ2toYSDihpIgc21UaWJldGFuXG4gICAgMTM4OiAwLCAgLy8gbGFuZ0phdmFuZXNlUm9tIOKGkiBzbVJvbWFuXG4gICAgMTM5OiAwLCAgLy8gbGFuZ1N1bmRhbmVzZVJvbSDihpIgc21Sb21hblxuICAgIDE0MDogMCwgIC8vIGxhbmdHYWxpY2lhbiDihpIgc21Sb21hblxuICAgIDE0MTogMCwgIC8vIGxhbmdBZnJpa2FhbnMg4oaSIHNtUm9tYW5cbiAgICAxNDI6IDAsICAvLyBsYW5nQnJldG9uIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNDM6IDI4LCAgLy8gbGFuZ0ludWt0aXR1dCDihpIgc21FdGhpb3BpYyAobW9kaWZpZWQpXG4gICAgMTQ0OiAwLCAgLy8gbGFuZ1Njb3R0aXNoR2FlbGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNDU6IDAsICAvLyBsYW5nTWFueEdhZWxpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTQ2OiAwLCAgLy8gbGFuZ0lyaXNoR2FlbGljU2NyaXB0IOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNDc6IDAsICAvLyBsYW5nVG9uZ2FuIOKGkiBzbVJvbWFuXG4gICAgMTQ4OiA2LCAgLy8gbGFuZ0dyZWVrQW5jaWVudCDihpIgc21Sb21hblxuICAgIDE0OTogMCwgIC8vIGxhbmdHcmVlbmxhbmRpYyDihpIgc21Sb21hblxuICAgIDE1MDogMCwgIC8vIGxhbmdBemVyYmFpamFuUm9tYW4g4oaSIHNtUm9tYW5cbiAgICAxNTE6IDAgICAvLyBsYW5nTnlub3JzayDihpIgc21Sb21hblxufTtcblxuLy8gV2hpbGUgTWljcm9zb2Z0IGluZGljYXRlcyBhIHJlZ2lvbi9jb3VudHJ5IGZvciBhbGwgaXRzIGxhbmd1YWdlXG4vLyBJRHMsIHdlIG9taXQgdGhlIHJlZ2lvbiBjb2RlIGlmIGl0J3MgZXF1YWwgdG8gdGhlIFwibW9zdCBsaWtlbHlcbi8vIHJlZ2lvbiBzdWJ0YWdcIiBhY2NvcmRpbmcgdG8gVW5pY29kZSBDTERSLiBGb3Igc2NyaXB0cywgd2Ugb21pdFxuLy8gdGhlIHN1YnRhZyBpZiBpdCBpcyBlcXVhbCB0byB0aGUgU3VwcHJlc3MtU2NyaXB0IGVudHJ5IGluIHRoZVxuLy8gSUFOQSBsYW5ndWFnZSBzdWJ0YWcgcmVnaXN0cnkgZm9yIElFVEYgQkNQIDQ3LlxuLy9cbi8vIEZvciBleGFtcGxlLCBNaWNyb3NvZnQgc3RhdGVzIHRoYXQgaXRzIGxhbmd1YWdlIGNvZGUgMHgwNDFBIGlzXG4vLyBDcm9hdGlhbiBpbiBDcm9hdGlhLiBXZSB0cmFuc2Zvcm0gdGhpcyB0byB0aGUgQkNQIDQ3IGxhbmd1YWdlIGNvZGUgJ2hyJ1xuLy8gYW5kIG5vdCAnaHItSFInIGJlY2F1c2UgQ3JvYXRpYSBpcyB0aGUgZGVmYXVsdCBjb3VudHJ5IGZvciBDcm9hdGlhbixcbi8vIGFjY29yZGluZyB0byBVbmljb2RlIENMRFIuIEFzIGFub3RoZXIgZXhhbXBsZSwgTWljcm9zb2Z0IHN0YXRlc1xuLy8gdGhhdCAweDEwMUEgaXMgQ3JvYXRpYW4gKExhdGluKSBpbiBCb3NuaWEtSGVyemVnb3ZpbmEuIFdlIHRyYW5zZm9ybVxuLy8gdGhpcyB0byAnaHItQkEnIGFuZCBub3QgJ2hyLUxhdG4tQkEnIGJlY2F1c2UgTGF0aW4gaXMgdGhlIGRlZmF1bHQgc2NyaXB0XG4vLyBmb3IgdGhlIENyb2F0aWFuIGxhbmd1YWdlLCBhY2NvcmRpbmcgdG8gSUFOQS5cbi8vXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL2NsZHIvY2hhcnRzL2xhdGVzdC9zdXBwbGVtZW50YWwvbGlrZWx5X3N1YnRhZ3MuaHRtbFxuLy8gaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9sYW5ndWFnZS1zdWJ0YWctcmVnaXN0cnkvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5XG52YXIgd2luZG93c0xhbmd1YWdlcyA9IHtcbiAgICAweDA0MzY6ICdhZicsXG4gICAgMHgwNDFDOiAnc3EnLFxuICAgIDB4MDQ4NDogJ2dzdycsXG4gICAgMHgwNDVFOiAnYW0nLFxuICAgIDB4MTQwMTogJ2FyLURaJyxcbiAgICAweDNDMDE6ICdhci1CSCcsXG4gICAgMHgwQzAxOiAnYXInLFxuICAgIDB4MDgwMTogJ2FyLUlRJyxcbiAgICAweDJDMDE6ICdhci1KTycsXG4gICAgMHgzNDAxOiAnYXItS1cnLFxuICAgIDB4MzAwMTogJ2FyLUxCJyxcbiAgICAweDEwMDE6ICdhci1MWScsXG4gICAgMHgxODAxOiAnYXJ5JyxcbiAgICAweDIwMDE6ICdhci1PTScsXG4gICAgMHg0MDAxOiAnYXItUUEnLFxuICAgIDB4MDQwMTogJ2FyLVNBJyxcbiAgICAweDI4MDE6ICdhci1TWScsXG4gICAgMHgxQzAxOiAnYWViJyxcbiAgICAweDM4MDE6ICdhci1BRScsXG4gICAgMHgyNDAxOiAnYXItWUUnLFxuICAgIDB4MDQyQjogJ2h5JyxcbiAgICAweDA0NEQ6ICdhcycsXG4gICAgMHgwODJDOiAnYXotQ3lybCcsXG4gICAgMHgwNDJDOiAnYXonLFxuICAgIDB4MDQ2RDogJ2JhJyxcbiAgICAweDA0MkQ6ICdldScsXG4gICAgMHgwNDIzOiAnYmUnLFxuICAgIDB4MDg0NTogJ2JuJyxcbiAgICAweDA0NDU6ICdibi1JTicsXG4gICAgMHgyMDFBOiAnYnMtQ3lybCcsXG4gICAgMHgxNDFBOiAnYnMnLFxuICAgIDB4MDQ3RTogJ2JyJyxcbiAgICAweDA0MDI6ICdiZycsXG4gICAgMHgwNDAzOiAnY2EnLFxuICAgIDB4MEMwNDogJ3poLUhLJyxcbiAgICAweDE0MDQ6ICd6aC1NTycsXG4gICAgMHgwODA0OiAnemgnLFxuICAgIDB4MTAwNDogJ3poLVNHJyxcbiAgICAweDA0MDQ6ICd6aC1UVycsXG4gICAgMHgwNDgzOiAnY28nLFxuICAgIDB4MDQxQTogJ2hyJyxcbiAgICAweDEwMUE6ICdoci1CQScsXG4gICAgMHgwNDA1OiAnY3MnLFxuICAgIDB4MDQwNjogJ2RhJyxcbiAgICAweDA0OEM6ICdwcnMnLFxuICAgIDB4MDQ2NTogJ2R2JyxcbiAgICAweDA4MTM6ICdubC1CRScsXG4gICAgMHgwNDEzOiAnbmwnLFxuICAgIDB4MEMwOTogJ2VuLUFVJyxcbiAgICAweDI4MDk6ICdlbi1CWicsXG4gICAgMHgxMDA5OiAnZW4tQ0EnLFxuICAgIDB4MjQwOTogJ2VuLTAyOScsXG4gICAgMHg0MDA5OiAnZW4tSU4nLFxuICAgIDB4MTgwOTogJ2VuLUlFJyxcbiAgICAweDIwMDk6ICdlbi1KTScsXG4gICAgMHg0NDA5OiAnZW4tTVknLFxuICAgIDB4MTQwOTogJ2VuLU5aJyxcbiAgICAweDM0MDk6ICdlbi1QSCcsXG4gICAgMHg0ODA5OiAnZW4tU0cnLFxuICAgIDB4MUMwOTogJ2VuLVpBJyxcbiAgICAweDJDMDk6ICdlbi1UVCcsXG4gICAgMHgwODA5OiAnZW4tR0InLFxuICAgIDB4MDQwOTogJ2VuJyxcbiAgICAweDMwMDk6ICdlbi1aVycsXG4gICAgMHgwNDI1OiAnZXQnLFxuICAgIDB4MDQzODogJ2ZvJyxcbiAgICAweDA0NjQ6ICdmaWwnLFxuICAgIDB4MDQwQjogJ2ZpJyxcbiAgICAweDA4MEM6ICdmci1CRScsXG4gICAgMHgwQzBDOiAnZnItQ0EnLFxuICAgIDB4MDQwQzogJ2ZyJyxcbiAgICAweDE0MEM6ICdmci1MVScsXG4gICAgMHgxODBDOiAnZnItTUMnLFxuICAgIDB4MTAwQzogJ2ZyLUNIJyxcbiAgICAweDA0NjI6ICdmeScsXG4gICAgMHgwNDU2OiAnZ2wnLFxuICAgIDB4MDQzNzogJ2thJyxcbiAgICAweDBDMDc6ICdkZS1BVCcsXG4gICAgMHgwNDA3OiAnZGUnLFxuICAgIDB4MTQwNzogJ2RlLUxJJyxcbiAgICAweDEwMDc6ICdkZS1MVScsXG4gICAgMHgwODA3OiAnZGUtQ0gnLFxuICAgIDB4MDQwODogJ2VsJyxcbiAgICAweDA0NkY6ICdrbCcsXG4gICAgMHgwNDQ3OiAnZ3UnLFxuICAgIDB4MDQ2ODogJ2hhJyxcbiAgICAweDA0MEQ6ICdoZScsXG4gICAgMHgwNDM5OiAnaGknLFxuICAgIDB4MDQwRTogJ2h1JyxcbiAgICAweDA0MEY6ICdpcycsXG4gICAgMHgwNDcwOiAnaWcnLFxuICAgIDB4MDQyMTogJ2lkJyxcbiAgICAweDA0NUQ6ICdpdScsXG4gICAgMHgwODVEOiAnaXUtTGF0bicsXG4gICAgMHgwODNDOiAnZ2EnLFxuICAgIDB4MDQzNDogJ3hoJyxcbiAgICAweDA0MzU6ICd6dScsXG4gICAgMHgwNDEwOiAnaXQnLFxuICAgIDB4MDgxMDogJ2l0LUNIJyxcbiAgICAweDA0MTE6ICdqYScsXG4gICAgMHgwNDRCOiAna24nLFxuICAgIDB4MDQzRjogJ2trJyxcbiAgICAweDA0NTM6ICdrbScsXG4gICAgMHgwNDg2OiAncXVjJyxcbiAgICAweDA0ODc6ICdydycsXG4gICAgMHgwNDQxOiAnc3cnLFxuICAgIDB4MDQ1NzogJ2tvaycsXG4gICAgMHgwNDEyOiAna28nLFxuICAgIDB4MDQ0MDogJ2t5JyxcbiAgICAweDA0NTQ6ICdsbycsXG4gICAgMHgwNDI2OiAnbHYnLFxuICAgIDB4MDQyNzogJ2x0JyxcbiAgICAweDA4MkU6ICdkc2InLFxuICAgIDB4MDQ2RTogJ2xiJyxcbiAgICAweDA0MkY6ICdtaycsXG4gICAgMHgwODNFOiAnbXMtQk4nLFxuICAgIDB4MDQzRTogJ21zJyxcbiAgICAweDA0NEM6ICdtbCcsXG4gICAgMHgwNDNBOiAnbXQnLFxuICAgIDB4MDQ4MTogJ21pJyxcbiAgICAweDA0N0E6ICdhcm4nLFxuICAgIDB4MDQ0RTogJ21yJyxcbiAgICAweDA0N0M6ICdtb2gnLFxuICAgIDB4MDQ1MDogJ21uJyxcbiAgICAweDA4NTA6ICdtbi1DTicsXG4gICAgMHgwNDYxOiAnbmUnLFxuICAgIDB4MDQxNDogJ25iJyxcbiAgICAweDA4MTQ6ICdubicsXG4gICAgMHgwNDgyOiAnb2MnLFxuICAgIDB4MDQ0ODogJ29yJyxcbiAgICAweDA0NjM6ICdwcycsXG4gICAgMHgwNDE1OiAncGwnLFxuICAgIDB4MDQxNjogJ3B0JyxcbiAgICAweDA4MTY6ICdwdC1QVCcsXG4gICAgMHgwNDQ2OiAncGEnLFxuICAgIDB4MDQ2QjogJ3F1LUJPJyxcbiAgICAweDA4NkI6ICdxdS1FQycsXG4gICAgMHgwQzZCOiAncXUnLFxuICAgIDB4MDQxODogJ3JvJyxcbiAgICAweDA0MTc6ICdybScsXG4gICAgMHgwNDE5OiAncnUnLFxuICAgIDB4MjQzQjogJ3NtbicsXG4gICAgMHgxMDNCOiAnc21qLU5PJyxcbiAgICAweDE0M0I6ICdzbWonLFxuICAgIDB4MEMzQjogJ3NlLUZJJyxcbiAgICAweDA0M0I6ICdzZScsXG4gICAgMHgwODNCOiAnc2UtU0UnLFxuICAgIDB4MjAzQjogJ3NtcycsXG4gICAgMHgxODNCOiAnc21hLU5PJyxcbiAgICAweDFDM0I6ICdzbXMnLFxuICAgIDB4MDQ0RjogJ3NhJyxcbiAgICAweDFDMUE6ICdzci1DeXJsLUJBJyxcbiAgICAweDBDMUE6ICdzcicsXG4gICAgMHgxODFBOiAnc3ItTGF0bi1CQScsXG4gICAgMHgwODFBOiAnc3ItTGF0bicsXG4gICAgMHgwNDZDOiAnbnNvJyxcbiAgICAweDA0MzI6ICd0bicsXG4gICAgMHgwNDVCOiAnc2knLFxuICAgIDB4MDQxQjogJ3NrJyxcbiAgICAweDA0MjQ6ICdzbCcsXG4gICAgMHgyQzBBOiAnZXMtQVInLFxuICAgIDB4NDAwQTogJ2VzLUJPJyxcbiAgICAweDM0MEE6ICdlcy1DTCcsXG4gICAgMHgyNDBBOiAnZXMtQ08nLFxuICAgIDB4MTQwQTogJ2VzLUNSJyxcbiAgICAweDFDMEE6ICdlcy1ETycsXG4gICAgMHgzMDBBOiAnZXMtRUMnLFxuICAgIDB4NDQwQTogJ2VzLVNWJyxcbiAgICAweDEwMEE6ICdlcy1HVCcsXG4gICAgMHg0ODBBOiAnZXMtSE4nLFxuICAgIDB4MDgwQTogJ2VzLU1YJyxcbiAgICAweDRDMEE6ICdlcy1OSScsXG4gICAgMHgxODBBOiAnZXMtUEEnLFxuICAgIDB4M0MwQTogJ2VzLVBZJyxcbiAgICAweDI4MEE6ICdlcy1QRScsXG4gICAgMHg1MDBBOiAnZXMtUFInLFxuXG4gICAgLy8gTWljcm9zb2Z0IGhhcyBkZWZpbmVkIHR3byBkaWZmZXJlbnQgbGFuZ3VhZ2UgY29kZXMgZm9yXG4gICAgLy8g4oCcU3BhbmlzaCB3aXRoIG1vZGVybiBzb3J0aW5n4oCdIGFuZCDigJxTcGFuaXNoIHdpdGggdHJhZGl0aW9uYWxcbiAgICAvLyBzb3J0aW5n4oCdLiBUaGlzIG1ha2VzIHNlbnNlIGZvciBjb2xsYXRpb24gQVBJcywgYW5kIGl0IHdvdWxkIGJlXG4gICAgLy8gcG9zc2libGUgdG8gZXhwcmVzcyB0aGlzIGluIEJDUCA0NyBsYW5ndWFnZSB0YWdzIHZpYSBVbmljb2RlXG4gICAgLy8gZXh0ZW5zaW9ucyAoZWcuLCBlcy11LWNvLXRyYWQgaXMgU3BhbmlzaCB3aXRoIHRyYWRpdGlvbmFsXG4gICAgLy8gc29ydGluZykuIEhvd2V2ZXIsIGZvciBzdG9yaW5nIG5hbWVzIGluIGZvbnRzLCB0aGUgZGlzdGluY3Rpb25cbiAgICAvLyBkb2VzIG5vdCBtYWtlIHNlbnNlLCBzbyB3ZSBnaXZlIOKAnGVz4oCdIGluIGJvdGggY2FzZXMuXG4gICAgMHgwQzBBOiAnZXMnLFxuICAgIDB4MDQwQTogJ2VzJyxcblxuICAgIDB4NTQwQTogJ2VzLVVTJyxcbiAgICAweDM4MEE6ICdlcy1VWScsXG4gICAgMHgyMDBBOiAnZXMtVkUnLFxuICAgIDB4MDgxRDogJ3N2LUZJJyxcbiAgICAweDA0MUQ6ICdzdicsXG4gICAgMHgwNDVBOiAnc3lyJyxcbiAgICAweDA0Mjg6ICd0ZycsXG4gICAgMHgwODVGOiAndHptJyxcbiAgICAweDA0NDk6ICd0YScsXG4gICAgMHgwNDQ0OiAndHQnLFxuICAgIDB4MDQ0QTogJ3RlJyxcbiAgICAweDA0MUU6ICd0aCcsXG4gICAgMHgwNDUxOiAnYm8nLFxuICAgIDB4MDQxRjogJ3RyJyxcbiAgICAweDA0NDI6ICd0aycsXG4gICAgMHgwNDgwOiAndWcnLFxuICAgIDB4MDQyMjogJ3VrJyxcbiAgICAweDA0MkU6ICdoc2InLFxuICAgIDB4MDQyMDogJ3VyJyxcbiAgICAweDA4NDM6ICd1ei1DeXJsJyxcbiAgICAweDA0NDM6ICd1eicsXG4gICAgMHgwNDJBOiAndmknLFxuICAgIDB4MDQ1MjogJ2N5JyxcbiAgICAweDA0ODg6ICd3bycsXG4gICAgMHgwNDg1OiAnc2FoJyxcbiAgICAweDA0Nzg6ICdpaScsXG4gICAgMHgwNDZBOiAneW8nXG59O1xuXG4vLyBSZXR1cm5zIGEgSUVURiBCQ1AgNDcgbGFuZ3VhZ2UgY29kZSwgZm9yIGV4YW1wbGUgJ3poLUhhbnQnXG4vLyBmb3IgJ0NoaW5lc2UgaW4gdGhlIHRyYWRpdGlvbmFsIHNjcmlwdCcuXG5mdW5jdGlvbiBnZXRMYW5ndWFnZUNvZGUocGxhdGZvcm1JRCwgbGFuZ3VhZ2VJRCwgbHRhZykge1xuICAgIHN3aXRjaCAocGxhdGZvcm1JRCkge1xuICAgICAgICBjYXNlIDA6ICAvLyBVbmljb2RlXG4gICAgICAgICAgICBpZiAobGFuZ3VhZ2VJRCA9PT0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd1bmQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsdGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGx0YWdbbGFuZ3VhZ2VJRF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTogIC8vIE1hY2ludG9zaFxuICAgICAgICAgICAgcmV0dXJuIG1hY0xhbmd1YWdlc1tsYW5ndWFnZUlEXTtcblxuICAgICAgICBjYXNlIDM6ICAvLyBXaW5kb3dzXG4gICAgICAgICAgICByZXR1cm4gd2luZG93c0xhbmd1YWdlc1tsYW5ndWFnZUlEXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgdXRmMTYgPSAndXRmLTE2JztcblxuLy8gTWFjT1Mgc2NyaXB0IElEIOKGkiBlbmNvZGluZy4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIGRlZmF1bHQgY2FzZSxcbi8vIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IG1hY0xhbmd1YWdlRW5jb2RpbmdzLlxudmFyIG1hY1NjcmlwdEVuY29kaW5ncyA9IHtcbiAgICAwOiAnbWFjaW50b3NoJywgICAgICAgICAgIC8vIHNtUm9tYW5cbiAgICAxOiAneC1tYWMtamFwYW5lc2UnLCAgICAgIC8vIHNtSmFwYW5lc2VcbiAgICAyOiAneC1tYWMtY2hpbmVzZXRyYWQnLCAgIC8vIHNtVHJhZENoaW5lc2VcbiAgICAzOiAneC1tYWMta29yZWFuJywgICAgICAgIC8vIHNtS29yZWFuXG4gICAgNjogJ3gtbWFjLWdyZWVrJywgICAgICAgICAvLyBzbUdyZWVrXG4gICAgNzogJ3gtbWFjLWN5cmlsbGljJywgICAgICAvLyBzbUN5cmlsbGljXG4gICAgOTogJ3gtbWFjLWRldmFuYWdhaScsICAgICAvLyBzbURldmFuYWdhcmlcbiAgICAxMDogJ3gtbWFjLWd1cm11a2hpJywgICAgIC8vIHNtR3VybXVraGlcbiAgICAxMTogJ3gtbWFjLWd1amFyYXRpJywgICAgIC8vIHNtR3VqYXJhdGlcbiAgICAxMjogJ3gtbWFjLW9yaXlhJywgICAgICAgIC8vIHNtT3JpeWFcbiAgICAxMzogJ3gtbWFjLWJlbmdhbGknLCAgICAgIC8vIHNtQmVuZ2FsaVxuICAgIDE0OiAneC1tYWMtdGFtaWwnLCAgICAgICAgLy8gc21UYW1pbFxuICAgIDE1OiAneC1tYWMtdGVsdWd1JywgICAgICAgLy8gc21UZWx1Z3VcbiAgICAxNjogJ3gtbWFjLWthbm5hZGEnLCAgICAgIC8vIHNtS2FubmFkYVxuICAgIDE3OiAneC1tYWMtbWFsYXlhbGFtJywgICAgLy8gc21NYWxheWFsYW1cbiAgICAxODogJ3gtbWFjLXNpbmhhbGVzZScsICAgIC8vIHNtU2luaGFsZXNlXG4gICAgMTk6ICd4LW1hYy1idXJtZXNlJywgICAgICAvLyBzbUJ1cm1lc2VcbiAgICAyMDogJ3gtbWFjLWtobWVyJywgICAgICAgIC8vIHNtS2htZXJcbiAgICAyMTogJ3gtbWFjLXRoYWknLCAgICAgICAgIC8vIHNtVGhhaVxuICAgIDIyOiAneC1tYWMtbGFvJywgICAgICAgICAgLy8gc21MYW9cbiAgICAyMzogJ3gtbWFjLWdlb3JnaWFuJywgICAgIC8vIHNtR2VvcmdpYW5cbiAgICAyNDogJ3gtbWFjLWFybWVuaWFuJywgICAgIC8vIHNtQXJtZW5pYW5cbiAgICAyNTogJ3gtbWFjLWNoaW5lc2VzaW1wJywgIC8vIHNtU2ltcENoaW5lc2VcbiAgICAyNjogJ3gtbWFjLXRpYmV0YW4nLCAgICAgIC8vIHNtVGliZXRhblxuICAgIDI3OiAneC1tYWMtbW9uZ29saWFuJywgICAgLy8gc21Nb25nb2xpYW5cbiAgICAyODogJ3gtbWFjLWV0aGlvcGljJywgICAgIC8vIHNtRXRoaW9waWNcbiAgICAyOTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDMwOiAneC1tYWMtdmlldG5hbWVzZScsICAgLy8gc21WaWV0bmFtZXNlXG4gICAgMzE6ICd4LW1hYy1leHRhcmFiaWMnICAgICAvLyBzbUV4dEFyYWJpY1xufTtcblxuLy8gTWFjT1MgbGFuZ3VhZ2UgSUQg4oaSIGVuY29kaW5nLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgZXhjZXB0aW9uYWxcbi8vIGNhc2VzLCB3aGljaCBvdmVycmlkZSBtYWNTY3JpcHRFbmNvZGluZ3MuIEZvciB3cml0aW5nIE1hY09TIG5hbWluZ1xuLy8gdGFibGVzLCB3ZSBuZWVkIHRvIGVtaXQgYSBNYWNPUyBzY3JpcHQgSUQuIFRoZXJlZm9yZSwgd2UgY2Fubm90XG4vLyBtZXJnZSBtYWNTY3JpcHRFbmNvZGluZ3MgaW50byBtYWNMYW5ndWFnZUVuY29kaW5ncy5cbi8vXG4vLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvUmVhZG1lLnR4dFxudmFyIG1hY0xhbmd1YWdlRW5jb2RpbmdzID0ge1xuICAgIDE1OiAneC1tYWMtaWNlbGFuZGljJywgICAgLy8gbGFuZ0ljZWxhbmRpY1xuICAgIDE3OiAneC1tYWMtdHVya2lzaCcsICAgICAgLy8gbGFuZ1R1cmtpc2hcbiAgICAxODogJ3gtbWFjLWNyb2F0aWFuJywgICAgIC8vIGxhbmdDcm9hdGlhblxuICAgIDI0OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0xpdGh1YW5pYW5cbiAgICAyNTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdQb2xpc2hcbiAgICAyNjogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdIdW5nYXJpYW5cbiAgICAyNzogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdFc3RvbmlhblxuICAgIDI4OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0xhdHZpYW5cbiAgICAzMDogJ3gtbWFjLWljZWxhbmRpYycsICAgIC8vIGxhbmdGYXJvZXNlXG4gICAgMzc6ICd4LW1hYy1yb21hbmlhbicsICAgICAvLyBsYW5nUm9tYW5pYW5cbiAgICAzODogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdDemVjaFxuICAgIDM5OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ1Nsb3Zha1xuICAgIDQwOiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ1Nsb3ZlbmlhblxuICAgIDE0MzogJ3gtbWFjLWludWl0JywgICAgICAgLy8gbGFuZ0ludWt0aXR1dFxuICAgIDE0NjogJ3gtbWFjLWdhZWxpYycgICAgICAgLy8gbGFuZ0lyaXNoR2FlbGljU2NyaXB0XG59O1xuXG5mdW5jdGlvbiBnZXRFbmNvZGluZyhwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlEKSB7XG4gICAgc3dpdGNoIChwbGF0Zm9ybUlEKSB7XG4gICAgICAgIGNhc2UgMDogIC8vIFVuaWNvZGVcbiAgICAgICAgICAgIHJldHVybiB1dGYxNjtcblxuICAgICAgICBjYXNlIDE6ICAvLyBBcHBsZSBNYWNpbnRvc2hcbiAgICAgICAgICAgIHJldHVybiBtYWNMYW5ndWFnZUVuY29kaW5nc1tsYW5ndWFnZUlEXSB8fCBtYWNTY3JpcHRFbmNvZGluZ3NbZW5jb2RpbmdJRF07XG5cbiAgICAgICAgY2FzZSAzOiAgLy8gTWljcm9zb2Z0IFdpbmRvd3NcbiAgICAgICAgICAgIGlmIChlbmNvZGluZ0lEID09PSAxIHx8IGVuY29kaW5nSUQgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0ZjE2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vLyBQYXJzZSB0aGUgbmFtaW5nIGBuYW1lYCB0YWJsZS5cbi8vIEZJWE1FOiBGb3JtYXQgMSBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgbm90IHN1cHBvcnRlZCB5ZXQuXG4vLyBsdGFnIGlzIHRoZSBjb250ZW50IG9mIHRoZSBgbHRhZycgdGFibGUsIHN1Y2ggYXMgWydlbicsICd6aC1IYW5zJywgJ2RlLUNILTE5MDQnXS5cbmZ1bmN0aW9uIHBhcnNlTmFtZVRhYmxlKGRhdGEsIHN0YXJ0LCBsdGFnKSB7XG4gICAgdmFyIG5hbWUgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBzdHJpbmdPZmZzZXQgPSBwLm9mZnNldCArIHAucGFyc2VVU2hvcnQoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHBsYXRmb3JtSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBlbmNvZGluZ0lEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbGFuZ3VhZ2VJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIG5hbWVJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gbmFtZVRhYmxlTmFtZXNbbmFtZUlEXSB8fCBuYW1lSUQ7XG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZUNvZGUocGxhdGZvcm1JRCwgbGFuZ3VhZ2VJRCwgbHRhZyk7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IGdldEVuY29kaW5nKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiBsYW5ndWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgdGV4dDtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gdXRmMTYpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZGVjb2RlLlVURjE2KGRhdGEsIHN0cmluZ09mZnNldCArIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBkZWNvZGUuTUFDU1RSSU5HKGRhdGEsIHN0cmluZ09mZnNldCArIG9mZnNldCwgYnl0ZUxlbmd0aCwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbnMgPSBuYW1lW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25zID0gbmFtZVtwcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbnNbbGFuZ3VhZ2VdID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nVGFnQ291bnQgPSAwO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgLy8gRklYTUU6IEFsc28gaGFuZGxlIE1pY3Jvc29mdCdzICduYW1lJyB0YWJsZSAxLlxuICAgICAgICBsYW5nVGFnQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG59XG5cbi8vIHsyMzogJ2Zvbyd9IOKGkiB7J2Zvbyc6IDIzfVxuLy8gWydiYXInLCAnYmF6J10g4oaSIHsnYmFyJzogMCwgJ2Jheic6IDF9XG5mdW5jdGlvbiByZXZlcnNlRGljdChkaWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkaWN0KSB7XG4gICAgICAgIHJlc3VsdFtkaWN0W2tleV1dID0gcGFyc2VJbnQoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVJlY29yZChwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlELCBuYW1lSUQsIGxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ05hbWVSZWNvcmQnLCBbXG4gICAgICAgIHtuYW1lOiAncGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcGxhdGZvcm1JRH0sXG4gICAgICAgIHtuYW1lOiAnZW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZW5jb2RpbmdJRH0sXG4gICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2VJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGFuZ3VhZ2VJRH0sXG4gICAgICAgIHtuYW1lOiAnbmFtZUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lSUR9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG9mZnNldH1cbiAgICBdKTtcbn1cblxuLy8gRmluZHMgdGhlIHBvc2l0aW9uIG9mIG5lZWRsZSBpbiBoYXlzdGFjaywgb3IgLTEgaWYgbm90IHRoZXJlLlxuLy8gTGlrZSBTdHJpbmcuaW5kZXhPZigpLCBidXQgZm9yIGFycmF5cy5cbmZ1bmN0aW9uIGZpbmRTdWJBcnJheShuZWVkbGUsIGhheXN0YWNrKSB7XG4gICAgdmFyIG5lZWRsZUxlbmd0aCA9IG5lZWRsZS5sZW5ndGg7XG4gICAgdmFyIGxpbWl0ID0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlTGVuZ3RoICsgMTtcblxuICAgIGxvb3A6XG4gICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDwgbGltaXQ7IHBvcysrKSB7XG4gICAgICAgIGZvciAoOyBwb3MgPCBsaW1pdDsgcG9zKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbmVlZGxlTGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF5c3RhY2tbcG9zICsga10gIT09IG5lZWRsZVtrXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gYWRkU3RyaW5nVG9Qb29sKHMsIHBvb2wpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZmluZFN1YkFycmF5KHMsIHBvb2wpO1xuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIG9mZnNldCA9IHBvb2wubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcG9vbC5wdXNoKHNbaV0pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVRhYmxlKG5hbWVzLCBsdGFnKSB7XG4gICAgdmFyIG5hbWVJRDtcbiAgICB2YXIgbmFtZUlEcyA9IFtdO1xuXG4gICAgdmFyIG5hbWVzV2l0aE51bWVyaWNLZXlzID0ge307XG4gICAgdmFyIG5hbWVUYWJsZUlkcyA9IHJldmVyc2VEaWN0KG5hbWVUYWJsZU5hbWVzKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZXMpIHtcbiAgICAgICAgdmFyIGlkID0gbmFtZVRhYmxlSWRzW2tleV07XG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZCA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVJRCA9IHBhcnNlSW50KGlkKTtcblxuICAgICAgICBpZiAoaXNOYU4obmFtZUlEKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lIHRhYmxlIGVudHJ5IFwiJyArIGtleSArICdcIiBkb2VzIG5vdCBleGlzdCwgc2VlIG5hbWVUYWJsZU5hbWVzIGZvciBjb21wbGV0ZSBsaXN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZXNXaXRoTnVtZXJpY0tleXNbbmFtZUlEXSA9IG5hbWVzW2tleV07XG4gICAgICAgIG5hbWVJRHMucHVzaChuYW1lSUQpO1xuICAgIH1cblxuICAgIHZhciBtYWNMYW5ndWFnZUlkcyA9IHJldmVyc2VEaWN0KG1hY0xhbmd1YWdlcyk7XG4gICAgdmFyIHdpbmRvd3NMYW5ndWFnZUlkcyA9IHJldmVyc2VEaWN0KHdpbmRvd3NMYW5ndWFnZXMpO1xuXG4gICAgdmFyIG5hbWVSZWNvcmRzID0gW107XG4gICAgdmFyIHN0cmluZ1Bvb2wgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUlEcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lSUQgPSBuYW1lSURzW2ldO1xuICAgICAgICB2YXIgdHJhbnNsYXRpb25zID0gbmFtZXNXaXRoTnVtZXJpY0tleXNbbmFtZUlEXTtcbiAgICAgICAgZm9yICh2YXIgbGFuZyBpbiB0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdHJhbnNsYXRpb25zW2xhbmddO1xuXG4gICAgICAgICAgICAvLyBGb3IgTWFjT1MsIHdlIHRyeSB0byBlbWl0IHRoZSBuYW1lIGluIHRoZSBmb3JtIHRoYXQgd2FzIGludHJvZHVjZWRcbiAgICAgICAgICAgIC8vIGluIHRoZSBpbml0aWFsIHZlcnNpb24gb2YgdGhlIFRydWVUeXBlIHNwZWMgKGluIHRoZSBsYXRlIDE5ODBzKS5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgY2FuIGZhaWwgZm9yIHZhcmlvdXMgcmVhc29uczogdGhlIHJlcXVlc3RlZCBCQ1AgNDdcbiAgICAgICAgICAgIC8vIGxhbmd1YWdlIGNvZGUgbWlnaHQgbm90IGhhdmUgYW4gb2xkLXN0eWxlIE1hYyBlcXVpdmFsZW50O1xuICAgICAgICAgICAgLy8gd2UgbWlnaHQgbm90IGhhdmUgYSBjb2RlYyBmb3IgdGhlIG5lZWRlZCBjaGFyYWN0ZXIgZW5jb2Rpbmc7XG4gICAgICAgICAgICAvLyBvciB0aGUgbmFtZSBtaWdodCBjb250YWluIGNoYXJhY3RlcnMgdGhhdCBjYW5ub3QgYmUgZXhwcmVzc2VkXG4gICAgICAgICAgICAvLyBpbiB0aGUgb2xkLXN0eWxlIE1hY2ludG9zaCBlbmNvZGluZy4gSW4gY2FzZSBvZiBmYWlsdXJlLCB3ZSBlbWl0XG4gICAgICAgICAgICAvLyB0aGUgbmFtZSBpbiBhIG1vcmUgbW9kZXJuIGZhc2hpb24gKFVuaWNvZGUgZW5jb2Rpbmcgd2l0aCBCQ1AgNDdcbiAgICAgICAgICAgIC8vIGxhbmd1YWdlIHRhZ3MpIHRoYXQgaXMgcmVjb2duaXplZCBieSBNYWNPUyAxMC41LCByZWxlYXNlZCBpbiAyMDA5LlxuICAgICAgICAgICAgLy8gSWYgZm9udHMgd2VyZSBvbmx5IHJlYWQgYnkgb3BlcmF0aW5nIHN5c3RlbXMsIHdlIGNvdWxkIHNpbXBseVxuICAgICAgICAgICAgLy8gZW1pdCBhbGwgbmFtZXMgaW4gdGhlIG1vZGVybiBmb3JtOyB0aGlzIHdvdWxkIGJlIG11Y2ggZWFzaWVyLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlcmUgYXJlIG1hbnkgYXBwbGljYXRpb25zIGFuZCBsaWJyYXJpZXMgdGhhdCByZWFkXG4gICAgICAgICAgICAvLyAnbmFtZScgdGFibGVzIGRpcmVjdGx5LCBhbmQgdGhlc2Ugd2lsbCB1c3VhbGx5IG9ubHkgcmVjb2duaXplXG4gICAgICAgICAgICAvLyB0aGUgYW5jaWVudCBmb3JtIChzaWxlbnRseSBza2lwcGluZyB0aGUgdW5yZWNvZ25pemVkIG5hbWVzKS5cbiAgICAgICAgICAgIHZhciBtYWNQbGF0Zm9ybSA9IDE7ICAvLyBNYWNpbnRvc2hcbiAgICAgICAgICAgIHZhciBtYWNMYW5ndWFnZSA9IG1hY0xhbmd1YWdlSWRzW2xhbmddO1xuICAgICAgICAgICAgdmFyIG1hY1NjcmlwdCA9IG1hY0xhbmd1YWdlVG9TY3JpcHRbbWFjTGFuZ3VhZ2VdO1xuICAgICAgICAgICAgdmFyIG1hY0VuY29kaW5nID0gZ2V0RW5jb2RpbmcobWFjUGxhdGZvcm0sIG1hY1NjcmlwdCwgbWFjTGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdmFyIG1hY05hbWUgPSBlbmNvZGUuTUFDU1RSSU5HKHRleHQsIG1hY0VuY29kaW5nKTtcbiAgICAgICAgICAgIGlmIChtYWNOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYWNQbGF0Zm9ybSA9IDA7ICAvLyBVbmljb2RlXG4gICAgICAgICAgICAgICAgbWFjTGFuZ3VhZ2UgPSBsdGFnLmluZGV4T2YobGFuZyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hY0xhbmd1YWdlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBtYWNMYW5ndWFnZSA9IGx0YWcubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsdGFnLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWFjU2NyaXB0ID0gNDsgIC8vIFVuaWNvZGUgMi4wIGFuZCBsYXRlclxuICAgICAgICAgICAgICAgIG1hY05hbWUgPSBlbmNvZGUuVVRGMTYodGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYWNOYW1lT2Zmc2V0ID0gYWRkU3RyaW5nVG9Qb29sKG1hY05hbWUsIHN0cmluZ1Bvb2wpO1xuICAgICAgICAgICAgbmFtZVJlY29yZHMucHVzaChtYWtlTmFtZVJlY29yZChtYWNQbGF0Zm9ybSwgbWFjU2NyaXB0LCBtYWNMYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZUlELCBtYWNOYW1lLmxlbmd0aCwgbWFjTmFtZU9mZnNldCkpO1xuXG4gICAgICAgICAgICB2YXIgd2luTGFuZ3VhZ2UgPSB3aW5kb3dzTGFuZ3VhZ2VJZHNbbGFuZ107XG4gICAgICAgICAgICBpZiAod2luTGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lID0gZW5jb2RlLlVURjE2KHRleHQpO1xuICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lT2Zmc2V0ID0gYWRkU3RyaW5nVG9Qb29sKHdpbk5hbWUsIHN0cmluZ1Bvb2wpO1xuICAgICAgICAgICAgICAgIG5hbWVSZWNvcmRzLnB1c2gobWFrZU5hbWVSZWNvcmQoMywgMSwgd2luTGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lSUQsIHdpbk5hbWUubGVuZ3RoLCB3aW5OYW1lT2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lUmVjb3Jkcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICgoYS5wbGF0Zm9ybUlEIC0gYi5wbGF0Zm9ybUlEKSB8fFxuICAgICAgICAgICAgICAgIChhLmVuY29kaW5nSUQgLSBiLmVuY29kaW5nSUQpIHx8XG4gICAgICAgICAgICAgICAgKGEubGFuZ3VhZ2VJRCAtIGIubGFuZ3VhZ2VJRCkgfHxcbiAgICAgICAgICAgICAgICAoYS5uYW1lSUQgLSBiLm5hbWVJRCkpO1xuICAgIH0pO1xuXG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ25hbWUnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZVJlY29yZHMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdPZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDYgKyBuYW1lUmVjb3Jkcy5sZW5ndGggKiAxMn1cbiAgICBdKTtcblxuICAgIGZvciAodmFyIHIgPSAwOyByIDwgbmFtZVJlY29yZHMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3JlY29yZF8nICsgciwgdHlwZTogJ1JFQ09SRCcsIHZhbHVlOiBuYW1lUmVjb3Jkc1tyXX0pO1xuICAgIH1cblxuICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdzJywgdHlwZTogJ0xJVEVSQUwnLCB2YWx1ZTogc3RyaW5nUG9vbH0pO1xuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VOYW1lVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlTmFtZVRhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy90YWJsZXMvbmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSBgT1MvMmAgdGFibGUgY29udGFpbnMgbWV0cmljcyByZXF1aXJlZCBpbiBPcGVuVHlwZSBmb250cy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3MyLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG52YXIgdW5pY29kZVJhbmdlcyA9IFtcbiAgICB7YmVnaW46IDB4MDAwMCwgZW5kOiAweDAwN0Z9LCAvLyBCYXNpYyBMYXRpblxuICAgIHtiZWdpbjogMHgwMDgwLCBlbmQ6IDB4MDBGRn0sIC8vIExhdGluLTEgU3VwcGxlbWVudFxuICAgIHtiZWdpbjogMHgwMTAwLCBlbmQ6IDB4MDE3Rn0sIC8vIExhdGluIEV4dGVuZGVkLUFcbiAgICB7YmVnaW46IDB4MDE4MCwgZW5kOiAweDAyNEZ9LCAvLyBMYXRpbiBFeHRlbmRlZC1CXG4gICAge2JlZ2luOiAweDAyNTAsIGVuZDogMHgwMkFGfSwgLy8gSVBBIEV4dGVuc2lvbnNcbiAgICB7YmVnaW46IDB4MDJCMCwgZW5kOiAweDAyRkZ9LCAvLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnNcbiAgICB7YmVnaW46IDB4MDMwMCwgZW5kOiAweDAzNkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3NcbiAgICB7YmVnaW46IDB4MDM3MCwgZW5kOiAweDAzRkZ9LCAvLyBHcmVlayBhbmQgQ29wdGljXG4gICAge2JlZ2luOiAweDJDODAsIGVuZDogMHgyQ0ZGfSwgLy8gQ29wdGljXG4gICAge2JlZ2luOiAweDA0MDAsIGVuZDogMHgwNEZGfSwgLy8gQ3lyaWxsaWNcbiAgICB7YmVnaW46IDB4MDUzMCwgZW5kOiAweDA1OEZ9LCAvLyBBcm1lbmlhblxuICAgIHtiZWdpbjogMHgwNTkwLCBlbmQ6IDB4MDVGRn0sIC8vIEhlYnJld1xuICAgIHtiZWdpbjogMHhBNTAwLCBlbmQ6IDB4QTYzRn0sIC8vIFZhaVxuICAgIHtiZWdpbjogMHgwNjAwLCBlbmQ6IDB4MDZGRn0sIC8vIEFyYWJpY1xuICAgIHtiZWdpbjogMHgwN0MwLCBlbmQ6IDB4MDdGRn0sIC8vIE5Lb1xuICAgIHtiZWdpbjogMHgwOTAwLCBlbmQ6IDB4MDk3Rn0sIC8vIERldmFuYWdhcmlcbiAgICB7YmVnaW46IDB4MDk4MCwgZW5kOiAweDA5RkZ9LCAvLyBCZW5nYWxpXG4gICAge2JlZ2luOiAweDBBMDAsIGVuZDogMHgwQTdGfSwgLy8gR3VybXVraGlcbiAgICB7YmVnaW46IDB4MEE4MCwgZW5kOiAweDBBRkZ9LCAvLyBHdWphcmF0aVxuICAgIHtiZWdpbjogMHgwQjAwLCBlbmQ6IDB4MEI3Rn0sIC8vIE9yaXlhXG4gICAge2JlZ2luOiAweDBCODAsIGVuZDogMHgwQkZGfSwgLy8gVGFtaWxcbiAgICB7YmVnaW46IDB4MEMwMCwgZW5kOiAweDBDN0Z9LCAvLyBUZWx1Z3VcbiAgICB7YmVnaW46IDB4MEM4MCwgZW5kOiAweDBDRkZ9LCAvLyBLYW5uYWRhXG4gICAge2JlZ2luOiAweDBEMDAsIGVuZDogMHgwRDdGfSwgLy8gTWFsYXlhbGFtXG4gICAge2JlZ2luOiAweDBFMDAsIGVuZDogMHgwRTdGfSwgLy8gVGhhaVxuICAgIHtiZWdpbjogMHgwRTgwLCBlbmQ6IDB4MEVGRn0sIC8vIExhb1xuICAgIHtiZWdpbjogMHgxMEEwLCBlbmQ6IDB4MTBGRn0sIC8vIEdlb3JnaWFuXG4gICAge2JlZ2luOiAweDFCMDAsIGVuZDogMHgxQjdGfSwgLy8gQmFsaW5lc2VcbiAgICB7YmVnaW46IDB4MTEwMCwgZW5kOiAweDExRkZ9LCAvLyBIYW5ndWwgSmFtb1xuICAgIHtiZWdpbjogMHgxRTAwLCBlbmQ6IDB4MUVGRn0sIC8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWxcbiAgICB7YmVnaW46IDB4MUYwMCwgZW5kOiAweDFGRkZ9LCAvLyBHcmVlayBFeHRlbmRlZFxuICAgIHtiZWdpbjogMHgyMDAwLCBlbmQ6IDB4MjA2Rn0sIC8vIEdlbmVyYWwgUHVuY3R1YXRpb25cbiAgICB7YmVnaW46IDB4MjA3MCwgZW5kOiAweDIwOUZ9LCAvLyBTdXBlcnNjcmlwdHMgQW5kIFN1YnNjcmlwdHNcbiAgICB7YmVnaW46IDB4MjBBMCwgZW5kOiAweDIwQ0Z9LCAvLyBDdXJyZW5jeSBTeW1ib2xcbiAgICB7YmVnaW46IDB4MjBEMCwgZW5kOiAweDIwRkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MgRm9yIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjEwMCwgZW5kOiAweDIxNEZ9LCAvLyBMZXR0ZXJsaWtlIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjE1MCwgZW5kOiAweDIxOEZ9LCAvLyBOdW1iZXIgRm9ybXNcbiAgICB7YmVnaW46IDB4MjE5MCwgZW5kOiAweDIxRkZ9LCAvLyBBcnJvd3NcbiAgICB7YmVnaW46IDB4MjIwMCwgZW5kOiAweDIyRkZ9LCAvLyBNYXRoZW1hdGljYWwgT3BlcmF0b3JzXG4gICAge2JlZ2luOiAweDIzMDAsIGVuZDogMHgyM0ZGfSwgLy8gTWlzY2VsbGFuZW91cyBUZWNobmljYWxcbiAgICB7YmVnaW46IDB4MjQwMCwgZW5kOiAweDI0M0Z9LCAvLyBDb250cm9sIFBpY3R1cmVzXG4gICAge2JlZ2luOiAweDI0NDAsIGVuZDogMHgyNDVGfSwgLy8gT3B0aWNhbCBDaGFyYWN0ZXIgUmVjb2duaXRpb25cbiAgICB7YmVnaW46IDB4MjQ2MCwgZW5kOiAweDI0RkZ9LCAvLyBFbmNsb3NlZCBBbHBoYW51bWVyaWNzXG4gICAge2JlZ2luOiAweDI1MDAsIGVuZDogMHgyNTdGfSwgLy8gQm94IERyYXdpbmdcbiAgICB7YmVnaW46IDB4MjU4MCwgZW5kOiAweDI1OUZ9LCAvLyBCbG9jayBFbGVtZW50c1xuICAgIHtiZWdpbjogMHgyNUEwLCBlbmQ6IDB4MjVGRn0sIC8vIEdlb21ldHJpYyBTaGFwZXNcbiAgICB7YmVnaW46IDB4MjYwMCwgZW5kOiAweDI2RkZ9LCAvLyBNaXNjZWxsYW5lb3VzIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjcwMCwgZW5kOiAweDI3QkZ9LCAvLyBEaW5nYmF0c1xuICAgIHtiZWdpbjogMHgzMDAwLCBlbmQ6IDB4MzAzRn0sIC8vIENKSyBTeW1ib2xzIEFuZCBQdW5jdHVhdGlvblxuICAgIHtiZWdpbjogMHgzMDQwLCBlbmQ6IDB4MzA5Rn0sIC8vIEhpcmFnYW5hXG4gICAge2JlZ2luOiAweDMwQTAsIGVuZDogMHgzMEZGfSwgLy8gS2F0YWthbmFcbiAgICB7YmVnaW46IDB4MzEwMCwgZW5kOiAweDMxMkZ9LCAvLyBCb3BvbW9mb1xuICAgIHtiZWdpbjogMHgzMTMwLCBlbmQ6IDB4MzE4Rn0sIC8vIEhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cbiAgICB7YmVnaW46IDB4QTg0MCwgZW5kOiAweEE4N0Z9LCAvLyBQaGFncy1wYVxuICAgIHtiZWdpbjogMHgzMjAwLCBlbmQ6IDB4MzJGRn0sIC8vIEVuY2xvc2VkIENKSyBMZXR0ZXJzIEFuZCBNb250aHNcbiAgICB7YmVnaW46IDB4MzMwMCwgZW5kOiAweDMzRkZ9LCAvLyBDSksgQ29tcGF0aWJpbGl0eVxuICAgIHtiZWdpbjogMHhBQzAwLCBlbmQ6IDB4RDdBRn0sIC8vIEhhbmd1bCBTeWxsYWJsZXNcbiAgICB7YmVnaW46IDB4RDgwMCwgZW5kOiAweERGRkZ9LCAvLyBOb24tUGxhbmUgMCAqXG4gICAge2JlZ2luOiAweDEwOTAwLCBlbmQ6IDB4MTA5MUZ9LCAvLyBQaG9lbmljaWFcbiAgICB7YmVnaW46IDB4NEUwMCwgZW5kOiAweDlGRkZ9LCAvLyBDSksgVW5pZmllZCBJZGVvZ3JhcGhzXG4gICAge2JlZ2luOiAweEUwMDAsIGVuZDogMHhGOEZGfSwgLy8gUHJpdmF0ZSBVc2UgQXJlYSAocGxhbmUgMClcbiAgICB7YmVnaW46IDB4MzFDMCwgZW5kOiAweDMxRUZ9LCAvLyBDSksgU3Ryb2tlc1xuICAgIHtiZWdpbjogMHhGQjAwLCBlbmQ6IDB4RkI0Rn0sIC8vIEFscGhhYmV0aWMgUHJlc2VudGF0aW9uIEZvcm1zXG4gICAge2JlZ2luOiAweEZCNTAsIGVuZDogMHhGREZGfSwgLy8gQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXG4gICAge2JlZ2luOiAweEZFMjAsIGVuZDogMHhGRTJGfSwgLy8gQ29tYmluaW5nIEhhbGYgTWFya3NcbiAgICB7YmVnaW46IDB4RkUxMCwgZW5kOiAweEZFMUZ9LCAvLyBWZXJ0aWNhbCBGb3Jtc1xuICAgIHtiZWdpbjogMHhGRTUwLCBlbmQ6IDB4RkU2Rn0sIC8vIFNtYWxsIEZvcm0gVmFyaWFudHNcbiAgICB7YmVnaW46IDB4RkU3MCwgZW5kOiAweEZFRkZ9LCAvLyBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcbiAgICB7YmVnaW46IDB4RkYwMCwgZW5kOiAweEZGRUZ9LCAvLyBIYWxmd2lkdGggQW5kIEZ1bGx3aWR0aCBGb3Jtc1xuICAgIHtiZWdpbjogMHhGRkYwLCBlbmQ6IDB4RkZGRn0sIC8vIFNwZWNpYWxzXG4gICAge2JlZ2luOiAweDBGMDAsIGVuZDogMHgwRkZGfSwgLy8gVGliZXRhblxuICAgIHtiZWdpbjogMHgwNzAwLCBlbmQ6IDB4MDc0Rn0sIC8vIFN5cmlhY1xuICAgIHtiZWdpbjogMHgwNzgwLCBlbmQ6IDB4MDdCRn0sIC8vIFRoYWFuYVxuICAgIHtiZWdpbjogMHgwRDgwLCBlbmQ6IDB4MERGRn0sIC8vIFNpbmhhbGFcbiAgICB7YmVnaW46IDB4MTAwMCwgZW5kOiAweDEwOUZ9LCAvLyBNeWFubWFyXG4gICAge2JlZ2luOiAweDEyMDAsIGVuZDogMHgxMzdGfSwgLy8gRXRoaW9waWNcbiAgICB7YmVnaW46IDB4MTNBMCwgZW5kOiAweDEzRkZ9LCAvLyBDaGVyb2tlZVxuICAgIHtiZWdpbjogMHgxNDAwLCBlbmQ6IDB4MTY3Rn0sIC8vIFVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3NcbiAgICB7YmVnaW46IDB4MTY4MCwgZW5kOiAweDE2OUZ9LCAvLyBPZ2hhbVxuICAgIHtiZWdpbjogMHgxNkEwLCBlbmQ6IDB4MTZGRn0sIC8vIFJ1bmljXG4gICAge2JlZ2luOiAweDE3ODAsIGVuZDogMHgxN0ZGfSwgLy8gS2htZXJcbiAgICB7YmVnaW46IDB4MTgwMCwgZW5kOiAweDE4QUZ9LCAvLyBNb25nb2xpYW5cbiAgICB7YmVnaW46IDB4MjgwMCwgZW5kOiAweDI4RkZ9LCAvLyBCcmFpbGxlIFBhdHRlcm5zXG4gICAge2JlZ2luOiAweEEwMDAsIGVuZDogMHhBNDhGfSwgLy8gWWkgU3lsbGFibGVzXG4gICAge2JlZ2luOiAweDE3MDAsIGVuZDogMHgxNzFGfSwgLy8gVGFnYWxvZ1xuICAgIHtiZWdpbjogMHgxMDMwMCwgZW5kOiAweDEwMzJGfSwgLy8gT2xkIEl0YWxpY1xuICAgIHtiZWdpbjogMHgxMDMzMCwgZW5kOiAweDEwMzRGfSwgLy8gR290aGljXG4gICAge2JlZ2luOiAweDEwNDAwLCBlbmQ6IDB4MTA0NEZ9LCAvLyBEZXNlcmV0XG4gICAge2JlZ2luOiAweDFEMDAwLCBlbmQ6IDB4MUQwRkZ9LCAvLyBCeXphbnRpbmUgTXVzaWNhbCBTeW1ib2xzXG4gICAge2JlZ2luOiAweDFENDAwLCBlbmQ6IDB4MUQ3RkZ9LCAvLyBNYXRoZW1hdGljYWwgQWxwaGFudW1lcmljIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4RkYwMDAsIGVuZDogMHhGRkZGRH0sIC8vIFByaXZhdGUgVXNlIChwbGFuZSAxNSlcbiAgICB7YmVnaW46IDB4RkUwMCwgZW5kOiAweEZFMEZ9LCAvLyBWYXJpYXRpb24gU2VsZWN0b3JzXG4gICAge2JlZ2luOiAweEUwMDAwLCBlbmQ6IDB4RTAwN0Z9LCAvLyBUYWdzXG4gICAge2JlZ2luOiAweDE5MDAsIGVuZDogMHgxOTRGfSwgLy8gTGltYnVcbiAgICB7YmVnaW46IDB4MTk1MCwgZW5kOiAweDE5N0Z9LCAvLyBUYWkgTGVcbiAgICB7YmVnaW46IDB4MTk4MCwgZW5kOiAweDE5REZ9LCAvLyBOZXcgVGFpIEx1ZVxuICAgIHtiZWdpbjogMHgxQTAwLCBlbmQ6IDB4MUExRn0sIC8vIEJ1Z2luZXNlXG4gICAge2JlZ2luOiAweDJDMDAsIGVuZDogMHgyQzVGfSwgLy8gR2xhZ29saXRpY1xuICAgIHtiZWdpbjogMHgyRDMwLCBlbmQ6IDB4MkQ3Rn0sIC8vIFRpZmluYWdoXG4gICAge2JlZ2luOiAweDREQzAsIGVuZDogMHg0REZGfSwgLy8gWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4QTgwMCwgZW5kOiAweEE4MkZ9LCAvLyBTeWxvdGkgTmFncmlcbiAgICB7YmVnaW46IDB4MTAwMDAsIGVuZDogMHgxMDA3Rn0sIC8vIExpbmVhciBCIFN5bGxhYmFyeVxuICAgIHtiZWdpbjogMHgxMDE0MCwgZW5kOiAweDEwMThGfSwgLy8gQW5jaWVudCBHcmVlayBOdW1iZXJzXG4gICAge2JlZ2luOiAweDEwMzgwLCBlbmQ6IDB4MTAzOUZ9LCAvLyBVZ2FyaXRpY1xuICAgIHtiZWdpbjogMHgxMDNBMCwgZW5kOiAweDEwM0RGfSwgLy8gT2xkIFBlcnNpYW5cbiAgICB7YmVnaW46IDB4MTA0NTAsIGVuZDogMHgxMDQ3Rn0sIC8vIFNoYXZpYW5cbiAgICB7YmVnaW46IDB4MTA0ODAsIGVuZDogMHgxMDRBRn0sIC8vIE9zbWFueWFcbiAgICB7YmVnaW46IDB4MTA4MDAsIGVuZDogMHgxMDgzRn0sIC8vIEN5cHJpb3QgU3lsbGFiYXJ5XG4gICAge2JlZ2luOiAweDEwQTAwLCBlbmQ6IDB4MTBBNUZ9LCAvLyBLaGFyb3NodGhpXG4gICAge2JlZ2luOiAweDFEMzAwLCBlbmQ6IDB4MUQzNUZ9LCAvLyBUYWkgWHVhbiBKaW5nIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MTIwMDAsIGVuZDogMHgxMjNGRn0sIC8vIEN1bmVpZm9ybVxuICAgIHtiZWdpbjogMHgxRDM2MCwgZW5kOiAweDFEMzdGfSwgLy8gQ291bnRpbmcgUm9kIE51bWVyYWxzXG4gICAge2JlZ2luOiAweDFCODAsIGVuZDogMHgxQkJGfSwgLy8gU3VuZGFuZXNlXG4gICAge2JlZ2luOiAweDFDMDAsIGVuZDogMHgxQzRGfSwgLy8gTGVwY2hhXG4gICAge2JlZ2luOiAweDFDNTAsIGVuZDogMHgxQzdGfSwgLy8gT2wgQ2hpa2lcbiAgICB7YmVnaW46IDB4QTg4MCwgZW5kOiAweEE4REZ9LCAvLyBTYXVyYXNodHJhXG4gICAge2JlZ2luOiAweEE5MDAsIGVuZDogMHhBOTJGfSwgLy8gS2F5YWggTGlcbiAgICB7YmVnaW46IDB4QTkzMCwgZW5kOiAweEE5NUZ9LCAvLyBSZWphbmdcbiAgICB7YmVnaW46IDB4QUEwMCwgZW5kOiAweEFBNUZ9LCAvLyBDaGFtXG4gICAge2JlZ2luOiAweDEwMTkwLCBlbmQ6IDB4MTAxQ0Z9LCAvLyBBbmNpZW50IFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MTAxRDAsIGVuZDogMHgxMDFGRn0sIC8vIFBoYWlzdG9zIERpc2NcbiAgICB7YmVnaW46IDB4MTAyQTAsIGVuZDogMHgxMDJERn0sIC8vIENhcmlhblxuICAgIHtiZWdpbjogMHgxRjAzMCwgZW5kOiAweDFGMDlGfSAgLy8gRG9taW5vIFRpbGVzXG5dO1xuXG5mdW5jdGlvbiBnZXRVbmljb2RlUmFuZ2UodW5pY29kZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pY29kZVJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB1bmljb2RlUmFuZ2VzW2ldO1xuICAgICAgICBpZiAodW5pY29kZSA+PSByYW5nZS5iZWdpbiAmJiB1bmljb2RlIDwgcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gUGFyc2UgdGhlIE9TLzIgYW5kIFdpbmRvd3MgbWV0cmljcyBgT1MvMmAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlT1MyVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgb3MyID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBvczIudmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueEF2Z0NoYXJXaWR0aCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dlaWdodENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c1dpZHRoQ2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLmZzVHlwZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNGYW1pbHlDbGFzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5wYW5vc2UgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgb3MyLnBhbm9zZVtpXSA9IHAucGFyc2VCeXRlKCk7XG4gICAgfVxuXG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlNCA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi5hY2hWZW5kSUQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCkpO1xuICAgIG9zMi5mc1NlbGVjdGlvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNGaXJzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNMYXN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0FzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvRGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvTGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dpbkFzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaW5EZXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChvczIudmVyc2lvbiA+PSAxKSB7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgfVxuXG4gICAgaWYgKG9zMi52ZXJzaW9uID49IDIpIHtcbiAgICAgICAgb3MyLnN4SGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi5zQ2FwSGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi51c0RlZmF1bHRDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNCcmVha0NoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9zMi51c01heENvbnRlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9zMjtcbn1cblxuZnVuY3Rpb24gbWFrZU9TMlRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdPUy8yJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB4MDAwM30sXG4gICAgICAgIHtuYW1lOiAneEF2Z0NoYXJXaWR0aCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dlaWdodENsYXNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpZHRoQ2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2ZzVHlwZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY1MH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY5OX0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMTQwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRYU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA2NTB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY5OX0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRZT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDQ3OX0sXG4gICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNDl9LFxuICAgICAgICB7bmFtZTogJ3lTdHJpa2VvdXRQb3NpdGlvbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyNTh9LFxuICAgICAgICB7bmFtZTogJ3NGYW1pbHlDbGFzcycsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiRmFtaWx5VHlwZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JTZXJpZlN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYldlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JQcm9wb3J0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkNvbnRyYXN0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlN0cm9rZVZhcmlhdGlvbicsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JBcm1TdHlsZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JMZXR0ZXJmb3JtJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYk1pZGxpbmUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiWEhlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlNCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdhY2hWZW5kSUQnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6ICdYWFhYJ30sXG4gICAgICAgIHtuYW1lOiAnZnNTZWxlY3Rpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzRmlyc3RDaGFySW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTGFzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc1R5cG9Bc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0Rlc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0xpbmVHYXAnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5Bc2NlbnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2luRGVzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxDb2RlUGFnZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3N4SGVpZ2h0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NDYXBIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNEZWZhdWx0Q2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNCcmVha0NoYXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTWF4Q29udGV4dCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy51bmljb2RlUmFuZ2VzID0gdW5pY29kZVJhbmdlcztcbmV4cG9ydHMuZ2V0VW5pY29kZVJhbmdlID0gZ2V0VW5pY29kZVJhbmdlO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlT1MyVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlT1MyVGFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9vczIuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgYHBvc3RgIHRhYmxlIHN0b3JlcyBhZGRpdGlvbmFsIFBvc3RTY3JpcHQgaW5mb3JtYXRpb24sIHN1Y2ggYXMgZ2x5cGggbmFtZXMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL3Bvc3QuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVuY29kaW5nID0gcmVxdWlyZSgnLi4vZW5jb2RpbmcnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgUG9zdFNjcmlwdCBgcG9zdGAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlUG9zdFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHBvc3QgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBpO1xuICAgIHBvc3QudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgcG9zdC5pdGFsaWNBbmdsZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIHBvc3QudW5kZXJsaW5lUG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwb3N0LnVuZGVybGluZVRoaWNrbmVzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QuaXNGaXhlZFBpdGNoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1heE1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWluTWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1heE1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgc3dpdGNoIChwb3N0LnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcG9zdC5uYW1lcyA9IGVuY29kaW5nLnN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcG9zdC5nbHlwaE5hbWVJbmRleCA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4W2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3N0Lm5hbWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPj0gZW5jb2Rpbmcuc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVMZW5ndGggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgICAgICBwb3N0Lm5hbWVzLnB1c2gocC5wYXJzZVN0cmluZyhuYW1lTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyLjU6XG4gICAgICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcG9zdC5vZmZzZXQgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zdC5vZmZzZXRbaV0gPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBvc3Q7XG59XG5cbmZ1bmN0aW9uIG1ha2VQb3N0VGFibGUoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgncG9zdCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMzAwMDB9LFxuICAgICAgICB7bmFtZTogJ2l0YWxpY0FuZ2xlJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuZGVybGluZVRoaWNrbmVzcycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdpc0ZpeGVkUGl0Y2gnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTQyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21heE1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5NZW1UeXBlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfVxuICAgIF0pO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VQb3N0VGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlUG9zdFRhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy90YWJsZXMvcG9zdC5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5pc0Jyb3dzZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG5leHBvcnRzLmlzTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbn07XG5cbmV4cG9ydHMubm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmxlbmd0aCk7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmlld1tpXSA9IGJ1ZmZlcltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWI7XG59O1xuXG5leHBvcnRzLmFycmF5QnVmZmVyVG9Ob2RlQnVmZmVyID0gZnVuY3Rpb24oYWIpIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihhYi5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBidWZmZXJbaV0gPSB2aWV3W2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG59O1xuXG5leHBvcnRzLmNoZWNrQXJndW1lbnQgPSBmdW5jdGlvbihleHByZXNzaW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgSU9iamVjdCBmcm9tICcuL3JldmkvY29yZS9JT2JqZWN0LmpzJztcbmltcG9ydCBDYW52YXMgZnJvbSAnLi9yZXZpL2dyYXBoaWNzL0NhbnZhcy5qcyc7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSAnLi9sYXlvdXQvVmlld3BvcnQuanMnO1xuaW1wb3J0IFBlcnNvbmEgZnJvbSAnLi9wZXJzb25hL1BlcnNvbmEuanMnO1xuaW1wb3J0IFBlcnNvbmFFdmVudHMgZnJvbSAnLi9wZXJzb25hL0V2ZW50cy5qcyc7XG5cbmltcG9ydCBJbnB1dE1hbmFnZXIgZnJvbSAnLi9yZXZpL3BsdWdpbnMvaW5wdXQvSW5wdXRNYW5hZ2VyLmpzJztcbmltcG9ydCBFYXNpbmcgZnJvbSAnLi9yZXZpL3BsdWdpbnMvZWFzaW5nL0Vhc2luZy5qcyc7XG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJy4vcmV2aS9wbHVnaW5zL1NjaGVkdWxlci5qcyc7XG5cbmltcG9ydCBHZW5lcmFsQ29uZmlnIGZyb20gJy4vY29uZmlnL0dlbmVyYWwuanMnO1xuaW1wb3J0IFBlcnNvbmFDb25maWcgZnJvbSAnLi9jb25maWcvUGVyc29uYS5qcyc7XG5pbXBvcnQgTGF5b3V0Q29uZmlnIGZyb20gJy4vY29uZmlnL0xheW91dC5qcyc7XG5cbmV4cG9ydCBjbGFzcyBQZXJzb25hcyBleHRlbmRzIElPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubUNvbmZpZyA9IHtcbiAgICAgICAgICAgIGdlbmVyYWw6IE9iamVjdC5hc3NpZ24oe30sIEdlbmVyYWxDb25maWcsIGNvbmZpZy5nZW5lcmFsKSxcbiAgICAgICAgICAgIHBlcnNvbmE6IE9iamVjdC5hc3NpZ24oe30sIFBlcnNvbmFDb25maWcsIGNvbmZpZy5wZXJzb25hKSxcbiAgICAgICAgICAgIGxheW91dDogT2JqZWN0LmFzc2lnbih7fSwgTGF5b3V0Q29uZmlnLCBjb25maWcubGF5b3V0KSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1DYW52YXMgPSBuZXcgQ2FudmFzKGVsZW1lbnQsIHRoaXMubUNvbmZpZy5nZW5lcmFsLmluaXRpYWxEZXZpY2VTY2FsZSk7XG5cbiAgICAgICAgdGhpcy5tRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubVZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KHRoaXMubUNhbnZhcy5zaXplLndpZHRoLCB0aGlzLm1DYW52YXMuc2l6ZS5oZWlnaHQsIHRoaXMubUNvbmZpZy5sYXlvdXQpO1xuICAgICAgICB0aGlzLm1TaXplRG9tYWluID0gdGhpcy5tQ29uZmlnLmdlbmVyYWwucGVyc29uYU1heFJhZGl1cyAtIHRoaXMubUNvbmZpZy5nZW5lcmFsLnBlcnNvbmFNaW5SYWRpdXM7XG5cbiAgICAgICAgSW5wdXRNYW5hZ2VyLnJlZ2lzdGVyQ29udGV4dCh0aGlzLm1DYW52YXMucmV2aUNvbnRleHQpO1xuICAgICAgICBFYXNpbmcucmVnaXN0ZXJDb250ZXh0KHRoaXMubUNhbnZhcy5yZXZpQ29udGV4dCk7XG4gICAgICAgIFNjaGVkdWxlci5yZWdpc3RlckNvbnRleHQodGhpcy5tQ2FudmFzLnJldmlDb250ZXh0KTtcblxuICAgICAgICB0aGlzLm1DYW52YXMuYWRkQ2hpbGQodGhpcy5tVmlld3BvcnQpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIElucHV0TWFuYWdlci51bnJlZ2lzdGVyQ29udGV4dCh0aGlzLm1DYW52YXMucmV2aUNvbnRleHQpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgbG9hZERhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLm1EYXRhID0gZGF0YTtcbiAgICAgICAgbGV0IHRvdGFsUmFkaXVzID0gMDtcbiAgICAgICAgZGF0YS5wZXJzb25hcy5mb3JFYWNoKHBlcnNvbmFEYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBlcnNvbmEgPSBuZXcgUGVyc29uYSh0aGlzLm1Db25maWcuZ2VuZXJhbC5wZXJzb25hTWluUmFkaXVzICsgKHBlcnNvbmFEYXRhLnNjYWxpbmdGYWN0b3IgKiB0aGlzLm1TaXplRG9tYWluKSwgcGVyc29uYURhdGEsIHRoaXMubUNvbmZpZy5wZXJzb25hKTtcbiAgICAgICAgICAgIHRvdGFsUmFkaXVzICs9IHBlcnNvbmEuc2FmZVJhZGl1cyArIDIwO1xuICAgICAgICAgICAgcGVyc29uYS5wb3NpdGlvbi5zZXQodG90YWxSYWRpdXMsIDIwMCk7XG4gICAgICAgICAgICB0b3RhbFJhZGl1cyArPSBwZXJzb25hLnNhZmVSYWRpdXM7XG4gICAgICAgICAgICBwZXJzb25hLm9uKFBlcnNvbmFFdmVudHMuUEVSU09OQV9DTElDS0VELCBzZW5kZXIgPT4ge1xuICAgICAgICAgICAgICAgIHNlbmRlci5zZWxlY3RlZCA9ICFzZW5kZXIuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubVZpZXdwb3J0LmFkZENoaWxkKHBlcnNvbmEpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBlcnNvbmFzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BlcnNvbmFzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblxuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcG9seWZpbGwvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuY29uc3QgR2VuZXJhbENvbmZpZyA9IHtcbiAgICBpbml0aWFsRGV2aWNlU2NhbGU6IDAsXG5cbiAgICBwZXJzb25hTWluUmFkaXVzOiA2NSxcbiAgICBwZXJzb25hTWF4UmFkaXVzOiAyNTAsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBHZW5lcmFsQ29uZmlnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy9HZW5lcmFsLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuZXhwb3J0IGNvbnN0IExheW91dENvbmZpZyA9IHtcbiAgICB6b29tQ29udHJvbHNQb3NpdGlvbjogJ3RvcC1yaWdodCcsIC8vIGF2YWlsYWJsZSBvcHRpb25zOiAndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCdcbiAgICB6b29tQ29udHJvbHNQYWRkaW5nOiAxMCxcbiAgICB6b29tQ29udHJvbHNCdXR0b25TaXplOiAyNCxcbiAgICB6b29tQ29udHJvbHNCYWNrZ3JvdW5kQ29sb3I6ICcjZmZmZmZmJyxcbiAgICB6b29tQ29udHJvbHNCb3JkZXJTaXplOiAxLFxuICAgIHpvb21Db250cm9sc0JvcmRlckNvbG9yOiAnI2NjY2NjYycsXG4gICAgem9vbUNvbnRyb2xzRm9udFNpemU6IDE2LFxuICAgIHpvb21Db250cm9sc0ZvbnRDb2xvcjogJyMyMjIyMjInLFxuICAgIHpvb21Db250cm9sc0ZvbnRTaGFkb3c6IGZhbHNlLFxuICAgIHpvb21Db250cm9sc0ZvbnRTaGFkb3dDb2xvcjogJyMwMDAwMDAnLFxuICAgIHpvb21Db250cm9sc0ZvbnRTaGFkb3dCbHVyOiAyLFxuICAgIHpvb21Db250cm9sc0ZvbnRTaGFkb3dPZmZzZXRYOiAwLFxuICAgIHpvb21Db250cm9sc0ZvbnRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgdmlld3BvcnREcmFnVGhyZXNob2xkOiA4LFxuICAgIHZpZXdwb3J0TWF4Wm9vbU11bHRpcGxpZXI6IDIsXG4gICAgdmlld3BvcnRNaW5ab29tTXVsdGlwbGllcjogMC4zLFxuICAgIHZpZXdwb3J0Wm9vbVNjcm9sbE11bHRpcGxpZXI6IDAuMDAxLFxuICAgIHZpZXdwb3J0RGVsYXllZFJlZHJhdzogdHJ1ZSxcbiAgICB2aWV3cG9ydERlbGF5ZWRSZWRyYXdUaW1lOiA1MCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExheW91dENvbmZpZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb25maWcvTGF5b3V0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuY29uc3QgUGVyc29uYUNvbmZpZyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMzMzMzMzJyxcbiAgICByYWRpdXNPdmVybGFwOiAxLCAvLyB1c2VkIHRvIGdyb3cvc2hyaW5rIHRoZSByYWRpdXMvdGhpY2tuZXNzIG9mIGNpcmNsZXMgYW5kIHN0cm9rZXMgdG8gbWl0aWdhdGUgYXJ0aWZhY3RzIGNyZWF0ZWQgYnkgY2FudmFzJyBhbnRpLWFsaWFzaW5nLlxuXG4gICAgc2VsZWN0ZWRCb3JkZXI6IDQsXG4gICAgc2VsZWN0ZWRCb3JkZXJDb2xvcjogJyMyYWIzZTQnLFxuXG4gICAgdW5zZWxlY3RlZEJvcmRlcjogMixcbiAgICB1bnNlbGVjdGVkQm9yZGVyQ29sb3I6ICcjQ0VDM0I4JyxcblxuICAgIGdhdWdlVGhpY2tuZXNzOiA4LFxuICAgIGdhdWdlQmFja2dyb3VuZENvbG9yOiAnI0Y2RjFFRScsXG4gICAgZ2F1Z2VQYWRkaW5nOiAxLFxuICAgIGdhdWdlTWFya2VyVGhpY2tuZXNzOiAyLFxuICAgIGdhdWdlTWFya2VyU3BpbGw6IDUsXG4gICAgZ2F1Z2VNYXJrZXJDb2xvcjogJyMyZjJmMmYnLFxuICAgIGdhdWdlQmFyUGFkZGluZzogMyxcbiAgICBnYXVnZUJhckNhcHM6ICdidXR0JyxcblxuICAgIGF2YXRhckJvcmRlcjogMixcbiAgICBhdmF0YXJCb3JkZXJDb2xvcjogJyNGRkZGRkYnLFxuICAgIGF2YXRhclN1YkltYWdlUG9zaXRpb246IDAuNyxcblxuICAgIGxhYmVsV2lkdGhTcGlsbDogMTAsXG4gICAgbGFiZWxTY2FsZUZvbnRTaXplczogdHJ1ZSxcbiAgICBsYWJlbFNjYWxlQmFzZVBlcnNvbmFSYWRpdXM6IDEyNSxcbiAgICBsYWJlbFZlcnRpY2FsUG9zaXRpb246ICc1MCUnLFxuICAgIGxhYmVsQ291bnREaXNwbGF5TW9kZTogJ3RvdGFsQ291bnQnLCAvLyBBdmFpbGFibGU6ICdub25lJywgJ3Byb3BlcnR5Q291bnQnLCAndG90YWxDb3VudCcsICdwcm9wZXJ0eUNvdW50L3RvdGFsQ291bnQnXG4gICAgbGFiZWxQcm9wZXJ0eUNvdW50SW5kZXg6IDAsXG4gICAgbGFiZWxOYW1lQW5kQ291bnRzUGFkZGluZzogNCxcbiAgICBsYWJlbE1pbkZvbnRTaXplOiAxMixcbiAgICBsYWJlbE1heEZvbnRTaXplOiA0MCxcblxuICAgIGxhYmVsTmFtZUZvbnQ6ICdkZWZhdWx0JyxcbiAgICBsYWJlbE5hbWVGb250U2l6ZTogMTgsXG4gICAgbGFiZWxOYW1lTWF4TGluZXM6IDIsXG4gICAgbGFiZWxOYW1lQ29sb3I6ICcjRkZGRkZGJyxcbiAgICBsYWJlbE5hbWVCYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDMzLDMzLDMzLDAuNyknLFxuICAgIGxhYmVsTmFtZUJhY2tncm91bmRQYWRkaW5nOiA2LFxuICAgIGxhYmVsTmFtZVNoYWRvdzogZmFsc2UsXG4gICAgbGFiZWxOYW1lU2hhZG93Q29sb3I6ICcjMDAwMDAwJyxcbiAgICBsYWJlbE5hbWVTaGFkb3dCbHVyOiAyLFxuICAgIGxhYmVsTmFtZVNoYWRvd09mZnNldFg6IDAsXG4gICAgbGFiZWxOYW1lU2hhZG93T2Zmc2V0WTogMCxcblxuICAgIGxhYmVsQ291bnRGb250OiAnZGVmYXVsdCcsXG4gICAgbGFiZWxDb3VudEZvbnRTaXplOiAzMCxcbiAgICBsYWJlbENvdW50Q29sb3I6ICcjRkZGRkZGJyxcbiAgICBsYWJlbENvdW50U2hhZG93OiB0cnVlLFxuICAgIGxhYmVsQ291bnRTaGFkb3dDb2xvcjogJyMwMDAwMDAnLFxuICAgIGxhYmVsQ291bnRTaGFkb3dCbHVyOiA0LFxuICAgIGxhYmVsQ291bnRTaGFkb3dPZmZzZXRYOiAwLFxuICAgIGxhYmVsQ291bnRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgbGFiZWxUb3RhbENvdW50Rm9udDogJ2RlZmF1bHQnLFxuICAgIGxhYmVsVG90YWxDb3VudEZvbnRTaXplOiAxNixcbiAgICBsYWJlbFRvdGFsQ291bnRDb2xvcjogJyNGRkZGRkYnLFxuICAgIGxhYmVsVG90YWxDb3VudFNoYWRvdzogdHJ1ZSxcbiAgICBsYWJlbFRvdGFsQ291bnRTaGFkb3dDb2xvcjogJyMwMDAwMDAnLFxuICAgIGxhYmVsVG90YWxDb3VudFNoYWRvd0JsdXI6IDQsXG4gICAgbGFiZWxUb3RhbENvdW50U2hhZG93T2Zmc2V0WDogMCxcbiAgICBsYWJlbFRvdGFsQ291bnRTaGFkb3dPZmZzZXRZOiAwLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUGVyc29uYUNvbmZpZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb25maWcvUGVyc29uYS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmV4cG9ydCBjb25zdCBBcmlhbCA9ICdkMDlHUmdBQkFBQUFBR0hBQUJRQUFBQUFxK3dBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQnZBQUFBQndBQUFBY1BldS9Wa2RFUlVZQUFBSFlBQUFBSWdBQUFDZ0JGd0FrUjFCUFV3QUFBZndBQUFKVkFBQUhsREdXTXZKSFUxVkNBQUFFVkFBQUFJc0FBQURLd0IvSXowcFRWRVlBQUFUZ0FBQUFFZ0FBQUJKaFpHRitUMU12TWdBQUJQUUFBQUJnQUFBQVlCQ0pXZ2xqYldGd0FBQUZWQUFBQVlnQUFBSGluOUJDS0dOMmRDQUFBQWJjQUFBQVNBQUFBRWdPL3hLcFpuQm5iUUFBQnlRQUFBR3hBQUFDWlZPMEw2ZG5ZWE53QUFBSTJBQUFBQWdBQUFBSUFBQUFFR2RzZVdZQUFBamdBQUJQblFBQWpQUTljZG9xYUdWaFpBQUFXSUFBQUFBekFBQUFOZ1J2Ukk1b2FHVmhBQUJZdEFBQUFCOEFBQUFrRDdFRi8yaHRkSGdBQUZqVUFBQUNDd0FBQTU3UGgwa0liRzlqWVFBQVd1QUFBQUhHQUFBQjByS3drUTV0WVhod0FBQmNxQUFBQUNBQUFBQWdBZ1VCc1c1aGJXVUFBRnpJQUFBQ1hnQUFCaWFYMHJjL2NHOXpkQUFBWHlnQUFBSG1BQUFDMGN5UHZXaHdjbVZ3QUFCaEVBQUFBS2NBQUFFRXo5L04wSGRsWW1ZQUFHRzRBQUFBQmdBQUFBWkUzVktsQUFBQUFRQUFBQURNUGFMUEFBQUFBS0xqSnlvQUFBQUF6c3IxWEhqYVkyQmtZR0RnQTJJSkJnVWd5Y1RBQ0lUUGdaZ0Z6R05nWUlSZ0FCcXhBVHdBQUhqYTVWTTlhRk5SR0QzMzNmdGVxN1Q1STRRU1RIQ0lnZzRWSWxvVGloUUpKWlhnRU52U2hDQTJFbjJZMnVFaGd1aFV4TkdBT0RpSVkzR1dOeFFuY1JMbllvTVBuTVZCeEVrYytqejM1bG1DTFc0dGlzUEo5Nzd2Zk9kODczNzNCUUxBWVRTeEJuWHRycmVDN0EydjA4Vnh0OVAyVUZ4WnZyMks4MURzUVJoQzkrNzlMT2doYXZQVm80eS9XS3ZiOFZZUnU3WHNkWkZtcm12QUtLTUZTYTBOQnlQTUQ1RTlnZ0tLbU1FbHRPRGhNVHQwMzBQeks2eEhKaXJybWJWaGJWcGZvMnhiWnVWWldSOWs4cXE4TDU5S1A4cmV5SS95aDhxWWJGUVYxSXhxcXdkcVhiMVZuKzB4VXgyM1UvYWtmZEcrYnEvWnorMVg5bnY3bXhOelRqcXpUbnN3MWJrQ0lUNlpNNll3aVdsY2dJczdlSUoxYkFoTG5CTTN4UXZ4VXJ3Vzc0aE44WUZuS29ROVRJVUJwZ21CZE9qeWJOTFVYSlNJY3VpVGM5RWczeVJhUkorNVJEek1JVWxvaHhGcS9DR05helF0MXZwa0Zka0E4ZTN2U0JJRk1zck1MQkhsYUhacTBFTy9CQlhhTjBma2piK0xJcmtLbjJlSktsR2pjNTF4Z1hHUmNZbXhTVjJMR0tkTEpYS3AwTVduaTI5Y0trU1Y5UnJkNm94YXJaWDZQY2VvNmxFVlVOV2pLcUFxb01xbnlxZEtLd0lxQWlyMEZyNGd2bk9xQk9mb2srV296SWYzaG1aVm9qZXQ0REx6ZWNZbDlqUUlDM042a3pobU50a3pVL3Vvc1I1blo1S3dkdW9DVyt5VlpzZUxadi82cnJneGZvVUZuTUFwbk1ZWlRLR0VNdTk4RGd0bzhOL1J3aFlkcGVrVWlKa3ZXVVRRMVRTUklDYUc2Z1BPSWpkaFdPemk5a08zSDl4Qm4rRlB1b1BtSkRMSUltOXUvbmYyWCt2NG0vYjZmM1A2bml6ZVUyYXZtL29KT0xiK0hRQUFBSGphWTJCa1lHRGdZb2hnS0dKZ1NhNHN5bUdRU2k5S3pXWlF5VWhOS21Jd3lFa3N5V093WVdBQnFtSDQveDlJd0ZpTUtHeEdvQW1NUGlFZUNrQWFKc3VVbkp4YndNQUhKa1dBZkpBWUExZ3RFd01iQXg4REd5T0lKd0JrZzhTVUdKakJzbnhBTEFabU1USDRNUGlDZFlGa21JQXFSWUE4Q2FoSllCdUFrSm1CRmV4K1pRWm1BSUh1Rm1jQUFBRUFBQUFCWVhKaFlnQU1BQUFBQUFBQUFBQUFBd1ExQVpBQUJRQUVCWm9GTXdBQUFSc0ZtZ1V6QUFBRDBRQm1BaElJQlFJTEJnUUNBZ0lDQWdUZ0FDci93QUI0UXdBQUFBa0FBQUFBVkUxRElBQkFBQTM3QWdabS9tWUFBQWdNQXNGQUFBSC8vLzhBQUFRbUJib0FBQUFnQUFSNDJtTmdZR0JtZ0dBWkJrWUdFTGdENURHQytTd01CNEMwRG9NQ2tNVURaUEV5MURIOFp3eG1yR0E2eG5SSGdVdEJSRUZLUVU1QlNVRk5RVi9CU2lGZVlZMmkwZ09HMzB6Ly80UE40UVhxVzhBWUJGWE5vQ0NnSUtFZ0ExVnRDVmZOQ0ZUTitQL3IvOGYvRC8wditPL3o5Ly9mVncrT1B6ajBZUCtEZlE5MlA5anhZTU9ENVErYUg1amZQNlR3bFBVcDFJVkVBMFkyQnJnV1JpWWd3WVN1QU9oMUZsWTJkZzVPTG00ZVhqNStBVUVoWVJGUk1YRUpTU2xwR1ZrNWVRVkZKV1VWVlRWMURVMHRiUjFkUFgwRFF5TmpFMU16Y3d0TEsyc2JXenQ3QjBjblp4ZFhOM2NQVHk5dkgxOC8vNERBb09DUTBMRHdpTWlvNkpqWXVQaUVSSWEyOXM3dXlUUG1MVjYwWk5uUzVTdFhyMXF6ZHYyNkRSczNiOTJ5YmNmMlBidjM3bU1vU2tuTnZGdXhzQ0Q3U1ZrV1E4Y3NobUlHaHZSeXNPdHlhaGhXN0dwTXpnT3hjMnZ2SlRXMVRqOTArT3ExVzdldjM5akpjUEFJdytNSEQ1ODlaNmk4ZVllaHBhZTV0NnQvd3NTK3FkTVlwc3laTzV2aDZMRkNvS1lxSUFZQWRYU0pjd0FBQkNZRnVnQ3RBS0lBbEFDYkFJMEFwZ0M2QU5FQXRBQzVBSzhBdEFDa0FMNEF3Z0RJQUpJQWlnQ29BSmNBZGdDUUFJRUFZZ0J0QUdZQWVRQmtBR29BZlFDZ0FFUUZFWGphWFZHN1RsdEJFTjBORHdPQnhOZ2dPZG9VczVtUXhudWhCUW5FMVkxaVpEdUY1UWhwTjNLUmkzRUJIMENCUkEzYXJ4bWdvYVJJbXdZaEYwaDhRajRoRWpOcmlLSTBPenV6Yzg2Wk0wdktrYXAzNld2UFUrY2trTUxkQnMwMi9VNUl0Yk1BOTZUcjY0Mk10SU1IV214bTlNcDErLzRMQnB2UmxEdHFBT1U5YnlrUEdVMDdnVnEwcC83Ui9BcUcrL3dmOHpzWXREVFQ5TlE2Q2VraEJPYWJjVXVEN3huTnVzc1Arb0xWNFdJd01LU1lwdUl1UDZaUy9yYzA1MnJMc0xXUjBieURNeEg1eVRSQVUydHRCSnIrMUNIVjgzRVVTNURMcHJFMm1KaXkvaVFUd1lYSmRGVlR0Y3o0MnNGZHNyUG9ZSU1xellFSDJNTldlUXdlRGc4bUZOSzNKTW9zRFJIMllxdkVDQkdUSEFvNTVkekovcVJBK1VnU3hyeEpTanZqaHJVR3hwSFh3S0EyVDdQL1BKdE5iVzhkd3ZoWkhNRjN2eGxMT3ZqSWh0b1lFV0k3WWltQUNVUkNSbFg1aGhyUHZTd0c1Rkw3ejBDVWdPWHhqMytkQ0xUdTJFUThsN1YxRGpGV0NIcCsyOXp5eTRxN1Zybk9pMEozYjZwcXFOSXB6ZnRlenI3SEE1NGVDOE5CWThHYnovditTb0g2UEN5dU5HZ09CRU42TjNyL29yWHFpS3U4Rno2eUo5Ty9zVm9BQUFBQUFRQUIvLzhBRDNqYXhiMEhZQlJsMmpnKzc4eHMzK3p1Yk0ybWIzcEl5SWJkdENXUWhONmtpZlFpdllVaVZVUkFPZ2dJZ2lCWTZDaEZrWm5OZ29KNElpZ2dpRjA4KzNuZmVSbzl5NTEzWnlFWmZzL3p6bXdhQWMrdi9QOWlrdG5aM1puM2VkNm50MkZZcGpQRHNPTTFBeG1PMFRINUVtSDg3Y0k2UHZYYmdLVFZmTnd1ekxGd3lFZ2NudGJnNmJCT20xYmJMa3p3ZkZEd0NSayt3ZGVaVFpIVHlRNTVzbWJncjA5MTVxOHdjRWxHWkJpeVNYT0swVEFHSnNTRXRReVRLK21NTmZCTkpwZUlSci9JWEJXMWdRaG5aeEw0WFBXUHFBOUlKcExMU0VRbjJFVStWTkRHSVFRRkxvMHJDcnJFendybit0L2c1NUV1OHZPMVA4bGJyK0J0NEQ2anVHcjJibm9mRXpPS29aY1hkY0dJeHNqbzRZTEdBQkhOZUMrSnM5ZFU4eHlqejQxb3JJd0FiMm44RVY0NTRteVNsdVJLQnZpRTBhQ0ZUNWlVOHlaL3hFaVBwQmhZRkN3R2xzR2xFZnA3MUpYV00wamNsWUpwL0tVZmZwQnJpQWQvNDNwYzE3L2toMnJlWWVLWlpES1FDY2NCM0dHWDJ4c01Cc002V0Z0WWJ6TGpzWVl3dWRWYWd6RW0zUk9VZUUxTk5XZExTazczQkNJTWlkUEU1RmF6UWtJaXZzWEFXMDVQYkR5OFJjUVV2eGgzVmZKYWEwU3ZUZExCa3ZYV21yQk9iOHl0cnRReGhseVJENGg2bStTR04xendoc3VOYjdnYzhJWWxJTHBzaUZySmJLMlJmQ1JYTEk0N1ZYN2l4eExHbFdzOFZYN3l4KzU0SU1iWnF0azRuU08zbXFPL3RmZ2JibFZ0OE9yaHdHMnJOcnBOY09DeVZjZTR6UEFCRy8wdDBOOU8vSTJmOGREUHdMZGk2YmZnbXZIUjZ5UkVyNU9JbjZsT2luNHlHYzl6bFRhV1E0ellCQVE0SVRFcE9iL1pmMkpsbkxJTkRsK1J6eEhrOENmb1N1TjhMaCtYNXNDZkVwL0Q1N3JRVS82ZStBYy9QSmlVRGQ0KytPamxYc1F0dnpiNDRVSHllVGdYSVcxN3lhK1F6ZHRJMVRaeVZCNkFQOXZrYmR2a1FlUUkvc0I1b0N1TzZYRzlOZS9RZG1CYU1XMllVdVlJSTJiNXhmU2dwTkhXaUlGQU9FdUR1TTNLQk56NllWT0NrbFZURTdiNjhhVFZaZ0FDRC9sRjAxVXAxMVFqNXRwRWtuSlZrQmc0WnZ3U29hZWtUSkliMWxqekE0RkFKSVBTV0ZpSWd4Y0JNY01tRmNFKytjdzFvczhtdXZHYkhqajIrQ1czdVVacWk5eWh5UUx1U0F1SmZ1RlpocGpjSGw5K2Fib25KRnJ0b2gxWnBzVHRjWHVFekt4OFVsUllVbHdDNUlvbmRQa2tTM0I3a2xpWFU2dHpwUlhsc3c0bmZNeENTRGw4TGpPcngzRlgwVzFUWjg0ZE5ITHQ4T3FwTzBmTWp6MWxtekJrYmQ0ZFUwUGZ2VEIxemVGN1g1MTA3NVI3eUcxVDdoK3ptV3hQM2R4NXRJbHQ3K3BRY0dUYW1idjcyUWNOc3ZZZSsxVEMxRm4ydWw5U0hSbFR0d3g4L2xmRGlZZ3crQ3czY01TaURQSVAyOXBycDJNZW56UDJiajl3NnQzWEwybDNBNCtZR0Evd1NSWVRaTFl4SUdxQWM3M0JpRXZISkFIelpmakYyR0FrVjNuUnhoOUpwa2ZWaHVRMndLQlcrb0tJaFpTMWdhWkZzMDJ5QTlxMGNLaTFTUWx3bUEySDJUWXBIdzVUZ2VnUnFYYXpZSy9tRE1oTklTay9HMTU0a3pQaTRBVWp0Y2tWN0ZKQ2FpZ0VyQU5IakRhRXFDd3NEZ2JjZ0xDMDFNd1NwenNZS0FaTXBhVnFIU1JvSURkNTcrNWRENjg3L3V6cVZkTE9ZUjA3RHgzV3FkUFFuVnpxbHRyUHlSZTd0c01iYStnYlhlQ056a1A1WVRzL2Z1WEZVNitlUC9IQW5MbVBicHd6OTljdnRZWmZmaUliZDMyRXB5OGMzekNYbnFiME9PVDZwNW9zd0ZreWs4TVVNL2N3NFFTVXFHbDhUZGdBaUpNS05UVkVMS0hvU0JGcXFyVXBJT21rVmtBNEtUYXBEZks5bWVKSW9GaW9rVXJoYnlzdGtCRVhFdHNJRVVOQ1dwWUZhY2hzRDF1OW1hRVFZQ1F0QWQ1Mmg4UkM0UVNqTlR1OVdmbndBWXFURXFRc0JYb05LUzd4YUhWQVhwbFpGcEtXbXFYaW9vUllDTkJYc2tKY2dKWWh4NTRaMS9HTm5RKy9LSDlEZEsyOXp4ZmNQbUhwUGRQbkRuMTc0ZWNycTg1dVhONy9hS0Y4WXN2RVkybHAvZVoxdWJOYmp6Rms2OXFQQnN6ZTJISGx1ZWVXdmJWVmxvYk16VDZ6YVBYd1RWM3ZIemR1eDZJRFE4OU02RWNlR2J5TlBaN2FxOVhJTHBNcmV0MDVDdkJFbUdGY05jbWkrcUJBMFFhcUtpQ2lOcW9IcUM3UVVGMmdhQUNVcGZYeWZkaVZncG44Sy8vNmwvd2R2ZDRpdVQ4N0d2QnVZMktaTUUrVmwwQXZaQUkwMnBYdklac0Z0VHI0NTdLUnRFeDJVZTlocDVmZGs5VStMWmZrTHR2Mk91djQ3c082YTI4T1hmZnc4eS9JeVhMS2FmSXpjK08xOWRGcnMxZWxtSVpyTTBKaFZpYjhDd0lUdTJ5c2JoSEp6VTF0bjdWdzJlbGh2ZC9ZS3ZjbmZ5S2Zuejc1OExwaGIxK3IrL0E3K1IreS9qUzlkaVUzam4wUHJoMkwybGVEZUhBYUdSM3drZzBVaWRjdmFxNUd0RlltRzRDUFE3N1JDUFl3cDdmVG5kYzRoUVpSQW5mVzZobzJXYXZMS2k3SnJNemYzZDFCTm5QT1Nhdnk3MXZZZnVhQ3RuMTdsczZmRzFqR0g5MVltbk84ODdodGhYa2JXMW1LMWc3c3UvYUJuZ00zNVh2cG1tWXozL0p0K1JQQTk3ZURmZUFIUFMwUmZZMm9DWVFaZ3FLVE1ScHl3NFRCUThLaEZBWFZiYndxc2dISkVGTUQyaTFzTU9KN0JoMTh6R2pBUXlPb3ZYcnQ3QU5qQVZTQmtDYk1KcHVPa0UzeXJDUHNmWWZ3N3lGNUJ0bWk0UHlJL0NsWndWeGhqQ0RYd3p6eWtNWUlyR1B5aS94VlNXZXZFWFcyQ0tmYUJYN0pETGpoZUVDSE1RUzM4SlNUa2pRZ0VwQ2dSMExGM01Rci9RYS81eDB6L01xVldlc3o4ZG9keUhQc1ZIWTZjR3NxUTJXOW9RWi9pTWo3SllaUUt3Y29VZEpFMSt2cXdPYVE1NDRmeCsrZWdsOXJZRjBjOEhlWXdYVVJzSmFpQjNpSlJ0U3JYaUlJYXpsMUJTMGh3akRYdjJSRHNOOGMwMFg1dnNnRkZXdUlEYXJmUnJpeUZYdUh3R3BZWmZzMWlqWFFmdDkzNTlBSTRJaWlaVjBrU01qaEIrVWhYczNmZm5VcXR0WkFzRzBFelJtZzEwU3dHOE14dURnbktENWtDeWtPSlZBU1hhVUF3a2F3U1I0MHFvQ1NrK0d2UndDcEdzTWplY1VCZVVsZ0ZDS0IyZXdnUjVLSUhTaGJpOUxEWVVQcElkaEFaT2kwQTZ2ZTJUTS9QTGZqMUhmMnZudlA1cE9IRnkwNmZIakpvcDRqMlhjSVQ5by9mV2UxZlAxRFdaYlBIZDN4TE5rcGIvLytCektaVFAxdXltcTZ6NS9CZ3EvQldvMU1CaFBXb1JXbU1DOXN0TzZxcERYVjBMM1ZLb1ltM1E3WTNDRFFqb1Y4dHYzUC9ybVJEdTl3KzU3cGR1bk9YeXY1ZThzWDBXdVdNd3l2ZzJzbU1iM1ZQVXJnYXNKMmhONkUwQ2Y3UmV0VnlRTFFXMnlTSHMwd09Fd01TQ2xvcWxsQTNXanMzZ1NxYmt3SitNcGlkVkdaR3N3c2dadEhSYVV1cTV4UTRXb2hPdmpmNXlwblBSbjdILzMrMENQM0xuK2NuSFQ4L05ZNy8rNSs4T3krRVVuc0d4M2FqVHV6NU9VdkpsWTk5UGc2eHhzZmZIMTB5SkhUQjlhT2FYT1VybmZROWIveWJsaHZMck9DQ2VmZ2VzSFNEQ2ZnZWwyYW1valZtSk1Ra3l0WmRUVmhvNVZ5a3htWkxvL3VJZG9wWHJRK1l1R0FLT1ptcHExR3RPTzVGTmpWMXFoS1lnWDdjU052VGtqTG9XQVpnVldBbDFHQmlGWUJiUlNYUFJ6clRRblJ6UzVKSWxFMXFTdHAwSmdLdkVrRTJRcC9NNkJSQjBXU3QxWGRkMnpmNHVCdFRydHB6bk9ycDA3WjRJejR2bjVtd2FXcWllT1hQeWgvZGZXbDYyUkY3Q05yeE9XTDlqcDNzUXNXajF1K2NtWEs4UXVUd3VQdmZEdy82WVdOWitSLy9SVm9GZ3h3M2diNndNakVNS09ac0FFcGdVVnh5SmdNYkF6WXpHQmpnd3pTZ2xTMCtFWERWZEVja1BRQU1oY0k2Nm1JMFd0QjJoaW9rVzFBYVdQRnpUUUEyYkM0and3Y2tKRElDbUlNZ2xoRWdnSllwRUJHNEJqRnNUc2ZPbjgrSWhlUnkrVE9KN2dUdFQyZmtQZkNFYnNOOWdaNXlhZDVFbWhwdGFyTFlXL0FMNUpjUENEWkwxazVoYUJ3SzJ6MU94QnJxMEZxb3ViN21SK3JxTlZ1emJlSWxqTWF5Ujd6aTBWMG5HRWtpeU0vbjFSYnJIYUhhalFUK0M1c1RJd3JBVGNtVnBCc1FramRyV3FHeE1RcWlyM1I5c0NlT05Db0J1WmtYRTRkMmpnRFgzQTlNbTE1NU9pR3dSdXlEMjlrUDZoN3R1L0t6V2VJZnU0RC83eFlSNWJhMXExL2VkK2o0YjRWYnZidlQ4dnpSOGovZnV2QzV2Q2ZGTG5SRzJCMUFSMG1nalU5aFFuSEk3U3BVYmxoQmtwMFpzZnpRSWxPSG1ET1ZVU0lpWXFRREJRZHdFUjZwRG9kTUcwZVloOWt5WEhlR1orVW1rMnBManNWcWM0RE1JVWtNd29YblY0UkxpVm9wS0RXUW9vRFZrSTZzeU5mcGFVeUpjNUc0UGJlZWY5WFJ6OXhWOGZtOWFnYTFHSGdXTGJENlVtUnVydmZYUG01L0pjMyttN3NNL3ZBdm5zWEhtR2ZJWWRmT25UMktjdlVndDRGNWQ5OVBHNjAvTlBiNjc1ZFFub2RIbmxrNkhPN2RodzdwdWlZTVVCemJzMUJvTGlBUW5GVUdlQ0dVaEtUOU9hYUtIRnhDa1dCeTh0UWEwelJDMXFHMCtyU2l1Tkl5Ump1K0FiNTIxN0YxcFBjOGgvdjUzODl1bUdiYkpldlBmZlJVZkkxdWZBNFEyM0RBWUJmTCtEWHc2U0QxYk9PQ2J1b2JOS290bUUrWURnNzFXVUFER2VqbUdwRE1Sd0xhSTIxaVJtSVdTMGNhLzFTQmoxRjVUVVlpYUxkSnByeDNWdzR6dldqQ1NrRjRLM2NERUMvd2VwS1NPVW8rbE1UMEdBRzAwSE1Gb0JzNFcrK1hUSkhEZWhHeG1JOWV6ZEZ2cU9SOVR4ZzgrcTdwdjMxeFROZlYwMWY4NEQ4N3c4K2tQOTlzc2VEQTVZZE9ycjh2b050VjFkTlhuWC94RWxyeWFGTkw2WGw3Smk2NThQUDlremNucFAzOHRyVDF4bENYdXo5WU44bmx5NC9jb2pObXJ4eXhaM2oxcXhVZFphWHl1eFd6TjFNMklTWXNRTm0wTjFBZEVRU1VrMGNZQ2FoZ2ZhU0FkNWttMmhGMkMxZ2VGaUFHMlB3Rk5Wb1VTcjBnSjl3M01RbHBHWW9WSmhnQnpSWXJBQitxaUNDS1oxdEI3WGpWU1JmSVFNSXNBdFV5V1ZtVVVZclo0c0txY25NTnZZZUJoTGQrVTNmM3J2dzcvdWUvdEI5MUwxb3pJREYvWXBKOGZQVFQ5U0MvbHU4OTRtNUM4TGNXNThSMjZQeWY0R3Q5NlZjL2N5TFIyMExaOXgyM3gvdk1zY09xaUw2dHpjY08vYllZeWRlUnI0N0NjUzRtcytrc1IxL0k2c0NndzhTajFhRm5zWmgrQUFhRlNBRHFXMWhxTGN0TU81eThncit4dzJOeGx1by9RVFhORElXcHJMQmdncWI4Wm9tdktZVlRTblJGS0RXVkV5Z3FVRmx1NWxCaGZlS0dsV1pWK3JOS3Y1ZWVtUEMzTVg4bVMvanp6RmFoZ0VwNnpJUTExM2M1VnFaWTlsbGg4aWoxZkxMOGt2VnVMN1paQy9ZbUZvS2M1eGloWUY0QndOTW82ZndxdUFobHhING1jMWRyQzNsTHBLOWh3NlJGdzRkWXByZnE2VElRSXJ3WHFUMk9uZjV6OVdrZ3JTcmxpY2VvcmdZQm54dUJwc3JDZXk5TVV3NEdYR1JZbFJwS3g1WkxZMFNWQklRVkpJTllSZVRBMUpNVEkyVWlxaXhTYkZvZ2dCYnBjUGZHQkFBRWhldkNHaURHd1YwZkFvSWFDMFRrNlFJYUJSZlBPTEt3dXJTTXFsemoxUkU1VFg2THNPOFAxMStIenlnRlVPSzQ5aWpKTW5kSnYzNTBnTjN6M2swOXRRVlB1L0toMTgvT1hyZjNENDlSMDlMdDAvdDNiWXM5NG14YmFmc2Z2Q1JhMTlIOTNhbTNGLzNudVk5cGhzem1EbktoTjBJVHkvZ0ZRc2U1T2hycUI4aEJlQk1FdTcyQUZCWUhmMVNXM2pkdGlOS3M3YmxhRDhNb1RBWGcvdGRiS1BPUlhjQXY3dE42Z2MyWjZaQ0NKbUtYMjRFdjN3by9PM1hYYkNmY0dqY2diWWRFVlF4VTVCU2ZZb2NzYVFoSW5MQWVCSWRJV2xBTC9pZ2tZbnpaZVlYNHdlVDRJTnBDb2VWMkJsZmdFY2ZpYXFyTE1VZlJlRmpwMXFnSk1ocFhjaHBKY1gyb2tJMlBTMlZaMTFPT3g5TVNTOEpXZ2lmbHBwSHNqSXo4Qk1xVWkzc3pQRUx5VXVrOG1leWZ2YVkxMDc4c2N0QVo0eTJ3OTcrUXc5TjJmK1AyWU4zaFZLckgwektTU3dhTkh2VlUvTFJLMS9MaTk5N2p6ejBMNklsWTRjY0QvNHNIL243cC9MOThzK2Q3bUNMbDk5UnVtaFc5elZqS21kTnJTVHYvZk1UWWlVcGwxODllbG4rOVBOTHJiSzg3WHNObi96SFpidEp4WjdoSXgrckc3UEJHcC9WdmgrSjJYU1FwRDd6a1R6cDYzL0p1dzZMUzZaOGVOL3NMN2E5OE56OU96cXR2RHh4N2NNZEhueWQ3dHYxT29iUkRBVWJSd2M4bWRmVStvOW85YURoZ2NxMGxET1JCa0hYNkFHZFprQmJHaGo1YVp5UGMvZzRkTzA0TnZnV08rU1RwK29lMi9zQitmc2pYVk1UZ3BwVHYzWWxwK1hPN0REeThNbTdIMWhQOWMzRFFQYzFjRCtCU3RWeHFtU3hjMHAwVjJyRjFVU1NrK2h0azdsNnFXb1hRSVFHUUtsSVhveEhBQU1vcXNlbWlOTU1FSitpQWZZNnlVNFhKeVlMOEZKc1pSZTFhQ0VMdmtZV29vVk55L0FGS1BIbmt6UmZFUjRUNWZoaE52UFE1VGtUSjYzYU5IanBTeHZraDhqMFVabWRoclc5WTlzRytTaHB2NnkwWjYrdXkzZkpIMmxPRFQwNVlkU1R3YXpUU3lkSm85c2MxWmxMcTdyZWZrK2JvNEo3WXU4ZU0zTVVPVER4K3BlYStjRGZpVXhRaWVSS0RyMXF0WmowOWQ2TzFVNWRIREFHSFlJOW9tUDBibzhhS2JHbkE4Tmk1QTA0RkltTlJrWThXcUMxZEhiaU1kTHA3TWNrcit6RjRObUhEdi9YaU9sL1hiMy96OWxuMjh2bnZ2aFdmdjh4OXFzdnlFRHBUNWRiNzlteVQvNSs4L055emJyVEo5dDhmKzBsTWtQaDFWMnc1OE5nRDZ5d3VsSjFCMnpSSFVqazZsZG5BN1RiVkY4c3V0QkVHOFcxZ2xhUDIrTUdvNGhWa0Zxc3VDRmdNZmwya1YrZUdyWms2Tnc1ZlJadXZySktsa2hvOHhOdHV2VGVQcTNQVWZrMXpTbFg0bTFqNVRkZVBpakxoOGNFamhhMzZWTHo1RjkvYXBXRWVOc0g5UEVWck0zRTlGUlhab2l1akFmYTBDZ2txY0ZGS3NGNWc2QzQ5OVQxTjVnTStKc3pxSzYrNnQ4cnZyM3lzNDlQcjkzRjVkYSt4NjNVbkRvcVZ6d3R4eHlGKzRKVTVsZkJmUTJvbWZDK0xkL1QyTUk5Rys1bWFuYTNROXdudFYrd1lsMC92RlBibzNVVEZkcVlEclJ4RW1nakE3UkZPQlZoOUhBcWJjVG93YXBJVEVXTE5nSHZsMG52NXdDS2R5Z0NNZGxXRTQ1THh2dkdKY0FkcytCVUhOQk8yTUNub29FT2xLOUhnOElEdTVRY0VoTUZ5UUhlc2hoakI3OGoxRUJZR05ObFFVd1JuWllLTXRnN3dWZVVJU2owTmIyYTlQdG9OeUZiTW8vNXhwNll1ZXJzM2I3U05ZVGR2T1NIY3JrL08zMlQvT2FlUDhxN0krelZxMlJPWk5Keld3dnVXdHE3LzhxK2EzZS9MUCs4ZEV3SkVaNG1kWCthUGVja0dhWEFld0RvTFpYdWFZVXFZWFJxZkVFVGpIQkdpbDJ1WVVkTmdGMDJJSnFvSDR3R2hrNm9xZDlJVEJ5aHErMFREcHhsZnoxN3RrNnJPVlgzSkR2czE2NXNkVjF2NVg0dndxOWxjRCtPOFRYYXkvbzRDRndOZnpUMVYzenhMSW9xNWJ0bDE3L2t4c0IzbmVDeGg2Mk1RZ0xVRmlhaXl5ODZ3S1dLb1M0Vit1aXdVcG95MFlPTEpGb0I3d1l3VHlUaWFIQlpnU1BnQms0bHZsbFVXSFpNZDllNEhsT3p6dzU5YWZsTEU4ZVJQYkdIRm5XYXM0VDdSNjMzdVV0VFoxYTlvY2MxZ0l6VTNFN3hWZEFNWDN5d0taSW9XcWo5TDNGMGZ4RWM0ak1RSDlFSkQ1OWwvMGgwZFkrd3k2OHpkZi8rQWZDVXc3NWY5MHp0RHZhdlg4dThjaCsrRlkxM3FwSWZkMEhGbFRhS3F6QkhxWnpUR0tLeFRyb0pMcmo2MjRDMkg0OHFlTnZCTUZvclhNdkdkRld2Wll3SnFxdldCNk9CVDV1WlNoVE1KaG1WT0tWa0FvRWlzWHBVMVFoSFdHTzJoaFJJZk1UdEtTNGhHSlFqYVVUWVFkTEo4QUszdDRqY1NUVFB5NE9PeVVNMHA2NzlZM1AzZm85eHRiOTI1UzlmSytML2RDMEYxZ0t1alNhWjhuSkhGWC9hUnZoVFdSaFdZckJKbkdwRjRZbzRBNjVFRjEySnhPbFZqQktrT0NJOGZvRmpUMTJvbGVHdXkvajc0STVMcnkybDhuUWM4UE1ubW5kQmc4WmpiRXZ4RS9TcUxlZEZhWjhRbGZhaTFTYTUwQk1BZVpwSWsyMTRJeFBlMDR0T0FLTlQzRTgwU0ZDeVVuNHNzWUVQd0FpRkxGZ1d6RGl5bGhSZkpsMmZpc2duWG54RFBuWG9Ja2w4L3lNU2YwL041dGZsOTlsTFpEclplVlorNHVQUDVEM0hMNUpoZjVCL2t0OGdoU1MrbXBnZWtyK0l5bisrRHZBVHc4UkdNYVJJdTFpUWRtWUw1VWN6OHFPWExqc0dTTTBTUUpzVDkwc1BLNDlEcW90Rncwb2YxUVNZSEdKemlKZjRxRDlDbFFDYnM2WDN0QzFEdjVOZmxkZVNlMC92R25sYm01WHkvWnBURnZ1RUU5T2ZsK3ZxbnViSWh2dEdySERGS0hwcHlQV05tdThBank0bUc2eklzSjFSMEtkSXhrekVZdzVka0J2dzZMWkpxZXBxV21HYXhnM21MbSt6bTlDMDB3dWlKWXJRR0ZzSWpjS3czc1NFR2dsQXhLMGFsYTdIY0FtNFYwQnhLcDZIaUtUTHE0am5HVFBYekE3dDJybi9sUXZ5NldNWFNmekhrMGNNbitBL05QMHB3UGdIOHAvWlR6NGc0MCs5SkQveDRYSDVzNnFSdVd0Qzl3NC9RMFo4S1A5WmZqMnJ6UHVBZitUakpCUW14b2ZrOXhIR3ZVQ2JSd0gzc1dEM0QxV3AwNkpRcDVUSzEwUzhIb3ArU2pXS0J4QUw2UGNHMExsT1FtSzFLeVovVWl6Vnc2SldvSUxINjFGZWd2L1kxT2JCL0IzWWFmbHNWbVl1M1IwbFZPamJ5NjU3K2JXRmw5N3BuVDN3TnViNlA4OE9uREc0dGEvWDUyVHZxb2Y3Yk44dkYyaE85YjE0eitOWEV6UFMrOHlUWjVFMkt6ZVVtblIxODdoZ3lUM2RKcTlXZUg0RStNZmZnQjRyWU81a3dxMnBOd2Z5dzQyZ0pIRktzTUIrbGFZakdUVFhDTTFMb2hNbDVjQmhQSjZMVXdNRDhUNndmeXdhZDBacjZoQW5hY0JCWm9nOUxqNG5HbUJpZ3dIVnZFaW42VWtsOEtkYVNDNm54ODE3cUgwSEw5TXpSendiYytmRnhUT1BET2czb2t5ZTFuL0twQ1gvMkxyL2w5V2FVOWFqaDhXOW9WTHl3WkNsQzFkZjIzbEIvdkVSOHI1dHhnT0RPODdwM0dWU21tZE1ic24rQ1ROZkdqL2x0V1dXOVJ1WERlOGJERlpsbHgyZlArK05PWE5yRU9ZQzRKMVQxRjV1cTFRbUtGdkhjQmoybzA2eDlxcWtBYkdwMGFMWTFJQnhFTmJTaks4V0k0QU5IaVNLdFFKK25SeC9WaE56OU9pdlAycGlLRTczZ2l4SnBmcW5oQWtMdFBKQmxjbWlLVWhWa0NLV01SSnZSTmRQVlVGR0RnaEFvTkZvVkRnMFJ1SWxjS1NJa0wxbnV4MWRmUFhFMmZIeXRYZGZsMys5aTYzaSt0YUdYencrOWl4eGNuMXFwVS9rMnYwYlNZeXlyd2FnMGE0MDdnbjYwNGd3TWtwcEJJYkFNZmJOU0l3eFdtVVJWS1EwT0FPR3Q4bmkvT1RVMW1URCticXpGMEJLdnIvMHJnVUwrQnhRcllUeE1veHVQcVg3dVV3NEZxbmVGcVNYbGZTV1lEQXFhb2lkNmxZTEFHUVZxSnpCY09YWnF1KzIwSENsUHQ4aUdzNUlUdGN2b3YwTUV6YlluZmtZcnRRckIwcTQwZ0s2V0xMRm9rUmxnRWNrM2tUWlB1aFFsdW13d3g5WWRCcEJyNFdrZVM5OGxoNVhhaVNlcjkvdW01YlErcS9uNUJuUHk1ZXpkQjZuL09wNXphbmFpdTNidmtublBxMkxrLy8yNC9vSTl3eUkvWkViVWlaMHU3YS9BVmM5QUM0SGs2bHlzemxJZzhTaUFhQnkrbEhhTXhLTCtrUnJvL3JFUUtJb00wUlhZV0JMWlBPWHhEZ2dyVTBua3ZWT1hSMmIrNE84S2RuWHhpVS95TmF5ZjVEWHpxdm9ONWlzcXV0ZCt3dHJhbDNVTDBrbWNHK3R1azltdEJOTVRmWXBodFlRR0FHSGlFdWpTVWxWU0l6cGhtMERNdFQramZqNmRlazRpaVQ4dWU1WnNJWGtyb3NXelhtUUhLdXRybnVJbmE3QUNXNE5MOUo3WlVmMU85Q2xsbVZVd3pqR2ozZGlKSTBSTFNCRmN4YVI0aElmQmt0MFBsY08rMzIvN3JXdjgzRzFydzdsRGtXNHA4YjNQSHEwVmpjSmJlLzE4aFEybHZKVUNhT2EzUnBhOEtEUlJPTk1FWjJkTVlIM0R5YVB4bFFUZmNVRm9nd0ZCa21hRUhTdEp3OTg4SUU4UmRkLzJ5OGZiR051eUcxeERNMXBLV2dpOWJrdG91UzJDRFVIbXVXMnpvNXFtdHNDYXlCdE16bjBvT1lkekd3UkprdWVRaUowN1pWS2psZmlZTzA2UDFiZjBMWHJyc0l5STFwbHdWb2JUWTRRa0JLMktCQzYrcmdTV0JsRjREaGtmZkFCZVVDZUk4dmFyRzAvSDRON0ZMTmhiajNBb0FXdldUWFA0RXQ2NVV2SWVTWlNUTVpzSnVPTy8vUURmTlJYK3hrN3NPNHB1bS9YUDVlbmdKRDVCdUQzTUJoRVkzUTErRVB6aW9vRmpDVXd5ZnpoYTRQbGI1WXJlejJVUDBMZTBweWx1VWdsRWdCR3VwV1BXdEFSbGk0OG1vc01PdEtHL24zTlpzMVorU3ZBYTgvclgvRUpmRGxRU1Fremh3bjdrQ296a1Z6eWRLQWFNUFJqMGRSRTlJRk1OMmc1UFM2a2xISitqcTFHektIMUJsakpsV2lxa1VLb0p4aWFUc1k2QTYxRmNHZWlkayswU3o0YTJkRm5BcWtsd3FGb0VjS0NQVUhWNytXa3BCai9GUlZtcVNraWxtb0tkeUp4dWoxcFNuQW5XbXRRM0o1Z1RLeG50em5kaTZvK25FU0NYZGJlZDAraUdEdmp6ZnZYSHVsbk0zaFNUeWZveDUrY2V1ejBtZWxUSnUvTFRCejc4c3dSQVJMYloxa2ZweVVtTGozRE9LTjErNkd6WW1ldDcxVTVwbWYrZ2grdXJXcGYybXRnMTZmV2RSODl2Ry83dXp0bUo5aXlld05lVmdOZWtxbDluSWkxWnRUbW9rbFFsMFlSNzBwa05WN05oQklROGtBbzFvQWtXS21zajFWTlpneXd4M0tZQVl4eHhWTmRHZThDTkJneGVLd1JhQllBN1hOTWpiSXVHd051aDRzRDVWZ2ZKVjRkbVMyTlBUYXJVdjdIQzZlcjJNS0JtK2MvL2NTOCtVK0RjL0N2VFgwM1hab2pmeTlmM2JtS2pYOXg0UG9ybDk4OFQvUEQvYTUveFgwTGV4ckg5Rk5rdHlSZ0JvWkVjNWZ4ZEFmVjNLVVRyZHFZR2xwSDR3UVRNYXpuWTlFemRRbWlEck5lZ2hMb2NMcWlnUTRsMGFLcWNTWE1RYk1zL1diWDNILzA0K1JqM3Z1R3JUMXlZT1hValE0cDhmdG5QcFIvWXExUEUzYlpzYjN4VmRQT3ZYUDE3UEkxbm1mZklJbUE0NjZ3enM5b2JDbVJHYTlLUkVzVXgxZ2pvYXc1dmlIYnJLUXFFTGtZZERZQ3FvMDJqTklqZnlWVE14M05Ta3RqVERObUFJWkhZQnBXai81QmtSWkRobzBEOGwybnZydGk5TVArNm9NVFhyN3Z2WGtubjU0My80bEQ5eTdZeTlwM0UyNWQvdzZzNWRldXEzZHR1TGIvdFVzdm5mL3d0WmNWRzdnWDBFa1M0Tm9GTUFDMkhZeVM1Z3B6NnNvamJvTURjdzd1QmlEUWxYR3IwUWpHb0FVcmcwWnFER1pZclJYTlg3Y1FMVXBTSEFtbnprZnRBeFhSRGgvTmNtbDdFZWZIN3hFTHFmM0tHRjQxYmtQT3FienZUdGJJMzcvTTlqZVhEcnAvMFdIV1NNd2tXLzVVL3NXV2N1elU1Tm1lL1JHU1RHYXY3alQ1U1VWdXdHTFpwU0NuUE13ZFNnU1lJaDFqR21FQ3l4ZUZJSW9lMFFGMlVxeGZkTlBxREJjZzJ4Wm9WSEFZZHJ2dzBJM1draGZoaUVIbjJrU3pXOEdpd2hLMCs4QnVoL1VtRWlWZDZ0anRpRnN4LzdZUjhhV0IyenUvOFVZMTkraUdXVldGWFFmYmR4cTdqaDY3b1hZaTk2aUMyNDV5Zis1cndHMGE0MmVxRk5ra1pRRnVkU1JLR3ExQmRvTW1pMFhrRmxEa3BnTnkwMm1ScDlncWdFV1R0Q1FxSGZXNUFINCsyTjhSUHNhWjZLTUU0b3RWVDB1dFl6Q3ZxRTJPK2h4QUpwNmlSb0dBSWd5ZFVRRUV4OXBtbVp5T005NTY0UFRDSnlkOHRPY1A4MllkTXdVNnpWMjhOalptdnZqUkR5ZWZYTHpvME5HRkN3NngzaDJFYk5peHRIYnF6MjhzR0RqZ2dFWWIxejhqTUg1WWNLZkp2SjYwKy9xdE15KytkdTc4T1dWZjFqQU05eFcxS2J1cE5vb3gyRWptV0RHK3F4aVdUaE1OdlRoVkY5MmsySlltTE9yUllIV1BWVTAwUmtVTWNRSCthY0FianRaRWxweVovMHl2eUx5cWZnKzBBNEh5ankwakR6eGVkeWU3ZDgyOUF6WXVybnVlN3NGYVdGQTdHcHZSUmFNYlNtcUFOeXBVMGppeFpGSVNTNmI2eEJLVzlCWUZYV3Nqa1FpZmVlMUQvcHMzM21EWTYvdmsvcVF0WE5QQzJKbDJUTmlHbDdNYWxYM0Y3ZVFRUUFkYTVpaFFEWmdlRHFDY1lpUU90a2xrUXFKT0VBbUF4U21sQldoQVl5WUFFeU9qVW91VFM0b2p3UTdiZSt5SnlPTWZzZlRZd28rNHR1ZmwzdU8xTzk1NlM4RXZ3TVQ5VE9NMWdhYnhHa3BVOVJFYlUwUEVobThXc2FHbW9FNVlHeUZIYXVTcDVNVlA1YjMzZ2ZGNW1vankvTHJ4YlBKQ2VUamNad1hjck9UbWNTMUFFLzQweExWV1JCcmlXa0FEMmt4Sys5R1l1OVdMOFJra2ZTMmgzb1dVcEswUlhjQ2M2ZlI2YVhnOWtJaHBTdURSYTZLbHc1aUVzOEk3bUYzM01vclRhUk9BUDhGcGF3S1VpMWFpZUdqNkZvbEVFZkNOeVdWdjRNbXA4N2NuTDdtMDYwaDEyb2p5dTdaR2hveS9iVmxiUG5OYm56dkhEamwxN0VSZEZydHoycDF0dHgybzI4NkdGeXpvOStqbXVnK2k5UHhYZ01YTmRHK3d1U2trbEo3dHVOMGVKVktnd3VDMklkNGxNN3hFUlJyalZnbmF6alFRdEt0WU1STWFyM2JOdm5tZmpON2J6MmFNdEtycVB1Y2duN245V0plN2VnY1cxODFoVjgrWTNtSExhM1duZ2FZN2c4ek9ndlhFZ0pjVGpmL1VhMGdQeXBLNDVocFNCNm84WHRXUWtvbldOdEV5SngzVFVIN0FxT1VHalpQY25RL2MvOHBIeEgzdk4rcy9rNzg5R1Y2ek9seTlhazJZZFpDc2pmUGx6K3V1ZkxPY0pKR1kxeTYvOXRZcmx5OGh2NjBCKzg4SGE3TXpTYWdUcVRwMFkxNk9DbHdMZzFWelVScVFFblJLNFFoYUgxWVUxSkxkUkswUHIycDlZRFVTaGxXcXRSYTNVbzNrdGxDL1Uwd1F3Q0VJS1dYM3JtaFJqcEt6RnJoR0FLdzUwSGJMNUxWdlRwMzMyYjNETnVVTFQ4NWY4TlRCdVhNa2VZcm1oWFg5KzIrNHZtTy9mRzM5YlczcnJuRUhycng4K2IzTGw5NVhaSGQzZVFyM0o0RER4aVF3WTFVNG5FMWtkNXdPYTJDSW1OaXNqZ3hGQ01odExHOEhnWVpsTWhoSE1RcFVzenVWRWw3Y0JxQmhNYTVlVTlMNEFvcHNyT3BxdGduZFo3Nno1SlZaK3lLdHRnOThRZjcrNU5NTDVqeDViUDY4L1d6aUhubkZreHQvN2NUcXkvcVFmTUpjdVhMdXdydFhMMUQrV3dWQW5JZjFDeGczVUhpM0h1MG1yUE96UjJ0WEVQV1NneWFGVlA0aVFrTXMwdFdnLzNSQW9LdjJsVStwR0Q2cXZHUEhzbEhPSkQ1ejc2enViUTltZGFzWVBidnVYWHJmQ3JDSkpMaHZBVE9WQ2VkSDY3aGNlTnRFdGFERGVsVktpY0ZxM3h1S3pWT1V5aUdzQlk3RHQ3d3hTclFtTGdYckY4eThpeGIyTWxJaVQ4TTFWbTljcTZiMVFGbVpXZmxzVVdGeHlRM1JHbzlTVDA1dDhZcXc5ZjU3Rnkwb3luam8vQ045TzVTMjJqeGc4UXZEQk5FOFo4cWlxVzYzUDM3bGk5c0hUVG0vK0kwUFNQdUVxdGtUT3JkUGk4MEk5RmpXcDlzOTJjbTUzZStkRkh2N2lOdEwwaElTSGNiMFlJZEZJNGJ0SHZ3MGhUMzkrai9ZVnBwSHdCN3BxMFlUNjAwUmpXS0s2QnFiSXFnWU1LdmpyaThVZFJ1YW1TS1lYN1FwcG9oUVFxdTFhS1NseEVPTnZ5SWhmV1gxOGVPTzNPeWtObkczdFJzN0xROU1FYUtiSmord29lNmgzbmx4dXQyMjhnbjcySEc0dGhXd0wzL2lNNWxZcGc5b0xLUUhhdXJwdGVvQ1krcGpJcHpDZ21aRjhHSUEyUWJVYlBOVHFXem1hSFpiemNzS2F0dUwwOU9RZTFBTjA2ek1GUkdUTUtOLy80MWxrYjJMM2h1MXY2L05STGF5VytxcUgyalRyZitBVFd2WjBMVVBINDkwbjk2M2lPSXVEbTBHV3F0Ukh3TWlONDhCMGVBS1JsWGkvdkNYak9UWTNMK2RsR2NjNGpQclZrNmFlY2Q4ZHUyMUQrazFNVjd4TEZ6VFRrcVYvUWpIV0FUc2FHRm9SNHZPWkU3M0JLbW14bENRbVlhQ2FPTUprSjFUclZ4TC9HRXpEUVZwOHkwaWQwYXlPWDdSaU1LWlUyZjFQeEI2M3BJdkNUYTlhRHRqa1F3OHZLYzdjNnI5a0c5ZnhQY2tuVUV2bW15aTRZeEdOTnZFR0hqbmo5K3ZnWGRNZ045cURhZDE1SjQ2YS9yKzMvU016bGF0MXhuZ1RQdmgzNzVHenhoczFVYURDVC9EL3lEUU16WmJ0ZFZtY1lEYTRiUXA2MUxXcFlHUGFnK0Y0WHVOWHNFbjhBOTh0ZUVrYzRMVDZBMUdxMDF0VGlHVlprNmoxY0dwR0l2VkpqVHJXeUdBQk9vR0s5NDJ4YlREUTlITlpYRnAybE9ISy9qZzRaTzdpOXFmT0NaSG5qK2M4LzVwUVAxamZ4RXVzVFBxZGx5K3drNjg5aUc3NkhqdEc3Z0hWdGpYdjhNZTJKckVxNGdhcnhMOHRIWmNqVmRaby9FcVlOYmlDbXFrY0ZuRVNsYktqM3krUHo4aEw2UDZmWGt6V2YvSmgyM2xHamFieUw5MEsrZ1l2Q2FiNjE0blBZZktJK21lKzhEbS9nN3VGOGZrTWxFU3dxb29CMGNkUjNRVEdjbGhvWHdsTW9MRUM2RW1GQVhlT1lnSVAxR01aZmpuTy90SmJtcHk3bjlGNUdrZDBnc1dEU3FzZEpibHRldnVFVEkxSmdEN2tYbkxGczFucTY1ZFBOWng2QUQzWVZ0MmVueVZOVkd4Z2JJQjluZGhMWmFvNVNtWmdkMm9DS2FScG1pTmd4bWhKMFl3NDdHMlhjbHhGQkZ0bWhMTEtnNzZYTm5zZ1RsRDVMN2MrTHFYWnQ0emxYeXpoZE5ydDl4ZE4rcGV3Mk53bjVEY24xMEVmbEFyWmhBVE5yT0tpUzJtZ2t1cFZVU3JXaStXVGEzY09PQm1leUFjbDAyVHVqNEQ4SDRBeXhxQXdaSmhIWEhaSWRRQUl1M1NrVFIyaXA2aWN0WmVVczZXRkpjUkZ3cFVHNVlvb3NZRnhxZW5RT3l5K1NUVWUwd0txekcwNlY2YU9hZzBlWEpuazMzd3lCbmplSDJITzVOTHgrWlYzdUZsVThhUWwvYXpmZGVSUGtWM1RHeHZNKzdzdFZ6K3RVdlYzTmI1TDd4L0xxTno4VTZiWjlJdU1ubGRQOFRmYWJDemg5SllXZ0xUMVBTMEtscExqUWlCMURtOVUrNnZXLzd6RW9wM1ArQmpOc1hIRVBCb1djVkVFMXY1UWRmV2dBOEw2a1BCQjM5Vk1sc0NBZXk1RWIyQk1KK0tHT0ZiQVVic0trYW9pWW1aYmpHUmxualk3Wkk1VGlFWVZEZFlDbzI1Z2F4OGtrdUtncGlWc29QV2NWbFlGZ3VmdExuRUQxZ3cyRVlQbVROS28ydU1oZDZOTVNWLzEydkZyNTFtcnNvb09mNyt1Y3hPUlR0dDdzbTc1QjMzOTJQM3MvM3VsOE5GQXllMHQ1a1VtaHJNdHVZSGNmUEFGZzB5R083bEREV2lPVkJ0NEp6NlhNa0dMNWdBR3FOb2RvS1pnY1VUTVNHYWFhUU9oNk9JeGc4VWI5eWxWQjNCZmc2ZStuUzdsUXU3ZEVucnNMNjRjc1h0N2FaLzI3ZHlGdHY2eW9LMHdrUjduN0ozMnhVblRDMVI3S0t2NUdua0F0QTA5a3JtTWRRY2tyUkdwVkpCUTlza2VhVk5rbS9TSmxuUXhnTThKcVNoaS9OVjRkeVN6L1J2OU9YMHRUL0x6L1BmWHJrQzE2MlNKL0ZHOERWU21GWUVkbHNYOVdaRWJWREtBczJaRWNDa0ptaW8rQ0RXUk5MV0VOakN4S3ZWUWlKam9VMW9HS0dzRnZSdWVJVmV2c3RQemZFOEtzakZUQkJyQ1luNXI0THhrSkQvS3BGMGVqelc2L0pmaFhjMVlxS3RXcHVvUS9FNzl6c2ZGYllKdG1wRGd0NlJXMjNGMzVwcUczMFJqNzlQdGIvck8wVWl3OWVTOEd2VjZmaGJVNTJCZjhKd3FrSDJpdWtna3hQMGVHUUlNZFVHYTFJNkZjSFBhZzFXVzN4U2VrWVR5ZXZ5Z1IvUHgyQXRwdWdHa3dRMGJSWVlBUkV6RStOeU40cGdlUndlRHUyYnpDeXVJWVNWeFdVNU10R3o5emlvejFNMXIrYWU5TXBaTSs0YU45VjFMSzdycDc2RXlkdUZhdDlQaDlvVXo3OXJ6cHd0Snl2TFBrdXgzNzZwRzJzSk05ZVg2c21LRkhseDd1YnA4WGVWMWJHR2pVdWRKOSsxeVBOU3lNWVNRaTZ0UEpISFh1T0d2d2cwR0gvOUwzeGI0SzhROHlZVDlxTk1Ed1dsSEE0RHFrcWhWREYyR0xLSzVSL1JhZjNXbUZ3eE1TanBZTi9pQTlVT3YxVVByTnlXcGd5OHRwcXd5WXVNWjlJYWNxczVyd25vT0FWT3BuQjRNaVVSdUJFc1JacTgwOXRyc0NveTNrNDlRd2VXL3NJR2wyRTZEL0FyYWRKQWdxYUFnUkpPeWloR0JEcUU0MVozVm80L1NJM0dqR0lNa2FUbGhtZ1VSZUpTNE5NT25XS0h1d1hKN2tXK3BpVkZXV2xGUWFVanNYR28wT056K1dobE1LSWZpL01VbktPcGc4WngvT2pWd3N1UCt1eVBMaEtQZnhOZmJkMDJlZVpESVZJbS84VXg0TTYrSFFaTWZycDl6L2x0UjB3SXRNcU52NUxrOTNmZjMybHowU3NiMjFkc3ZXdFNtemZuamJ3UWlWK3didE9FbWRWYjgvSUduNTNnOXVhVVBwRVZxOWRVYVBXQlhJeHpNOStBWDNXRzlpRE9ac0NJbEpKNTRBcS9aRVJobHUwWHVhdFNBc2l4QkNWUExZQjB6Q0ZZMUFOdUI5SG9NS0FvcGdyVmVyTWJQUkFSenNaWUhTNkttT1JZZU9Wa2xEY3lCUGk0MVlHSFJuQzc5R2FMYW1GakVXZFdDZnJYbmhLUERoQ2g4K2d3bVoybGEreXE5RnpmcmR2Nk9ldW5ybGc1WmYxY1BKNjdmc3JLRlZQWHo5MVJWYlZqKzdTcUhXVHMyaGxMRnM5WWUvZjY3dDNYMzcxMnh1SWxjTHloUjQ4TjVKdHBPM2JBQjNZb2VZUTZodUduZ3p5SXcveWR2Vkd1S2VKMDJaa1lORmdscHc0ajFwRllMejFoQ0dJY1RUUUZhSURZZmxWMEIyaHB2amtRRnV4SVM0S0p0aGVIN1FLK3NzZkNLMmVBeG8wRmV6UmY1VlZOVEs0K1h3Vzc3bEt5cDZDTzhSOTNrYVMyaWZlVUVmdFZ1WW9NbE1lVHgrWHhFWGtNMlEwL0F6V242bXFIZEN5YVFhN1ZoYlp1V2k4L1Q3cXMzN1JWa1owTitreUhtUTROcTBhZk9LcVhXU3VOUHNHZlJ2a1pUS21lM3Jseko1bGNXOE5QNDl5MVg4TjErc3Y5ZVJkY3B4U280aUNqRk03YkFQUXN2NVNQc1loZVZFbUdyRFhWMmhEMlZqcGlzSnhMekVVZWFtV2ltaEM3ZlVNMnFTT1NTQXhTalZJK0gyT204VWpzd0lSVGFYaXFEWHl5alo5R1oyN0RpdnBXR0hRQjlwSmlISUs5MG1Ed1pPVVh0YS9vMnAyMlpBcFNiQXJHRm16NWd2MVpyVGttclZWdVJmY2JlakdidVdVRTJ6WjAwV1M2V25OT25ibU1mSkJtOUVPVUxaVksyZjRMcG5ScmUvR0o1OTkyUGUrYU1uVEVyUFRTWDNlV2RPdlVvOVZkL2ZxT1B6Mzl4VCs1anljc25ESnhUbnE1L1BYV2VUMzM1K2Z2WFQybVo0L0NvcWZ2NzlTL0M3dHk5T1BKbmVkMFdIbzZmTml4Y1BTNGRvVjVuWGVNYnQxdWFhOVovZkw5N1RmMEc3Snp3SXRINHBaUG1kdzFtTnZyeVBCSkcwWlhoRUozOXUyU09hRWdWRkV4OVk3aS9CRzRsKzM1ZjdNek5PZm9YaFl6MGVveThGR29UNmZrNk91cjFpWE9SbjBxSGlNeHR2cjlCVjJJcGV2dFQ1ODh6ZjhiUzlmaGF0ejE3elJmd2Q1YW1XVHczSGVDUGNkZ1B5UnRJcWI1dmtnQ1BZNlV0akh6TWZCSGVaV2VTMStsNnhnNzVzM0thTjdNWm1VU3NZdlNobkdVU0w3eUt0OG1GY0tySXVWVkVVMUdSUFQwbGRRTzFsY0lXM2ZDN0V4SXorWnBxM2FSSUdiQmp1YTJ3ZDNXMjJLWnJKVHN3cUxHVmFNTmRVTzB0Qys5dm1iWlU2akU1RzVNdG1SeWw4blVQL3lCVEwxMFFYN2s1WmZsUnk0dVBrank5dThuZVU4ZWx0L2V0VnQrNThnMzQwL2V2VXBNdVR0cFh0ODUyeDY0YTloYTk3MUo1OWFMSDdOL2VvVlVuVHNuYjN2bG5Memp3Z1V5K2R4KytiMkRCMG51L2dQRXYzKy8vTmFUSzgrTnUyOTZZcysrQng1NVpPZmtvZW1MdC8wRjlzdlBmczIrRG5oTlk5b3c3ekpoSjJJeVJ1blk5dmtqV1dxVGRrQ0p3VnN4QmkvYWdQd2pnb0lud1IvRlpycU5taFNHUU1TcnBIRzl0a2l5OGxheVh3b3FicU1wKzh3MWRBRjUwUUIrby9ZTUwrVjVmckdJK1dkRXJhMWFwd1UvTHd5L0d6bG9FYTNPa0tjNloyR3RydDRleUVNRDFPa0Rkdk9DY1M0bW9qM2d3L2J2Wkt5eUZDS01UWWlOVXpjREU1RVZCTmlNcmU5VXd5U2t6b2xKU0cyakhHUUo3Zi8xcDFRRTBpb2Y2aDVMNHJxVjllMWp1Tis4NDRFRG5UdVJuSzFPZHVIcVdTdTNkUzd2TWMydUkwWHJoOFVuY0s4VWRDOFZURWEzUmR1MUlLMUR1OVNoZDdjdnYvdUg5cXNEMlcycTdoMmQwN1pQeURuQTRyWjQ0ekQzeUhUblB1UCtTT2RjTUxRQlBVMzV2WnBVYkpXdkVXNUxEeExhSWY5TTlEdFlHN2tvbDhxbDVLTHlWK205Sllkb1h3VDJSYXRkRWRHdVc5NmcxQXFDNmM3RjFJUjVhaVR3aktHaEw1cjIxSElYajNDakR0WHRJeWVhOXJveVRUcFpRY1UwNGJkaXBwS0ozSnpqQ2tzb2p4VlNIZ3NYbHVDdEMxTkFpK1FISXI1SytwNVA1YjhPTGZCZnNmS3FKSUM5Qm1WS2cwR2kwbURRaUFWUklwY1ZvOFhuVE9CemxBNEQwUjhTWSsxaVBteCtTYUZnUHc1Y21NM1E5eW9GTWZNL1lFVFN1RHdybWFTaEpNWHFMQ3BtMFhmNWJYYUVEM2syTGIzdHZpbTVjVzI2amR2VGZXQmhlcGZldTJjUHlPNDJldHR2c21UZDgxeGU2N3NxaHE3VTI3MEZzM1l2M1o2WklCOGtyM1l1VFE4bFlNMkFOb2xmcDkydDFBemdmdXRxOEtkeHpRQnNXekovV0p1MGJCblExMUx1RVB1VU9wT2hqektOQVVjeEFPWkZneDhITHRBOWlLVjdZRmE2T0pTWkM5aEdqajMwWG5YQWdtVGdVRnZSb2tndGM2c3hDa3YzejU2N2IvK2MyZnVuait2YVpkeTRMbDNIOFgrWXMyL2ZuRG43OTgzdE9tNWNWL2hSZEh3ZjdLZmpVWkpic2M5RzZXT2lYVDJZOGREQWtRRThUVnFneFZzTXVXRU5UOHUyZEVqWE5yOW9RUmNLMjI3QWNRckhXUEM5R002QXcySENscGhvQkIydEJVSHRmS0t0UWZYTjVIMndSU2phVUg3b0VMdjlJQjRkbEtlVGg3QW1pdjJFWGF0NURienB6a3hZUUt3WkZRbkkrQ054cWdSTXBEM0hUaXRhNm1HZE16cXZCV1BZakdTTXd5QjJqTVdwU0J3UUpla2x4YzA2Z1ZHMDZId3VyemFuZ3FURVozVHQzTEdEYTN2aXB0WGJIeWhydldkQUdsbk9maElLRFhvcktTZTNvTnpmeVRaenl2eUJkL1FxbmRNKy9SNGxmc05lWmxmREduT3hWajBSMStoVytNMkV6cUExR0xFcEc1M2pqMmpVSmVmNVJmMVZLUk9XbkdrVFU5Qm1jV0F5d1MrbFdKWFdYNzJERGlGaEpKT21vZWZYUm50KzNmWnFoemN1UmJWeDNRMkZDenB0V29tN09XeUtsWUswNGR2aVRNa3Q2emFvKzJDenk2SjM5Ky9WcnF5MHdyTXBaL0dDQjFkMDZ6VDBqbDFiTm16bDlscmJ1WlA2bEFUYXNXUUdhWmViVVpqWDFqUDFqcXArSllNYzdnbWRSNjZiQ2ZCK3loOWgremFwZldHYTE3Nlk2MnRmNGttUSszVFYzejdtajVCWStTdUtyejN5Rk81WDhNZTlHUHZCK3ZHd2t4Yng4V3BjMXh5RTNZMG1oTHhLdXRXcmhEbVJ5bUpza2hXUVpmWFQ3SkFKelY4bklFcG5WWXZhR3BYMzFZZDNkYlQ5UFV2WUV5NmNkMXUvSllYUzNzSmcxNUVES2d2YVlsWkZMdi9YNWp1R3JQOG5lZVhhaDB2NkplWDR2RDNyWkNWMlFlUXAvQURhQjlKRjRWcXM2UkkxQVV4WVlxQVg2Tjk4VlRMQmVreTJDRU1IRU9Eb0JhVXdYOUxGMUZDcWw0eG1ta1JWbU5WSFUvTDRMNStRdjMvRjN2UGdrYytlZVA0RDN2blNGMGQvR2FFOThNc0kzbVg4VExuL2QreGk4anpYczJIbWdiSG01Z01MMERyNzdncTdXTzNwcTVLSHN3a2diMXhnbFlsT2Y0UlRPQWRqMHhoWmRGTzJRYThMdTFjRUhZMjdBTUVwVlpKZ0dJc1doY0t3cVF0bGJsWkpNRXBNVmFiS3BGR1ppWjd5N29XcmZRTUhQYmo1ZG5uU1BEN09tV2hQY0JLcHlqaXdzTmNjWlEzc0orUmo0QTBEa3grZDcySEUrNnJUTWNDa29PeEtsTTZRbGdZR2FLdktkL2luYlo3SVAzeXZjMnI3T29GdDFSOWtWbXYyTCt3THFqenRxTzZNQzN3cmd4OGI3bFZKMm14MFRZc3k5TmFqYUZvL3UzbnpzODl0MnZ6YzFnbDkrNDJmMExmL09INXc1T0pGOGRqRmw2dVh6SnUzWXVIYzJZb00zUUQyd3hkUis2SEVnS2FEZzJhc054QzkvUE4yMGxZKy8vMVdVaUcvOUJEaHUwY3RCKzVCeFk0QW5WNTEvWUoySThCam9CWG44Y3h1QlZzZ2dMR3AyUm1NZUJVWllnZWhTa01QRmc5SVlpK1Z0bDQ2RWltaFpiUmlQUjFtK09JQ0ViZGkvQW1Cc050RGt6Wk91SVNIcG5JOElOZHBzVDF1Z01USGdMRHhDTUJiR05JQnJqSWp1bmpndExEV0doOVN3NnZxOW1CMVhZYmFtTzlLSzhvS0N1cUdlZmcrajErclpwZVFiUXNuVDM3d3IzOXR0SUhYQkszNWwzOUc3aVVmeXA1cGp6NDZqZWl3N3cxeHNGYkZRU3RtZVdNTVJMSVYybzJOVGlxaWtiU2J3ZXRTaGhLSk9ZR3dpd1pJWFFoZVhoUHdYTUp4a3praE9WUHBMbzdGYVVYMitJUlVIRjNFbzltcWJRSWtoMERlU25lb01CTys5MDZBZVllMlZUbHFraTVkcUNaNWNCVnFrdDEzZ0NhNUFRbHhwYUhCYnlhRFptbnY3Mmk5UzlFc2M5dW4zUU0wNFZOcElvZHBEWDV6R2ZNeEU0NUhqT1FHMGRTTEtwaUlSYUdNZkw5WUdJeUVsQmVCUURnL2hKRG5sOEFlaC9MeE1GUUEyTWxxMEVIdHFBNVNIWWNrMUVGWVJ5ZjRwU1I2U2lvQnFta2JRQnNRcWFaTklGeE16Y2ZpUXJoaVNURWVsdVFEV3R1ckl3TkVYMGdxU1FmMDBtaFZzU0FWNUNIVlpJWGdsTDhNdkFGVms2V0hhRFVpZkZ4MDJxc0ZUMnpTRFpyczFucnNSb0tyMTJ4M0JHNmkxODRyKzdLRWJMMTM4dVROWDN6Um9PZTRsdFZjN1FNM1VpanRDNUVIOEgxQmQyRlA4aFFtbklLeDVHUndvQlA4V0VFWDdVZFFhK1l3TVd3RWplVUxZTTFjc3IwR0N3ZU1TcUdpVisxTFRyWmo5TlRHNFhTRldLUk9uQ0xCU01rdUhCNmhpL1ZTNUhnd1BjeVdCQlY2czdCTi9GS2NtTGRyNklxaHhkNW9WM0xKZ2J0blB4YjduUGVuUzMrOFRtWmZTUnl6WjI3Zm5xT25wUW96c0MvNXdOaTJVM2M5dU1OMStlT3YrUVNsTjVsVGVseDFlYlRIMVg3TExsY3dVcHkzN0hJTk90SmE2SFJkaGZXdnpicGR1WFN3Q1A1WDcrMEljaTNjT3h2c2orYjNaczJxUGRMMC9xNGI3Mjl0dUwvYmo3SVU3bStsS2VXRys0T1Y0MGpMMG5FM05QcHUvT09aejErYk1XdEZzMzVmclJQdmZ1UkliZGVHdmw5bEhkcHJzSTVrSnBOWjJId2RLZEYxWU9HT1BpalpkRFhWOFRhUFBsY3lxeFdEV2NqUjlaNDlEVGRIbklxUGxvMmtoaEZuYllvU1pTWm0xaE9mamc2WjB5NXBmTFNqS3dXZ1NtK00xY3dTTlhCY2pFM2NhRUtobGVtNUVjd3RwRzFvYUhsVldWcEtxbTQ1Ti8yT2lrbWRrbE5kYmxKK0E5eVR5OHVMazlJS1o4OHVUWStOOVRlQ24xZmgveHpnTndFZHVLTlZXQTBZTU5kalFPOFhIVUhKQUl6bnBMa2psR1FtR3hwaE5NYnV0aWxGVENhRW1KZ3B4Smc4QlYzR3hsQlF6V3FWUWoyb09JOUJBWXNlTm9BbW5uNUlCZUtwMHcxZ1hMa1NYVHByVm5nb3V2NS9VanFLZ3gyYzNtejlzVlEyTnlKb01kMGZzYXV1WHhZV21VVGlGZGN2M29aVEpDTXV4ZlhEdmZQRmczL05Fck05bHVvck9zN0VIQkxUaGJEVmxVUTFjbk5XdUlsRjB3SjdqSy9xMFhQcTFCNjlwdDVXa1p0YlVaNlhXM0VEczRSNlRLMjZyZmZVcXI3K3lzcldyU3NycUN3a0RLTjdrTnJHRHF6WE50TkpMTUdHWm1RSGJmaUpXR3htaE5kQzI0VE45VzNDVHJTY3Njb3cyaWxzcGpVbGJMUlRXT2xVcHIwaDREU1NodTVrK09HdzQ1R3dML0hWZGNuczBib0JiRzF0aDdwTEYwa2MrY3RtN0NOdS83UnNQVW9PeWtQWkFld3B1dGFKOHZENlh2UFpTcmQ1cEpXaVJLTU41MkxBajhHUVJwTVAxV1pFck9QenF6TU9NM0FzaVNNcHAxVmVBSG5ITDFTYjR2aGN1aWR4bUFmTHlmT2pKRGUxZ28vcEdMM2pQMnBXSnkzYTJML1J3azRldWNFR3YwVlhlMjMvRnN4endBdnRKUWZaWjRKZC9NMXVjdHQvMEUwdTNOQk5qcUt4VVVkNTdUK29KbERieW5WNUtJVC92MWtIS0lkRzY2anJTYldDdWc1RklEZkhpZjIzMStMNEQ5YmliR2t0cUM4YW8rVnhSVk0wVzlHUkk4b01Jcm9ta0kwbXltM1RiNzBxZEU1dFFTbkdpRlc4bE5OK2E0blk1MHVycDJ4SzlSUWNPa0NHdW01Y3VKb0FhTHp5bDA2ZlBOMW8yVFFyZ0hnc0JnZndHY0FqNWh1eWxGazJEUWtrSEFjbzBMUUNPUDRvcGRFbFUxcGxPS3ljQmlJWmRSYXA0NWUvS1JXNkxQTUFYRS8rbmRjRHhXekMzdVFIWUxQSG5WVndHcjBpenZiNEUveEMzYTlsakhoTlhiUWlQenJKRHR2REVERkdOTTFZRGIwbXAyd2VSaGxTbEUwVHprWjNxK0hhSEZqd0RGc0VlOFpSamRhbDBZb3hSQUFhSEJ4NTBhQ01VRmFXWDgzcGVORG5qSTNXd0hDMm1tbzlQUUdxcmZHUVpMWEVtejlOenVwUEk4S1Z1K0pSZEY3Sk1OcHZsOEZNVXF2Nm5KemFhKzBEU21HSW5ZdkpGVk9WQXIvMEFKMmhZS2NGZms0QnpkV3drMllmbmVsZzZ0dHBRTTJPTVR5blRRbTUyR3R3cUlMYUFtNktSKzBENjJrMDdBTGpMVDdCRVoxM2tjK21VZnJoOXBKZmo5Q1pGeHZQTCt1MnFlNzdzeVMwNVVCQmx6NjlGKzNZS2I5R3RzclQyTWRXc28rcHN5LytKTCt3SlZsZ0g1UHR4UVZkdmpyNDlPdUxDbVQ3U29WSGFmODYyRW9HeHNlc3VhR0RIWXN1akVISkRoWlNvdDBMQ0xUb2xMTHQxTWFON1VaUXNUN0ZXUEpScHhFOVpIemxibWg2VDhPOVY4YlJLWVVPRm04aUNuZ095Nk4xTjJ1RHY1bmhGRzJQSDNJVGM2bHgyM3h6VTBtaEtkcEhEL1NLZmZUSjJLdlFRaWQ5U2t1ZDlENjFrNzZhTXlVa1VYMzFIemJUSTdIZnVxSCs3OENydjlWVXo4V2hkUDMvWS8wbzltKzlmcklRaE1OdkFjQ3lVWCtoQ1F5cE40RWhyU1VZMGh2QmtQeDdZRkRkaTF1REVWRmswWDhHU0ZTdlVGaUFqeENXSUxPNEJWZ3cwSklRbE5LQmwvenB1VmpwQXJ5VUZXaG1JeVVBOXdRVjdnbmFVRHBFc3BWWDJRM2dvLzBFM3JyOWhNbk9wWGh6L2IrTENtL0NVYmRHeWNHYjhObHY0K2hHM3VOVlhIMnUwbTRhVm92ZmlLMEV2NWdTbEJLTktFYWpiU0lOT01MWk5PaVpZWk5BbW8wMmprU3hnMVptU2pJbERxLzlkNkZHVmNtM1JzVUhvS1IvRzJ4VmR4Tm1MMG5oRGZ4YW1nMDFrQklEOFJpSXprRDJrakw1L0VMU2xvUVd5QmRKMjRYeWVma1Y4Z2dwbzRja2RJOThnYjR0djZMTVRYeEY4NjNtQjhCV0psUEF6RkFubnVYcWxVWkRLVjJ2MU5hRDZrdXcweW9nSEZwbXR5djE4d2xVaWVPOHRuemh1TWtkcC9kbG9jR04xWXdXOU9CeTNZaWN1QkQ2UU1lSmhiZW5GTkM1RnFDUVloQmpGWVFPSjB1bnc4azhtRVJVa0plVmlkVS9PUEVobi9ZczBLZ1RUb0VlSUk3dEdDRmRMcXgrZGU2aGNlS2dwT3dUOHJNbjE5MDFhTTZoV1c1YmtQMTYxQU4zZmlULytabmVIUWFPKzVBa0RQUytzdTJkclg4bVkwNTBHM0w2anZOTFJ5OTUvSE41VHlRcmFlQnBMbmJ1c0U1anVVNDlpK1gzNjlnS3J3OFE3SDV6dDZLMzZPd0NrQjFPSnBZcGEybDZnYmVsNlFWeDZ2U0NzT0R5aEVJM25XQ0FVcUw1RkFQU0hxVnp5Nk1NTkVkb1AvTC83WnBBL042d3BsZFE0TGE4Sm42TEttY2JyeXUrNVhVbHRMU3V4SVoxeGQ1NlhTaFNiMWdhbzByUlc2Mk9DazlPV1IvSUE4UmJBalBpeGhWaXg2QTNLTGxCR01RRm9sMDM2bkpkeXJoWm5GbUNhWWtFRytXQUtCRFlmdVBGVGttZGNBc1FWTWEvQVlZTTVQV2JBYUN5T09DWHprWUEvSm9aRzFQWWZEcUNVRDhkd2E1T1J3anpGaHNkWU43eWhBU012VFdka21DakRsYlRTUW5jd1FZL0t6cGp4OHJFTWIwYWRldEZMRFltR2pIZzRocEdYeWs5MURqMGdyVUZBaWhSc1UzTWFLOVJLdVRqYkhUdXBUcDhxZVZ4TzJmSnBDMTlwbTBaVWo5dlo4UnRiVmJodkIzNXFzVXg0Y1QwVTNLZGZKVzh2MkhKOEpVdUM4ckJSNjUveWUvWHZBTyt6QkoxaGJTNU8xblRNSzB4K21DQVloTWR5ZWpIZUhoTVRYV00zcTgrSTZDVm54YXA2WlV5UjFmMCtRREYyS0dlRUUvakNERllzU1RwL1hCS2lFM09wT0kvZ01wQTc0cFBVSVpZQzRYUnVkV3NXb1dtUm5jYUZaL2h2NkxDNk5SS2wvREkwRGVYSHoyZlBpTFc3UnEvdG5YbGxUMUwvdUIvTERDKzVMWnBLYTdoVDJabHgwOUttVDY4YWkzMzViT3YzSFYwZG5EYTNvcllsT1NVRGtPTGUwOVpmMzdOMU80anUwL3VXcG9kVno0N0ZHcVgxVThja2xwKzU4cVBhMzFBKzNTR2dlWXNuV0ZRaHJtYXBsTU1TckVXdXNWUkJ1MXVNc3FnZlpOUkJpZm9LSVBTdGsyR0dRVFEvazVrMGpDQm9NY2hQcUxGL2o4Y2FvQkM0SGNPTnVnQjh2VDNEamZnNXlzMDN4eHZxNXJqTGZRL3hOdXpDdDVDWlFyaXdyNjB0cUgvSTlSaFl2OTNvZzdGL3U5RkhUZXEzdTV1d0oyZktXZnViNHk3SU9DdVZWUGNoUnB3VjBGeFZ3QzRLN0FoNzBWeFZ3bTRLMEQvelo0RGVDa1ZLZzBVZmExeVcvdnI4WmRIOFJmNjM4QmZORW53ZThkcUhGVlUwdk8vYjdvRzcxRlRESE9hak5tb3grTVJ3R01sZHYwMXhtUG5KaE5JZWtaUmlBTkljb0pTRy9BQjJyVXBCYkhXR3M0VmdrcnJSekhid1ZaVG5kTUJIL2hScVJqOUhXeFNqM28waTRWWWxLZ1ViMHI5QWVXVk9VcUZRYUZRYWRKcDNabXRMYVh0T3QvV20xWnVSbm05NS84R3dtK2F2L2k5Ty9EWVRmeUkwYjl6U3dxYVpUK0dOZDBhOERHVXZUbW55b2NLNXBtV0pJVFlQaWlWZ2xIUkx0Q3lyS2hzTEN0UTE1VEJZVmxqc1ZGZGtkZ0d0ckVkbkcvbmx5cHNOVklIK0ZpcHVqRmxnbFNVQ1lodlo0OW8zWG1GOU5FMUZZS2sreitUd3FvaDh6dkZpUUJtenU4V0owZWk5azhVMTk5U1hIY0NUbmpoUDVqRkkzYndSN29wT2ZiZS9raVptcnpwMXd6aGtjNUtIcWV6VGVvSnI4cVZWK1ZOQkhmL1JnanZyQ0s4cC8wRVJYaFpCMFI1dVRJTzVoWUlsM3AzQStsVld2NC9RUDFOMGtTL2N5dm0zWkJDK3QwYjg5Mk5LU2FRVloydmY2Vzl4SmN6UmJCRFBabER5Z3c5TVJpVU1qVTFZaWdRZG1MQldId1FoK3lJM1FPUnpxbXRuYkJSbmVGVlo1dW94YUtHY2wxOWUwRXhScmRwTGFzdEJ0dUQ4UWpucDVZSHBNNGdwMUlENGM3MFFSU2RrdzI1dEhOQWoxV3R2RE1ZcXNUOWdGMktMVUFXU00zRVh1NmNWZ1hGMGZOOE1pWjl0T28wbVliTlVDWmRFMlVyYUU4QVRxcDM0WFFadGlHRDMzUmppbWlwTS9IUlZGSG5jZExaaHllU0tTc0dMd2c1amlWTWVYbkZ3WWxsMlpYNzV1eDdkeXhiUjloT0R3Mlp0Q24rZE9DSDhIMHY5cDc4M3IxUHYvamkxQWx6bm9xejl2MXhlbDRaZTU3dGJ0bXhjTWxlRWp0b2V4K3ZNOUZyV3pLaFZlK0Jybm4zOXdra1ZuYnRzVk9XRnp0YVBiaDg4UHlxMklNblJrK2NPRnBhMVczTTdJR0ZCMUt6aEZRL3NlN2Fzb2ZhNnYza21lcDhvd0ptclRMaENDdlFhZjVNSFhJayt2MlJKRFYvMXFieE1BZTBldk9zTldKZXcrUWo5UEJUTFlMOVdWNklqYy9NeXFINk5rK1FUTmpKNmNSKzB1Z3dwTmdrb1A3TW5EeWFWY3RTc21yQ2IwOUdhcmxzN2FiemtqNjlNWmZXNGdTbHV2azNwTkU0WlI0UjJDVTRqOGlIY3g3ckp4SWxvVW5TNGxpaTFKdU1KVXByTXBaSWluZW9aYjVTRXBibHBmem1nQ0kwYUg5clNGRVNSZ1J1UHFpSS9ZTnFiOTBjcnVUL1BiaVNFYTZrMzRRTHJjM2ZndXNrUmhWdURoZDVrbHFTamVGS1lOSXhRMUlQbDZjZXJsU0FLMUdCaTg2QXlLaUhLN0VKWEprNCtKdWhqM0pyREY5cVBYd2VqcjU1TS9qcUMwZHVPVjlLdFFDZnZlV1lLVzYvWXZEVnZVSEhUZkVxbk9mVS9jdEFiNlBKRG9wcFFTbkpTT1ZlaTN1WjJmSmVZdW9FNHhNK0c1MVZpdHlkWWFNWklTbkpRQnMrcEZSUVdXSjg2TDh4WUN0cUN2eldYdk1ZNHJqRlh2K0Rxbm1XU1FNbi9qRmFxNnpER0FjZmpYSFFNVGoxaVVOVG84UWhSMmlNUTBOelBnMEp5VFJnbXM0Um5PQjNiUkRPVllLTHZBQ0NNYi9adGNsL2NHMmlVWXVCbzhuSkY0QndOMFNVQ21uMTZwakgreDUrVFliclkyNnlVTTFOMHV2clNhTUVwYWxSZ3BKb1F0RTVGM2o5Um9sS1FhRWdnM3FYSTBmcTc4UGhmRTYycmRvWFpzSnEybnBJc0VFUjI4UDBBUlVtYzVQV01GT3VNZ2dPdEtpcGVaSVNiNHAvRGFkSmhLZTlZdGVNZEI3VnYrbSs5S0RQWnpvRkhKak5UR2JDWHZwc0Q1eTVnM2UxQnhXQ3pOVFZ6ek5PUk02ejBYUWNQcWdUNXhtbkpZSTI0RXhhdXhPTDVMRDFHSWQ4WktaZ1hOZ05GTWVwdGxLMXdTaW8xZjlJZW00UHFBUk5WZ2w5NWwrSlJ3ZWt5RFE4V1ZHeGZub1E5bXpiSVIzVGl3dmxiL08rSHpQamcrNUZWMXMvVFNybHI5Ky92bW5rYzhkV0xLMCt2bkw1RVZaRE5DUWhOcTFILzdMN0prMGYxcXU0WU9MRUFmS0Q4b0k2K2FPejkvM3g3TXR2WER4eitUTFZuM1FlRS9oY2JpYWZtWCtUaVV6SWNKNmdsQXhlVnF2a1RERFA0M1hJbkFTZmdkb3dxS25hNDBaUEs3OCtWYWxPYlJKVDBjMUtVOXlzQXRTditXQzhhT0x0bVRod2hybnAvQ2J1Sms1U3M3bE9SVGR4Z1ZxYTk4U2ZhNVkrNFpUNVQwRExPUDhwRVdmZjFVK0FpcXNmT3VocG1OZlhiQXhVc2pvR3F0ckV4eWt6bGVvblFVbHgrTGliaEZ0T2hFSTJhSGtxVkZ0VWhTMVBobUwvS3hxenVmbmE0LytIYTQvSHRjZmRjdTJvK0ZwZSszdW83bHBlTzdtc0JFMGFyOTNKcE9CVUtMcjJXTFhaWFZsN0VxN2RSOWVPVDlSektWbCtYRHVOVjZKMnM0VEVlT0c0eVdxek8zbGtOaDBkcEV3bmJDdVFXSG42cWVhUU5BbDV0RENlNjdnaWxpNjFQS1dMTzZCcXRDbjEwN29hWURvQ01HVXdiVkNyVVpoeW90UEUvR0NLSnZwRlMxQnlBeWY1M0luQVNYWWRqc3VJTmt0bW1tdXFMWm5JUlJuMS9XeDVDc2pWY2JvOE9POVZ6bnY5a1RpRm9ZSVlrTStndVVzKzBaZWo1Qzc5T1RjYlIzYkx3RU1MZU5oL0UrNmFlUlBFdk5DVXdlcjZOU0NJVi9GelRxVlhIek90R2NXS3lVRXBEcVI2VXFBUjdhWTJwbDNNN1NUYXFNUnRwT21qRkkxQ09Da1JLVnJ3OEUwcCtwWmNxS3IybHFrNUJSWDZUVGpSRS9YWk9hWVBxZURkL0NSVlYrVXp0Ti9PV0JOOUVCVStnTXBZbzFiVW9LZU5EOGt5QmhxZVlVb0xtTEI0cGc5M3NlNDRYSmE5NzlBaCtRejhIVTU3bVpkZGwvanhjSDB2NEMyWG1hWG1kTkp4SGhnVHRRMlRFVi9LWXh6amNPd1h6WGZUaDhwaTUxWWNiWDlGQlpRbEhOZHlEaUV4bFViNEFVRUcxTTdwQXEwZEZwT0Y0d2JHSFpPQXhZTWlCOWFpUHRTZ290U01KWDNZVXBZT2xSWG9KdytoYUhSSGcvM0xTT2I1MjlmMUdUZTZxc0tUZlBqK2wzWXZuREpxV3BrMysyUWhlWG40K0ZXUjVYM0dyajl1MXNlelBHbE5ZbHExWHRwMTNhQ3U0MWZKN3o0d3E5K2FiZzkwN2p6OWtZY25zTDI2dmxiM2FjVnJyOTBXYWxXaDVHWG8zQzJRR1pqVkd0bDg4cGFYVmVleTBmRmJpYmNldjVXa2p0OEtPN3p4b1ZERENDN1JLNEI1ZUl0QlhDaXhieHpHOVFtRzNsc2V5TVh2VmVvSUc2OTlmUE8xeC8xMzFvN05kaWkzc2ZzdXZoRUljWUxvdlJVSW1QaHNZWjVZUjR5QnR3d0RkMzlEYnF3QmptU3M5cnNWSENtM2hnTUxaemlVNFY3czZZbzQ0dUlUc2ZZRXJIS3FOLzl6Z0ZSWmZpTk1zeFVoZmt1b292VW1DbHpuNlA2a1lJMzdqWkNKU1VISmE2U09WajJNdmlpTTFWNThzRFJObHpaQVc1MWlOZXRWaWVYSFNTeU53RWNWbG9pUFVIVG9RLy9SRExpb21Mb1J6b2N4M25nVElOOVQvUTA2eXd2MkxZNUp3aGtMK0REWUcwWjZKZnV4L3VPR2tWNWlnbDFoaXBzUDlzSWM2NjJHZTJIRzlhWUR2dmluS1htcDh5N3ByTnNVdEwydDlSWkJMQWEvckhUZUphNmJEa3BLMHRVYkI4cmtXOGtGaUkxV0FxbzJRcndUK0VSbmpWVUtzMktWN2dneENXZWVvcW5BcWZndUxpbHVHSHFaMVh6cVphUkhTZmNSZE96bHdnSGRpcnMzbW51cDYxOVgyOXVidXVINmpnTnk3WHBmWEsvR295ODVGZWZuS001VDhTbTBpSFdzd29rMzRqUFJic0IvbWwrTXZ5b2wyZWhUQTlFOFM3V3BEd3lKcHdWK3NjcFRvaVErRGlubTl3eGU0MVRhdWRVZVliWHN6ZmZvWjVXT2xsMy9VdmNpblJPZHpqeW9haUVMVjZOMHlzWnIxY2NLR09xck9yVTFFV09NRTExM0kxY2Zyb2kxMC9vQ1RPQnJrZ0lCeVdLaXJkd1dXdHhwMFdQeHI4Vk1mOXZVVUFZK2NUak1DVTRxckdNc1NsclJLSVNaV0d3eUVBMDRFbGFwUmtyeEZEVXF5Uy9TK2xMdzhkTDJZQUNmdzRrMTdzdElBaWtrK3JWY1JkMThkbkRkWWZadzdiNDE4ay95TzQrdHZmamxucjFmZkxsN3dwbXg3R2VrSXdsL2R2Nm9YUG0wYkQ3NjdyZGZYU0dGOGx2eW4wa2k2VUVDSkg2NS9CT1ZHN2RmLzByWGdTOEhpczFuaXBnRlREZ0pQYWpZb0pTaHdTSm5aZTZXTVNqbHdzdGdJT0szSk9IendmeW9xWXNwTG56S2sxV3dsd0tOSEg4QSs5dWtiQnhNd1NmUmpqUkpGNDlRVzhES0N6dGRxSzlFUDBEdXk4YWpYSHVUYWVZWXgyVzR4aEVNSllqTE9Cb05rcmNRalJMRXZYM2U5MXZXWFFsV3Zycm9ZMkpqYTMvZ3FsZVAyNVFTeWYybWV2Vzc1YmVkWC9nNTJFSGRSankwN0xuakt3ZHY2YzIxWm51WmQ4OWZjSkRWSGlhbWxYT0dqSndodnkyLzgrUkxNMmZHUFZFOVpkUzQ4V0FiV1UrTldmTHVoZk5YeHA0UnRqOStRSkd0dEo1RCt6bXQ1M0RpazNNYVYzVGc0eTZFb0dReDRpUTlPc3RhS2Urb3RobHhmRldNalU3UnNkbm9lSGNCZlJhYit0UVUyeTBmakJFbCthYWxIOC9Ra3ZEbXBSK1V0Z25qNVkrd1cyaGNvM1dUL25INmRCaWQ4aWgxTzZQamMrbnpHNVJlRjQwU0xrRUY1RlhVVFRTUW9mUko2L2h6N0FId0NUeE1Od1lma2NvRU1WdFQ3ZEJiQVRoZXA4eFlVc1lyZUJUYjNrTTd5bkhZUXFJNlhzSGt3U0lYcTBPdEdycUpEYSs3bVNOODdzYWF3VnZOOGZodnYzZTlsbHppWjdMRDRiMmtTaXNwWXRnNFRRcEZhL1hDMk53K3RyK010UDJWOGZmK3RrMEJqcURnK1RuazB1Yk45RGtmNUpLZW9kK0xxNHpCNzlHdjBXL1oybzIwdFdQODhCMEJ2cU5ubEsvQXUwdTVIMGwvMm1jTjY4QkhvZ0t4NjRLdXBTbXRodWVWRkhLanVCK2ZXTjJ1WDA1WHovREJiK0hucDRIMGFhOTVsWDQrK3ZSWm5WWTNyYmlJRy9WU2N1NXd2c0I5NTRDM25saGQxaitIWG4rYS9IZlNubmtMUCs5cDZmTVhHMzhjU0hrQTl5TTdUTzM3YnJLaVlLUGpBZEhWeld0cG1ZMFd6RExkdUJxMkQxMnZwK21LTXhvZGQ0dXVoaGhiZ0tOYnd4TGhldkxmMlQ0VUhrOVRpSDdqZWhkYnVodytCNUc4eVU3bUxzUDFrazh5SEJsUWFURm9YMHRoQ3VCVzg4eUREOExPL1h2a3QzVGpHbWZ5cG0rYlBHWGJ0aW1UdDdHdlQ5bTZkUW9jbzN6NG5tRjBkdWFLNmp1MXE3UnJOU3poamUzMGVwMk81em1qc1ozaE9lSU42OXBwNE0relhEdm1zdm1EZitFZDZ2QWZVOUhPaHYrKzlRVGFGRkFscC81OGY0Vjhlb1Y4OGpwOWtqSHk5d2ltTzV0SGUrSFZTVG9qU05rMitTZGkyTVpheWF0eWlSeFNuNDBGbi9NcG4xTTY1a2NRZy96VE5sSWd2OW1kWENMbjVVcTVBT245TDllLzVBZkFuZ05MY1NWQkhPcVdWaEswWnhTclE1NlZEbXlkajg2NzAvbG9RV2VKUzV1V3dtVm1KU1JNNGNpS2hMbmxSTFAzN0tuN3NoYytkbWgyNTVKU0kzc2t2bTRNSWV6S2hMcWpyZmJNV2YzOGxNWGI1WGE3VXp5c1ozV3JOazdYYXRKMTQ1RCtweWIwTHhneS9QYlZMa2R2NitvdlJuY1orM3Bic3VDMmFVaUhuN1BydFQvUlo5bzRGUTZsaitBVGdpQ2pVQ2ltY2NMbjdLUHl2OWVTYnkrK2Z1SGxSVy9mKzVHbXd6MzMxUFZrVDlUMTVQeDE4OWoxdFcreFQ5ZmRnYThwYjRMam5zNm5JNyszRVh3Q0hsLzdtRTZYWWJoNUFMdUwrdklNZmI1RGNmT25PeEMxSWNTelorMUQ0KzVJS01vYjJmbjExeU9zTVJLSmNJK3RuN1Rya0dlSG9lZUNMdXRySjNDUDFVNm9meW9Bd29IWG42TmUveFpYYjNabGZVdlhWUnBmL2g5NCtlekdBQUFBZU5wallHUmdZR0RsajdIZElqc2hudC9tSzRNOEJ3TUluRHYxTlFaRy8xLzBMNUNEZ1YwSHlPVmdZQUtKQWdCbk1RemRBSGphWTJCa1lPRGcrV3NQSk9YL0wvcS9rNE9CQVNpQ0FwNERBSGlBQmNJQWVOcGxrejFvRkZFUXgvKzc5M1l2cVN4VVFpSkJEZ01xS0lwQzRBaCtSQTYvb3FJZW5qRUVJUmpTbkNIQksyd3NFb0tlb0drUGhYQ1lZQ0hIRmJhS0lsWlhpTFdkZW1qQUlwak95ckQrWm04anF5bCsvTitiTi9ObWR1YXR2NlpDbHlRLy81ZVgvaWZkZEJYdGhIUFpmdDBOU2hyMXFocnpHN3BuWlBwMTBqVjFCOThHKzJIMHRjWGlmdzIrd0hFb1FWOWl1d2dUVUxROXZxOHNsanRtN1o1WUt4cnIycTJab0JSdGtLOFd0RFFGZGRZcjdwdGVoSGxOczM5TzNEc25EWmtQTWJXd29TZllsemkvaGEyT2pySmZaajFPM09GazNaMWRWSzhwaE5qM2M4K2o1SHYzWnQ1cjBGV2lOdDl5Z3p2UHd3TnlYRVpQd3dnKzI5RlRVUFZhZXVpMW9oWE9VUzJRdjJwMktDUjZsbnZ1YzM2Q3VBSDJDNno3cUNORXQwRU85dmxONWYwZGVvTWU0dnV2eDdVMDlBUC9NdXpxMUJGdG1BL3JLNXdkQzFhVjhYL2hiL1ZaLyttOTJWdzVhbWVPYXM1TjZoSzJYc2pCWjdla1orNkNQTlkvb1J5enBvUEVQdzZiS2lmazZFZTkwL2V0OERhOGVCYk1JUTMxRHNLaW40KytvaTVvNFovTTRYK29kUmt0eHJOSXd5eHNadVIvbXZSOUM3eS9RaktMa1RUazNBTnZ5YitPZHR0YlRjM2hYK2dMT2VialdhU3hXVmdNeW5mTzgwYXVXazFKRDdPWm1wUTlJRzJxUDBrelBzQ1JEbHBGWjlDcGVIYkRtekMzMy9aUDhUN200TGFCdlFobllqNXFtdk4xaTJVL2J0aTl4SDNIM25ZRHJLVWU5ZndCY1RUVTF3QjQybU5nWU5DQndnU0dGWXc5VEZaTVY1Z3ptQ2N3NzJOK3cyTEdVc0d5ak9VSXl4TldNZFljMW1tczc5Z0syUGF3RzdHdlluL0VVY0R4amxPQ000UXpnN09MY3g0WEc5Y2piaW51UHU0N1BGbzhhVHh6ZUVWNGZYaXplTmZ3UHVCajQvUGhhK0c3dzYvQlAwdUFRYUJLWUpYQUcwRXh3U2JCQTRMZmhGU0Vnb1NhaExZSVhSSjZJOHdsUEUzNGk0aUh5Q3BSRHRFSTBTdGlVbUl1WWkxaU84U3VpZHVJdDRoZmtqQ1RtQ1p4U1RKQWNwN2tPeWtKcVZ2U1F0SVIwajNTUDJSRVpKcGtEZ0hoTzlramNuVnkzK1FUNUZzVTNCU0tGT1VVcnloK1VaSlIwbEo2bzh5aUhLUzhRUG1UU3BaS2w4b0RWUVZWTzlVRzFUV3FYOVJFMUthcHk2bS8wQWpSbUtSeFNWTk1jNXJtTjYwOHJTUGFBZHBUdEcvcHFPalU2U3pUdWFEelQ5ZEtkNDJlaGw2SDNpdjlBUDFuQmpFR2RZWWNoa0dHOHd6Zkdma1o5Ums5TU00eDRUQlpadXBsSm1GMnpueUJSWXJGSjhzNHkxTldkbFlIck41Wnkxa0hXZmZZc05pMDJEeXlkYkJkWldkbHQ4THVobjJVL1E0SEdZY09oeCtPWG82Ym5HU2NsamliT1hjNWIzRmh3QUg1WEdSY3RGemNYQkpjS2x3bXVLeHd1ZUR5dzFYQjFjMjFDZ2o3WEJjQjRSczNFVGNGdHdDM0tnQlRUSStFQUFBQUFRQUFBT2dBV0FBRkFBQUFBQUFDQUFFQUFnQVdBQUFCQUFGVkFBQUFBSGphcFZUTGJ0TkFGRDFKRzBvcnRRc1dDSFUxeTFhQ2tMU0EyaUFoVmJBdElCSkFiSkNjT0E5RGFrZUoweWhibHF6NUFuYndDWHdCL0FJcnZvTVZaODZNWFRlRVNCV3liSjk3NXo3UDNCa0EyL2lNTlpUV053Rzg0K3R3Q1Z1VUhDNWpCNm5IYTNpTER4NnZZeGUvUEs3Z0ZuNTdmQTA3cFJzZWIrQmJ5WGg4SGJYU1Q0ODM4Ykc4NWZGMitXdjVrOGZmY2JQeXlPTWZxRlZhK0FLREE5VDRIQkcxTUVDWC8xTWtpUG1tbUdNa3pXTktZMkw3RGFpUFpGSGx5Z21HZkF4ZVVOZW5mNHFKcEM3L1hWcWY4eHZTOG9RNG91OVFhMzFNaVFMcUZuTTFDcFptd2JhQlY0bzU4ZmtON2pOeURRK0k5aGdwUW9lckNkY1Q5Qmh4ZjBXc2YwVzY4RGdsSDBYL1NKMEZmRk94RURMQ21XSzlwODVtdkRxRE5tcXNpTTd2SmFXSWt1WE1vRWtVU0hLWlkycnZLb0pSN0lGNk1PdzZZVit4Nm9wa1hiMXlKWC9idFhMMFJKWXoxZHFuL0l5OTlzUzJYYjBqYmhPMGZTOVB0VEtneGpJOXdXM3FuaXZUV0N1Uk9HenlPMVZIYmg4TTZqam1GQjdnamJveDRuYk8vMVNUNURoeWU5QlRyYWwwQ2IraDlDUGxtK2RNR1dyR3FpbjFITVhpMHNtQklvMlUvVXljWjZ5M0ZTUGJrYUh2TTg2cmNCNVpIZU9DN1VqVEY3TGlqbkk0UG1hcTJ6S3l2QWNuVzlzT3MwM0ZTS2l6dGNpRTlSZ0s3ZEYrbjM4N2dXMWY5L0xZOFgvMGZoRTl6UGQrclBuSzlqS2JubVVkRkdmN2NsMFBDM3RrTzNHOXBNcVh6YVdONzNvTnFabXA4MFNuYnRVa0JKZDJ2ZXRQeXVKNXNheW10SnZLMDFaN25rK3ppMk10aDdSWU5VTlZ2Q1pxRjJxbzZ3NXBhcTd0cWVuU3cvQTUwaTE3eVB2THpuZ0Q5MmpsN3QwNkR2OEFuSU1JYUFBQWVOcHR6MGR3akhFWXgvSHZrMngyazAzdlhTZTY5MzAzbTZMdnlxN2VleGVTN0M2UnNza2lXaGk5RG1QR2pVRnl3ZWgxR0J3d2VodGxjSENPT2c2NHN2SCszZnd1bjNtZW1lZVo1eUdDdi9sZHdFSCtsemFRQ0lra0VndFJXTEVSVFF4Mllva2puZ1FTU1NLWkZGSkpJNTBNTXNraW14eHl5U09mRG5Ta0U1M3BRbGU2MFowZUZOQ1RYdlNtRDMzcFIzOEdvS0ZqNEtBUUowVVVVMElwQXhuRVlJWXdsR0VNeDRXYkVaVGh3Y3RJUmpHYU1ZeGxIT09ad0VRbU1aa3BUR1VhMDVuQlRHWXhtem5NWlI3eldjQkNGbEV1RmxyWXpCWnVoTDlzWXl0NzJjVWhqdE1xVWV6a1BaczRJRmF4c1VlaTJjNXRQa2dNaHpuQlQzN3dpMk9jNGdIM09NMWlsckNQQ2g1UnlYMGU4b3pIUE9FcEg2bmlKYzk1d1JsOGZHYy9iM2pGYS94ODVpczdXRXFBWlN5bm1ocU9VRXM5ZFFScElFUWpLMWpKSjFheG1pYldzSTYxWE9Vb3pheG5BeHY1d2pldWNaWnpYT2N0NzhRdXNSSW44WklnaVpJa3laSWlxWkltNlpJaG1aem5BcGU1d2gwdWNvbTdiT09rWkhHVFc1SXRPZXlXWE1tVGZLdXZ1cW5Pcjl0Q05RRk4wOHBNWFpwUzFXNUQ2VkE2bGFYdEd1RkJwYTQwbEE1bG9kS3BMRklXSzB1VS8vYTVUSFcxVjlmdFZRRmZLRmhaVWQ3Z04xdUcxOVRwdFhoQ3dkcjJ3cVB1OExyTk84SWFmd0JoUlpuNkFBQjQya1hOdlJMQlFCUUY0R3hXTm9uOG03Um1valAySFl4Q0ZLSXdxdDBaWGtPdFVWSXBQTWFOeXRPb05KNkNnN1c2KzUwemMrNlZQZmZFRGs1RHdWSzFqQjExT3hOU0RTalhEWlVySER2ZEp5SFh5aUZlMWNUbGxJS3F2dkNUS3ovd2dXQmtJQUIvWStBQjRtelFBYnlKUWZnZVVBWmRJQngrd1NneVAyS2swY09WTFo5dHdRU01iNVlwbU53dE16Q2RXK1pndHJBc3dQemY5c0JpL0tPbVVyNEFqNXRNRlFBQUFWS2xSTndBQUE9PSc7XG5cbmV4cG9ydCBkZWZhdWx0IEFyaWFsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy9mb250cy9BcmlhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmV4cG9ydCBjb25zdCBPc3dhbGQ3MDAgPSAnZDA5R1JnQUJBQUFBQUdvRUFCTUFBQUFBdDhRQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJxQUFBQUJ3QUFBQWNhMG51OVVkRVJVWUFBQUhFQUFBQUp3QUFBQzRCK2dFYVIxQlBVd0FBQWV3QUFBUEhBQUFKanRZcTZVVkhVMVZDQUFBRnRBQUFBR29BQUFDUWhUQ1VVazlUTHpJQUFBWWdBQUFBVGdBQUFGYVptV2RUWTIxaGNBQUFCbkFBQUFHTUFBQUI0dEIrTGZCamRuUWdBQUFIL0FBQUFDNEFBQUF1Rk8wUEgyWndaMjBBQUFnc0FBQUJzUUFBQW1WVHRDK25aMkZ6Y0FBQUNlQUFBQUFJQUFBQUNBQUFBQkJuYkhsbUFBQUo2QUFBVnc0QUFKbE1oTCs5OW1obFlXUUFBR0Q0QUFBQU5BQUFBRFlOZ3FVYmFHaGxZUUFBWVN3QUFBQWZBQUFBSkJDdUJzRm9iWFI0QUFCaFRBQUFBbk1BQUFPa1libzdyV3h2WTJFQUFHUEFBQUFCeVFBQUFkVFFpL2ZzYldGNGNBQUFaWXdBQUFBZ0FBQUFJQUlHQWRCdVlXMWxBQUJsckFBQUFmSUFBQVNVVkppaC9uQnZjM1FBQUdlZ0FBQUI2QUFBQXR1TUNudW1jSEpsY0FBQWFZZ0FBQUJ6QUFBQWlPUUdEcnAzWldKbUFBQnAvQUFBQUFZQUFBQUcvQXRYWWdBQUFBRUFBQUFBekQyaXp3QUFBQURMZzUrYkFBQUFBTk9JcklwNDJtTmdaR0JnNEFOaU9RWTFJTWtFaEl3TVQ0RDRLY01MSUpzRkxNYkF3QWpCQUVlT0F4VUFlTnE5bHR0dlZGVVV4cjl6T3IzUTZWQjZ3V0pOU0I4YUNDUkNVbXRLc1RIRzlBcE5vNlVRUy92aUEvRUJRd3p4SCtEVytHUWtYbEZvOUFWUmZGRExKVlNsUUluUnhQU0JOSUl0aWR3c2RSamtFbWtSWTVhL3ZhZVNUcWtPUTRqelplM1phKysxOTE3ZjJ1ZXNkUlJJeXRjemFsTldmV05yaDBwZjJyeGhveXBlZnZIVlRWcXFDTE15azdQNnA2K1UwV0RqaHMyYmxPZDZYaUlLK1ErVkg3eXVJS2ozdGd2VnFGWnQxUnQ2WHg5cXI3N1dDWDJuSVExclJPT2FDQ0pCY2JBZ2NGWjNFYXdJbms2Q1BhdnRzbUlxdEFzcVFpcnRuR290b1pWMlVYVjJWbHZRdHlMYmtPM0lEcVFINldVdWkxV3ZzR3FOMWxrY3IwN2JTWTBnZ1JiWkQ3VHQ5cFd5MVdEWDFHazMxVzAzZEJRNWhnUnF0RHUwVFp3ZHFNdCtvVzJ4UGo5eWszMjdiUkxiU1d3bnZSWkhpNlBGdlpaQVM2QWwwQnJ0Q212RzFXRS9zdm9BRm9FTzJpM2xjUHBWOWRrb1k2T01qT29RY2hoeGZ1MzNwNDdSTGxTbEZtdUpscXRHZFdvZ09rMXFWb3RXYWJXZTB4cXRWYWZXcTB0YmlQQTJiZGNPOWFoWG4raFQ3ZGRuQ25PcjNCMWtWK1JVNkRFdDBBUDg3SGNic2trYnNQUDBoMU5tZHR2ZWU2eHZJVmVSUDVFRXNVcTMrL0FNZlR3cC83SGlSc1lNK3BGQk8wVjdNcTN0bmhuNmI4Z1ZhN1ZyOXV4OW5IUTdQViszNHpUOUVuSXFkY1IrbmVwZGQyZG55SFhmalAzSGtKKzV3ZXN1Q240a2tUTC92ZjJWb3NkZC9PME03WmxaOTMrUGQyRzZmaGI1MXZydG5BM2Q5VC8rQUUvWmJSdEwvN1Q4dnovN1k1WXhvbVVUR2V5QkxWbnI0Zmp6TDArWGUrZnVlNC9MeU1qMHQvc2h4d3l1ZHNlOVorbmZOVy8vazdQUDhJeEVodkdmY0huS1BwOWxPcVRLVllLQUhMc1liUW5JMGpJUUllTXVwenBVZ1ZCUGdCeFZnMUJQZ2x5eWNRMTFid1dZbzFxUXI1VWdTbzZ1VXdGNXVvR2E1V3JaWFBKMWt3ckoyYzJhUjk1dVVSRzVlNVdLeWQrclZVTGxiVk1wbWZ4NSt1M2s4eGdaZmEzbWs5VTdWVVptWDAvVzdnS1BxaHVVaytkNzhIWW5DUFdtM3FYZEJVSnE2eDQ4NlFVRitoS1VxRStIMmUwSWlPa29LTmNBaU9rWUtOY2dLR0RkNC9oV1NLOEl6SjJLeFNMZ0lyT1VOc2sveWR4eHp2S2NJNTV6dHVlY282ZEFybWVlcDNvd3gvUFBoMzB6RVhGc1kzQnJwOThCb3A1aGtkYUJZcjBBU2p6YlVzOTJ2bWY3aUdkYk5zWDJOWEF2MjRobm02ZVA5REVuN3FQYVJmVUZpSHJtVWM4OHFuNTl3LzZPZjVsblhxYmpJT1FiNUFTekxncDVPZzNtOFRVeVFpUUNXQ1FyN2pMdXY0cDdyK2ErYStCY0M5ZVpGYmpOMzF6N3REcmNuVktKZCtMMVczcGI3K0Q3THJ6K1FMdnh2SmY3NmRNQkhkUWhQRDJDYndONE52ZzNnYXFoMlFCNDJtTmdaR0JnNEdKd1lnaGdZSFp4OHdsaEVFa3ZTczFtVU1oSkxNbGowR0ZnQWNveS9QL1BBRktGaTgyWWs1bWV5TUFCWW9FeEMxaVdFU2pDeUtBSHBsbUFOZ2d4U0RFb01MeGdZR2J3WlBCbmVBNm1mUmllTVRBQmVVK0JwQTlRSlNPREp3RDVFaE9PQUFCNDJtTmdaRlprMnNQQXlzRENhc3c2azRHQlVRNUNNMTluU0dNU1ltQmdZdUJnWmdDREJRd003eDBZR0x3Wm9DQXZ0YnlFUVlHQjl6Y0xXOXEvTkFZR3pueW1GMERoeVNBNUFPUnVET0lBQUhqYVkyQmdZR2FBWUJrR1JnWVF1QVBrTVlMNUxBd0hnTFFPZ3dLUXhjUEF5MURIc0lYaFAyTXdZd1hUTWFZN0Nsd0tJZ3BTQ25JS1NncHFDdm9LVmdyeENtc1VsVlQvL0diNS94K29peGVvYXdIRE5zWWdxR29HQlFFRkNRVVpxR3BMdUdyRy8vLy9mLzMvK1AraC93Zi81Ly8zL3Z2djc4c0h4eDRjZkxEdndkNEh1eDVzZjdEK3diSUhUUS9NN2grODlZTDFDZFNGUkFOR05nYTRGa1ltSU1HRXJnRG9kUlpXTm5ZT1RpNXVIbDQrZmdGQklXRVJVVEZ4Q1VrcGFSbFpPWGtGUlNWbEZWVTFkUTFOTFcwZFhUMTlBME1qWXhOVE0zTUxTeXRyRzFzN2V3ZEhKMmNYVnpkM0QwOHZieDlmUC8rQXdLRGdrTkN3OElqSXFPaVkyTGo0aEVTRzFyYU9ya25UNXk1YXVIanBrbVVyVnExY3ZXYmQydlViTm0zWnZIWDd0dDI3OXV4bEtFcEp6YnhUdnFBZyszRlpGa1A3VElaaUJvWjBpT3R5cWhtVzcyeEl6Z094YzJ2dUpqVzJURHQ0Nk1yVm03ZXVYZC9CY09Bd3c2UDdENTQrWTZpNGNadWh1YnVwcDdPdmYwTHZsS2tNazJmUG1jVnc1R2doVUZNbEVBTUFldVNOQWdBQUJSa0hCd0QvQVBRQStnRVpBVkVCVVFGc0FNMEFxd0VTQVJRQTN3RHRBTllCU2dFZUFSWUF4UUJFQlJFQUFIamFYVkc3VGx0QkVOME5Ed09CeE5nZ09kb1VzNW1ReG51aEJRbkUxWTFpWkR1RjVRaHBOM0tSaTNFQkgwQ0JSQTNhcnhtZ29hUkltd1loRjBoOFFqNGhFak5yaUtJME96dXpjODZaTTB2S2thcDM2V3ZQVStja2tNTGRCczAyL1U1SXRiTUE5NlRyNjQyTXRJTUhXbXhtOU1wMSsvNExCcHZSbER0cUFPVTlieWtQR1UwN2dWcTBwLzdSL0FxRysvd2Y4enNZdERUVDlOUTZDZWtoQk9hYmNVdUQ3eG5OdXNzUCtvTFY0V0l3TUtTWXB1SXVQNlpTL3JjMDUyckxzTFdSMGJ5RE14SDV5VFJBVTJ0dEJKcisxQ0hWODNFVVM1RExwckUybUppeS9pUVR3WVhKZEZWVHRjejQyc0Zkc3JQb1lJTXF6WUVIMk1OV2VRd2VEZzhtRk5LM0pNb3NEUkgyWXF2RUNCR1RIQW81NWR6Si9xUkErVWdTeHJ4SlNqdmpoclVHeHBIWHdLQTJUN1AvUEp0TmJXOGR3dmhaSE1GM3Z4bExPdmpJaHRvWUVXSTdZaW1BQ1VSQ1JsWDVoaHJQdlN3RzVGTDd6MENVZ09YeGozK2RDTFR1MkVROGw3VjFEakZXQ0hwKzI5enl5NHE3VnJuT2kwSjNiNnBxcU5JcHpmdGV6cjdIQTU0ZUM4TkJZOEdiei92K1NvSDZQQ3l1TkdnT0JFTjZOM3Ivb3JYcWlLdThGejZ5SjlPL3NWb0FBQUFBQVFBQi8vOEFEM2phdkwwSGZCejFsVGcrMzZuYmQyYXJ0TnBkYlpGV1phVmRhMWNyYWRWdFMrNEZkeHR3d1RhWWdMRXhwcGpRaVNrSkxmUWFFbnBDQ1RPck5TUWtKSTRwQ1NrUTdpNU9ONWRLSE5Jdk9jQlk0Lzk3MzVsVnNXWGorOTE5L2hocFoyZFhNKy83M3Z1Ky90NHdMRFBFTU94bVlRWERNUktUMFFpVDdTMUp2UC9QT1UwVWZ0RmI0bGc0WkRRT1R3dDR1aVNKZ2NPOUpZTG44MHBjcVk4cjhTRTJwdGVSKy9TemhSV0huaG5pZjhEQUpabjFERU5la0N6MHVyT1lFcHhMbDRuSStQaDBpV2VaTkZFdFdaWFpyL0k1alpNT2pvZ2NZMG1YSllteDhXbFZ5cFpGZXFSWlNaclJlS0o0VkxFNHJRM3ZSK0pjY2oyWnFiOU1WbDEySWVuVFg1RXNoMTdIK3pYeUpmWk55VXJ2dHhydUIvZFErWHlaRXhrSkxpbm02Qm56TGIwNXQ3L00wcnZBSW0zcGtVR09zYVpWVnRZa2tqWnZYeElsL0VBVXJBWWswOXE4Y0hlRW9KR2t5UGRJbGtUT2VrR3lqbjZKWFRYNkpZUmhFOFB3RE1CUXc5U1NiVXdwQkdzdStRUFYrWHkrSk1IZFN4YTdBNDdMREFsSnp2UUlxNFFqZGNHOHhuQUhSM3pCcXBxNllLNHM4UFFqVG83VzRrY0NmQ1JhYlU3NGlLaXhyQnJhWDY0MmNGUnRBR3FSR0JrQWxTd0lxSVFyNEhPcVJWYjlzZjFLT1dCOE5aQXQrNDMxK0FQNE5iOFh2dWJDcjJsMnVJU0RYa0tMazdUYUVYcHA0SXozYXhoLzJ2YlN3T24vL1Q0ZXFDRjVoQTFKWGdDSy9oYnhOOXgreEZwdGdZT0FQR0lMMk9IQUw0ODQvUTc0Z2t4L0svUzNEMy9qZDRMME8vQlhWZlN2NEpvMWxldUVLOWVKNEhkR29wVnYxdUo1YmxCbU9jU0FyQ0NLd3BGb2JlYW8vOVRCRUZKR3lYY21sYnczejlFZmYxS0NIeTdwaFo4YUFoOXRLc243M2ozbDdTVzN3cytOejhrdi8zck5tNnR2ZzU5LzNpcmZ5cDdOSExtQU9jSzJqYjZGUDBjdU9ESjZIM3MyL3VCNWhqQnJqenpFeDZXYm1BRm1BMFBVd2F4YXZWOWxjbHJhZWxBbE9UVXRhOTJBdkhDdVhEUVFIczJwUlZtendibFVUaXZBbHhJNWJUcEphOTFweGFQeFNyR29GcFd5VzdZMFp1cUNSZFhtVWV1S2FrRlJzMFZjUjczZkYrWHl1VUo3UnNpU0RGOW83K2dzNVAxUkVpRkNSNkU5bVJEOXZrQXRpZkorbnlqNWs0VU10NVpzNWVXYWp2b3R0ckN2M1Q5c1BiOHdzREtUL05PM043ejR2bjRUZDM1Zjc4TDVsODFlZVhwYjdOQUxHM1k4YzFhTzdScHVpeGZtWkJPWFZiZTJSakxlZ3JTbXVXUHQ4b3RuN0h2UDg5bys2M3ZQWm5JZHZrY1h0Yy9aVWx4Ym1Idm1ocXNYUFBjYjY5UFAySmJmK0JURENNdzZocEh1a2RLTW0ybGlXcGsrWmhYektsUHFCVTdYbWx1QnQ0ZDRKb0k3QnpkYjBqaE80MVpzeVplWHRQZW1uZW55RW5wV1hTS3JMbUJTZFhHK0hLQm5pTG9hSlVKWmxwZ0FmQzdMV28zQm5mQnVwTmxSQS9LaDFjQ3ZROVl5OEZHLzhWRzZQd01mdFJnZjljdmFYUGlvbTM2a3JURjR1cy8xcHg4Z0szTkF1NUJXSXdNVlhHS3hxTTF0Z2FQMjNpTEZlNkc5bjgzbm9telFMOGRqaE5LZ24rMGo3UmsrbVhCeGZpdkpXMG1objV2Nkt3a1g3MS9YdVByZWN6NXg3NW9tb2wraFgwVnN2S3U2SmRiUUZwUllpenZVV0JOcnJYYnl4TU5PTDQ5K2c1eEpHbGZmTS9XWEpibTZxYU14SkZ0WXdTMWVyTjB3UEh5OWRwRkZKK1JJeitMbGJiSDA2V3ZuVzNNRGMxc2FsWERMS2ZONkR2MWVTbi93STNMRWVwRjYvZkR3ZGRwRjFrbGZGZklEODFzYVBaNkcxcm5UY3lDRE9XYkdrVi96bjVDYW1UaVRaZ3JNYlV5cEZtaW5odkphdlhDUVNpbXRYVGhJMUE2a2haYVFnSGxsdFFXbENTK0JqQVg1a2tWYzQxRkMxdG9BMXphRERMS3REY2lnR0lqdkJHNXY0UUc3YkJOd2U1dFNsbXJyblEwR3QydXVNR0JjcTY4RnFSNHVxdTNLSG9hM0JadHdMd0FaNUU0V1dENmZDL2g5ck9UdEtNU0J6YU1rcUlqSlJJT0xKQk9wZWw4Z24rdE13UnV2TDloUEN1MnBaR0xHYjcvd3lqUHF6Kys4N210TnhEZTBOTEt5TlJxOTZIUFQxWTB2L0pCME5iZk1tbk5GMFZ2VFBidHRvTFY5SmJtT1NEclo5Tnl6di8zaDg0L3BmLzYwL3AxenYvZmk3M2JGMDd6K0cvR2V1WXYrL05iUzdhZC9kNGYzQ203UGc4L05IbG5TdlFiUUJqS2dsdGZJWWxCUUhKTmdKdXNTZm9JdTBZUXhQVkZMcHMxK1RKSkduemIrL3FFamU5a3JwSjFNTTNNL295YXpXb0kvcUxxem1vc0haS2V6S2s4bGU1aEhPYUsxR0h5N2Q4Y0hseUhmOG1vNDQxS2plN1VteDRkcXcxNDFETEl5SEFVcDJTU1BORFkxZU5NbGVCdjdUT3d6U2RHbGVJb2xPQWN2ekI2UWxnMk5UWWFVSk9YeE43QUxpRllONUZHdFFBaDNBdWdrVmhVUis3MkFmTmdJUXQ2ZmNnbFI0bk9ScU5EcEZ6UENRNnduTVh2VDV6WTM5RGRGM1RaQ09JNFFtenZhMU4rdytYT2JaaWM4TEhlWkpOa0ZtMi9ySjM5M2EzbkxuQU9rZWVHNlhlZGR1WHBkZE4ycUs4L2J0VzVoTXpsQTVwNjE1NWJmZjlMQXh6YkF4eWtVSHc4eEtwUFZDT0REbDlYOEpqNXMrMEZGbFpNR1NpTGpLRG52Z3ljTWxMZ0FKZkplWG9zNFAzU3BOWHRCWG95NFpSY2dwUVpVU2swRWtBSy9KeUFGUHFSSWNibGxVQ01tVWtid3pSaEtralpBU1FwUTRnT0xRN01rRVNYQlFxQmZhRSsxZDRBOGxncTVxTVVmSm42ZlM5alcwTjlZNjdZaUlxenUyc2IraHRtN1RwMlRTL2xkQWtGVWJmN2NvSUdDYlZlc01sQndLVVZCYkdqK3JvMzNiSDVrNlR6Rm81ejd5ZC9mdHVmc3VRWStGbkNuY3B2RmN4Z1h3M2c3ZzF5ZTZ3eEtRYWxCYXVoY01PK2Rta1BWNzh6Nzd5ZGV2L2lpVng4VnZLOWRUQ3o2Kzd1K3ZlNzNGNzczM29YdkduOC9pMXpIUHMzOWdiRXpLeENmcXBTbktCWEE4Q0dvOVJtYk5WMGlEQjRTemdwczY2Qklabk5sS3pVQXdIQW9XVzM0c1ZXQ2I5cXNlR2dEaTBKekdpeGR5SU1lQXFVS1NtZldLd2RlZWVVQU8vdWRmZnZnZitQK3k0ODR5TDJrai9Fd014blZsa1ZiejRLN3c1dFZ5WDZObFJBVWpZY1hYaTU3REdIdHlRS20wNW9Ic1cyem8xQWdTQUVXMGE3RWZmNkFpOHVTSEFyWnduSXlrM0JWN1dmT2J4UnNJYThIdUs4LzJyMXoyNE1EVGZZbmlSS3VOV0RneVd2a0NmWnh1a2RObnNJZjNLSWFZNGNkYTJYYzQzdTBFUGZ6NUJIeTJqdnY0TitDN1VhK0NQQ0RxVHZaV3Axd1RQYzZpRVd3V09tUGNTRTBTemVSWVRSRzRUcW5nWkE5QmZRanh3d2IxMUc1UEpqTDhNcm16Yjh2YzhiNk9Wa2pJRURISmNjeHlncXZUdkxrTktvMVVOQXoxTFplZnVTWGZBUmt1QjkyVHpkVFVsRDdoc1dEVk90cWRhS3hnd0RPQU5nZUFSbE5PODBCNE1JZTB1SUJRTFlpR2pwUE1YV2VYL0c1MkdRaXc5YWJTcTJneUZUckxTOWU4UElWbDc5OFFiSDNvcTlmY3VuTEYvYVE5WUljemllYXUwUFdHK3JiYTl3Y0s3Ty8yL1hHUTZ0WGYrNDd1MFpyZHI3eDBHbW5QdlRHaGJVOTh6dFRoZFVMbXRqZkVTN1Z2cmlqanRJbkRjQVh3VDYyTWRPWWtoV3RZNUc2QXZhc2F0MnZXYVNESlNzMVpLM0lkZzZBMW1LbHBqK0Z0Wi9yQkY5RFNZZlh0UThHaUUzL29sQWtWcVUxUE5qNndmdENrVjRmekJEdUVPQytpVG5EcEdHRHlIaUFobEZFakFNdzVJamk5UjFCM0FETldUVkk3YmlBUk5Fa0lYcmdzQkVzT3ppVUFGTWpqbWdLMVJhak5UQUFDU21xRGtXVDRrWHFqSkIrRHF3MHdKdUxCMjNsajRQZ0JPUjVRRHB3VWx6cEpTK2tjc1dJTzFwSWhGdkRQb3RJOUtkaWM3WTl1dVczaCtaLzV1cFNFenVORk5pZG5ZdTJiVzJ2SGV5dEQ3VjJUNS9SVTYxSU96WTljZXZHVHYxZnY3dms0SThmZjZ0VGZ4TFdOUnZvN1paYVlHZGR3cFE4akVIa1VwMEgxMUpYYlRVOEtxMEk1NG84bmlzeXVMNmhpcDBhaGtWTno0SGF3SFdwN1RuTkNTZWtYQ250eEMrbk00RHNZVmh3T2d5czRlRkJZVHNWMVFackx0YkJDY2xKTlVPaDNVUFhodHJZYjNBTDF3RGFHY1JobE0vMTg2QTJVcElTQU5ZeFVlSURsTXdlZmZmMyt0bzE2MWNWdG4vajJtMWZQSGNvekpMVEJhc3YzTnJWRXZaWmhjc3U3MXMrSExlRnVwb1JSVmFCLy9ZRkI0R3kvM3gzeDF0ZHMzNjMrNHJ2UExTOGE4Tm52N0M1VDNURjZtYWx1MnFEdnBwODNmUkk3UldmNXNnNjF0MjB0TCt4cnpjZXJPMXNHYTZMT1VUY0cvM2dnM1ZTSG5NeXkwMHVZMUZkMit4VzFvaytvV1lURDRKRFNGUVhzcDNxeUNIbnFWeXVaS0V5enlJQ1FpZndvUnQ5VU5ZT3FDQUdLc0FIVmZKS0VuaVJ5eXY5NUN2ay9pOStVWC9xMVZmSkhoTGl1ejk2VmYrRFBoK09xOWd3OHVSNm9GMDF3TlBCUE15VTJwQjJGcUNUcFkzZUNxNVBlYk1jcDN4YXJxdHVpem9ONmxiWDRUZXFJMGpKenF3YW9jWllLUkhCczRtWUZjMHZsWUJkcGpFQVBNbzZhcXBwTWxEWW1kT2FZYnQzQVUxSmhGcFptZ3hLZnNSU1hkZUdObGl6b3JxQXZOVVcrS3k1cU5ZcGFnTFhGUmVqUEd4K1B0VUp4RVN6VjVSd3c4VVZNTWVpSEJDZFI2S3ZKNmNTVm5SWE40VGk3YkdnVFdJSmEvRkVzclZ0OHdQNlQ3azFvKzl0V0x6aDd0TjZBbkpxOXBZSE5tNy80aWVtVjdNOWJUTVg1MXI5b2RhZW1jT0RZYThsMmpxekxWTzlvcE8zNlUvclgrdnBQK3VPKzA5ZGMvL25MOXRZR056NithY05HYmZxeUcvQTU4SzlQTVJjeXBUcUVIUFRSTk5FOWNLQmx6cm5YcWMxWGE2YVVRZGVzMWFGa20rWVNyNW1rSHorbk5vc28vWkM0YWZHY21vUG9pc0ttSmtGNTV6Tml1Y0ZTZlJXMVJWbUlGSjZGTFVEa0RKakdpQWxXbFNyRkRWUU5FUWtCeEl5UXVMdEdTNlo4UG9yeU9BUUdhYThsRXlFU2F0Q1ErZDgrY0R6Mjd2MTUxaG5NQk83aVR0OTU0WTdUeThHWW5PM1BiWGx6Q2UyTFlpYkV0U1hEUGxjZG9FbnJPUUp0OFdXRk5nVWUrV0c1NzU4NWFKVGJubDVleXpWdmlDYjFMK3dwYjluNDJmdlg3dmgrVWN1bWpYei9Ic2VtMEVGcXoxVTFScnVxdXEyaHhMcDJkbHMxWExrc3dqSXZqcXdUMFdtblNrSnlQV29kRFFHY1NKbFZXRS9LdDhTTHlEU2VEQUFOQXNnZ1JmRzVXdmNUK0lrd2tuNmQvWG5TSmZ3RTVMVlBueGErQW42REwxSGZzWHpJSCtDb0c4R21NOHlwUUJTSTRaOGpQZm9GUStXYzAwQkM1QWdoN2NicENTb1FwV1BHRytCZ3lwWmE0RDdLWENveUtvTlQzZkRjWGRXc3dFOTBEbHVBVkJBcVlMMDZWWkdhbU5OQWNOYktGa2NkVVUwRFpwaXFMZ1krRHluYUE0T1hudkJhaERvamdRZk9RVUNLZ2J5U2FMRVlaUG9ud201ZnFFQWlzempvNHd0b1B2c0lyMzlwKzkrajd6K2gwOU5HNHc1OHR1K3VWc1BrMlZFdEFXaW1kNXNKR0FUeUdkdmp3S0hWelhWQk91clpBdFBkdFMxQlZqNXRyZm0zZmpodThTaC85ZnZSM2MzbkxIajNLR3JYNy8vRkxZbW5PeHRtQmIyK21yYVV2MnhDR2xrbHcxbUZuWjBScW9TM2EzRGljaStoaG1VbjVjQVA5Y0FQMmVZMmNqUFhzUmdIREFZOXlKRjRpakZxZm9lQUdTMmRuaEZRR1lySW5NT1NuRXRCTWlhblZORHNzWlljYnZqVVNOZ3JiNllvK0ljdlY2dE1RU2IzQ3VtV3FuR2FvMERiUnVMYW9laXBvdnFnRWRsS0txb0M4dWh4a2NPWmxHR1Z3UjRIeEdUTVlZaXE2UFRsT09DZjBsczNyWW50MndHM2sxVUEzZWZmNEcydlpjaksxaFJDYlYwWjhJK20zRHFObjBOc0RYSTlaWnc0OXlncmJxbk9keFNBL0tjOEY5Zi8veGpsOHllYyttano2OGQvZUdXRjErOGR1bWlXMTdhRWExdG50N1NFb2kxenV0WjAxTG5FbHR6ckM4NjNOQVJEV1NTZjI1Y3VMcWpPdG1ibVpPSUdqRzFlOG5qL01zMHJ0ZUdWcDFwaTZFaktwaFcyY1JRSWtoMlRRS0VHQUc3VGd3WlV2dHN1djVOTXYxZTBxTy94djZSOU9xdjRyVlhISG1FM0FmWDlqQUJacEFCVTdYc002OFlSS3RWOWViUWNOVUVmMjRLMDdWcWt1bEtielhKWk9YZ3RpdU9NbHUza3VsM0hXVzVzbjgyb01FOVBJOHBzSC9oUDRDVkpobHpWV1hSU2dPWVhBNVhwSWtNT3RXOGFiNFJoUVNJTW85OVhCK2FSeTVnbmNSRGZxci9YSCt0UTM5Zi93V3NieFpod1NkSWplT091Z1JnREF0b0ZGZXdobWF4RVNNdFMvU29FdXdFQTVuQXp5eDI4K2hEN0diQ0hqaEFoc0ZZSnN4T3BzQUZBVTZSaVROVXVzQjF1SndKS2hVc0NDY1k4aFF0VmdCVDJVbStyZyt4anhkSUhSa2dQYVJlYjlEL1F2ZEZCZ1JNQ2ZaRkRWUExuTXVVd21pMVJVVEdTK095c0I5OHVBbGlXVFc4WDdYbnRGcWdnalUzRXF3Tlc5SVZ6UmVFbDFwWlUvQzJRQzIwZHNONCsxQlJxdzBxbmhMbnE2WVN4QWU2Y0lRUmJTRWowakFXWlFBNm9TV1hvckcxb0pBQ1VhaGtmdmJ6WC83amEwL3FwUm1Ybk4wM3ZhK3I2TlZmai95SUxCS3UzdnZlZXovYnA1YzM2SDhndTF0MzNQakk0dUZacHczMTkvZHVQL1FiTXFSL25hNXAyWkVyeFV2RVpjeGNaaTN6REFNcVNSdWszcTNxeW11TDRTaWRVMWRrdFNnY0ZVeGFyS08wN2piYzNXNFptYXM4ejNnM1Q5YVdnRktQNWNyMXhvbDZXWnNHSDF2cE8yMDlMSGNKZUpNalF0UlhRSmxacjVTVXdXRllzVHJOVTNMTm1HbXNmUkFRTXFPb0xsWlVwYWl1OE95eFZ0VXowN3J4KzFHbEZJc25pb1lnOVhUVTVYTzh4N0R3VWpUaWtpR0dZUnNzeEJXZnYrSWdHTktCTmQ1M0JzVmtvaTZGN2dQNEU1MUtocUFGNlBjdDIvcHQwdklWbld4OHJtWE4vWnVXM0pGclc5YXk3WkY1Y21iNHdubXJtMGt0RWV3Qk9aN3hpSm56WHJ2MW10Y3Y3cWxkZk5YcnU2L2FzL1dETDc2cmYrVzdhOW5ITGQ2V1dLS0dEY2pSVEVnV0NCZDhrYlQ5L05JMzlkdEcxejl6KzRxZTd1bnRWMzV0Ni9UZHQyK2JNOUF4T3NMeWlqZW11SHJXRGNWdmZ2dExxemM4dmYvS1QzMS81S0laM2IvdXV2Z3Y1SlFIb2gyOXlUQzVTdzVXNXpMem14SnVwQlVZaVB4eXlRSTd4TWJNbit5eGxVVUxRMEFPaTBnaE8xVnFFa2hmU2RaNFFEcG5QVWg5RkY0QzVJTVJaS1ZTbDZCUlpVUC9BTFJwbkV0eTNqeG5KZGVSR1dTM2Z2Kzg5MmF0ZitrMHlmTEJCK1FhL1NyMkRQWWhoc2JremdVWU9nQUdHZlpBTTBpOGtrejFLM2VRV3E1YUxYK3dyRFRMWUwxcUNqL20zTVVBRkNXbnhtUXRoZVlNdkF1aVdyV1lqcDRsQllEWUFhSm1VSnlxczZncUNyeFZhejJxeFVpbFVETkdsSGhGWnVJVm1ncEpyM0dVU3BOenljN045OSs1dm5qZHpTQTdEK3YvV3RxZkcwcTZuSElxMGdPa1RzeGVuWEZ2dXFST3N2ajd6bnJxZ2xzZXpTN1NiOVQvcmgvbWgxSnpseGRiaDFwcjNSSTU5T2Y0S1dldXVPVWhHaC80SmI4Szlua3pzNUlwMWVQNmdxRDlndldvL1lKZzVScTczUVBuUEJ5ZTg5alI4aldXNmtkclR0YkNzQTFRQmxoUkJ0QkZodjFvTk5TYjRsREdOWUdsVnFDbVdqV1JqZmhzM0c5WXJzdFoyN1puTHB3ZjF4L2dsVWl4OGVHSHM0TmhHOW5NUnVkc1Z5KzRhTTlGQzJyWk5leHk5c3Flcys4cm5mdmdrMjJ6VHlzMjZ2OTkrSDM5L1k1TjYvdStldCtXTHorK1kzam1qaWRlb0hzY2FkWkZhUlptdWt5S0tSV0toVGtnVTRUQ3JpQ1o2SVlHYi9hZ0ZzWFhLc29qakVrRzZuNEQ1a0VKRjVUMlZNTzVaRmY1NEhWNVI3eDQ2bFhQYkJmYmUzdkRWZEk1VjBpVzZYZi84SkhSMG9iYlByMSs2YlFRYzRSeitCczdtN2czMW5RVHdDL0F3NTBLOE5qQnZxQmNyRm1GZzRZTnlBc0h5NExCeWdJQzVxQ0FXUUV3alBuUWtKRFZqc212bkJIOE1TTStBSnpmY0FEaS9uUFp2K3BYRUkvK0YvSXB5WEpJRHh4aFJ2Y2ZvanFyY2w4cmFGQjYzNm52YVp2aW5tQ0ZtamUwSDNYRHNkdVpOenY4Q3pQRzlFditVdUNoUnVaeUkyNWRTbFlZYVFydUtZTnB4c0g5YS9EK1RSTVpxZHBncElnVjNDenFVRlhYV0dsS0RZM1JacUJRTmZCVkNRd2tsS0kyUmF1Tm9Rd05KNEZzc2VKeE9FMHBvRWVZTkVRbThKcjMvT2N2WHBEUUh4ZDhpY0dXcDU1NjhrMjIrMUFtOC9TcFozeCt5eXlRa3V3blRVWTc1OHJzN0ZWZEtZUFJpUGV6UkRpODhjbzVhMlpmOVBBVEZmenk4eWhkQjB6cEpKbnhKQ0ZmNW13VXc5dzRWZTJ3UWphbjJtVlV3MmdTZ2NRYXArZll2M1BKVmlLUWJmb2Qra2VTWlRUSy92cUREN2prNFY4YTl5TS9wbm5iK0FSNmprVys0R3I0TXg3NWdpdWhRS093TWtjT3NIUG9ubWd4ZVJBZ296NENVWldzS3UzWGJJQnl5VlpKVm9MOWhKZnhLMkF4ZFhZVTRHcG9sWXJpSjV0YnlGWnYrNm0zblprZ1RHUFRibUhGb1M5dXV1bVNXUTBtUGg2aitKaDJGRDc0L0dRazBHVnJCQzBtemxvY3l4OWJRVEJMRkFFaGNxOStPL21NZnIzK3R4bUFoUlhzTTZPMUgvMlU2M3g2ZENjenh0dDljQzhCMXlQUTlaaDdpcWhpQlI4bGpuSXpoMWxpYVJ6UmZyekRXWkxsdzMrTTdSTmhHVnpMeGV3eGNTTTY4Z2JrWU5EbEFYWTN0UUZjUnZyTG1WTmROQ1NsV25LWWpzYXNpbXpHd04vODEyOW9adGFSNFZYblhwZkd1VDRVVkhidlN3T2VmOVVhd1hGTHhxWGE5Z29hNy81UVl6bUx5c0dIa1g5dGhnL3RxazBlc2RvczNuUUpmby9IeDVreVozRmFiVVpZZkEvTDhRN3pEUTJORzR1cUliQXVUbVNsdUIyMFEzbnZXK1FKL1orVzZEMVIvVysvdEVpV2owN2gxUTgrNFAveHl1RzdYdUVQZlNTTzRaQnZCcnZTT3FaZHhRbjBNc1VDV25XeXhobVo5MGFlQ2dUTmF0aVFtc2pCcTFTc2tOSmlraExOK2lRQlFvcmtKcEk1ckY4c1dROHY1Yjc4d2Z2Y3U0ZXJ4K09rTzBCZUtFd1U0NlFPeHJBbkRXRlJqWVpsTGIyL0IvakZJMnNCdENDQnVXUHdHdkRBdmRETk5EVkxySnBVZkg3WTdMRGpxZld6bkhXeDd0akNTMTY0Nk1JWExsNFlKMXNmZmV5eHRxR1lrejJGWGN0ZU9YcnQ2TE5iWDN4ODU0enAyeDk1SVFTNzI4clppSzF0eGJJMlEzOXc3d0EvT0dDZnpUQjNHdFVkY2U1ZzJlNWtVTnZiY1Y4bktJZ09BQkY0d2lGclFZQk9BRG1WUk82T093RTNncW5RamRDakFvcEViTWM4RHFqemM4bkllL3V6eTNjL2NDYUp0Q1pDaWtQa2lPaXNydXNFeGEwZit1Q1Q1WXRtUjhoaG5lY2thNVduS2RTZHJMY0pEWTM5dFkwZUY4VmZnTjhGK0FzeFRWaFRRYjMrQ09DUEJwdzl2Qm1Nb1FIblpncGxEVUJaSTFNbEJ3WUpEYU5HYThBOGtrUWY5ZWVkU3NrTnpJYlNOS0lBNU83eEVBdTRwTElVeVB0akRTS05STXVBOFlxUnVUeStjTmVMZjN4eDE4TDRqNkozNkgrN090MTEvZmN2NzRmOXRjQ1pHTTYxellxN0VPSGJYM3I4L09uVHozLzhwZTJqeitxM2prei81WGVGdFUvL3VvZmkzWXBZYjF1K3ZHMU1kNlBPOG9LOXRjamtTbmZlTkxZNHc5K0ExWGhoTmI2YzZwVzFFTWFEclladkVmSUM0R0JFUzRybWxIRWx0Y0NXSlVueEZZdkZNWTJPaFBCZ0ZyQ2FvQkVDQzBHRDZ1WWJmdkRBS1paSWJ0M2dvN3YwRzk3c1BidTV0OFp1RFJaU2wwcVcvSGxmdmFacjlZNVZ5OE9qdXY0UTEzZjRGYjZtYStXY3dhRmxCYnFQV28vOG5IdGZhbVdLNkNVVmtBQVNVTUkvUm9EdXJPcWgwZDRHZ0xwQnB0NWlEZzZyY21wT3BqWlRiVmJyZ1pNTndObXFBeXhCcFN6WndjRUR1c0FYNFZ3THJLVU9qTms5RFBIVWhIT0dsMVJ2VmlNWXRRaE1Qc2Y0Slo5ZmFPOHdQQUFSSFlBZ1dwSm9Zckd0WkFmWVZvVzZyVC9hMFRHNHFpMUpBci8vSm5FUS9VYk9GcHlXNk8xTnp1N2Q3Rjk0enJxcy9vOXZYYkh2a2tHV205MjVmTk5BK2pNdmYyMURhKzlaNjYrZi8zUG1pUDYzdlU2bjBtN1B1dXRtekdoWU45aTFjVVhYRXUvUUpmZDgrY3lYLzM3Nnczc051ZUtDL1hNZHRkdGhaNHNUNDEzZ2lsTG5WdHl2Q1NDZUJSSEZzOEJoZ0lWR3YwUm12SjdIVkljdTdoSjlWTDlMK0lESSt0OE9XWVFQakh0c0F2a0JkaGQ0NDhOTUtZSTR0NG1HL0ZlOUlMenFLaW9BTXprZ25ORzgwT3JSTlVESmxTaXFzcUtGSTJCQytEMXEwQXl5S1VhMEJiWW4xWFpDSWlOc0lsdFppeS9aZFVwWDBtZGh5VlpiZU5vcDV6Mnc5NEd0cDB5TDJOalA4ZWQrOUlVTnE2N0lkWHM4eGR4bEs5YnpMTC9obzd0WDNuelB6azhNTlRZT2ZXTG5QVGNqckNEY2VCREM0Sk5QTi9GQlM2QzR2T21nMHdBeG9VSVdZeG5VUzBlQnFvcEZsVk5BaGpDQU96UDc1a1ZSVCtJT3N1YnpLbG11UDZTUGdIUi9tWi81Z1lrWFAraXl4NmpzdXNLVXFoWTc2REs4b2NhSnFNdWNFMjhwNHU2Qlc3ck1FcU5MMzZjWkxwVURMY1h1MVd3eXFDLzdYbzdSV0J2bVpGbk9aamNWandFaE1LdW9xRmJZY3VpOEFKd09VK2hST09GL0RoUlMzRTg2em4rQTJPKzlpSFFlMXQrNDl5NzlEUUI2TmYvRmo5YnpqNEJhZXVDanN5cXc4ekZxUDF6SWxHeW1QcUtRRXk2ZnI2UkZZUitoVWlJNTFFdVNFVmxBYThwcExHSGYzLy8wYjdnRWw4cklBRG9zRWhhQ1dRS0FuLzZtK1dSUlFuMGxvSXhnTUxGcHFZQU1KZ2dBVFB6azFDKzlRSmJxdnlTMStwZWVmVnIvSWttQ0dmSjdOblQ0a2NPcjJHV2p6M0dQVVh3Zk9RSXc4d0N6amVrek14cU1ZUUNPcGM2QUJ5MHlXbVUwQkZKSm5XbUVwVGUzbW5UbDR0NE9UeWZWbklTcyttTHQ1Vkd5VUg5Ty80SmtPWHp3V3RaNzdVZnpSNTlqbHhrMFBnWDIxMjBTV0dsTXhyUlhKTEI5YUtLSkU2aEJUNjEyVFRJU1l4clBWYXIwQ21BWFl6RFpmd3I1dVg0Nlo5R1Q1SmUvRlpvTy9lN1FUdzZOMTBKOFU5b0plN2VMd1dvL2dXY2NSa1NQcFVlVjJKZEFReHhnZWRFZExGRVh4ZHk1UWNOWDhEL0VKdlZSd2cxS0l3OS8rT21INGRwWXo5Z3M1Y0YrQmNuT01aUHlyb1JlYjRRaldHeklHdkVUTSsyNmQrMkhlY04yNG1TVjJhdXlza3Iyc2hwRHhnd2diOXdiSHlLeDEvVjNwUHdIUHpCeTlyQ09CZEtnc1E2TVRJNnRReGhmQjdzZjZ4cXhTbytsR1F2V3FOS3JyS01BcTRDZkJZUTVBa1FkdkZxOCt1b1Byb1pyVCtkdTRpNFVzelRHaGdGZkxvK0JUMXB3SW1WeDl4cjJrTEVQY0xmYXlYVGlCcDV5NndkMlhjTGR4RDQrZWpwNVZGK0hjSUk0NEZxWWR3QW5VWk9XQkpSMzVZQ214MDJESGdnbmNpbk1pTlAxQ1R2WURNMWxKeGdqSXNLSkdQNnM0Sk1GczI1Q3pZczN1WUNjZXVNUHBMUSt5N0MvdW8vOGh2dUMwTW5VTTFubUFrT0NsdUo0MXlad0N3SUVjN0p3NEtCVmlRNHYrdnZUYUN6Um05TlNFbzF1cEdTdGxkckFHQUhIY2lNdGhZdU9GOVZXVE5Db0lZOFdpZEwwUU1USTJ6aVVFYVk2WkJZVHRmY0xuVFN3NTZJSkhCcndVM3pCdU9Ha3NiU1VxSjkwS21KM09MMXc3Z1duRGlXYXdra1hyMy8xMXorKzU5ZHAvZnZ4eU82TmM3YjJSY2ljMm5wL2s4ZnpKRWtPWGJobWFiR3ZLYnh0ZUNpWXFhK2Q5NnUvLyt5ZTBic2VlZW1HMCtaMnJUL3Z0TVppalM5SXBsOXZySDg5clA4KzJMY0tlS3hyVEJ2UFNZMG96bEFqSlJHUlVEZnVvQ3F3U3RhVHkySElBSTJOaWtOcWkyT1JqcE1hVG9nQUdjemlPbmpsVExlbW54aHJFekZxNTFlQ1VRdXVyS0RRakllMG5peHAyakd3ODZGN3RzL2MxU2dLdkVOMFdCMTJoMWhWSTNSNTBySUhwTTVYQzlPL2NmbmgwZk9mR3VyWlNISVdDeTlMTHRIRzg3RmtEZnZZeW9TdkN2bGhFYXpuZktCbkRHTTRVV29Fd2tJOE5LZnVxY0k4TkM3SENlZWNOQS90dENKTjQzUmxNaEJVcHRZckJtOUNOQU90SldCcFFhekg0Nk9WaWdRa0V2V3NnV3l3b0VvSXgwZUx2eGE5L3IzdnY2YnZxVWtQRGxaRm5EeVpmLzRMNXo3eEo3S0luZmJEZzM5NCs0SzdGODNkTlBySmJiNXArY3hOcjJ6OTBzbzNnQWFMQWVZYktRMGlTQU03MHNDTm9BZE0xOVFBbWdZSm9vWTNJRkZ2QUYwUXFTcVhvelNveFdBL3VoKzhHMmtRc0ZPMXBQRTExRFhCS0RjRlBJaldSTUdzVTRzU2pJWGlNaFkvdEhOZ1J4Tlpvai9mdUd2bTludklFcUdtS3QxZVRIVWQ0cmpMdnpHOXdNNys0SU9OUFVOUDdhbEp4dWF3cjg1ZkNYQlhjTzFud3N6WlRNbkhWSGFMais0V2R3WGJJWEFYQWxZZjcweGpIYVVmTjZjUmVMSmhWVU1PM0QyS2N4Zk5pcWh5amhybk51UWhYMUVOS2hydktGTEY2cDJBZnovYUp2a2N4YnNZUzVFOFpzNzhCdkt6ZzdQSS9EL3BML3lKTFBuVXpFR3lqRTBqNnZWLzZPOXN1L2kyT3gvN3dadnMrZVZObXd6NU1SMDJ3Vzd4MjB3TnM5U3NoaVlBc3VyUGF3eC9VQTBDbDJjMUd5SStqS1hOS055ckpUUzVTOVVoR3BVSndpSkQxWGdZUXBzdGdwR1pVQ1YyaGdWSi9RSkFXMHY4R0x1UGtMd2ZRekRURnhDTHY2bC9RMy96T2JIWXNMZTU3ckhIOU9mNXJsK3h2YWVmUFg4d0x2SGNZVEhiMy9lcmo3N0RkNEZrQytqUGNMOEVQT2ZCeGx2S2pEQWxONkhtbmJhQXB5bmtYRmJyZ0tOb1ZwdURrQzVEODBDYmhaa0hMSXBzTjd4MW02eUsrTGJPaU5EUGtyVjVDQ3Q4cTlmTWdHckxDUnJxcGdPcnpRSjdRRXNNQWVybktlVm9ycVBiamU1UnRhZWtCQnVwZTlTUlV6QmpwMGFWc3NqVnRjekVqK2Q0TkVzQy9tU0JvdG1xNGRXTmZnaW9rUGFPVGd6U1l3NFU2M21DSFQxRVNrZ0JNNGlmSldpa0N6UmxIU05BVnZ5SCtlcUdwT2oxNFNHdFlGblExN1RndXJOYVQvL2NsZ2NXelgyMk9ieXBwYm13NmNGMW5nNlBKemk4N2JycnR3MjNMZGwxK1FLOWx0Z1BzRHhMdG9meXVUbnAycXJXRFF1WEx2UkdGTHRBemhuK2RJdS9HQ3ArNmFXdmIvalN6VXVYTGZ0N3kvejcxbnpoOGprV25tdTFWc1g4Z1dUdTFONWxWOHpQS0tTaFo2aXFnV1pYWjNQemYvNkh2L2lhMHRPenlET2dzTGg3WUwrR0tuRk0xWjZmSUN2OVNJUWF5dUFvUTFpYUUwVjd4dzQ0RHVPcncwaHBhNkwvS1BrWUpjalg3UjIwb3BkSXlqcXlwTzJHT2NQbkZmVG5DU0dpVFhINE1qNlVoZVhPb2RWWEQzMzBPdzVjTUtWRzlsaGlBZjloTCt6SkRRQ2dKcjV1NXRQTTZCaXl5d2x5a2R4WUxqSnY1aUkzb0NBQUdWQjk2RjNoSmt4SW9xNDQ4cDcrQmprQTEzWXdNbm9iQWw0V2JDeVdBNzgvVzNhWlYxZXdVaFFMUEhBenUzTVlRTk1rM3RnU1lENGJ4cktnMEZ3dmVOTTU2bVZnN1N5Nkh2NnUyQUt5K0lrSDU1LzlPRm5jS0cvbmYvMFIrVnk1Um56S0FJTFd3SEh2VWRzNE56bTJSa1hOV0hSTkdvK3U4Wk9qYTE0MGJUbEoyVVNXdkVrK29YK1RET3FQUGRzSzV1VUM4dHJvVDBkZDdLd0Z1aGtYb3JnOGZwenhtQW83d05wWW5CRjRSRGdIOW15Q09jdTBaNVFhaktVUmswdFVSeDc5ZVBCOWlab2NLMlFHWGtuUUpJSldJOUV3aGNlb1NORHE4QlFXUDFteEtsd3gvR013cjJvbnJzMVBWV3h3QWlPaC80dkp3M1o4QVdiS1hqczhmVnU0N2JaVGhyZDE2cyt6bG9CUzE2VS9uMGtWaGVxMW5VUExCMllzV1gzTlRPQ3FuM2lDZGQ1NWh6M2N6OWJOQjdhcThMelFjUlRQVjFhanVVK2E1NGw3bk9mOUUwQUZoaGZkQklHY2RzTmN5dkZkb3ROcGMwa3VYcFNFNnRNN1o2eTZhdWlqMzNLL1dzVkpna04wQzBBeWgySERvQjY2Q21CekFuUkRoc2VrZVVFUFVlVlROUTZaQ3lCenlacmY5UFVRTEJkRG9WSDlXRTZHT29hdjZKaVlhYXRraUpFeXBJYUtmOUZyNU5Idi91Tkw1MzFsQjFuQ09hSlZDeGNPbzM1NSs5MTMzeDc5MFdNL1dQUE0yWUZJZzI4YmU3MmhYOEMrMG0vaDdnTStRTjIraWpGTUt4K2FWbU9vQTdVT3huTkZzMCswcnFwTTZ3bzF1NjFxekxyeU9RM3JpdFNZbVBSV1NGK3hycXBKWU15Mm1teFp0YWZSb0VvVjlWdkVtMWVQMjFONm1uMW9qbUZIelRmZ1hncHdYMFRoVGlEYzdncmNGbEl4UjZJQXR6MWI0ZDZKRmttMWFaSFVUYlpJZkc3RElyRkVUWXZFVk9YVXYxQk1pd1NOcVU2RkJ0V0lmK25kMi9yT3EwZFoxTEMxZDl2ZFpISEdVUjJ5MjkzdUJ0a0hsc1FSTG83QW4vSGhoZVQ3aGVuUFBybmNWZXVXMlZmOTN0cEliWlhCcyt6WGhSYkdOVWtTVXJtRlVSSXpuRTNaQW9TRlRQMFYyd1R1Qk9DQ0NzMjVBMXN1WHJnbDByODJOVHhicUQ3bkNwditXOXVLeFlmdk11U0VEL2h2QWZCZkFXczZZN1RQQkh3WGVodGx2RkhCaDNhRFRIT0NFVGkwNVdnTGdnOGpjOG02SEtaeFdwUVJRWWsxb3g2TmVMUWdMVGRXbWpIYVpiTkhrblVWaDhIb0FaRm8rWnZSYVlOWlVxUjdQZGJGWU1JblN6TEVOM3ZYM1V2blhuL21QTjgvSEhJeVBpMlViRGhqUlg5dTd0eUdkeDYrLzBDYXNEWkhwQ1pkTlZCZE03T3V0ZlBjVDNJL1h2SHA1YTM5VzY2WnZTemFNSkNLNUdJdDU4M3ViRjI4ZVZ2bncyOSs0NEhUby9HQlJHUmVUYkZwUml5VlhWdkdPTVdSdjdPZkFuMFFZamFhRmI1WXYwcTFqV0RZVDFKdVVqMTNEUzMzWkkzQUJTYlpxc2VLdWF0cFlXTTEybEM0TDYzVk5JTEphSTZ4R0d3QlJTemFUN1M3QXJzdE1rSkI4WVBRZmZUUnhueDM0NHc3ZTlaUHo5YTRCVENreUhQNnNsK05kbllVUlAwalh6ZzdaLzdtbFozc0xxVFZLcURWWjRWcTRPdlpFeTF0d2R5U3FnVThjVTlGdm1QUUREZ2EzUURrWjI4bGJ1WUd3QVREdmpicWQzd0kwWmhkdllvc3liVDJJdHZtYjV5MTVlcFJQbnk0WTlzODdpK0gzdDNSZjhyekJzL0FyYmtkQUFmNnptWXNqSXpGd2d6ZitlaFlsNTMwWG5NZTZkVjEvUm1oK3ZCdDNJNURabDE5RGNQd0IrQmFEdXlWd1ZnWHJJSmVib1J3b2xRWHJBUzd6T0NDR2U5Q2x4OVRObWJJYSs4TlpzaUxrVlhIWHBjUkwzcHBZUFA3ZVNPS0pNcXFzRmRRSlZtMTBEaVlRT05nZ3NWUmlZT0pXR2hrcFV4TG8xODJFL0o4SmZwVlE2clAzcXB2dklEdzM5SVBYTFpiQjVBUC81eXJQL3c5cm5Eb1hZNDdQSXByQWQrYnV4VFc0bVJTazlkQ1EwbXVyRkhyaWpjQVc0SVdoQmdCSTg2THQvREd5Y0wxenVrS1dmalh2K2psRGV2MDh0K0VhbjFMa2Zqbmo5NDdlZ3A1UUQrTFZTbk9QUG9iM0ZxNGo1ZEpNaFhVZy9HZ09USFlnRTBlOURiT1NSUndnWGxUd0g0ZUcvR1EvS1hua0lMK0czZi80dTNuelVwdlhuYk96VUwxYUNQN2swT3ZEcDNaVStjNHlKNTIxcWZJdjFnWnJsMEVPWFFZN2pVaFRzV2Iyb25qVHk1T1ZTUmI5TGZabS9SN3lEbS81V2I4MXp1SFgvcW4yVk54WkMvN3RMU1Q2V0srd3FqTldhMXBRczlPa1JZUFozUFlXNGwwcjgyVi9IU2IrWnRwZXlYdENVVFNGdzc5MkNCeXU2eG05bXB4ejRkcWN1OUlJcDcwcG5rNE41SnR6M2pUTCsydE9ud0hwdWRHOHZpMkJCOVA2RjJCYzVpaWV5R2VTR2F5OE1ic1h0bUQ3eXR2YWNUUmI2VjFUNHptYnFMZFBhZ0dzS0tYT2daK3JPZ0huMERDaUwwRjNtWTRPRTh5L0t6WXRMQWlFalp6eVpkdjY1N2I3T0ZkeWZtRi9LeWt6QkdPRXgyZWNLb2pjY216NXd3RUNPR3QzbkFMWnlPMTFlMjVSWm41bHMvdjI5bDRJQkJkTVd0eC82V2YyVkViV2JudGpCbkI1YTF6bWdxUmlPTkE1NFlIbjczWTNWZWJxMGtvZHNEbjlVZXVKSnVsTXRoOEVXWkNMNFRNcDgwWDA5NExLbm5sK2dQWFdqcmUvKzRrT3N4a2ZqZFd4VmFmMVZKSWg2R3NhdDlmY3NtaFhDNkhMWUVZMDJzWnlPVks5bjZraGgyamJmVTVMSENuc2VkdkgzckNvSVpGVnBXOTJxRGpRN1Y3TDd3WnNWb1ViM3JFaWIvNUVSZDlJK1B2bHdZT2dpckN4T21nUE5JejJJMGZEK0JMQ2Y1aW5FYXFzMWlDVDVGTWd6YUwxZW1TbGU2ZWdjSHhObFh5QXB5RmM0T1pDZlRxQnprMzRnOW5zclIycUo3UUxBd0dCWFA5VW1jdjZTajA4NTFBcFY2U2taSUZvMkFIdEpBQy9ocXR3dWRtUmR2cUkxNlhSV0N4RER0WU45RFNQai9wNWdTYnl4OU9aU01YM0gvSjlCaExSS1ZtV2l5Y0RudXRQQ0dCZ1hPZUd6emdrT3RDblluaHVrYUwxUzEyTGpwenpweXErRlVQM0RDVVRIUlVwZVNnMWNZZHFPclordm1MTGN2YlYzVjFSL1JmMlpWRVRhNjJ6MzNKc3crdTcwU2EzTXgxY09meGx6Ritaam1EbThJQ3U4N2lwbFh0TmtBNW9KZEgxOWVMTkFwUVNodE55RmgvWVFNQmFUZTZYakNiYWZPUG1URmV0MklXcXFZTTh4VlViajVnbEtHQmhYZ3p5WjYzT0xOalk3aCtEeDVsTDk0VVRIRHpsbCszT3QweXZPeUdOUzB0UTZaZEtKTVhRQ2FnbjVZMWZLa3lQKzZmOGZ1cCs4VGxSb2pFVzhZYWNBd3ZEV1NxRjcyMDlaZGRlTGIrTXBtcHkwTDNvZGVGNzVGK2ZSL1ZjZnFIM0tWaURDVG9ET0RoQmlOUkNGZnp5cGlSeFhMS2hMRk9zZUp1WUllQmFaUmd5VzRpQ2F1Vi9XUHhyazVnZG16dmpYZDJWRUplbUZ6RHlrdWZLQ2xKSlVOV2FTK2VPdktjWGlha3BtVndzQ2tLN3VxQzc5MTk2bjAvSkxlUmwxLzdyWVBVNnI5eS9lYlZybmtMNW0vUytXMjkwd1hQdE1SVjk3d2g2ejhsRFU1akR5MEhQZWFXbXNIaS9DUlRTbFRxdDkwWTFPV0ZoTnVaVnNONUVJNEgxV2h1cENyaHRxU3A4Y251Ung4V1M4MXFjcVVZN1pPUFJjR2lZR01UUXRsWWc0Ym1kTUEwUzZ0aVZJMnJBVVhEd2tKR2l5Vk1VWjh2ZE1LQzhyVEZNQmNWL1BIMmhPSTNlaW1XWDNycHBWS3dZY2FwMXk1WmNPbXkzcmhYMUw5NjY3LytSYjczVWcvNVQ4SWRtSFhoZFdkdm50NFlMeXhmZnVHR2dmZjF4MytoaitxejlkOGl2WGVSZzl5VFFwQ3BadXFZVHpGcU1GdU9HSkg0Wkxac015UHg5YlJMTTJUUUJ2eW5HUENnYkJBZTYrZENvQmIyRVBCN3FxclJSSXdwSTdaQUVFdjZWTm16eCs1d2VYeCt1a2NqUWZ5ZXg4djRxL0REcEtMSldJdHU4K3dSUkl2ZDZUTHNTQXpGZERaMEJqdGl3YzRnUm1Ld2xVK01OVWhldEsrQXZLbUV1R3Zsd01ES1UxZXVKL0w2bGFldUdoeGNCY2Y2MzlhdnZPTHMxZXMybnZHTk05aVpLOCs0NGJvejRDdjR2VlZuN0w1dWszRk03bHQ5MVpXcjExeHhPYVZySHVqS1NYbW1pam1US2JsUXA4c2dFZk5seFdpenR1YXc3bFRLbC8zR2V3RmM0dXFzNnRxdmVuSmxwNkc2TExtUzAwWGp0VmdGSnVaS0x0b1k1SkxoblM5SGs5OU9WNldlMTlEVzJBZG9oTnVTaFh3QmZsSnNualRzK3haSjZUKzZaOSsrZmZxdlhubmxsVHV5MzVieWh5L2pydnZvVzYrZTlXMU0wM3o3ckZlZlpmZlRQYnJ4eU4vSkFqRkM5Mmlqb2JrbmxpUWJQWWxpNVdnczY1TlhPUGpaK01jLy90SE4zais2aGJzVGYrUDF6anp5Ris0T2FSanNnVm5NUlV5cGsxYllnSjVJWnJVSXlxRFpXZFc3WDJPcVFFdVlaYmFwSEZiYXdvWFY2VGtNNUtIbWlFMEQ5Mm9POXVwN3NRS01CTkIxc0NwbE1aSnM3a1NDdDN1MGVBNTVPZ2tHNUlzTXFZckYyd2VHVEtwanFoejNybFF3T2hMUW13Z0VKYU95R053S0ZPRElEZWhQZVBGRUJ5YldYZVRNWHpwaXJRT0pqcjY2M29VclZ5M3NyVnU5OHNzRDIyNWYrY2hicVYvTTM5N1IxNXhkNmg0KzU4ek91Ky8rbGZibzl3NGxFck90Uzg5Skp6UGs5TG1KdnNGVVg4ZTBVN3J6bVd6UDBCbmRteDlwM1g3ajZzK3NiUDN1WTNOZjdldElGc05OMXVZbDUxNDkvTXI2YSs1KzdpdHZnT3JOaDlKU3kxRCt0R1JnRHVEdFF1RS91RStZY3pxS1RLV3lqT2JSd1lrd2F2bkVTclU0VXFQUjZGemtUVWQvUEpHT0xzU0ZKSHNQbVNiOEIyblh2NDgvUm4zcnNpTi9GLzRrN0FHL0lNNnNZSjR6UEhVelhLMHV5SllINkZGcFlBR3kzY0FjWUx1dWJMbkZPTm5WZ2llN2NuQ3lsdWJWYUloN0pZWEdhK3htRUwwSjJNMDl4cnNlR1Ftb0FwM25Ha3pVbGxQbkdzTUVyTVorWHdXZzkyRFhjLzB5b080Y1pZOHpVTnNpTEtEN3UydEE4YnhnOVhoRE5Rbkc5QW5IYXFKWm5sWTVlK1JvcGFnRENBcytvMFI3S0pPMEZoQUpqWjhLN1lVOGpYQkl5N1ovZzlqdmVwM00vL3JYOVQydjM2WC82eHZiMzdqMnIzZHMyM2Zkd29YWDdkdDJ4MThYRWRFZXFHM3JYNUZmdG10R1pEK3h5UEdxbWQyUlRKTUNxbDBTMkgrNzY4SGMwdDVwdFFFNzJHai9maWVSdjNQSmQvWG5YbnRWZis1N2wzeUh1RWxjUHpENjhOb0h2cnYvdXcrc2ZWamZYdWpkMkxzazF4bjE5Wng3MWVLYTJJeUcrSTB2M0hwM2s2TW0yRktWZHdaR2Z1S3I3Y2d2Nmx2Ylo4UWlIanp5TDg3R1hRZVVhV1h1RzVzR1VLNDNpR1BQb2lCQk90Z1ZhazY1ME5YTVVPd25EUFFtWk5XSnNXK1g4ZGFWUmJGaWZJQTlQMWkvRmpST0JPVnkyRGdLWjB2Qk1LMzhEWUZQbXNXcUZBeGxLTFVUSndQWWxSSlQxVWlyYWpyYis3bE83RWtCQlpta2hnRUhlek9ZTkZ6Q1RsOEFHMVpjL0lOdHhVdjdaN3VrZ1lVL1pPKzk4WlNkdlFtZXRZaU8vNHh0NlZ4eCthL0N2UjJ1aUxjWXFuNjl1SzZySnhBUTJKVlgzSGZUMXp0T3UvckdoMi8rYkc1RlMvdmxuNnB0VElVZlYrd05ZV3hWWlJZemc5eGIvRjd3STRGaHZRV2lDS1NhMEJkbE1kbDdCS1N2OFpzZHZKcGw5TDFIOUNQNlhwWVpQMGI1ZkNQaDJHZll4eGtCSkxWcHUxWTZzbm1yVVVmSVZ6cUNTend0WHVXWnNWSkNid0VsN0kxczhtSHkyanY2ZXJQWCtsYWl3VFhWOFQ1bjdpRCtHSDNPaFBZNVc4Ynpza3JjZnlzYklScHo1QWpEVDlpTE1hYWQ2V0crTlhrMzFtVExCYW94U3pVRmhLVW1BaHV2S3FmMlpNc0pRNmZteDNkaEwrV0RTa3VNakFrYXBEQytLOUIrMHk0NFVXZWNxRE9HZHBoYnNBK0x0eU5HSnJkTEtUc0RJU0dQNHJYT1U2cXVTcUhRelNocU16QkREZllyTjZlTE9DR2xiR1U4S1RvenBZZk9URWtvYW5US0hkcHA1TjZTWEJKTUM1RWwrWmlDaldGMFhBUnVXaTlLNlRRNXpzNTg0SXBucnVsK2FlY05SSDZQMUY1cFRjVjY3SnQyNEZhOU5uLzZndTNGS2JiZ1oyOGZmWGcxdVY3L0pGZWFyeDhoYS9SZmZHRkI5dUlsTjljcyt1dDE1OEt1MUxtWmEyNW15SkZmQ0JyNXNYZ0IwSzJ4VWk4QWVEUmZKbEp2UEt2T2dSbFlSejRTdEc5OXk5aXZuK0ZyT1JYMG5KMEpNQXNZMVpvdHV3M043cytXT1hPUVNwRFN4ZHlHVGhyb3hzSksxS08wYThtSndRU3NiZFQ4Ym94OE1zVUpEVEdvbkR3Vk15V1orTXpQdnZMVm4vL3NwYS8rOU1DRzVTdldyMXU1UWhqNTZrL3gzQytJNjltTEwxcTVhcWNCMTZmaDEzdmNIMkJ0Ym1icmVKVUJlbm4yUERhNWdDbFNhVDhFSVZJUytFcFJCMEdMWlZJbmtxMXlOT0trYzZIR1JJc3E1aXZMc3VTdzQ4ZXNXU0FUaGhOOG10MDQrdkMzL3ZOYjMvclBkOTRaRzFFQVBpUTdtLzJFOEJmQS9Ka1U5eW1EbStXS3JWaVNhU1c0SEVLQW1tZytrc25oVEE3Wm1MYUVRWjJZOGE0aFIzUHlZaldZQ0pINkZNM1hwY3orY0ZuUnhKalJNZDBQamh1YkVSSXVJVXhBT3hqWXhkNXcveXoybWszckNNZGJiRzZQYkxQd0hIbm4xdDFYMzU1Wk9uZWRtM1N3cys5aVAzZnRjKzFzMEJad2VPMTJRWFE0L2U0cVI1RGIvZUR0VjdkczM3WCtBdS9ucVJ5NGtiMlJmVWJNTXQzTW5ReXFUTHV4RW52WG1PY0xUQkV3RmhyTGxqUEd4N0VNTmVQVHVOQWVpdmwwRHFOWHVMVG1IQWF3c05DNE9sY3VWUFJuU2FheVFQYURYT29sV0lnTVhKUHBvcHRTelNNYllieXVnQlkvdkZWakhyVU5NWkFQczFIQjZDZEJWaW9nUjFYYUNpZWdwR0lSM1hpQWNJSmtkMXM5UVF0Ym5EdXZDenhhajlWdGx3U09ITGhsOXpXMzc5NTkrelc3YitHZVlxdnQxYTZBd3lINkdrSitrUnZPUHB3ZDRzUkFxTUVuT2gwQlY4aGV4U0ttYmkxMDNIejE3UThBbm5ZSU85aWxrK3BZbU9QWHNhQjV1K05HMk1UdkNUdklTL29zK1BzZ0dESFBBNTdkb0JHTXVKbVVON25XYkhvYnNZdklxTVlzTGRXUlJmZVdHckN5T2FLTEZpVEtaY1pnY0pEWkJ2UFNpRE9JZVBvdlE0SXpkdDE5T3ZuejJ6dCs4K2piL052cmIxcGMvK0hiM0NXSFA4MWR3bjhGODNQc1UrUko3dGZqOG9QNnRDY2NUdUdselk4ejJiRWMzKzdSdDFqMGttc3hKKzgxQzNuUnRHSk1SeW1HaGFTbXN6NWk4WHRnV2NHeEVXR2F4VU5qK0l6R21GcmFvNmdna0wwZTFZOGt6d1Z5ZENxQzFBRDdFZGxkU083bTZwTnRqWFYraXlLSFBYRm5sSDNtbC9VZHEyWnY2V2pXenlkRXRDaDJtMWR4dTIxTzBVYitjYzNaMXpSTmI0cTRMQVJoSFdadkpFOEEzaVdtaVRGTE9yRW1ER3VwSnBkeWFvSm9nSVg3cnFNVFBjcmg1MDliK1E3LzF2MnJ0eDlldzg0MlpOUUZSLzdPTGVlZlpmek1JTk52UnRYQk9jQWNQKzN4bWs0cE9tZ1FiSkNhTCtZQUttMEcyaWlESjVxZDBXRjBHWXVwUHRMZWtSRnBCMXdZOUs3UGYwRnk2WjJmMkhqSGlzYkdGYmR2K3NTZFM1UC81SzFLZFdPMVB4bjBZQU05L01kS05rOHc2WSswVkx0RlFyNU1acHoxd09XRHN5NS9hSjMramZXZnUzeDQ4UElITjlZV2t5M1ZIbHN3MEJUS1ZiVkxmNVhhcTlwcUdnTkJteS9kTUwwK3p2TWk5MWZCd1J4anR4Z05tUDVxUWw4V1k1MFoyV3Y4SGlTREJJN0lvTTVjclRNVDNnQXZEQi81dTdnQTlveEVOVTAxOHdPbVpFRjgyWDM1Zk1tS1hvSXRYdzRFTFZZbkNORjhSY3A0Y3FVZ0xlY0tVa014TkRYSlZFSFdMUFpLREFpYlZhekdJQ2ticmFYQStERFlIR1dmUVFoM3J1VHo0NS82UEtBMy9MVCt4ZThBd3RkTU5kN0xSbXNzZ3NXaTVzTUNBQngwRUF3WUhYQldwY1FKMVVhbm84a2xYcEluOVFXU3A3bVBwTktRTDFDKytiVXhwbXNoV2YvS3RkY2VXTHQyakk4K2FzTXBMUCs4aTEweSt0V0gwYU45K0NzNDZRVnd0ZGpFVlR2emxvRXB6T0dpckNqbkRMRmJ3Vm00eVFFNEs0ZU5zK0VtWEU0NGhkZ3EvRDlnSzRVejFCeDU3QTJWRGVTaHNtOHgzdVZ6V3NkVU9QTFVnK1pxYXN0UnpaV3pHTmdKS3lPaVIyakJjbkJyaytJWjRYako5SUFtNEVvNGdWYWJpTG0zVDZqaGprS24rK1QwSGMvY0NIaCtHL0RjRGJ0M0xyT0F6R0ZLYzVBbmUvcUJKM3NSdjMzNTh0eDVjM3FCSjJmQ2tjR1R3N25TdkxtSXpIblRyZWx5bHgwL0xuY2RyU3JMQVQvOXdHRGtjaVpHMzAyaE1oZitUMVdtV3BEVmZ2U1FLZzVxRnVQVTFFaVdVWjJXKzR4M2ZZYmpPajlYbm0xY1pVYXVOSHNPWG1YMk1ERCtuTmw0T0djQUdIL1JWRVE5U2lscmZiMUExM2xBNEhsejRXQVE3V3gxUWZIL1JsVmJqOWsySjZtOHlTc0dmMlFyTyt0L3FzMFBIemgyQXhwMjhlaGZlSmRRVGZ2SU56S2xDTVo4dzdTUFhLM09haTV4cktzRHkxZnN0QTRlUjYxaFhYYzBONktJbk1VSVlLS1NVemdNL25oUlZHZ0JrWmJLTVZyWWhlM2pQRzFrd2FJclR5ZHRIUENicG5KRHZZa2JEQjUvNW10UGtrVmpyZU9rTzRMdDVPUU1zbWpoUHJKZ0E2blNMNS9VT3I1cDczdnY4WWZOOW5HUUo3UW4yVHFmeWhNWFRyR1ozSlhzR085S2RrL1ZsWXl0Q0RUZFpTbXF2UElDWWEwMnU4TnB0Q2M3cUV3Y2EwL0d0RjVTbWR5aS9BSVc4WTYzS1Z2bjY3TU8vWkI5YUJKY3RxbmdzcHdFWE5ndC9RSjJTOXNkR0N2RjFnUG4xRzNUZHVLTms2TmFwOWRUdTJ4aUF6VjdGN1hSS3JBMUFHd3U4RzFQT3hvMjl6aHNucWxnODA3QzJZdUlNNGZMTFZNUWpUNXFXbHVqVEVRZFZvUTNTTnhrN04zN0JrbThxZjk1L3R6d09BcWwyOGs5K2puZi9TNUZZd1ZXeTdjQjFqaFR4MXgyTkt5SkNxeHFWUmFMSEhCa0NzN0sxR29RL1BxandGZjlPYnFDMUtRVkRGb0o2MUtxYXVPSnBMbUdBSzRCQS9GMVJVMnBNdHNSeHRaQ1cveU53cGE4REZ5TU5kTSsvMUhONjdkSVZRMUQyYmsvQ01vSysrQkR1YmV5YnA5VkdKNnd6b2Z5aTVaMkpMcmRibG5mUDlkcXFSTGRoMTZqVGU2OHVlYlhUSjcyTU5jZmw2dlIwSFBuTmF1STVhcDBnSnhsUHlxL1JxcjhWSWtPUGFKVFVDZ1dZQys3MGFuRnFnZjhDSEdCWStYc3dGSWxrVGd3bU9ER2lVZXF4MU5pQlNkVmVzZnVBenJPaVVOemVlS0s5NUJzelV1bkxTWFRKcEN5WGY4K0VoSTR6d2h3bW11ekJtRnRibGhaaFBuQzBXdVR4OWJtSG5QSWFpcitHcTFPc2xhaW1TT1MxNHF6TGNZWDZLVU55K2ozb3BZWVd5TVdMbm10aWdmTWY1dkJxTldLNXNIcHNrN1BDQ3ZZWGNhR2wyR2huaUtObzR4WUhVNExsVjZWWGNhMmQrUUNQakhCd1c2amNveE93WmlJZ09SdHY3anR0bDg0WHpxdDBOalVBUDgxTm8xaDRtcy91L2JhbjEzN1VTUDdFTmZTT20vZXlnWHpVQTYzTUl6WUxGa29KamFZM2hLVG45eU03cElkaUE4WGp6M2lqckVlY2FDMGM3K3FqRmV3MERTRWxiVmlSTURzRlBmUnFrT0JMb3F1WTZ4RkhYdFR2WG1saFJQWUR5dTk2cU10K205di9mRy9qN2VzbTJLajMrd1BIZjJtT1pOZ0hrN253cWtFNVg1RDQwL1JUNjdPeTViVEpzWG1UMnduN3dQcURCclVHVHhxU29HYVI4VS93L0NmRmdERityQ3pQTjA2RDdseVVDbDdndlVaamhJcVBRL1dOSnVPNytnYm5JR2F4OU1QWHcxaWUwUHhKS1lia0NsY3I0K2ZlRUF1UEs1M2RwTERFQTVmZUNJbmptVzI0SHdBMEJrWUZ3S053YU85NWdSbUVCREJGbUFHcTRNWGdBT3N5QUV5TFc5bGNuU2NCYWFsakRZQ04wMUxHZmtwT3VmRmliTmxpZG1kQ3hxTVRCaFZzQVhWbC83WDhZRUZxTUErMkQ1cGJJSFpmN3NPNExJYlh2MkpKeWJJSHpjeFFhbjBLenVLUjAxT1FDMDJZWHFDbmpSVldBVWFFQ2d2VmZwbDZDd0YwR0YyMkR2TFBnNG03OGZCNUROaEtqbWN0T1gyR0xoUWUwMEFiYlNsb3JvbVFVYzFsMkdYbkEyLzFvSU1SMXA2c1N2aFJOVEVwaVU1cnhFUkczbXc3R2RLMGlMRXZGekpLem1OUGtvdjJHR2lLNWVqaFVKR0RHTWloVkZXbjAyeStuOU1RT3UvZzRpbW9ua2lwWTB6RkxkSG5zUzVCcFFQTVpwQUlhZFFqMVVFV0drdWkxWlRsd2pIR2hqamdMbHdrTk9weUZTbmtLMFZYc0pDWkVvdjlxSHhhMDZvWXJhTVRVdXdtblZ0SlY2UXhxaWdVSzRnVy9YZmpoazBFL2pneUd2dzYwcmdBeEhzckdhbUpPRjFMWlZKbWNZVUJWci9hek5Hei9CaUhXMHY1VXlEQks3ZlV5SGxWcksxUXNNSzNCemlnbjJRMGhHMThmd0oyRUNpV1F5aVdYTzA0TnRBelFoSEt5VVlnMHhNMWlUWWlBVlAwenBrWThZRTNydnljeXJKbmtPMmJwMUlHTHBNSkFuTENLQXpNNkFuZkV3S09ZbE90ZlJ6Wm9kaGdqdFlKb3lIQnordVBtL0d4OVZranRaYmVHbVJvNStPVlMvNTZmUTBmejM0UjE0YUkvRFNxQ2ROUlZBMFljV0ZMVkxabUxUT2NXemlDcEFoWHhtNmtrUlhSamg5MHVnVi9XYXkxWjNyN1k1V1djNjl5bjc1NVZ6Zmk1eHYwaEFXcm05MEgrL3dOM1kwY1crY1dpU2pmM3B4ckwrOEdldzdLNU5rZGg4ejlVQU5aVFd2Z0hwZGxWR1owL1IwM2RnZ2hHVE9uSVdnQm5PVmNRajE1bGFtWlhsZ001ZGtid1ExaU9ncFNWVWh3NktwREVmUUlrYUxqQ1o3NFV5d2F2SzRCRzVxUTI5OGlzSXpVOWw0RTBjclRHSGtvV3lnc3haZ0x5aU1uMGxncFRqdEM2NnFURnVJb0FPV25EaVZObVJPVzhDS2tRQkRGYm9hVXNvT0w3aFVkY0ZqNXk2Z25PZU9QM3ZoVHR5aHZjZWZ2eUJ0QVRmbXZFbERHSmpKY0VjbndEMTVTa1J5cWlrUmRlYVVpTEtEcTQwbDBQNFNGVFYrNG5rUkdGcyszc3lJUGlvS1BtNXlCUHRwMDk4eDRHNEF1S3VZZXR6REZPNmFDdHd4aER0RjRhNEd1S3VOSFlGdzR4ekdhaFBmRVdXUHcrc0xWSEVVZkl6aEhnTitEVEdFeXZFeFg2ckltdFhIeDc3d25Pa0JIVVVCY3gyd1Z4UW16WFRoYkFPNmpreGxIWG1RUkltc1ZpTmd4NFphaGZ1bDNpeS9oS1cxd05KYTZEZzB1clJ1bkNPSis4Q0RZK2VuQVROVjFkU2JheXNCa2VoR3FVbVl4dU5SN0hVY0QrajQ2MzU1cXAxaU9RRU92bktzZDdUeEtJYmtUWHk4WnU2akZPYlNqdGxKNk1JbTh6Z0ZWYTNMVllyUWpHMWxQUG5EWThocEQzM3lCeDZON3pjMWlUaE1TWVpvVFBweHlERlhGWmx5eDZFZ243QitmSDhVRHU0aTJWWG1pdjlNcGsxTmVQU1h6anVLaDFFSEVHWTY2V2YvenYwVlp4ZDRzVndLYTZWdzV2bjBmZnZ1MmZmSzNmdXVtWDczSy92SWYremJkKzhycjl5NzcxTUQ5N3p5aW1HMzYvOEFISG1aSU9EbnAyWWNQNFFqWVZHTlVTUWxSTU1tUWJORHpGSVUrZmVQMlB5TUN6QUpuQ0tSOUloTnNzTzdNS0Frbk1XUlFZZ1F0U09rcGtKRTgva3piekNhMzVkNUE5djQ4VmdTTTIvQXB3SSs2RVR3aTk3MFMzM2x2N0swTU5RbmoxaDhramN0akhqeDVhVytGLzVxcFIvQVZ3UDQxUkw4bmxET0MxL0dPbEhORXNBeWI4SGlEWXdWaElheEUwVVpIenVUQzNxRFhNQ2tTQVBYNEUzUldWTmNlNFkxT2ZLU3RYUFBPT1ZYbENKbkxwKzlZY0Voc3ZXeFI0a3pOclJ4akFzVHhPYlREOXlwYnpMcFVxMGY5aEgvVFdReEpZcTNiZG1LdG9vOFpJMlpGeUFQazB3RFNwVmpwMTQwVGpYMW9zbTBjclJFWFJHVG9PVndwSjVPenY2WTJSY28xRTg0LytKMkZPc25OUVJENGtFdS9tL2hONloyQVBSMTlTYjBXakJWUEQ3OGFNZWRFSDd5bENIV1QyWUZ3andxMnl0cmFJQTFOT01VZzJQWGtKNXFEUzFIMFdBUDBxQ3h1YktNaGhNc3d4VHlKMXlKV2hIeko3dVdpdVBBR2VzQm1ZWTBTVE83amwwUm1qK05lYTBlQkZvVENMU1dDY3RURzh6R1doUmpkZGx5dzFnRm1ybHV0UkVGV2hvRVdpdm02SEJtdVloRFZ4b1ZNQURoTmUzUm5PRVRyTDFTdW5iQ3hkOUo2OXBPZHVYanhXK3NNYnNEK0JFanBuT1BudDdobm1wNmgyeE83eWdUMWdpU2FxSkFVelJUVC9KQW0yTFNOSTlGcGs4eGNhYUgwRzk0Rnl4ekJoRGtSM1FPV1QzQ00rYXpsT3FKTWErdDdIUXpPRGJQeVkxWkVDN2dMdGFkb3lQSlFtYmRYd01HWXVyZFpyY1plcGI1Q1FPb0pHTUFsWmc4ZzF6Vi90Nyt6TkpyN3Rra0JsUFJnR0szOEN6aHJLNWdyRFVzV2Y2a0gvcGcxOGhGYzZMczZCKzVJTyswaHp5TjFSMnhoSlZQSkl1UlJwL2ZVcG5EczFGcVp2TE1aaE5pUCszZ3J6eXhKbzJOWU8wVTFEemdNaytyL2FpOVZvZThZWk1PbHVybzBMazZUTWRFYzFvQm03SHpGSGExUnFIZG5ta3NOTEo1REd2WnNBWDhzaFRsL1RJVEx4Z3pNUnVNVjlvL3pQdVZUWW01NXp5dzdyY0hqOHk5ZEVsWHRmNEwvZC9tcjg5NUxyMndaVVpDWmtWM3NMNjZwcW5hTGJMQ29rVTNYYm82cDcrci8va00zN3gxRjF6Y3IvK1gvdEdoK2hYYlZsOTlMeGt0ckRxOUxaYnRiVXg1UFhYMVBZMnhROC9SUFVOblowaXJnRXBOc081UFRweWUwWHE4NlJudGxla1p6Y2IwakdiNmhKN0s5QXhjZERQS2gzaUtQcFNuRkdob1FpY2k1Q2xGb2tiWGVldWtLUnE1azVxaVFlM3lrNTJrMFlYaVhEakphUnJpK2Zxc2o1NFlHNmt4RVNkWndNbWxKelZScFAyRUUwVUtreWFLbEFMVDJneU1qRVNpdVR5TnkvM3ZCb3ZnNWp6WjRTSUMzYmNuUFdLRSs1b1pNS2pnSlE5NGFXRTZtQ3NuNG1YYThmRFNXY0ZMcTRHWFZsbHJIOGNMUGp1Z0ZhTVc4VlFEWXFRZGNKTnVNWEJUQm01cGFxYkltVFlKT1lXVFFrN0ZvVGhabGxsVjBUdnhrMlFiL2dWRDlVeGduUXFPeEg4SEhBMkEzUHZzUkJ6Tm5CcEhha2RXeTRMZmtUVWVnS1VWMGUrWVYwSGJvSUcyUVZtYlBZNjIrWUMyUVVEYlNEelZVa1RGTzl1Y1VnTTR5N1ozVUp3NTZCanE2dWdjbE96WkR2cklvWlBZWmNkeFQwNFdpMmRNNWF3TW5peEd2M1dNNS9MUkEyUEk1VTNjdm0zS3FrN21nWk9RVnFoYTJ2TmFBNmo4QXFqOHJtTkVsOXFFaWo5bHFQdFV0dHhrSEUyU2FXb0g3WVZ2aDZQMnJGWUU3TGVoZ0F2RWkwVXQxSzVVaGdNRmNIcE9ORmM4R1R5anp6T0dWSHozc1JJdFcydWljUStaZGhLOENZYkJPR2ZDSnFhR2dvbEQ2VExBWVN0Z2NBYXpieUlPMjQ2RHc5WnN1Y2ZJSmcwQ2dzemN4TXdLS2pNR0tqT3kyb1dvYkRCU0ZBM1pjcGR4bEpGUi9wbW9IT2tQRlN6cGN0cW96eDBDVkhZMTRQNXZiQzBheGJlT1FGdlBJUEpzcUY5QitkalVNb21ka2JtMXdSNTQwOUNjVHAyVUpQQ1kyYWR4SnZhT0o2RStCdTB2MEx3VVoySStWRWxPZlJ6K2hTNGphVFZHQVA2WlN1b0taTVRBa2Q4SXE0VXV3UDRpNWpUbXEweHBFQ04zM1hsdEZuZFFuWmFqUlFXcUw2K3R4dTc4WEdrMXJSaGRyYUE0UFowaVhjbVZaeG9STzN6RXprejZNRUpLaHNWSUJ2cWNHVXNXajNKd3ZoT2YySkpUTytYeUNtT0t6SXFzdGhadFB5Y2cwUmNjbUlVQ0pLT1Vxa0o5bUE3S3pRV1RNTkxTdldRMXhmc3NuT2plVjFSWEszdVlSS0ZqM21LanMxME5qU00rbWZEN0FuNEQ3L2tvTVdaWDRHeEtRY0w1SjNUMlM4cG9NNk96M3VrNEJsck4wT0RpQ0ZySnRITmxvS1pwd2V5ZHA4OWVOWWZUdi9xelYzZ2YzM2xCc3ZXV2VVdnYzdHlUbXJhKzkrS0dEc2ttRE03aXlLSTNuemo5NldCTFdiMWpIY2xPYSszckUyZXVhWFN5c3FWbXVEMWQ3SzdEN2JGdHljeVc1cEJ5dzh1NzVFN2J6ejRrYkRHZDZSclllRW14OC9TQnpuQlVzcktFNk4vYmRsZHdsdlhPeDEreGJwcC95cnFodTUvTUxiNWc2UlBCNGtBSCtUd3IxaVI2azVuQmhmWEdmSXJSMTh5WlZJUE03Y1pVcW5LN2tjT2JZaG9WN3BPNHVVK21WK1pTamVSbExON3NNSGFGTWFSS3N6YmxLbU9xY0wvSVpnMWdFT1RMSGo0YXI4c01VakxFVFRKRWxWSytvd3ZwNUFTNVUvSlVtWFZtSHpQUWFxcXMzWEdHWFBISHpkUWRmLzdWNkVzbnJMQkVucWR6cHNDbThqUFZnTVB6VHpCcEtncStRY2lZTkJVeUs5YmpZNU9tUW5UU1ZNMmtTVk1KYzlKVXlSZEFiSUNsWGVJZHdTS2RONlY1cTRySG56aUZOcVYzeXFsVEFUUWdVMU5QbmhLZjFHZU43cWJUcC81L1daZm1DeHkxcXBLWDB2MzRrN1M4Y2NKTlBVMHJUYTIvSjZkZUdmOG50UFdPV2x1ZXpnWkw0aHpMNDY0Tmh3bEhqTFZGekxYVmphMHRRdGNXbmJTMmVuTnRJNzVBTUd3K0hvSjMxQmpMRzRIbGhTcVJ3cW5XWjlwMlU1T3VVREhrYk1kZEpMWGJ6R1dDVHFUckJMdkNvR0VkODVuL0NSV3g2emlleCtId0lHVXJaVE00YWFJcWxNT0Y0K09SRzQydkdSVFdYUEhjR0I3cUpLT2l4aFl3SnFYVm1KUFM2azQ0S1EzdEJYUHhlSGdNNzJZZHNQVFBnSmt3NWVyQkVxQnJKOTh4Y21SSHZnVE83dytrbFpOemxvU1oyTVY4Z3B6bEt0d3FNOGdTYWFVKzY5Qm1IRGVGOHZKeStQV0Y4V3VPVFc0WnkxbEtKOHBaWGs2VzZQOHdpdU54Zk5WRDR6bkw3OEN2YTZUYzVKd2xtWkN6bEQ0dVo5bFY0WTkxWkFsYzJjZ1htSEJ6UjU2RzYzOWUvT0hST1V0eXZKeWw5UCtVczF4SnNtdkprblZrR2dDQWNldk41aktObkNYT04zbFRTc091YTJZdU5pYmFZYXF5NUdJTlJWUG1HME11WnhyYnFDc3hPbXo4anNpWUxNSkc2b0Q1Y0E2YzRWam1yVGJhTDZ6V0tTVkx5STViTE9EUlpDOWFySHlqTVpuWENSOVp2ZmlScTVLMFFMNEx0dU9EUVZOSnI5bGZyUGdxTXdlTllVb3BVTnVyMUlzMnpYTThNT1BCV2QrWVJ0YmZjOXVNNjl0MmZ1WGN4LzlBRm5QMkd0OXdxaU5GVnJBTnR6N2IvZG1oUlRjdkhpYldyODI5ZWVpNnZZZTFyYytlK3Rhai9ralNlelliaU5XbDZveTRNSjFSSmY0YkUyTGFtWjNIbVZJRmE5YnF3R09xazlVNGVrd1o5SmdLeHhsYzFZRmQxOGhrTmZFTTZrMGNZalVpMWpXbHFWNFZqVWxXV2wwYVhtdU9POUhxT0hWclV3KzYwaitjeWdrNjN2Z3I0YWtwODV4MEhoYnNIeWZOR0M0d0oySUZLeE94NkpNL2FpZE9iYW8yQTJZeGMyQlRpWE1wU05CcVJYUGJERjNJeThWakoyTlJIVGpsZEt3SWJ1emFLU2RraWR2MVdSK05qSS9KK2orQVYrTmNrNkF0OGJKU25BSmVxdHVtbnVhVnB4TGp5MU5Dek85QkdUSVZ6RG1BMmNmRW1TVW16S0VLekxYalkvSDlVdVhKTUJUbUpJYUVVWHR4TGpjbWtkV3dVdkxZdk1VVEFsNVJXbFBDM2xzUlN0enhvRGRpRGNmQ0w3NEY4RGZBYnZtRUNYOXJCZjRjUitkSkJtR25CR1hWaHpzbFByNVRHdkVScERKdGlwWE1iZEpvTE1rWHh5Vmx6V2xxSTN3d0hLVjdKUmcxaXhtUFlxRGpoUXltV21keHFxMnhZK28xdjN4c05PQ1pDWlBaZUhQOVB6UjVMb0gxSGNkd0hYYnoxZVkxdDRpUFpwdzQ2RXpPQVJkaXkxK2owZkpuc0tSYWF6eldMVkVaZmVZeVpzdFZVMndrcHB3dFI3WHhoTlZTbFR5MjRpako4dWI2N2pBMDhpU3lvcHMrVGxUeWJjTlA1MEMvL1lsOW1yL2YxRU50REIyZUxCNnNqS1d4WkxGdzFkUkMyUHNzR2NNR2JMbXg1eWdiQlV6NEk3S1A2MUVjM2tGcTJkbnZ2S00vZ2Nmc3JmamJmSTRZeCswV3cwd0FyTHlmbW5QaUFIVTA0V25hZC9qVVg5U0JIbEN5V1dyY2VmZVAyTHlZNXd3YVU5NUhiQllIdkl0S2xPbndPY0QxNDNsT2p4ZHptMTRQNWprbEN4NWJKRFBQNlpWSFJDOU5aMTcxbDFrMG5lbVJSNndlQytZNUZYeDVxZSthdnl5aUg4QlhmZmpWRXZ5ZWtPZUVMOU04cDlXSGVVN1JxdmpHOHB6UklBZ1dOei9CVkFaRlJoT2RPS3dTZE52a3lZRExYbnY3dERsekZ5NTgvaDlmR3A0eGE4SGMwODQ5YWtKZ2NOU24vL2NXL1YwZzMvZDkvL0xwMlNkMkdMUTdweklya000bUF6bUllZlZWeDUxT0Zqak9kTEpneFNKeWUvd29UZXdLbUlHcXplZ01PTUcwTWhUaVIwMHNpNlAwUG1wc21mZ3F6ZnY5MzhDb3VUMFRJTlI4T0dybVJEQ2k0RDRLUnRKQkpmWlJVQW8yTXo5cHdKbWp0U2VuSFJmTzZ1UEFHUnJIcGRmQXBSYW9LcDRjckthc1BncmN3WXFRUGhaZ013bkpHVENEVEZLb04zSCtjYURHZlJRd0tpdUNPZHEvWmk3Qmw0TlZqTmRWbUV2U3BJQTVqckVhZnRDSDREekc3QnU3OFVpRkU3R0dtWGM4YWkwSm1tazhkaUVUY29yR2ZEV3dRN0VDSXNQUWg0QWNNMmF0S290aWMyek1HZzdoOUUwMWJLMGVxRC9Wd0RWU1o1cjVVODFkdTNDOFpuV1RmZ3QzdlRuanZES0RNOEJQSEc4ZUVZd1puTWRPT0E5Tm5IQWVHcHZCR1RCbmNJcVI4Um1jeXRFek9JUGpVemhkRnY4bXNvUk9zYVF6TFJ1cTdUWmZnTThJZHF2ZFloZHR2RTIveFhJWmpqaC85dnpENzFSR2N2YTVSQnpLK2Z4S1RyQ0tUc2t0dUFqeWlZRmJDOFZ0RGJQZXdLNWFuY2VTTUxVcWR3eWV3MW5WdHg4N1pCdnBoQXZhWUY4RGE4SnlxNkFQL1RLSGpGeGVwU0FWYXN6bTJlUE92dXMwdVdJcWtvU040U3BUVXVUSDR3ekM0cXduNForZ2VMeWdmVmViOVRGdUFjZUJHdy9zdFFtNGxMTGRwVmdxVHhreVRFQ2ZsWTdSUkVuaXR1TEVxcEk3aUc2MjI0bVBhblBqUUNCTERpMURzd09XeTArb3Y0OFJ1WWNvUnFWVWJNSEZMMTdFM1ZFcHp6MjhiZlFmNHc5SE9vUHRPYWYwaFczVFB6VExkRmxSZjEvZ2FRa0t6b3I1dGJCYTZBQi92eFZzcDd1TmlKNGF5bXNwRG0yRFVvcE9tMDhGVEw4ZlBiODBVQ2FYSzJlY1VkNW8yYU54RHNPYXdnZTZ4NDFuNWVJbzBrek9IRktyWm8zbnZ0dHpob1ZGTXdUNDdIT1hvb2xoK3N5V2trVTJTaXRUVWVNaDJuemFIQjFvYXF3SkFZQktJQldVbHpqbWlIVlMzU1VZOFFCUVlaL2RlUFo5Kzc2RzhRQ09MUHI5STllZmY4bHRYL2kxb2NqbXM2REpmbVBHUmQ1K2QvSGlkekUyOEVjakRQclltNnRXdmZrMDZyTXQ3STVObXg1N3pOQnBuRkZiWUhtTjFoWjRtSE1tVnhlZzMrM080OVRRU2h1TlVXb3c0ckpZTGVteGhwcHN4ZFFhcjBCUTNXaVNnaTFHUzhnLzVrRWluTW13azBvUVhxZWNla3dKd3JnTUk4eTVZRjBhejZ0T01zWUQybm1Sc2FPam5odWYwc255NWhNdVRMbC9ia1hRQ3p2RzY5SUpjNmx3RXhjUnZ3Vnl2WWRSNVN6V3pLdFdZeVM3TVlBdVpEeGF6WGcrYlExZTJTdlRRWE9haUt0enVvcGp6MFkreGw2K2RFcW44WjVqblVQQzhPUTE4Z1Q3T0hBeGcyWWVUeDRocjFXZXBmRy8rSXkxMHM4U2xma3hZdy90WU94SHozckJ2MllGNDYvcDMzSUYrcmZCWS81MndoOXdiZlFQQ0hPNVFNZ2VxWm1SY2FZdlZsYVUzU0plbmM0ZGQ5Tm4weVY0MmhLUE9TSWNuKzF5R005bW05Ym1TZlh6K1dES1JTVGdodllyV01FVmExdmN2aXhlbkVhdTFuOHNYTGZnblBsTDhyRXZFV2R6WFA5eGpiRzJuWEMvNStCK2J0Uml3c1Q3MFVZUTdIR0crOUhtQ2h1R3VGak9iVHB3Z1k3T3BCTDNSVUYwSm5kMkx1T3VKbzI4ZVV2aGFkTFFScHBxUG1IY0VlOVQvUDhLdTViWU5xb29PbTgrL3BERWlSczdQenVPUC9tMHNiRTk0OWl4MHlRNEJEZFJRUzFKaVZSVk9Hb3JVSkpHb0s0YUlRR3BSQVRxaXJJSUxVR0M4aEdGSWhxUGExWjhXa1JDSkJhSURVZ3N1NkRza01pdWlBeThlOThiWnh3bFFvcGpqYTFFYzg5OTc4NTc5OTE3am5HWExBaHpGSWVnVUpJU1Z2WUg2VmVUL284Qk1oaVNJam1TblBob3pqaU56N2RsaFVnNXhDUW96REJVU20wcDJKZ0UyT1R5YTVndnJzSURBYWFMUkNzQmR2T1FMSFkxMHB1dnMyTXJXcGNiR3ZRQ2g4cStOajh6cGhhNWJuWmx3NHZMMUtZUXdCak9KVVFLSTNtRmZ6Q2RtWllBMXRlZlduaHlXZ05ZajRRcHJCZk15OE5KQnJJb0xOSDcxL2o5UHllZ3hqaXNjR0RMNG1GM3JtQjNYUmk3NnlveTd6SkxRRjhkalpNVjM2NFoySGJWeEZ1STNaajVidllFTVVSQ2haTHViTWRwMURKS2RwM1RZL1hVVWlpbmtzdmtpT2txRWtQWDRYV0l1YTYrUDd6cnU4K1lKN2xWYkwweGJOd1RTM1JIQ2Z1dkFuZ1RPR0dZUTRGQnhuU3R3K0xha29nYVRsQk16M2tlZGJzSVFZM3RQOERsSU5VMkRHN2ZJZXJraC9QR2FmSXArcC9HRm5KU2VsNmVvdkUxRGp5WHdQTlBnd2gvNDEwNGxVY3dzdkEzN0ZIYkpaTUd5dFZ3WEh3cGYyRmxZbkpsTVo5ZlhMbjYydUpqNGsvRmEwVk5vNytlWFMycWFuRVY2dVRvYy90ck1yS2I0OFFPSU5tUlNuR09EMTF4YWhwK1dpWDlxTGV1c2prcEczU0dPb2cxeDVuaVVab1Z1aFUyOFllTUdOK2JMN1QxcEpBWEc1RTNJbUxxZWxjVXArQmkrdVB3SHhXci9uZ05FNWFWQTZ2MmYrM1ZDSGNkb0JGdWNsTllXU2xZbkxELys3djBsUzJCN1BqbE1jQWtRNWZzbVRGWUNXU0c2RXJBWjU3MCtiQmwwT2R4UmlzQ0dmTTFSRXY5S1dBMkFZS2ttRlpSWlB6c2NBb29yRHFSQTVDVUpvSG1VcmNkbzB1SWZzWUNHSGxVMCs3UWxaSUwyalVxTVl5d3BUNnNwOG9TNEVTRVZ2NFdwTHZBRTk1K2tiWGR4dHgzNm4yWk1jalNaT2xUcFRWbjZwUUFTZUtvckFXa1ZpL3YzM01wWGsrblNhUG9EZGhBUURia1pZWFhZbC9hWGloTUtoMGpzMi8vOE03WjBYWmlQRkNhQTduZVlDclVXbWNuVzF0Ykc2TG9iR2dMcWwzWFNJdDNxUGplL011M3o4VVVVZHhZM3JUUHJsNDllM1RvL0p0clJaczlrcDhaampaM3FMM2pQZDFPMmJhNXZLR0V1OGY3TkorSG5MQTV6cjMvd1F1RnFldGZMam5ZM0xvcDNsWStWLzZrbzg4alhLcXFUdUZ4cWU2c2g1SEhpTXRzRkhLSHk2MXBGRDJ2U1ZvQi9HWDdhdTBoZndXZGZoNDJHVDNZcnd2QkVpWWpkRk0wZXFEMHJwNmpGVUpLQWVKTytRaXdUa2dSeVgyVC9QWHhMWEpyZTM1eCs4YVZ1U3ZLTTJ0ck8yZkVUM2JPU0huaktObjg1NTRZM2ZrRlhnSWVhaXJ0eVAzYVYzTzZ3ZG1HMlVSbGJ6emtxM1JPd0ordzh4RTZ2T1FUdGkzTVcxMWlOUmcwM3JQOVlRc2pYdS9RZ0M4bmlCT1FMaUNCL3ZTUXhOcEVPckU1eVE5WlNhM2NpUlIzblFDQnY1ckVhb01GcVlZNUxDUkFxOE1jRnBDZWR4RnplWmxPRFFEMXIxWGJ4aFR1SlV6aFJtem9IVm1ZTUJWdXhJdkd1bkhmV0JjdmtpazVlMTlwVnA1WWVIRXlia3JkL1AySG5BVzFHM0lLU1lCUWwwY3VvSTJtaFUzY3dyYXFoWjRFcXdEdHNoclZxcFg5V1BUZzc2QXVyclVQbnRKTlBHL01MZE9iM0p5Q3hVUE04d3lUYjk2MFVBYk5wRDM2UFdKVDlOalMwNDkvUWZ6bmpmVzNCcXNTUGxYREd1V0hwNVJ2bGFxTUQvT2I3V2RxMHlCZEE5NFF5aG5NdUtwY0ZVUnZpYWJRTWoyUm9sdFB1bi92U2NHK1J3L21OQkJMcm1SNU5CMU9sREpvYlpxNU1JTXNIaGtCV1R5Z2FvTkNvS3YwdTM2dHBDS2pYU25MU3VpR05DUzFTMmVZVHpVd3RLU0NZRFJRMlhVRHRTUVFkTmg4dVlNOGZLRFBEL1E3NmRnN0VONmdBK0ZIK25wQThkcmVkekFjTkRnc0E4VFVickw5UnZITUNPOXl2ZEZJc29wbWpLTVoxNnhvWWlKM01GRktJNElEREVHNnFhVUlwZ0hCQVZhNlJSRk0wdStpV2ptcHduZkpPUDB1aVdka2VvVFhIZzZrR1l3cXdLaDNKMUY1VzZCTFRnNGg1RmZDL3dPa1FpRUxXMGRXYUY4TXg0bm9qaDkvZGVZNitjNVliNTF2T0o2SDBXWjhVenZpOXFEWDgzQld1U3ViNHcvSDRIK1R0MG1HQUFCNDJtTmdaR0JnWUdKZzRGem1HaGZQYi9PVlFaNkRBUVF1ZDZ6cGd0SC9sLzNkeno2TjA1dUJrWUVEcEphQkFRQkQ5Z3liZU5wallHUmc0TXovS3dFa3ZmOHYrMS9DUG8wQktJSUNYZ0lBaWxzR2dnQjQybTJUVFVpVVVSU0czKytlTTk5b1NsaU5SWVJHMEtJd0k0b1dsdjNNb0NPV2FEa1RDcUtUVHFFMFVKaEdEWmkyR01wRWdwQmFtR2lMTEJSdEU0RzVLQXFFaUlvZ3JDQ0pWclhvWnhrWTR2VGVZUVpNL09EaG5Idk8vZTdQZWM4MVAxR0c5T2NNQWlZWEVmTUgyN1FiVVkyajBUdVBKaDFId0RtRnpXWUtRK1NzM0VTVitZdWdNNHV3TXdrMXF4Q1ZIalJvTzhMbUhvcTBDS1VhUklXR2NGQWJFTkY2MU1sK0ZPaGh4cy9odUhFUmRSWnhRcHB4eEs1RDJ5RnZzZE45aHBBMklsczdFZFBiQ0dzL1l0Sk82am4rd1BGanhFeUFQQUwwTXVOQnhEeFBtYnRGWmhDV1JkclhuTmRDVzRCaUdjQnEvY3A3K0pEcm1VSys3aVdTVE1vM0hKTWMzdVVDeXN3blZNa0wrT1VBWEhPRi9qdnNrKytJeUYxVTA5YklCS3JOTmVabnNGNStvY21zd1VsVG12d2hzNGhhMy9NY1RUWXViMUx6SS9JZXRlWVZ4MUg0ekJEeTVUZnYzb1VjbmNjbUdjUVdhY05hS1VaSnFuNlR1R3F0S3ZvenRlYytkYmFPV29oTFdvRTl6aE8wTUg5YVJ0RHBoaENTUHR4aHJvYm43Wld0dUdGanptUnlqblA3cU1GMTZoTzBPZE9OZGxuQUJwUEZjMVlpWVhham5HdWZ0Lys2SXloM2gxSHViVVd2RHFPUG1tU3ZoRnVKSFZZSGlhT1Z4TkswbVVEeWZrcUhRSExHK3BxQUo2UEJjbmdXZjhxM09pd2xoem9zb0ZuSDJEdTI1aXZnR2NDaGxBNFQvMk44eVRIalF4ZnRTekl1YzZ4eFJvTmxzQjZ1ZkdUZHJBNUxzVHJNY1c5YWR4M0NuaUgybmoxVE4rK1lRRnhIZ2V5ajdMTzBsWTNVcDVadnBEL05kdktaanlaQnl6ZVF3ZVJCMmV2S2VuZVJEc1pLMkY4OTVDSzFMcFV2aUx1RjdILythODZneHRRVHJxdDU4R1pONDRHSCsraEQxbXdVZnU4dVVnTC9QMjhsMFRjQWVOcGpZR0RRZ2NJVWhtV01rNWdrbUg0d1QySGV3bUxEY29UbENhc0theHByQytzSzFsdHNabXhwYkpmWU05ZzNjUGh3UE9FVTR0ekNGY0JWeDNXTTZ4MjNGTGNEOXlxZUJwNUR2Q2E4YzNpZjhDbndoZkZkNE9mZ1YrT1A0Ty9qM3lKZ0lKQW5zRWVRVDdCSzhJcFFqRkNmMEJOaEtlRUs0VXNpUENKV0loa2k4MFRPaUh3UzVSUFZFMTBuSmlaV0lIWkdYRSs4UWNKRFlwckVFVWsyU1J2SktNbERVZ0pTY1ZLN3BHV2tBNlRQeUtqSlpNbE1rUGttcXlXYklOc25aeVlYSkM4am53V0VNK1MvS0NRcFBGQzBVVXhSWWxBeVVtWlE3bFBlb0h4TCtZZktOcFVicWlxcUphcjMxSXJVSnFsZFUvdWg3cWRlcHY1S2cwZGprV2FZVm9yV0tXMHg3UlR0WFRvbU9vdDBOWFRyOUF6MGF2U082WXZwbCtqUDB6K2wvOHZBeG1DVm9ZcGhnK0VkSXdlakU4WjJ4bEVtSENZWkpxZE1qVXczbVA0d0N6STdZeDVtL3NpaXhGTEo4b2hWbTNXQ0RZTk5qczB0V3ovYmM3WS83RlRzUXV5bTJZdll6N0QvNE9EbHNNcFJ5M0dHNHptbkVxZGp6bExPSmM2M1hCUmNPbHhldVhxNDNuT3pjVXR5VzRZRGJuRTc1SGJCN1owN203dWRlNUg3QlBjUEhoRWVFenlPZWJJQm9ZNW5rR2VRRjV0WGhsZUgxeS92RkI4ZW4yVUFjd2lVdmdBQUFBQUJBQUFBNlFCZUFBVUFBQUFBQUFJQUFRQUNBQllBQUFFQUFXNEFBQUFBZU5yRmtydHVFMEVVaHYvZERaQ0VLRUlJV1ZHcVZZb0lDaHQ3RlVmQjBCQ2tJQ0drRktCUTUySWNLNHQzNDNWc1FrR0JxS2dvS0hrT25vSGJDeUJSVWZJQTFId3plMlNNaUJFZEdzMmMvOHk1emo5SDBoWDlVS1JnWms3U2tGM2lRQXRvSlE0MXF4ZUdJMjNxbGVFWlZmVFo4RG05MVRmRDUxVUpuaHUrb0ozZ2plRlpMUVhmRGM5cEtRd056MnNZTGh1K3FOWHd0ZUVGOER2RGkxb0x2eHErckVwMHlmQjc4S3JoRDZwSHR3eC8xR0tVR3Y2aytlaFppYjlFV281ZTZvNHk1VHBWWDExMWRLaUJZbDNWdnE0aEU5WFZZRlhaQ2ZvZWZqRmN0UEh1RWRkRDI5VUIrNGtLMWRCdUsyWEZFOWtLcjdXUkxzckZIdUM1alQ0aUxrWGJKSk9UazNsL1pXMFJQK2tkai8xYmYzUjR0dCtPejF2UVVkbHhRdjA2SzlGTnRBSHJNVEVueUl5T3UvaVVIQXp4cWVtRzkyOW9neHB0cmFuSnJwSzFTODRCZkRpZXF2N05HeDcxT1p0RU9uelhPaXkxcDV3bEduR3V3TS9LYngxWHh4MmYvWTZZbW9WbjNIWGQ5eHkxNFdnWGZNUmR4anYrOWp2VExOUHUvODlrOUpBanoyeE9ubzUvWjQ3L0tiWjlibXI4MU5FL2VoMzYzODJabE91c0FvdXJudnZhTlQ4UktUTGp0b045VzF1NlA0WDdSOVRiZzkvTXBxUGhaK2doRlU3UTduSDIvTzI2UDV0VWRBeTFtSlZrek5hNi82OXkxbEkvYlgyYnlhMXgzZ2M2eHVwbXl6R1QvZ1RHeGEvZkFBQjQybTNRUjB4VWNSREg4ZS9Bc2d0TDd4M3N2ZXg3dTB1eDd3TFAzbnNYaFMyS2dJdXJZamRpTDlHWWVOUFlMbXJzTlJyMW9NYmVZb2w2OEd5UEIvV3FDKy92emJsODhwdGtKcE1oaXJiNkF6NytWNTlBb2lTYWFDekVZTVZHTEhIWWlTZUJSSkpJSm9WVTBrZ25nMHl5eUNhSFhQTElwNEJDaWlpbUhlM3BRRWM2MFprdWRLVWIzZWxCVDNyUm16NzB4WUdHamhNWGJrb29wWXh5K3RHZkFReGtFSU1aZ2djdkZWUlNoY0ZRaGpHY0VZeGtGS01adzFqR01aNEpUR1FTazVuQ1ZLWXhuUm5NWkJhem1jTmM1bEV0Rm83U3dpWnVzSitQYkdZM096akFjWTVKRE50NXowYjJpVlZzN0dJcnQva2dzUnprQkwvNHlXK09jSW9IM09NMDgxbkFIbXA0UkMzM2VjZ3pIdk9FcDVFZitYakpjMTV3Qmo4LzJNc2JYdkdhQUYvNHhqWVdFbVFSaTZtam5rTTBzSVJHUWpRUlppbkxXTTVuVnJDU1psYXhodFZjNVREcldNdDZOdkNWNzF6akxPZTR6bHZlU1p6WUpWNFNKRkdTSkZsU0pGWFNKRjB5SkZPeU9NOEZMbk9GTzF6a0VuZlp3a25KNWlhM0pFZHkyU2w1a2k4RlVpaEZWbjlkYzJOQXM0WHJndzZIbzlMVTQxQ3E3TldWVG1WNXEzcGtRS2twZGFWVDZWSzZsU1hLVW1XWjh0OCtqNm1tOW1xYTNSZjBoME8xTmRWTkFiT2xHNlp1dzFJVkRqVzBCYmRSMGFyaE5lK0lxQ3VkU3RkZmxyMmNNWGphMjhINHYzVURZeStEOXdhT2dJaU5qSXg5a1J2ZDJMUWpGRGNJUkhwdkVBa0NNaG9pWlRld2FjZEVNR3hnVm5EZHdLenRzb0ZWd1hVVDgxVW1iVENIQmNoaHpZVnkyRUF5T2hBTzR3WjJxSG9PQmRkZERPejEveG1ZdERjeXU1VUJSVGlCNmpoMFlkeklEU0xhQUhRa0tKUUFBQUZYWXZ3S0FBQT0nO1xuXG5leHBvcnQgZGVmYXVsdCBPc3dhbGQ3MDA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29uZmlnL2ZvbnRzL09zd2FsZDcwMC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBOb2RlIGZyb20gJy4uL3JldmkvZ3JhcGhpY3MvTm9kZS5qcyc7XG5pbXBvcnQgSW5wdXRNYW5hZ2VyIGZyb20gJy4uL3JldmkvcGx1Z2lucy9pbnB1dC9JbnB1dE1hbmFnZXIuanMnO1xuaW1wb3J0IElucHV0RXZlbnRzIGZyb20gJy4uL3JldmkvcGx1Z2lucy9pbnB1dC9FdmVudHMuanMnO1xuaW1wb3J0IEVhc2luZyBmcm9tICcuLi9yZXZpL3BsdWdpbnMvZWFzaW5nL0Vhc2luZy5qcyc7XG5pbXBvcnQgRWFzaW5nVHlwZXMgZnJvbSAnLi4vcmV2aS9wbHVnaW5zL2Vhc2luZy9FYXNpbmdUeXBlcy5qcyc7XG5pbXBvcnQgRWFzaW5nRXZlbnRzIGZyb20gJy4uL3JldmkvcGx1Z2lucy9lYXNpbmcvRXZlbnRzLmpzJztcbmltcG9ydCBDYW52YXMgZnJvbSAnLi4vcmV2aS9ncmFwaGljcy9DYW52YXMuanMnO1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICcuLi9yZXZpL3BsdWdpbnMvU2NoZWR1bGVyLmpzJztcbmltcG9ydCBab29tQ29udHJvbCBmcm9tICcuL1pvb21Db250cm9sLmpzJztcbmltcG9ydCBHZW9tZXRyeUV2ZW50cyBmcm9tICcuLi9yZXZpL2dlb21ldHJ5L0V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vRXZlbnRzLmpzJztcblxuLyoqXG4gKiBDbGFzcyB0byBtYW5hZ2UgdGhlIGFyZWEgd2hlcmUgb2JqZWN0cyBhcmUgZGlzcGxheWVkLiBJbXBsZW1lbnRzIHBhbiBhbmQgem9vbS5cbiAqXG4gKiBAY2xhc3MgVmlld3BvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgTm9kZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIFRoZSBsYXlvdXQgY29uZmlndXJhdGlvbiBvZiB0aGlzIFBlcnNvbmFzIGluc3RhbmNlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIGNvbmZpZykge1xuICAgICAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5tQ29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm1EcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1VcGRhdGVTY2FsZSA9IG51bGw7XG4gICAgICAgIHRoaXMubVRyYWNraW5nTW92ZVRocmVzaG9sZCA9IE1hdGgucG93KHRoaXMubUNvbmZpZy52aWV3cG9ydERyYWdUaHJlc2hvbGQsIDIpO1xuICAgICAgICB0aGlzLm1ab29tU2Nyb2xsTXVsdGlwbGllciA9IHRoaXMubUNvbmZpZy52aWV3cG9ydFpvb21TY3JvbGxNdWx0aXBsaWVyO1xuICAgICAgICB0aGlzLm1EZWxheWVkVXBkYXRlU2NhbGUgPSB0aGlzLm1Db25maWcudmlld3BvcnREZWxheWVkUmVkcmF3O1xuICAgICAgICB0aGlzLm1EZWxheWVkVXBkYXRlU2NhbGVUaW1lID0gdGhpcy5tQ29uZmlnLnZpZXdwb3J0RGVsYXllZFJlZHJhd1RpbWU7XG4gICAgICAgIHRoaXMubVNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIHRoaXMubUNvbnRlbnQgPSBuZXcgTm9kZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5tWm9vbUNvbnRyb2xzID0gbmV3IFpvb21Db250cm9sKHRoaXMubUNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5tQ29udGVudC5hbmNob3Iuc2V0KDAsIDApO1xuXG4gICAgICAgIHN1cGVyLmFkZENoaWxkQXQodGhpcy5tQ29udGVudCwgMCk7XG4gICAgICAgIHN1cGVyLmFkZENoaWxkQXQodGhpcy5tWm9vbUNvbnRyb2xzLCAxKTtcblxuICAgICAgICB0aGlzLmFuY2hvci5zZXQoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBvYmplY3QuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGlzIG9iamVjdCByZWFjaGVzIHplcm8uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLm1Db250ZW50LnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tWm9vbUNvbnRyb2xzLnJlbGVhc2UoKTtcblxuICAgICAgICB3aGlsZSAodGhpcy5tQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdXBlci5yZW1vdmVDaGlsZEF0KHRoaXMubUNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubUNvbmZpZztcbiAgICAgICAgZGVsZXRlIHRoaXMubURyYWdnaW5nO1xuICAgICAgICBkZWxldGUgdGhpcy5tVXBkYXRlU2NhbGU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1UcmFja2luZ01vdmVUaHJlc2hvbGQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1ab29tU2Nyb2xsTXVsdGlwbGllcjtcbiAgICAgICAgZGVsZXRlIHRoaXMubVNjaGVkdWxlcjtcbiAgICAgICAgZGVsZXRlIHRoaXMubUNvbnRlbnQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1ab29tQ29udHJvbHM7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSB0aW1lIHRoZSBvYmplY3QgaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIHNjZW5lIGdyYXBoLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBvbkVudGVyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHJldmlDb250ZXh0IC0gQSB1bmlxdWUgc3ltYm9sIHRoYXQgaWRlbnRpZmllcyB0aGUgcmVuZGVyaW5nIGNvbnRleHQgb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgb25FbnRlcihyZXZpQ29udGV4dCkge1xuICAgICAgICBjb25zdCBpbnB1dE1hbmFnZXIgPSBJbnB1dE1hbmFnZXIuaW5zdGFuY2VGb3JDb250ZXh0KHJldmlDb250ZXh0KTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9uKElucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfQkVHQU4sIGlucHV0TWFuYWdlci5zYWZlQmluZCh0aGlzLl9oYW5kbGVQb2ludGVyQmVnYW4sIHRoaXMpKTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9uKElucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfTU9WRUQsIGlucHV0TWFuYWdlci5zYWZlQmluZCh0aGlzLl9oYW5kbGVQb2ludGVyTW92ZWQsIHRoaXMpKTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9uKFtJbnB1dEV2ZW50cy5JTlBVVF9QT0lOVEVSX0VOREVELCBJbnB1dEV2ZW50cy5JTlBVVF9QT0lOVEVSX0NBTkNFTExFRF0sIGlucHV0TWFuYWdlci5zYWZlQmluZCh0aGlzLl9oYW5kbGVQb2ludGVyRW5kZWQsIHRoaXMpKTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9uKElucHV0RXZlbnRzLklOUFVUX01PVVNFX1NDUk9MTF9VUCwgaW5wdXRNYW5hZ2VyLnNhZmVCaW5kKHRoaXMuX2hhbmRsZVNjcm9sbFVwLCB0aGlzKSk7XG4gICAgICAgIGlucHV0TWFuYWdlci5vbihJbnB1dEV2ZW50cy5JTlBVVF9NT1VTRV9TQ1JPTExfRE9XTiwgaW5wdXRNYW5hZ2VyLnNhZmVCaW5kKHRoaXMuX2hhbmRsZVNjcm9sbERvd24sIHRoaXMpKTtcblxuICAgICAgICB0aGlzLm1TY2hlZHVsZXIgPSBTY2hlZHVsZXIuaW5zdGFuY2VGb3JDb250ZXh0KHJldmlDb250ZXh0KTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25ab29tQ29udHJvbHModGhpcy5waXhlbFNpemUud2lkdGgsIHRoaXMucGl4ZWxTaXplLmhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5waXhlbFNpemUub24oR2VvbWV0cnlFdmVudHMuR0VPTUVUUllfVkFMVUVfQ0hBTkdFRCwgdGhpcy5waXhlbFNpemUuc2FmZUJpbmQodGhpcy5faGFuZGxlUGl4ZWxTaXplQ2hhbmdlZCwgdGhpcykpO1xuICAgICAgICB0aGlzLm1ab29tQ29udHJvbHMub24oRXZlbnRzLkxBWU9VVF9aT09NX0lOX0NMSUNLRUQsIHRoaXMubVpvb21Db250cm9scy5zYWZlQmluZCh0aGlzLnpvb21JbiwgdGhpcywgdHJ1ZSkpO1xuICAgICAgICB0aGlzLm1ab29tQ29udHJvbHMub24oRXZlbnRzLkxBWU9VVF9aT09NX09VVF9DTElDS0VELCB0aGlzLm1ab29tQ29udHJvbHMuc2FmZUJpbmQodGhpcy56b29tT3V0LCB0aGlzLCB0cnVlKSk7XG4gICAgICAgIHRoaXMubVpvb21Db250cm9scy5vbihFdmVudHMuTEFZT1VUX0FVVE9fWk9PTV9DTElDS0VELCB0aGlzLm1ab29tQ29udHJvbHMuc2FmZUJpbmQodGhpcy5hdXRvWm9vbSwgdGhpcywgdGhpcy5tQ29udGVudCwgdHJ1ZSkpO1xuXG4gICAgICAgIHN1cGVyLm9uRW50ZXIocmV2aUNvbnRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0cyBpcyByZW1vdmVkIGZyb20gdGhlIHNjZW5lIGdyYXBoLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBvbkV4aXRcbiAgICAgKi9cbiAgICBvbkV4aXQoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0TWFuYWdlciA9IElucHV0TWFuYWdlci5pbnN0YW5jZUZvckNvbnRleHQodGhpcy5yZXZpQ29udGV4dCk7XG4gICAgICAgIGlucHV0TWFuYWdlci5vZmYoSW5wdXRFdmVudHMuSU5QVVRfUE9JTlRFUl9CRUdBTiwgdGhpcy5faGFuZGxlUG9pbnRlckJlZ2FuLCB0aGlzKTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9mZihJbnB1dEV2ZW50cy5JTlBVVF9QT0lOVEVSX01PVkVELCB0aGlzLl9oYW5kbGVQb2ludGVyTW92ZWQsIHRoaXMpO1xuICAgICAgICBpbnB1dE1hbmFnZXIub2ZmKFtJbnB1dEV2ZW50cy5JTlBVVF9QT0lOVEVSX0VOREVELCBJbnB1dEV2ZW50cy5JTlBVVF9QT0lOVEVSX0NBTkNFTExFRF0sIHRoaXMuX2hhbmRsZVBvaW50ZXJFbmRlZCwgdGhpcyk7XG4gICAgICAgIGlucHV0TWFuYWdlci5vZmYoSW5wdXRFdmVudHMuSU5QVVRfTU9VU0VfU0NST0xMX1VQLCB0aGlzLl9oYW5kbGVTY3JvbGxVcCwgdGhpcyk7XG4gICAgICAgIGlucHV0TWFuYWdlci5vZmYoSW5wdXRFdmVudHMuSU5QVVRfTU9VU0VfU0NST0xMX0RPV04sIHRoaXMuX2hhbmRsZVNjcm9sbERvd24sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMubVNjaGVkdWxlciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5waXhlbFNpemUub2ZmKEdlb21ldHJ5RXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMuX2hhbmRsZVBpeGVsU2l6ZUNoYW5nZWQsIHRoaXMpO1xuXG4gICAgICAgIHN1cGVyLm9uRXhpdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjaGlsZCBub2RlIHRvIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRDaGlsZFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY2hpbGQgLSBUaGUgbm9kZSB0byBhZGQgYXMgYSBjaGlsZC5cbiAgICAgKiBAcmV0dXJucyB7Tm9kZX1cbiAgICAgKi9cbiAgICBhZGRDaGlsZChjaGlsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tQ29udGVudC5hZGRDaGlsZChjaGlsZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBub2RlIGFzIGEgY2hpbGRyZW4gdG8gdGhpcyBub2RlIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZENoaWxkQXRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkIC0gVGhlIG5vZGUgdG8gYWRkIGFzIGEgY2hpbGQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGF0IHdoaWNoIHRoZSBub2RlIHdpbGwgYmUgYWRkZWQuXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICovXG4gICAgYWRkQ2hpbGRBdChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubUNvbnRlbnQuYWRkQ2hpbGRBdChjaGlsZCwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBub2RlIGZyb20gdGhpcyBub2RlJ3MgY2hpbGRyZW4gbGlzdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkIC0gVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1Db250ZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjaGlsZCBub2RlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNoaWxkQXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhpcyBjaGlsZCB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge05vZGV9XG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tQ29udGVudC5yZW1vdmVDaGlsZEF0KGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgY2hpbGRyZW4gb2YgZnJvbSB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUNoaWxkcmVuXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRyZW4oKSB7XG4gICAgICAgIHRoaXMubUNvbnRlbnQucmVtb3ZlQ2hpbGRyZW4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBab29tcyB0aGlzIHZpZXdwb3J0IGJ5IHRoZSBkZXNpcmVkIGFtb3VudCB1c2luZyB0aGUgb3JpZ2luIGFzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZSB6b29tLlxuICAgICAqIE5PVEU6IFRoaXMgbWV0aG9kIHJlc3BlY3RzIHRoZSBtYXhpbXVtIGFuZCBtaW5pbXVtIHpvb20gbGV2ZWxzIGNvbmZpZ3VyZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB6b29tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBzY2FsZSB0byBhcHBseSB3aGVyZSAxIG1lYW5zIDEwMCVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgZnJvbSB3aGljaCB0aGUgem9vbSB3aWxsIGJlIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIGZyb20gd2hpY2ggdGhlIHpvb20gd2lsbCBiZSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGFuaW1hdGVkIC0gU2hvdWxkIHRoZSB6b29tIGJlIGFuaW1hdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdXNlQWN0dWFsQW1vdW50IC0gSWYgdHJ1ZSwgd2lsbCB6b29tIHRvIGFtb3VudCwgb3RoZXJ3aXNlIHpvb21zIHRvIGN1cnJlbnQgc2NhbGUgcGx1cyBhbW91bnRcbiAgICAgKiBAcmV0dXJuIHtFYXNpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB6b29tKGFtb3VudCwgeCwgeSwgYW5pbWF0ZWQgPSBmYWxzZSwgdXNlQWN0dWFsQW1vdW50ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbG9jYWxQb2ludCA9IHRoaXMubUNvbnRlbnQuZ2xvYmFsVG9Mb2NhbENvb3Jkcyh4LCB5KTtcbiAgICAgICAgY29uc3Qgb2xkU2NhbGUgPSB0aGlzLm1Db250ZW50LnNjYWxlO1xuXG4gICAgICAgIGxldCBuZXdTY2FsZTtcbiAgICAgICAgaWYgKHVzZUFjdHVhbEFtb3VudCkge1xuICAgICAgICAgICAgbmV3U2NhbGUgPSBhbW91bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdTY2FsZSA9IG9sZFNjYWxlICsgYW1vdW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLyogY2hlY2sgYWdhaW5zdCBtaW4vbWF4IHNjYWxlICovXG4gICAgICAgIG5ld1NjYWxlID0gTWF0aC5tYXgoTWF0aC5taW4obmV3U2NhbGUsIHRoaXMubUNvbmZpZy52aWV3cG9ydE1heFpvb21NdWx0aXBsaWVyKSwgdGhpcy5tQ29uZmlnLnZpZXdwb3J0TWluWm9vbU11bHRpcGxpZXIpO1xuXG4gICAgICAgIGlmIChuZXdTY2FsZSA9PT0gb2xkU2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2NhbGVEaWZmZXJlbmNlID0gbmV3U2NhbGUgLSBvbGRTY2FsZTtcblxuICAgICAgICBpZiAoYW5pbWF0ZWQgJiYgdGhpcy5yZXZpQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRYID0gdGhpcy5tQ29udGVudC5wb3NpdGlvbi54O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRZID0gdGhpcy5tQ29udGVudC5wb3NpdGlvbi55O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRTY2FsZSA9IG9sZFNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgem9vbUVhc2luZyA9IEVhc2luZy5pbnN0YW5jZSh0aGlzLnJldmlDb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogRWFzaW5nVHlwZXMuUXVhZHJhdGljLkVhc2VJbk91dCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxvY2FsUG9pbnQucmV0YWluKCk7XG4gICAgICAgICAgICB6b29tRWFzaW5nLm9uKEVhc2luZ0V2ZW50cy5FQVNJTkdfVVBEQVRFLCAoc2VuZGVyLCBwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubUNvbnRlbnQucG9zaXRpb24uc2V0KHN0YXJ0WCAtIGxvY2FsUG9pbnQueCAqIHNjYWxlRGlmZmVyZW5jZSAqIHByb2dyZXNzLCBzdGFydFkgLSBsb2NhbFBvaW50LnkgKiBzY2FsZURpZmZlcmVuY2UgKiBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tQ29udGVudC5zY2FsZSA9IHN0YXJ0U2NhbGUgKyBzY2FsZURpZmZlcmVuY2UgKiBwcm9ncmVzcztcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tRGVsYXllZFVwZGF0ZVNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubVBhcmVudC51cGRhdGVHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB6b29tRWFzaW5nLm9uKEVhc2luZ0V2ZW50cy5FQVNJTkdfRU5ELCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9jYWxQb2ludC5yZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubURlbGF5ZWRVcGRhdGVTY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1QYXJlbnQudXBkYXRlR2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgem9vbUVhc2luZy5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuXG4gICAgICAgICAgICByZXR1cm4gem9vbUVhc2luZztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubUNvbnRlbnQucG9zaXRpb24uc2V0KHRoaXMubUNvbnRlbnQucG9zaXRpb24ueCAtIGxvY2FsUG9pbnQueCAqIHNjYWxlRGlmZmVyZW5jZSwgdGhpcy5tQ29udGVudC5wb3NpdGlvbi55IC0gbG9jYWxQb2ludC55ICogc2NhbGVEaWZmZXJlbmNlKTtcbiAgICAgICAgdGhpcy5tQ29udGVudC5zY2FsZSA9IG5ld1NjYWxlO1xuXG4gICAgICAgIGlmICh0aGlzLm1EZWxheWVkVXBkYXRlU2NhbGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1TY2hlZHVsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tVXBkYXRlU2NhbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tU2NoZWR1bGVyLmNhbmNlbCh0aGlzLm1VcGRhdGVTY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubVVwZGF0ZVNjYWxlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1VcGRhdGVTY2FsZSA9IHRoaXMubVNjaGVkdWxlci5zY2hlZHVsZVRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1QYXJlbnQudXBkYXRlR2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tVXBkYXRlU2NhbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMubURlbGF5ZWRVcGRhdGVTY2FsZVRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tVXBkYXRlU2NhbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubVVwZGF0ZVNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tVXBkYXRlU2NhbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubVVwZGF0ZVNjYWxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubVBhcmVudC51cGRhdGVHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1VcGRhdGVTY2FsZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5tRGVsYXllZFVwZGF0ZVNjYWxlVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1QYXJlbnQudXBkYXRlR2xvYmFsU2NhbGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSB6b29tcyB0aGlzIHZpZXdwb3J0IHRvIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYXV0b1pvb21cbiAgICAgKiBAcGFyYW0ge05vZGV9IG9iamVjdCAtIEFuIG9iamVjdCwgY2hpbGRlZCB0byB0aGlzIHZpZXdwb3J0LCB0byBmaW4gaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZWQgLSBTaG91bGQgdGhlIHpvb21pbmcgYmUgYW5pbWF0ZWQuXG4gICAgICovXG4gICAgYXV0b1pvb20ob2JqZWN0LCBhbmltYXRlZCkge1xuICAgICAgICBpZiAodGhpcy5yZXZpQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gQ2FudmFzLmdldENhbnZhc0ZvckNvbnRleHQodGhpcy5yZXZpQ29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBiYiA9IG9iamVjdC5ib3VuZGluZ0JveDtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbFRMID0gb2JqZWN0LmxvY2FsVG9HbG9iYWxQb2ludChiYi52MSk7XG4gICAgICAgICAgICBjb25zdCBnbG9iYWxCUiA9IG9iamVjdC5sb2NhbFRvR2xvYmFsUG9pbnQoYmIudjQpO1xuICAgICAgICAgICAgY29uc3QgZ2xvYmFsV2lkdGggPSBnbG9iYWxCUi54IC0gZ2xvYmFsVEwueDtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbEhlaWdodCA9IGdsb2JhbEJSLnkgLSBnbG9iYWxUTC55O1xuICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IGdsb2JhbFRMLnggKyBnbG9iYWxXaWR0aCAqIDAuNTtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlclkgPSBnbG9iYWxUTC55ICsgZ2xvYmFsSGVpZ2h0ICogMC41O1xuICAgICAgICAgICAgY29uc3QgY2VudGVyUG9zaXRpb24gPSB0aGlzLmdsb2JhbFRvTG9jYWxDb29yZHMoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IHRoaXMuZ2xvYmFsVG9Mb2NhbENvb3JkcyhjYW52YXMucGl4ZWxTaXplLndpZHRoICogMC41LCBjYW52YXMucGl4ZWxTaXplLmhlaWdodCAqIDAuNSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oY2FudmFzLnBpeGVsU2l6ZS53aWR0aCAvIGdsb2JhbFdpZHRoLCBjYW52YXMucGl4ZWxTaXplLmhlaWdodCAvIGdsb2JhbEhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBlYXNpbmcgPSB0aGlzLnpvb20oc2NhbGUgKiB0aGlzLm1Db250ZW50LnNjYWxlLCBjZW50ZXJYLCBjZW50ZXJZLCBhbmltYXRlZCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZWFzaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRYID0gdGhpcy5tQ29udGVudC5waXhlbFBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRZID0gdGhpcy5tQ29udGVudC5waXhlbFBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0WCA9IHRhcmdldFBvc2l0aW9uLnggKyAoc3RhcnRYIC0gY2VudGVyUG9zaXRpb24ueCkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRZID0gdGFyZ2V0UG9zaXRpb24ueSArIChzdGFydFkgLSBjZW50ZXJQb3NpdGlvbi55KSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZVggPSB0YXJnZXRYIC0gc3RhcnRYO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZVkgPSB0YXJnZXRZIC0gc3RhcnRZO1xuXG4gICAgICAgICAgICAgICAgZWFzaW5nLm9uKEVhc2luZ0V2ZW50cy5FQVNJTkdfVVBEQVRFLCAoc2VuZGVyLCBwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1Db250ZW50LnBvc2l0aW9uLnNldChzdGFydFggKyBjaGFuZ2VYICogcHJvZ3Jlc3MsIHN0YXJ0WSArIGNoYW5nZVkgKiBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubUNvbnRlbnQucG9zaXRpb24uc2V0KHRoaXMubUNvbnRlbnQucG9zaXRpb24ueCArIHRhcmdldFBvc2l0aW9uLnggLSBjZW50ZXJQb3NpdGlvbi54LCB0aGlzLm1Db250ZW50LnBvc2l0aW9uLnkgKyB0YXJnZXRQb3NpdGlvbi55IC0gY2VudGVyUG9zaXRpb24ueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBab29tcyBpbiBieSB0aGUgY29uZmlndXJlZCB6b29tIHN0ZXAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHpvb21JblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZWQgLSBTaG91bGQgdGhlIHpvb21pbmcgYmUgYW5pbWF0ZWQuXG4gICAgICovXG4gICAgem9vbUluKGFuaW1hdGVkKSB7XG4gICAgICAgIHRoaXMuem9vbSh0aGlzLm1Db250ZW50LnNjYWxlICogMC4zLCB0aGlzLnBpeGVsU2l6ZS53aWR0aCAqIDAuNSwgdGhpcy5waXhlbFNpemUuaGVpZ2h0ICogMC41LCBhbmltYXRlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWm9vbXMgb3V0IGJ5IHRoZSBjb25maWd1cmVkIHpvb20gc3RlcC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgem9vbU91dFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZWQgLSBTaG91bGQgdGhlIHpvb21pbmcgYmUgYW5pbWF0ZWQuXG4gICAgICovXG4gICAgem9vbU91dChhbmltYXRlZCkge1xuICAgICAgICB0aGlzLnpvb20oLXRoaXMubUNvbnRlbnQuc2NhbGUgKiAwLjMsIHRoaXMucGl4ZWxTaXplLndpZHRoICogMC41LCB0aGlzLnBpeGVsU2l6ZS5oZWlnaHQgKiAwLjUsIGFuaW1hdGVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBwb2ludGVyIGJlZ2FuIGlucHV0IGV2ZW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaGFuZGxlUG9pbnRlckJlZ2FuXG4gICAgICogQHBhcmFtIHsqfSBzZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgLSBPYmplY3QgY29udGFpbmluZyB0aGUgZXZlbnQncyBkZXNjcmlwdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVQb2ludGVyQmVnYW4oc2VuZGVyLCBldmVudCkge1xuICAgICAgICB0aGlzLm1EcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1UcmFja2luZ1BvaW50ZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5tVHJhY2tpbmdQb2ludCkge1xuICAgICAgICAgICAgdGhpcy5tVHJhY2tpbmdQb2ludC5yZWxlYXNlKCk7XG4gICAgICAgICAgICB0aGlzLm1UcmFja2luZ1BvaW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnRlciA9IGV2ZW50LmlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnQgPSBldmVudC5wb2ludC5yZXRhaW4oKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIHBvaW50ZXIgbW92ZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyTW92ZWRcbiAgICAgKiBAcGFyYW0geyp9IHNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBldmVudCAtIE9iamVjdCBjb250YWluaW5nIHRoZSBldmVudCdzIGRlc2NyaXB0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZVBvaW50ZXJNb3ZlZChzZW5kZXIsIGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5pZGVudGlmaWVyID09PSB0aGlzLm1UcmFja2luZ1BvaW50ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gZXZlbnQucG9pbnQ7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZVNRID0gTWF0aC5wb3cocG9pbnQueCAtIHRoaXMubVRyYWNraW5nUG9pbnQueCwgMikgKyBNYXRoLnBvdyhwb2ludC55IC0gdGhpcy5tVHJhY2tpbmdQb2ludC55LCAyKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tRHJhZ2dpbmcgJiYgZGlzdGFuY2VTUSA+IHRoaXMubVRyYWNraW5nTW92ZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubURyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubURyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeE9mZiA9IHBvaW50LnggLSB0aGlzLm1UcmFja2luZ1BvaW50Lng7XG4gICAgICAgICAgICAgICAgY29uc3QgeU9mZiA9IHBvaW50LnkgLSB0aGlzLm1UcmFja2luZ1BvaW50Lnk7XG4gICAgICAgICAgICAgICAgdGhpcy5tQ29udGVudC5wb3NpdGlvbi5zZXQodGhpcy5tQ29udGVudC5wb3NpdGlvbi54ICsgeE9mZiwgdGhpcy5tQ29udGVudC5wb3NpdGlvbi55ICsgeU9mZik7XG4gICAgICAgICAgICAgICAgdGhpcy5tVHJhY2tpbmdQb2ludC5yZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tVHJhY2tpbmdQb2ludCA9IHBvaW50LnJldGFpbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgcG9pbnRlciBtb3ZlZCBpbnB1dCBldmVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJFbmRlZFxuICAgICAqIEBwYXJhbSB7Kn0gc2VuZGVyIC0gVGhlIHNlbmRlciBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2ZW50IC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGV2ZW50J3MgZGVzY3JpcHRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlUG9pbnRlckVuZGVkKHNlbmRlciwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmlkZW50aWZpZXIgPT09IHRoaXMubVRyYWNraW5nUG9pbnRlcikge1xuICAgICAgICAgICAgdGhpcy5tRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnRlciA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5tVHJhY2tpbmdQb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnQucmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgc2Nyb2xsIHVwIGlucHV0IGV2ZW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaGFuZGxlU2Nyb2xsVXBcbiAgICAgKiBAcGFyYW0geyp9IHNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSAtIFRoZSBhbW91bnQgc2Nyb2xsZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVTY3JvbGxVcChzZW5kZXIsIGRlbHRhLCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IHpvb21BbW91bnQgPSBkZWx0YSAqIHRoaXMubVpvb21TY3JvbGxNdWx0aXBsaWVyO1xuICAgICAgICB0aGlzLnpvb20odGhpcy5tQ29udGVudC5zY2FsZSAtIHpvb21BbW91bnQsIHgsIHksIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBzY3JvbGwgZG93biBpbnB1dCBldmVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2hhbmRsZVNjcm9sbERvd25cbiAgICAgKiBAcGFyYW0geyp9IHNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSAtIFRoZSBhbW91bnQgc2Nyb2xsZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVTY3JvbGxEb3duKHNlbmRlciwgZGVsdGEsIHgsIHkpIHtcbiAgICAgICAgY29uc3Qgem9vbUFtb3VudCA9IGRlbHRhICogdGhpcy5tWm9vbVNjcm9sbE11bHRpcGxpZXI7XG4gICAgICAgIHRoaXMuem9vbSh0aGlzLm1Db250ZW50LnNjYWxlICsgem9vbUFtb3VudCwgeCwgeSwgZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSB6b29tIGNvbnRyb2xzIGF0IHRoZSBkZXNpcmVkIGNvbmZpZ3VyZWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9wb3NpdGlvblpvb21Db250cm9sc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyIHdoZXJlIHRoZSB6b29tIGNvbnRyb2xzIHdpbGwgYmUgcG9zaXRpb25lZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyIHdoZXJlIHRoZSB6b29tIGNvbnRyb2xzIHdpbGwgYmUgcG9zaXRpb25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wb3NpdGlvblpvb21Db250cm9scyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLm1Db25maWcuem9vbUNvbnRyb2xzUGFkZGluZztcbiAgICAgICAgc3dpdGNoICh0aGlzLm1Db25maWcuem9vbUNvbnRyb2xzUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgICAgICAgICB0aGlzLm1ab29tQ29udHJvbHMuYW5jaG9yLnNldCgwLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ab29tQ29udHJvbHMucG9zaXRpb24uc2V0KHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5tWm9vbUNvbnRyb2xzLmFuY2hvci5zZXQoMCwgJzEwMCUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ab29tQ29udHJvbHMucG9zaXRpb24uc2V0KHBhZGRpbmcsIGhlaWdodCAtIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICAgICAgICAgIHRoaXMubVpvb21Db250cm9scy5hbmNob3Iuc2V0KCcxMDAlJywgJzEwMCUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ab29tQ29udHJvbHMucG9zaXRpb24uc2V0KHdpZHRoIC0gcGFkZGluZywgaGVpZ2h0IC0gcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMubVpvb21Db250cm9scy5hbmNob3Iuc2V0KCcxMDAlJywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tWm9vbUNvbnRyb2xzLnBvc2l0aW9uLnNldCh3aWR0aCAtIHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBwaXhlbCBzaXplIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVQaXhlbFNpemVDaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTaXplfSBzZW5kZXIgLSBUaGUgb2JqZWN0IHRoYXQgZ2VuZXJhdGVkIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSB0aGUgbmV3IGhlaWdodC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVQaXhlbFNpemVDaGFuZ2VkKHNlbmRlciwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAoc2VuZGVyID09PSB0aGlzLnBpeGVsU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25ab29tQ29udHJvbHMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheW91dC9WaWV3cG9ydC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBOb2RlIGZyb20gJy4uL3JldmkvZ3JhcGhpY3MvTm9kZS5qcyc7XG5pbXBvcnQgTGFiZWwgZnJvbSAnLi4vcmV2aS90ZXh0L0xhYmVsLmpzJztcbmltcG9ydCBGb250QXdlc29tZSBmcm9tICcuLi9yZXZpL3RleHQvRm9udEF3ZXNvbWUuanMnO1xuaW1wb3J0IEZvbnRNYW5hZ2VyIGZyb20gJy4uL3JldmkvdGV4dC9Gb250TWFuYWdlci5qcyc7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4uL3JldmkvZ3JhcGhpY3MvcHJpbWl0aXZlcy9SZWN0YW5nbGUuanMnO1xuaW1wb3J0IExpbmUgZnJvbSAnLi4vcmV2aS9ncmFwaGljcy9wcmltaXRpdmVzL0xpbmUuanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL3JldmkvZ2VvbWV0cnkvUG9pbnQuanMnO1xuaW1wb3J0IElucHV0TWFuYWdlciBmcm9tICcuLi9yZXZpL3BsdWdpbnMvaW5wdXQvSW5wdXRNYW5hZ2VyLmpzJztcbmltcG9ydCBJbnB1dEV2ZW50cyBmcm9tICcuLi9yZXZpL3BsdWdpbnMvaW5wdXQvRXZlbnRzLmpzJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9FdmVudHMuanMnO1xuXG5jb25zdCBGT05UX0FXRVNPTUVfS0VZID0gJ0ZvbnRBd2Vzb21lJztcblxuZXhwb3J0IGNsYXNzIFpvb21Db250cm9sIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZy56b29tQ29udHJvbHNCdXR0b25TaXplLCBjb25maWcuem9vbUNvbnRyb2xzQnV0dG9uU2l6ZSAqIDMgKyBjb25maWcuem9vbUNvbnRyb2xzQm9yZGVyU2l6ZSAqIDIpO1xuXG4gICAgICAgIHRoaXMubUNvbmZpZyA9IGNvbmZpZztcblxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gUmVjdGFuZ2xlLmluc3RhbmNlKHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCwge1xuICAgICAgICAgICAgZmlsbEVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHRoaXMubUNvbmZpZy56b29tQ29udHJvbHNCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBzdHJva2U6IHRoaXMubUNvbmZpZy56b29tQ29udHJvbHNCb3JkZXJTaXplLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHRoaXMubUNvbmZpZy56b29tQ29udHJvbHNCb3JkZXJDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVR5cGU6IFJlY3RhbmdsZS5TVFJPS0VfT1VURVIsXG4gICAgICAgIH0pO1xuICAgICAgICBiYWNrZ3JvdW5kLmFuY2hvci5zZXQoMCwgMCk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoYmFja2dyb3VuZCk7XG5cbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yT2Zmc2V0ID0gTWF0aC5taW4oMiwgdGhpcy5tQ29uZmlnLnpvb21Db250cm9sc0JvcmRlclNpemUpO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3IwMSA9IExpbmUuaW5zdGFuY2UoUG9pbnQuaW5zdGFuY2UoLXNlcGFyYXRvck9mZnNldCwgMCksIFBvaW50Lmluc3RhbmNlKHRoaXMuc2l6ZS53aWR0aCArIHNlcGFyYXRvck9mZnNldCwgMCksIHtcbiAgICAgICAgICAgIHN0cm9rZTogdGhpcy5tQ29uZmlnLnpvb21Db250cm9sc0JvcmRlclNpemUsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogdGhpcy5tQ29uZmlnLnpvb21Db250cm9sc0JvcmRlckNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlVHlwZTogUmVjdGFuZ2xlLlNUUk9LRV9NSURETEUsXG4gICAgICAgIH0pO1xuICAgICAgICBzZXBhcmF0b3IwMS5wb3NpdGlvbi5zZXQoMCwgdGhpcy5zaXplLmhlaWdodCAvIDMpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHNlcGFyYXRvcjAxKTtcblxuICAgICAgICBjb25zdCBzZXBhcmF0b3IwMiA9IExpbmUuaW5zdGFuY2UoUG9pbnQuaW5zdGFuY2UoLXNlcGFyYXRvck9mZnNldCwgMCksIFBvaW50Lmluc3RhbmNlKHRoaXMuc2l6ZS53aWR0aCArIHNlcGFyYXRvck9mZnNldCwgMCksIHtcbiAgICAgICAgICAgIHN0cm9rZTogdGhpcy5tQ29uZmlnLnpvb21Db250cm9sc0JvcmRlclNpemUsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogdGhpcy5tQ29uZmlnLnpvb21Db250cm9sc0JvcmRlckNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlVHlwZTogUmVjdGFuZ2xlLlNUUk9LRV9NSURETEUsXG4gICAgICAgIH0pO1xuICAgICAgICBzZXBhcmF0b3IwMi5wb3NpdGlvbi5zZXQoMCwgKHRoaXMuc2l6ZS5oZWlnaHQgLyAzKSAqIDIpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHNlcGFyYXRvcjAyKTtcblxuICAgICAgICBGb250TWFuYWdlci5zaGFyZWRJbnN0YW5jZSgpLmxvYWRGb250KEZvbnRBd2Vzb21lLCBGT05UX0FXRVNPTUVfS0VZKS50aGVuKHRoaXMuX2hhbmRsZUZvbnRBd2Vzb21lTG9hZGVkLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubUNvbmZpZztcblxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIG9iamVjdCBpcyBhZGRlZCB0byB0aGUgY3VycmVudGx5IHJ1bm5pbmcgc2NlbmUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG9uRW50ZXJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gcmV2aUNvbnRleHQgLSBBIHVuaXF1ZSBzeW1ib2wgdGhhdCBpZGVudGlmaWVzIHRoZSByZW5kZXJpbmcgY29udGV4dCBvZiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBvbkVudGVyKHJldmlDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGlucHV0TWFuYWdlciA9IElucHV0TWFuYWdlci5pbnN0YW5jZUZvckNvbnRleHQocmV2aUNvbnRleHQpO1xuICAgICAgICBpbnB1dE1hbmFnZXIub24oSW5wdXRFdmVudHMuSU5QVVRfUE9JTlRFUl9CRUdBTiwgaW5wdXRNYW5hZ2VyLnNhZmVCaW5kKHRoaXMuX2hhbmRsZVBvaW50ZXJCZWdhbiwgdGhpcykpO1xuICAgICAgICBpbnB1dE1hbmFnZXIub24oSW5wdXRFdmVudHMuSU5QVVRfUE9JTlRFUl9NT1ZFRCwgaW5wdXRNYW5hZ2VyLnNhZmVCaW5kKHRoaXMuX2hhbmRsZVBvaW50ZXJNb3ZlZCwgdGhpcykpO1xuICAgICAgICBpbnB1dE1hbmFnZXIub24oW0lucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfRU5ERUQsIElucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfQ0FOQ0VMTEVEXSwgaW5wdXRNYW5hZ2VyLnNhZmVCaW5kKHRoaXMuX2hhbmRsZVBvaW50ZXJFbmRlZCwgdGhpcykpO1xuICAgICAgICBzdXBlci5vbkVudGVyKHJldmlDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGlzIG9iamVjdHMgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgb25FeGl0XG4gICAgICovXG4gICAgb25FeGl0KCkge1xuICAgICAgICBjb25zdCBpbnB1dE1hbmFnZXIgPSBJbnB1dE1hbmFnZXIuaW5zdGFuY2VGb3JDb250ZXh0KHRoaXMucmV2aUNvbnRleHQpO1xuICAgICAgICBpbnB1dE1hbmFnZXIub2ZmKElucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfQkVHQU4sIHRoaXMuX2hhbmRsZVBvaW50ZXJCZWdhbiwgdGhpcyk7XG4gICAgICAgIGlucHV0TWFuYWdlci5vZmYoSW5wdXRFdmVudHMuSU5QVVRfUE9JTlRFUl9NT1ZFRCwgdGhpcy5faGFuZGxlUG9pbnRlck1vdmVkLCB0aGlzKTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9mZihbSW5wdXRFdmVudHMuSU5QVVRfUE9JTlRFUl9FTkRFRCwgSW5wdXRFdmVudHMuSU5QVVRfUE9JTlRFUl9DQU5DRUxMRURdLCB0aGlzLl9oYW5kbGVQb2ludGVyRW5kZWQsIHRoaXMpO1xuICAgICAgICBzdXBlci5vbkV4aXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBmb250IGF3ZXNvbWUgaXMgbG9hZGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaGFuZGxlRm9udEF3ZXNvbWVMb2FkZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVGb250QXdlc29tZUxvYWRlZCgpIHtcbiAgICAgICAgY29uc3QgYnV0dG9uU2l6ZSA9IHRoaXMubUNvbmZpZy56b29tQ29udHJvbHNCdXR0b25TaXplO1xuXG4gICAgICAgIGNvbnN0IHBsdXMgPSBMYWJlbC5pbnN0YW5jZShidXR0b25TaXplLCBidXR0b25TaXplLCAnXFx1ZjA2NycsIEZPTlRfQVdFU09NRV9LRVksIG51bGwsIHtcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgZm9udFNpemU6IHRoaXMubUNvbmZpZy56b29tQ29udHJvbHNGb250U2l6ZSxcbiAgICAgICAgICAgIGFsaWdubWVudDogTGFiZWwuVEVYVF9BTElHTk1FTlQuQ0VOVEVSLFxuICAgICAgICAgICAgdHJ1bmNhdGVNb2RlOiBMYWJlbC5URVhUX1RSVU5DQVRJTkdfTU9ERS5FTExJUFNFUyxcbiAgICAgICAgICAgIG11bHRpTGluZU1vZGU6IExhYmVsLlRFWFRfTVVMVElfTElORV9NT0RFLkFVVE9fTElORVMsXG4gICAgICAgICAgICByZW5kZXJpbmdCYWNrZW5kOiBMYWJlbC5URVhUX1JFTkRFUklOR19CQUNLRU5ELkNBTlZBUyxcbiAgICAgICAgICAgIGF1dG9TaXplOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcGx1cy5wb3NpdGlvbi5zZXQoYnV0dG9uU2l6ZSAqIDAuNSwgYnV0dG9uU2l6ZSAqIDAuNSk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQocGx1cyk7XG5cbiAgICAgICAgY29uc3QgaG9tZSA9IExhYmVsLmluc3RhbmNlKGJ1dHRvblNpemUsIGJ1dHRvblNpemUsICdcXHVmMDY2JywgRk9OVF9BV0VTT01FX0tFWSwgbnVsbCwge1xuICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICAgICAgICBmb250U2l6ZTogdGhpcy5tQ29uZmlnLnpvb21Db250cm9sc0ZvbnRTaXplLFxuICAgICAgICAgICAgYWxpZ25tZW50OiBMYWJlbC5URVhUX0FMSUdOTUVOVC5DRU5URVIsXG4gICAgICAgICAgICB0cnVuY2F0ZU1vZGU6IExhYmVsLlRFWFRfVFJVTkNBVElOR19NT0RFLkVMTElQU0VTLFxuICAgICAgICAgICAgbXVsdGlMaW5lTW9kZTogTGFiZWwuVEVYVF9NVUxUSV9MSU5FX01PREUuQVVUT19MSU5FUyxcbiAgICAgICAgICAgIHJlbmRlcmluZ0JhY2tlbmQ6IExhYmVsLlRFWFRfUkVOREVSSU5HX0JBQ0tFTkQuQ0FOVkFTLFxuICAgICAgICAgICAgYXV0b1NpemU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBob21lLnBvc2l0aW9uLnNldChidXR0b25TaXplICogMC41LCB0aGlzLnNpemUuaGVpZ2h0ICogMC41KTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChob21lKTtcblxuICAgICAgICBjb25zdCBtaW51cyA9IExhYmVsLmluc3RhbmNlKGJ1dHRvblNpemUsIGJ1dHRvblNpemUsICdcXHVmMDY4JywgRk9OVF9BV0VTT01FX0tFWSwgbnVsbCwge1xuICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICAgICAgICBmb250U2l6ZTogdGhpcy5tQ29uZmlnLnpvb21Db250cm9sc0ZvbnRTaXplLFxuICAgICAgICAgICAgYWxpZ25tZW50OiBMYWJlbC5URVhUX0FMSUdOTUVOVC5DRU5URVIsXG4gICAgICAgICAgICB0cnVuY2F0ZU1vZGU6IExhYmVsLlRFWFRfVFJVTkNBVElOR19NT0RFLkVMTElQU0VTLFxuICAgICAgICAgICAgbXVsdGlMaW5lTW9kZTogTGFiZWwuVEVYVF9NVUxUSV9MSU5FX01PREUuQVVUT19MSU5FUyxcbiAgICAgICAgICAgIHJlbmRlcmluZ0JhY2tlbmQ6IExhYmVsLlRFWFRfUkVOREVSSU5HX0JBQ0tFTkQuQ0FOVkFTLFxuICAgICAgICAgICAgYXV0b1NpemU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBtaW51cy5wb3NpdGlvbi5zZXQoYnV0dG9uU2l6ZSAqIDAuNSwgdGhpcy5zaXplLmhlaWdodCAtIGJ1dHRvblNpemUgKiAwLjUpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKG1pbnVzKTtcbiAgICB9XG5cbiAgICBfaGFuZGxlUG9pbnRlckJlZ2FuKHNlbmRlciwgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBldmVudC5wb2ludDtcbiAgICAgICAgY29uc3QgbG9jYWxQb2ludCA9IHRoaXMuZ2xvYmFsVG9Mb2NhbFBvaW50KHBvaW50KTtcblxuICAgICAgICB0aGlzLm1UcmFja2luZ1BvaW50ZXIgPSBudWxsO1xuICAgICAgICBpZiAobG9jYWxQb2ludC54ID49IDAgJiYgbG9jYWxQb2ludC54IDw9IHRoaXMucGl4ZWxTaXplLndpZHRoICYmIGxvY2FsUG9pbnQueSA+PSAwICYmIGxvY2FsUG9pbnQueSA8PSB0aGlzLnBpeGVsU2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnRlciA9IGV2ZW50LmlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaGFuZGxlUG9pbnRlck1vdmVkKHNlbmRlciwgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBldmVudC5wb2ludDtcbiAgICAgICAgY29uc3QgbG9jYWxQb2ludCA9IHRoaXMuZ2xvYmFsVG9Mb2NhbFBvaW50KHBvaW50KTtcbiAgICAgICAgaWYgKGV2ZW50LmlkZW50aWZpZXIgPT09IHRoaXMubVRyYWNraW5nUG9pbnRlcikge1xuICAgICAgICAgICAgaWYgKGxvY2FsUG9pbnQueCA8IDAgfHwgbG9jYWxQb2ludC54ID4gdGhpcy5waXhlbFNpemUud2lkdGggfHwgbG9jYWxQb2ludC55IDwgMCB8fCBsb2NhbFBvaW50LnkgPiB0aGlzLnBpeGVsU2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1UcmFja2luZ1BvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2hhbmRsZVBvaW50ZXJFbmRlZChzZW5kZXIsIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gZXZlbnQucG9pbnQ7XG4gICAgICAgIGNvbnN0IGxvY2FsUG9pbnQgPSB0aGlzLmdsb2JhbFRvTG9jYWxQb2ludChwb2ludCk7XG4gICAgICAgIGlmIChldmVudC5pZGVudGlmaWVyID09PSB0aGlzLm1UcmFja2luZ1BvaW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnRlciA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbFBvaW50LnggPj0gMCAmJiBsb2NhbFBvaW50LnggPD0gdGhpcy5waXhlbFNpemUud2lkdGggJiYgbG9jYWxQb2ludC55ID49IDAgJiYgbG9jYWxQb2ludC55IDw9IHRoaXMucGl4ZWxTaXplLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbFBvaW50LnkgPCB0aGlzLnBpeGVsU2l6ZS5oZWlnaHQgLyAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChFdmVudHMuTEFZT1VUX1pPT01fSU5fQ0xJQ0tFRCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbFBvaW50LnkgPCAodGhpcy5waXhlbFNpemUuaGVpZ2h0IC8gMykgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChFdmVudHMuTEFZT1VUX0FVVE9fWk9PTV9DTElDS0VELCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoRXZlbnRzLkxBWU9VVF9aT09NX09VVF9DTElDS0VELCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFpvb21Db250cm9sO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheW91dC9ab29tQ29udHJvbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBOb2RlIGZyb20gJy4uL3JldmkvZ3JhcGhpY3MvTm9kZS5qcyc7XG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4uL3JldmkvZ3JhcGhpY3MvcHJpbWl0aXZlcy9DaXJjbGUuanMnO1xuaW1wb3J0IEFzc2V0Q2FjaGUgZnJvbSAnLi4vcmV2aS9jb3JlL0Fzc2V0Q2FjaGUuanMnO1xuXG4vKipcbiAqIENsYXNzIHRvIGRyYXcgYSBQZXJzb25hJ3MgYXZhdGFyIChpbWFnZXMpLlxuICpcbiAqIEBjbGFzcyBBdmF0YXJcbiAqL1xuZXhwb3J0IGNsYXNzIEF2YXRhciBleHRlbmRzIE5vZGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoaXMgYXZhdGFyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118bnVsbH0gaW1hZ2VVUkxzIC0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgVVJMcyBvZiB0aGUgaW1hZ2VzIHRvIGRpc3BsYXkgaW4gdGhpcyBhdmF0YXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJhZGl1cywgaW1hZ2VVUkxzLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tUmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCAwKTtcbiAgICAgICAgdGhpcy5tQ29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm1JbWFnZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnNpemUuc2V0KHRoaXMubVJhZGl1cyAqIDIsIHRoaXMubVJhZGl1cyAqIDIpO1xuXG4gICAgICAgIHRoaXMubUJvcmRlciA9IG5ldyBDaXJjbGUodGhpcy5tUmFkaXVzLCB7XG4gICAgICAgICAgICBmaWxsRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBzdHJva2VUeXBlOiBDaXJjbGUuU1RST0tFX0lOTkVSLFxuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLm1Db25maWcuYXZhdGFyQm9yZGVyLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHRoaXMubUNvbmZpZy5hdmF0YXJCb3JkZXJDb2xvcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubUJvcmRlci5wb3NpdGlvbi5zZXQoJzUwJScsICc1MCUnKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLm1Cb3JkZXIpO1xuXG4gICAgICAgIGlmIChpbWFnZVVSTHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRJbWFnZXMoaW1hZ2VVUkxzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tQm9yZGVyLnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tSW1hZ2VzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubVJhZGl1cztcbiAgICAgICAgZGVsZXRlIHRoaXMubUNvbmZpZztcbiAgICAgICAgZGVsZXRlIHRoaXMubUltYWdlcztcbiAgICAgICAgZGVsZXRlIHRoaXMubUJvcmRlcjtcblxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGlzIGF2YXRhci5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVJhZGl1cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByYWRpdXMgb2YgdGhpcyBhdmF0YXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHJhZGl1cy5cbiAgICAgKi9cbiAgICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tUmFkaXVzKSB7XG4gICAgICAgICAgICB0aGlzLm1SYWRpdXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZS5zZXQodGhpcy5tUmFkaXVzICogMiwgdGhpcy5tUmFkaXVzICogMik7XG5cbiAgICAgICAgICAgIHRoaXMubUJvcmRlci5yYWRpdXMgPSB0aGlzLm1SYWRpdXM7XG4gICAgICAgICAgICB0aGlzLm1Cb3JkZXIucG9zaXRpb24uc2V0KHRoaXMuc2l6ZS53aWR0aCAqIDAuNSwgdGhpcy5zaXplLmhlaWdodCAqIDAuNSk7XG5cbiAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSB0aWNrLCBkcmF3aW5nIG9wZXJhdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZCBoZXJlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkcmF3XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IHZhckFyZ3MgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgbm9kZSdzIGNoaWxkcmVuIHdoZW4gZHJhd2luZy5cbiAgICAgKi9cbiAgICBkcmF3KGNvbnRleHQsIC4uLnZhckFyZ3MpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gdGhpcy5tSW1hZ2VzLmZpbHRlcihpbWFnZSA9PiBCb29sZWFuKGltYWdlKSk7XG4gICAgICAgIGlmIChpbWFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZVJhZGl1cyA9IE1hdGgubWF4KHRoaXMubVJhZGl1cyAtIHRoaXMubUNvbmZpZy5hdmF0YXJCb3JkZXIgKyBNYXRoLm1pbih0aGlzLm1Db25maWcuYXZhdGFyQm9yZGVyLCB0aGlzLm1Db25maWcucmFkaXVzT3ZlcmxhcCksIDApO1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5hcmModGhpcy5tUmFkaXVzLCB0aGlzLm1SYWRpdXMsIGltYWdlUmFkaXVzLCAwLCBDaXJjbGUuY2lyY2xlUmFkaWFucywgZmFsc2UpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuXG4gICAgICAgICAgICBjb25zdCBtYWluSW1hZ2VIZWlnaHQgPSBpbWFnZXMubGVuZ3RoID4gMSA/IHRoaXMuc2l6ZS5oZWlnaHQgKiB0aGlzLm1Db25maWcuYXZhdGFyU3ViSW1hZ2VQb3NpdGlvbiA6IHRoaXMuc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9kcmF3SW1hZ2UoaW1hZ2VzWzBdLCBjb250ZXh0LCAwLCAwLCB0aGlzLnNpemUud2lkdGgsIG1haW5JbWFnZUhlaWdodCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN1YkltYWdlWSA9IHRoaXMuc2l6ZS5oZWlnaHQgKiB0aGlzLm1Db25maWcuYXZhdGFyU3ViSW1hZ2VQb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHN1YkltYWdlV2lkdGggPSB0aGlzLnNpemUud2lkdGggLyAoaW1hZ2VzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgY29uc3Qgc3ViSW1hZ2VIZWlnaHQgPSB0aGlzLnNpemUuaGVpZ2h0ICogKDEuMCAtIHRoaXMubUNvbmZpZy5hdmF0YXJTdWJJbWFnZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0ltYWdlKGltYWdlc1tpXSwgY29udGV4dCwgc3ViSW1hZ2VXaWR0aCAqIChpIC0gMSksIHN1YkltYWdlWSwgc3ViSW1hZ2VXaWR0aCwgc3ViSW1hZ2VIZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kcmF3KGNvbnRleHQsIC4uLnZhckFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGltYWdlcyBjb250YWluZWQgaW4gdGhpcyBhdmF0YXIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUltYWdlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGltYWdlVVJMcyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIFVSTHMgb2YgdGhlIGltYWdlcyB0byByZW5kZXIuXG4gICAgICovXG4gICAgdXBkYXRlSW1hZ2VzKGltYWdlVVJMcykge1xuICAgICAgICBpZiAoaW1hZ2VVUkxzICYmIGltYWdlVVJMcy5sZW5ndGggIT09IHRoaXMubUltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubUltYWdlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKGltYWdlVVJMcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkSW1hZ2VzKGltYWdlVVJMcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaW1hZ2VVUkxzICYmIHRoaXMubUltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubUltYWdlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYW4gaW1hZ2UgaW4gdGhlIHNwZWNpZmllZCBjb250ZXh0LCB3aXRoaW4gdGhlIHNwZWNpZmllZCByZWN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZHJhd0ltYWdlXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2UgLSBUaGUgaW1hZ2UgdG8gZHJhdy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHdoZXJlIHRoZSBpbWFnZSB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLCB3aXRoaW4gdGhlIGNvbnRleHQsIHdoZXJlIHRoZSBpbWFnZSBzaG91bGQgYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUsIHdpdGhpbiB0aGUgY29udGV4dCwgd2hlcmUgdGhlIGltYWdlIHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHJlY3Qgd2hlcmUgdGhlIGltYWdlIG11c3QgYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3Qgd2hlcmUgdGhlIGltYWdlIG11c3QgYmUgZHJhd24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZHJhd0ltYWdlKGltYWdlLCBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oaW1hZ2Uud2lkdGggLyB3aWR0aCwgaW1hZ2UuaGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgICAgY29uc3Qgc2NhbGVkV2lkdGggPSB3aWR0aCAqIHNjYWxlO1xuICAgICAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBoZWlnaHQgKiBzY2FsZTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIChpbWFnZS53aWR0aCAtIHNjYWxlZFdpZHRoKSAqIDAuNSxcbiAgICAgICAgICAgIChpbWFnZS5oZWlnaHQgLSBzY2FsZWRIZWlnaHQpICogMC41LFxuICAgICAgICAgICAgc2NhbGVkV2lkdGgsXG4gICAgICAgICAgICBzY2FsZWRIZWlnaHQsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gYXJyYXkgb2YgaW1hZ2UgVVJMcyBhbmQgc2NoZWR1bGVzIGEgcmVkcmF3IGV2ZXJ5IHRpbWUgb25lIGZpbmlzaGVzIGxvYWRpbmcuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9sb2FkSW1hZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBpbWFnZVVSTHMgLSBBbiBhcnJheSBvcyB0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBVUkxzIG9mIHRoZSBpbWFnZXMgdG8gbG9hZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9sb2FkSW1hZ2VzKGltYWdlVVJMcykge1xuICAgICAgICBpbWFnZVVSTHMuZm9yRWFjaCgoaW1hZ2VVUkwsIGkpID0+IHtcbiAgICAgICAgICAgIEFzc2V0Q2FjaGUubG9hZEltYWdlKGltYWdlVVJMKS50aGVuKGltYWdlID0+IHtcbiAgICAgICAgICAgICAgICAvKiBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIG9iamVjdCBjb3VsZCBoYXZlIGJlZW4gZGVzdHJveWVkIGF0IHRoaXMgcG9pbnQgKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXRhaW5Db3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tSW1hZ2VzW2ldID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdmF0YXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcGVyc29uYS9BdmF0YXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTm9kZSBmcm9tICcuLi9yZXZpL2dyYXBoaWNzL05vZGUuanMnO1xuaW1wb3J0IEdhdWdlQmFyIGZyb20gJy4vR2F1Z2VCYXIuanMnO1xuaW1wb3J0IENpcmNsZSBmcm9tICcuLi9yZXZpL2dyYXBoaWNzL3ByaW1pdGl2ZXMvQ2lyY2xlLmpzJztcbmltcG9ydCBMaW5lIGZyb20gJy4uL3JldmkvZ3JhcGhpY3MvcHJpbWl0aXZlcy9MaW5lLmpzJztcbmltcG9ydCBQb2ludCBmcm9tICcuLi9yZXZpL2dlb21ldHJ5L1BvaW50LmpzJztcblxuLyoqXG4gKiBDbGFzcyB0byBkcmF3IHRoZSBjaXJjdWxhciBnYXVnZXMgb24gYSBQZXJzb25hLlxuICpcbiAqIEBjbGFzcyBHYXVnZVxuICovXG5leHBvcnQgY2xhc3MgR2F1Z2UgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgZ2F1Z2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJhZGl1cywgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubVJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgMCk7XG4gICAgICAgIHRoaXMubUNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5tQmFycyA9IFtdO1xuICAgICAgICB0aGlzLm1CYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5tTWFya2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tTWFya2VyU3BpbGwgPSB0aGlzLm1Db25maWcuZ2F1Z2VNYXJrZXJTcGlsbDtcbiAgICAgICAgdGhpcy5tQmFyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5tUmFkaXVzIC0gdGhpcy5tQ29uZmlnLmdhdWdlUGFkZGluZywgMCk7XG5cbiAgICAgICAgdGhpcy5zaXplLnNldCh0aGlzLm1SYWRpdXMgKiAyLCB0aGlzLm1SYWRpdXMgKiAyKTtcblxuICAgICAgICB0aGlzLm1CYWNrZ3JvdW5kID0gbmV3IENpcmNsZSh0aGlzLm1SYWRpdXMsIHtcbiAgICAgICAgICAgIGZpbGxFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0cm9rZVR5cGU6IENpcmNsZS5TVFJPS0VfSU5ORVIsXG4gICAgICAgICAgICBzdHJva2U6IGNvbmZpZy5nYXVnZVRoaWNrbmVzcyArIHRoaXMubUNvbmZpZy5yYWRpdXNPdmVybGFwLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGNvbmZpZy5nYXVnZUJhY2tncm91bmRDb2xvcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubUJhY2tncm91bmQucG9zaXRpb24uc2V0KCc1MCUnLCAnNTAlJyk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5tQmFja2dyb3VuZCk7XG5cbiAgICAgICAgaWYgKHRoaXMubUNvbmZpZy5nYXVnZU1hcmtlclRoaWNrbmVzcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubU1hcmtlciA9IG5ldyBMaW5lKFBvaW50Lmluc3RhbmNlKCc1MCUnLCAtdGhpcy5tTWFya2VyU3BpbGwpLCBQb2ludC5pbnN0YW5jZSgnNTAlJywgY29uZmlnLmdhdWdlVGhpY2tuZXNzICsgY29uZmlnLnJhZGl1c092ZXJsYXApLCB7XG4gICAgICAgICAgICAgICAgZmlsbEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0cm9rZVR5cGU6IExpbmUuU1RST0tFX01JRERMRSxcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogY29uZmlnLmdhdWdlTWFya2VyQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBjb25maWcuZ2F1Z2VNYXJrZXJUaGlja25lc3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5tTWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tQmFja2dyb3VuZC5yZWxlYXNlKCk7XG4gICAgICAgIHRoaXMubUJhcnMuZm9yRWFjaChiYXIgPT4gYmFyLnJlbGVhc2UoKSk7XG4gICAgICAgIHRoaXMubUJhcnMubGVuZ3RoID0gMDtcblxuICAgICAgICBpZiAodGhpcy5tTWFya2VyKSB7XG4gICAgICAgICAgICB0aGlzLm1NYXJrZXIucmVsZWFzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubVJhZGl1cztcbiAgICAgICAgZGVsZXRlIHRoaXMubUNvbmZpZztcbiAgICAgICAgZGVsZXRlIHRoaXMubUJhcnM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1CYWNrZ3JvdW5kO1xuICAgICAgICBkZWxldGUgdGhpcy5tTWFya2VyO1xuICAgICAgICBkZWxldGUgdGhpcy5tQmFyUmFkaXVzO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoaXMgY2lyY3VsYXIgZ2F1Z2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCByYWRpdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1SYWRpdXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmFkaXVzIG9mIHRoaXMgY2lyY3VsYXIgZ2F1Z2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHJhZGl1cy5cbiAgICAgKi9cbiAgICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tUmFkaXVzKSB7XG4gICAgICAgICAgICB0aGlzLm1SYWRpdXMgPSBNYXRoLm1heCh2YWx1ZSwgMCk7XG4gICAgICAgICAgICB0aGlzLm1CYXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm1SYWRpdXMgLSB0aGlzLm1Db25maWcuZ2F1Z2VQYWRkaW5nLCAwKTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZS5zZXQodGhpcy5tUmFkaXVzICogMiwgdGhpcy5tUmFkaXVzICogMik7XG5cbiAgICAgICAgICAgIHRoaXMubUJhY2tncm91bmQucmFkaXVzID0gdGhpcy5tUmFkaXVzO1xuXG4gICAgICAgICAgICB0aGlzLm1CYXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm1SYWRpdXMgLSB0aGlzLm1Db25maWcuZ2F1Z2VQYWRkaW5nLCAwKTtcbiAgICAgICAgICAgIHRoaXMubUJhcnMuZm9yRWFjaChiYXIgPT4geyBiYXIucmFkaXVzID0gdGhpcy5tQmFyUmFkaXVzOyB9KTtcblxuICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGV2ZXJ5IHRpY2ssIGJlZm9yZSB0aGlzIG9iamVjdCBpcyBkcmF3bi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIC0gVGhlIGRlbHRhIHRpbWUgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyQXJncyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW4gd2hlbiB1cGRhdGluZy5cbiAgICAgKi9cbiAgICB1cGRhdGUoZGVsdGEsIC4uLnZhckFyZ3MpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhLCAuLi52YXJBcmdzKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMubUJhcnMuZm9yRWFjaChiYXIgPT4ge1xuICAgICAgICAgICAgYmFyLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCArPSBiYXIucHJvZ3Jlc3M7XG4gICAgICAgICAgICBiYXIucG9zaXRpb24uc2V0KHRoaXMubUJhY2tncm91bmQuc2l6ZS53aWR0aCAqIDAuNSwgdGhpcy5tQmFja2dyb3VuZC5zaXplLmhlaWdodCAqIDAuNSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGFja2VkIGJhciB0byB0aGlzIGdhdWdlIHRoYSByZXByZXNlbnRzIHRoZSBzcGVjaWZpZWQgcHJvZ3Jlc3MuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZEJhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAtIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB0aGF0IHJlcHJlc2VudHMgdGhlIHByb2dyZXNzIG9mIHRoaXMgYmFyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciAtIFRoZSBjb2xvciBvZiB0aGlzIGJhci5cbiAgICAgKi9cbiAgICBhZGRCYXIocHJvZ3Jlc3MsIGNvbG9yKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLm1CYXJzLnJlZHVjZSgoYWNjLCBiYXIpID0+IGFjYyArIGJhci5wcm9ncmVzcywgMCk7XG4gICAgICAgIGNvbnN0IGJhciA9IG5ldyBHYXVnZUJhcih0aGlzLm1CYXJSYWRpdXMsIG9mZnNldCwgcHJvZ3Jlc3MsIGNvbG9yLCB0aGlzLm1Db25maWcpO1xuICAgICAgICBiYXIucG9zaXRpb24uc2V0KHRoaXMubUJhY2tncm91bmQuc2l6ZS53aWR0aCAqIDAuNSwgdGhpcy5tQmFja2dyb3VuZC5zaXplLmhlaWdodCAqIDAuNSk7XG4gICAgICAgIHRoaXMubUJhY2tncm91bmQuYWRkQ2hpbGQoYmFyKTtcbiAgICAgICAgdGhpcy5tQmFycy5wdXNoKGJhcik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHYXVnZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wZXJzb25hL0dhdWdlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IFNlbWlDaXJjbGUgZnJvbSAnLi4vcmV2aS9ncmFwaGljcy9wcmltaXRpdmVzL1NlbWlDaXJjbGUuanMnO1xuXG5jb25zdCBkb3VibGVQSSA9IE1hdGguUEkgKiAyO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgZHJhd3MgYSBiYXIgaW5zaWRlIGEgY2lyY3VsYXIgZ2F1Z2UuXG4gKlxuICogQGNsYXNzIEdhdWdlQmFyXG4gKi9cbmV4cG9ydCBjbGFzcyBHYXVnZUJhciBleHRlbmRzIFNlbWlDaXJjbGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBnYXVnZSB0aGlzIGJhciBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgdGhhdCByZXByZXNlbnRzIHdoZXJlIGluIHRoZSBnYXVnZSB0aGlzIGJhciB3aWxsIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAtIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB0aGF0IHJlcHJlc2VudHMgdGhlIHByb2dyZXNzIG9mIHRoaXMgYmFyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciAtIFRoZSBjb2xvciB0byB1c2Ugd2hlbiBkcmF3bnMgdGhlIGJhci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmFkaXVzLCBvZmZzZXQsIHByb2dyZXNzLCBjb2xvciwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHJhZFBhZGRpbmcgPSAoY29uZmlnLmdhdWdlQmFyUGFkZGluZyAvIHJhZGl1cykgKiAwLjU7XG4gICAgICAgIHN1cGVyKHJhZGl1cywgKG9mZnNldCAqIGRvdWJsZVBJKSArIHJhZFBhZGRpbmcsIE1hdGgubWF4KChwcm9ncmVzcyAqIGRvdWJsZVBJKSAtIChyYWRQYWRkaW5nICogMiksIDApLCB7XG4gICAgICAgICAgICBmaWxsRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBzdHJva2VUeXBlOiBTZW1pQ2lyY2xlLlNUUk9LRV9JTk5FUixcbiAgICAgICAgICAgIHN0cm9rZTogY29uZmlnLmdhdWdlVGhpY2tuZXNzIC0gKGNvbmZpZy5nYXVnZVBhZGRpbmcgKiAyKSxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGxpbmVDYXBUeXBlOiBjb25maWcuZ2F1Z2VCYXJDYXBzLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1Db25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMubVJhZFBhZGRpbmcgPSByYWRQYWRkaW5nO1xuICAgICAgICB0aGlzLm1PZmZzZXRQZXJjZW50YWdlID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm1Qcm9ncmVzc1BlcmNlbnRhZ2UgPSBwcm9ncmVzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoaXMgY2lyY3VsYXIgYmFyLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcmFkaXVzKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIucmFkaXVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJhZGl1cyBvZiB0aGlzIGNpcmN1bGFyIGJhci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgcmFkaXVzLlxuICAgICAqL1xuICAgIHNldCByYWRpdXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBzdXBlci5yYWRpdXMpIHtcbiAgICAgICAgICAgIHN1cGVyLnJhZGl1cyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5tUmFkUGFkZGluZyA9ICh0aGlzLm1Db25maWcuZ2F1Z2VCYXJQYWRkaW5nIC8gdmFsdWUpICogMC41O1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLnByb2dyZXNzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXIncyBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1PZmZzZXRQZXJjZW50YWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJhcidzIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgb2Zmc2V0LlxuICAgICAqL1xuICAgIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tT2Zmc2V0UGVyY2VudGFnZSA9IHZhbHVlO1xuICAgICAgICBzdXBlci5vZmZzZXQgPSAodGhpcy5tT2Zmc2V0UGVyY2VudGFnZSAqIGRvdWJsZVBJKSArIHRoaXMubVJhZFBhZGRpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXIncyBwcm9ncmVzcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHByb2dyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tUHJvZ3Jlc3NQZXJjZW50YWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyBiYXIncyBwcm9ncmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgc2V0IHByb2dyZXNzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubVByb2dyZXNzUGVyY2VudGFnZSA9IHZhbHVlO1xuICAgICAgICBzdXBlci5hbmdsZSA9IE1hdGgubWF4KCh0aGlzLm1Qcm9ncmVzc1BlcmNlbnRhZ2UgKiBkb3VibGVQSSkgLSAodGhpcy5tUmFkUGFkZGluZyAqIDIpLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhcidzIGNvbG9yLlxuICAgICAqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cm9rZUNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJhcidzIGNvbG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gVGhlIG5ldyBjb2xvci5cbiAgICAgKi9cbiAgICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdHJva2VDb2xvciA9IHZhbHVlO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2F1Z2VCYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcGVyc29uYS9HYXVnZUJhci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBOb2RlIGZyb20gJy4uL3JldmkvZ3JhcGhpY3MvTm9kZS5qcyc7XG5pbXBvcnQgVGV4dExhYmVsIGZyb20gJy4uL3JldmkvdGV4dC9MYWJlbC5qcyc7XG5pbXBvcnQgVGV4dEV2ZW50cyBmcm9tICcuLi9yZXZpL3RleHQvRXZlbnRzLmpzJztcbmltcG9ydCBHZW9tZXRyeUV2ZW50cyBmcm9tICcuLi9yZXZpL2dlb21ldHJ5L0V2ZW50cy5qcyc7XG5pbXBvcnQgRm9udE1hbmFnZXIgZnJvbSAnLi4vcmV2aS90ZXh0L0ZvbnRNYW5hZ2VyLmpzJztcbmltcG9ydCBBcmlhbCBmcm9tICcuLi9jb25maWcvZm9udHMvQXJpYWwuanMnO1xuaW1wb3J0IE9zd2FsZCBmcm9tICcuLi9jb25maWcvZm9udHMvT3N3YWxkNzAwLmpzJztcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi4vcmV2aS9ncmFwaGljcy9wcmltaXRpdmVzL1JlY3RhbmdsZS5qcyc7XG5pbXBvcnQgU2l6ZSBmcm9tICcuLi9yZXZpL2dlb21ldHJ5L1NpemUuanMnO1xuXG5jb25zdCBQRVJTT05BX0ZPTlRTID0ge1xuICAgIE5BTUU6IFN5bWJvbCgnUEVSU09OQV9OQU1FX0ZPTlQnKSxcbiAgICBDT1VOVDogU3ltYm9sKCdQRVJTT05BX0NPVU5UX0ZPTlQnKSxcbiAgICBUT1RBTF9DT1VOVDogU3ltYm9sKCdQRVJTT05BX1RPVEFMX0NPVU5UX0ZPTlQnKSxcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmVuZGVycyBhIHBlcnNvbmEncyBsYWJlbC4gSW5jbHVkZXMgdGhlIHBlcnNvbmEgbmFtZSwgY291bnQgYW5kIHRvdGFsIGNvdW50LlxuICpcbiAqIEBjbGFzcyBMYWJlbFxuICovXG5leHBvcnQgY2xhc3MgTGFiZWwgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKipcbiAgICAgKiBUaGUga2V5IHVzZWQgdG8gbG9hZCB0aGUgbmFtZSBmb250LlxuICAgICAqXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFBFUlNPTkFfTkFNRV9GT05UKCkge1xuICAgICAgICByZXR1cm4gUEVSU09OQV9GT05UUy5OQU1FO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgdXNlZCB0byBsb2FkIHRoZSBjb3VudCBmb250LlxuICAgICAqXG4gICAgICogQHR5cGUge1N5bWJvbH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFBFUlNPTkFfQ09VTlRfRk9OVCgpIHtcbiAgICAgICAgcmV0dXJuIFBFUlNPTkFfRk9OVFMuQ09VTlQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGtleSB1c2VkIHRvIGxvYWQgdGhlIHRvdGFsIGNvdW50IGZvbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3ltYm9sfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUEVSU09OQV9UT1RBTF9DT1VOVF9GT05UKCkge1xuICAgICAgICByZXR1cm4gUEVSU09OQV9GT05UUy5UT1RBTF9DT1VOVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhpcyBwZXJzb25hLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxudWxsfSBjb3VudCAtIFRoZSBjb3VudCBvZiB0aGlzIHBlcnNvbmEgb3IgbnVsbCBpZiBpdCBzaG91bGQgbm90IGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxudWxsfSB0b3RhbENvdW50IC0gVGhlIHRvdGFsIGNvdW50IG9mIHRoaXMgcGVyc29uYSBvciBudWxsIGlmIGl0IHNob3VsZCBub3QgYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHdpdGhpbiB3aGljaCB0aGUgbGFiZWwgc2hvdWxkIGZpdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCB3aXRoaW4gd2hpY2ggdGhlIGxhYmVsIHNob3VsZCBmaXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIFRoZSBsYWJlbCdzIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgY291bnQsIHRvdGFsQ291bnQsIHdpZHRoLCBoZWlnaHQsIGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1NYXhTaXplID0gbmV3IFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMubU5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm1Db3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLm1Ub3RhbENvdW50ID0gdG90YWxDb3VudDtcbiAgICAgICAgdGhpcy5tQ29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm1Gb250U2l6ZVNjYWxlID0gdGhpcy5tQ29uZmlnLmxhYmVsU2NhbGVGb250U2l6ZXMgPyAodGhpcy5tYXhTaXplLmhlaWdodCAvICh0aGlzLm1Db25maWcubGFiZWxTY2FsZUJhc2VQZXJzb25hUmFkaXVzICogMikpIDogMTtcbiAgICAgICAgdGhpcy5tQmlnZ2VzdEZvbnRTaXplID0gTWF0aC5tYXgodGhpcy5tQ29uZmlnLmxhYmVsTmFtZUZvbnRTaXplLCB0aGlzLm1Db25maWcubGFiZWxDb3VudEZvbnRTaXplLCB0aGlzLm1Db25maWcubGFiZWxUb3RhbENvdW50Rm9udFNpemUpO1xuICAgICAgICB0aGlzLm1TbWFsbGVzdEZvbnRTaXplID0gTWF0aC5taW4odGhpcy5tQ29uZmlnLmxhYmVsTmFtZUZvbnRTaXplLCB0aGlzLm1Db25maWcubGFiZWxDb3VudEZvbnRTaXplLCB0aGlzLm1Db25maWcubGFiZWxUb3RhbENvdW50Rm9udFNpemUpO1xuXG4gICAgICAgIHRoaXMubU5hbWVMYWJlbCA9IG51bGw7XG4gICAgICAgIHRoaXMubUNvdW50TGFiZWwgPSBudWxsO1xuICAgICAgICB0aGlzLm1Ub3RhbENvdW50TGFiZWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMubU5hbWVCYWNrID0gbmV3IFJlY3RhbmdsZSgwLCAwLCB7XG4gICAgICAgICAgICBmaWxsRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogY29uZmlnLmxhYmVsTmFtZUJhY2tncm91bmRDb2xvcixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYXhTaXplLm9uKEdlb21ldHJ5RXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMubWF4U2l6ZS5zYWZlQmluZCh0aGlzLl9oYW5kbGVNYXhTaXplQ2hhbmdlZCwgdGhpcykpO1xuXG4gICAgICAgIGNvbnN0IG5hbWVGb250ID0gdGhpcy5tQ29uZmlnLmxhYmVsTmFtZUZvbnQgPT09ICdkZWZhdWx0JyA/IEFyaWFsIDogdGhpcy5tQ29uZmlnLmxhYmVsTmFtZUZvbnQ7XG4gICAgICAgIEZvbnRNYW5hZ2VyLnNoYXJlZEluc3RhbmNlKCkubG9hZEZvbnQobmFtZUZvbnQsIFBFUlNPTkFfRk9OVFMuTkFNRSkudGhlbih0aGlzLl9oYW5kbGVOYW1lRm9udExvYWRlZC5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAodGhpcy5tQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50Rm9udCA9IHRoaXMubUNvbmZpZy5sYWJlbENvdW50Rm9udCA9PT0gJ2RlZmF1bHQnID8gT3N3YWxkIDogdGhpcy5tQ29uZmlnLmxhYmVsQ291bnRGb250O1xuICAgICAgICAgICAgRm9udE1hbmFnZXIuc2hhcmVkSW5zdGFuY2UoKS5sb2FkRm9udChjb3VudEZvbnQsIFBFUlNPTkFfRk9OVFMuQ09VTlQpLnRoZW4odGhpcy5faGFuZGxlQ291bnRGb250TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubVRvdGFsQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQ291bnRGb250ID0gdGhpcy5tQ29uZmlnLmxhYmVsVG90YWxDb3VudEZvbnQgPT09ICdkZWZhdWx0JyA/IEFyaWFsIDogdGhpcy5tQ29uZmlnLmxhYmVsVG90YWxDb3VudEZvbnQ7XG4gICAgICAgICAgICBGb250TWFuYWdlci5zaGFyZWRJbnN0YW5jZSgpLmxvYWRGb250KHRvdGFsQ291bnRGb250LCBQRVJTT05BX0ZPTlRTLlRPVEFMX0NPVU5UKS50aGVuKHRoaXMuX2hhbmRsZVRvdGFsQ291bnRGb250TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBvYmplY3QuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGlzIG9iamVjdCByZWFjaGVzIHplcm8uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLm1heFNpemUub2ZmKEdlb21ldHJ5RXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMuX2hhbmRsZU1heFNpemVDaGFuZ2VkLCB0aGlzKTtcblxuICAgICAgICB0aGlzLm1NYXhTaXplLnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tTmFtZUJhY2sucmVsZWFzZSgpO1xuICAgICAgICBpZiAodGhpcy5tTmFtZUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1OYW1lTGFiZWwucmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1Db3VudExhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1Db3VudExhYmVsLnJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tVG90YWxDb3VudExhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1Ub3RhbENvdW50TGFiZWwucmVsZWFzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubU5hbWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1Db3VudDtcbiAgICAgICAgZGVsZXRlIHRoaXMubVRvdGFsQ291bnQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1Db25maWc7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1Gb250U2l6ZVNjYWxlO1xuICAgICAgICBkZWxldGUgdGhpcy5tQmlnZ2VzdEZvbnRTaXplO1xuICAgICAgICBkZWxldGUgdGhpcy5tU21hbGxlc3RGb250U2l6ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMubU5hbWVMYWJlbDtcbiAgICAgICAgZGVsZXRlIHRoaXMubUNvdW50TGFiZWw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1Ub3RhbENvdW50TGFiZWw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1OYW1lQmFjaztcblxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gc2l6ZSBvZiB0aGlzIGxhYmVsLlxuICAgICAqXG4gICAgICogQHR5cGUge1NpemV9XG4gICAgICovXG4gICAgZ2V0IG1heFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1NYXhTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRleHQgb2YgdGhpcyBsYWJlbCBhcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBuYW1lIC0gVGhlIG5ldyBuYW1lIHRvIGRpc3BsYXkgb3IgbnVsbCBpZiBubyBjaGFuZ2UgaXMgbmVlZGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IGNvdW50IC0gVGhlIG5ldyBjb3VudCB0byBkaXNwbGF5IG9yIG51bGwgaWYgbm8gY291bnQgc2hvdWxkIGJlIGRpc3BsYXllZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSB0b3RhbENvdW50IC0gVGhlIG5ldyB0b3RhbCBjb3VudCB0byBkaXNwbGF5IG9yIG51bGwgaWYgbm8gdG90YWwgY291bnQgc2hvdWxkIGJlIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0KG5hbWUgPSBudWxsLCBjb3VudCA9IG51bGwsIHRvdGFsQ291bnQgPSBudWxsKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHRoaXMubU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMubU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5tTmFtZUxhYmVsLnRleHQgPSB0aGlzLm1OYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY291bnQgIT09IG51bGwgJiYgY291bnQgIT09IHRoaXMubUNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLm1Db3VudCA9IGNvdW50O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1Db3VudExhYmVsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRGb250ID0gdGhpcy5tQ29uZmlnLmxhYmVsQ291bnRGb250ID09PSAnZGVmYXVsdCcgPyBPc3dhbGQgOiB0aGlzLm1Db25maWcubGFiZWxDb3VudEZvbnQ7XG4gICAgICAgICAgICAgICAgRm9udE1hbmFnZXIuc2hhcmVkSW5zdGFuY2UoKS5sb2FkRm9udChjb3VudEZvbnQsIFBFUlNPTkFfRk9OVFMuQ09VTlQpLnRoZW4odGhpcy5faGFuZGxlQ291bnRGb250TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1Db3VudExhYmVsLnRleHQgPSB0aGlzLm1Db3VudC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSBudWxsICYmIHRoaXMubUNvdW50TGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMubUNvdW50TGFiZWwucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMubUNvdW50TGFiZWwpO1xuICAgICAgICAgICAgdGhpcy5tQ291bnRMYWJlbC5yZWxlYXNlKCk7XG4gICAgICAgICAgICB0aGlzLm1Db3VudExhYmVsID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3RhbENvdW50ICE9PSBudWxsICYmIHRvdGFsQ291bnQgIT09IHRoaXMubVRvdGFsQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMubVRvdGFsQ291bnQgPSB0b3RhbENvdW50O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1Ub3RhbENvdW50TGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbENvdW50Rm9udCA9IHRoaXMubUNvbmZpZy5sYWJlbFRvdGFsQ291bnRGb250ID09PSAnZGVmYXVsdCcgPyBBcmlhbCA6IHRoaXMubUNvbmZpZy5sYWJlbFRvdGFsQ291bnRGb250O1xuICAgICAgICAgICAgICAgIEZvbnRNYW5hZ2VyLnNoYXJlZEluc3RhbmNlKCkubG9hZEZvbnQodG90YWxDb3VudEZvbnQsIFBFUlNPTkFfRk9OVFMuVE9UQUxfQ09VTlQpLnRoZW4odGhpcy5faGFuZGxlVG90YWxDb3VudEZvbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubVRvdGFsQ291bnRMYWJlbC50ZXh0ID0gdGhpcy5tVG90YWxDb3VudC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRvdGFsQ291bnQgPT09IG51bGwgJiYgdGhpcy5tVG90YWxDb3VudExhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1Ub3RhbENvdW50TGFiZWwucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMubVRvdGFsQ291bnRMYWJlbCk7XG4gICAgICAgICAgICB0aGlzLm1Ub3RhbENvdW50TGFiZWwucmVsZWFzZSgpO1xuICAgICAgICAgICAgdGhpcy5tVG90YWxDb3VudExhYmVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBmb250IGZvciB0aGUgbmFtZSBsYWJlbCBpcyBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVOYW1lRm9udExvYWRlZFxuICAgICAqIEBwYXJhbSB7Rm9udH0gZm9udCAtIFRoZSBsb2FkZWQgZm9udC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVOYW1lRm9udExvYWRlZChmb250KSB7XG4gICAgICAgIC8qIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgb2JqZWN0IGNvdWxkIGhhdmUgYmVlbiBkZXN0cm95ZWQgYXQgdGhpcyBwb2ludCAqL1xuICAgICAgICBpZiAodGhpcy5yZXRhaW5Db3VudCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLm1Db25maWcubGFiZWxOYW1lQmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICAgICAgICBjb25zdCBmb250U2NhbGUgPSB0aGlzLl9nZXRGb250U2l6ZSh0aGlzLm1TbWFsbGVzdEZvbnRTaXplKSAvIHRoaXMubVNtYWxsZXN0Rm9udFNpemU7XG4gICAgICAgICAgICB0aGlzLm1OYW1lTGFiZWwgPSB0aGlzLl9jcmVhdGVMYWJlbCh0aGlzLm1OYW1lLnRvU3RyaW5nKCksIHRoaXMubWF4U2l6ZS53aWR0aCwgdGhpcy5tQ29uZmlnLmxhYmVsTmFtZU1heExpbmVzLCBwYWRkaW5nICogZm9udFNjYWxlLCBmb250LCBQRVJTT05BX0ZPTlRTLk5BTUUsIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5tQ29uZmlnLmxhYmVsTmFtZUNvbG9yLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLl9nZXRGb250U2l6ZSh0aGlzLm1Db25maWcubGFiZWxOYW1lRm9udFNpemUpLFxuICAgICAgICAgICAgICAgIHJlbmRlclNoYWRvdzogdGhpcy5tQ29uZmlnLmxhYmVsTmFtZVNoYWRvdyxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogdGhpcy5tQ29uZmlnLmxhYmVsTmFtZVNoYWRvd0NvbG9yLFxuICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6IHRoaXMubUNvbmZpZy5sYWJlbE5hbWVTaGFkb3dCbHVyLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFg6IHRoaXMubUNvbmZpZy5sYWJlbE5hbWVTaGFkb3dPZmZzZXRYLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFk6IHRoaXMubUNvbmZpZy5sYWJlbE5hbWVTaGFkb3dPZmZzZXRZLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubU5hbWVMYWJlbC5vbihUZXh0RXZlbnRzLlRFWFRfTEFCRUxfUkVOREVSRUQsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2dldEZvbnRTaXplKHRoaXMubVNtYWxsZXN0Rm9udFNpemUpIC8gdGhpcy5tU21hbGxlc3RGb250U2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZWRQYWRkaW5nID0gcGFkZGluZyAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uTGFiZWxzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tTmFtZUJhY2suYW5jaG9yLnNldCgnNTAlJywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tTmFtZUJhY2sucG9zaXRpb24uc2V0KFxuICAgICAgICAgICAgICAgICAgICAnNTAlJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tTmFtZUxhYmVsLnBvc2l0aW9uLnkgLSBzY2FsZWRQYWRkaW5nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1OYW1lQmFjay5zaXplLnNldCh0aGlzLm1OYW1lTGFiZWwuYm91bmRpbmdCb3gud2lkdGggKyBzY2FsZWRQYWRkaW5nICogMiwgdGhpcy5tTmFtZUxhYmVsLmJvdW5kaW5nQm94LmhlaWdodCArIHNjYWxlZFBhZGRpbmcgKiAyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm1OYW1lTGFiZWwub24oVGV4dEV2ZW50cy5URVhUX0xBQkVMX1dJTExfUkVOREVSLCAoKSA9PiB7IHRoaXMuc2NhbGUgPSAxOyB9KTtcblxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLm1OYW1lQmFjayk7XG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMubU5hbWVMYWJlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgZm9udCBmb3IgdGhlIGNvdW50IGxhYmVsIGlzIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2hhbmRsZUNvdW50Rm9udExvYWRlZFxuICAgICAqIEBwYXJhbSB7Rm9udH0gZm9udCAtIFRoZSBsb2FkZWQgZm9udC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVDb3VudEZvbnRMb2FkZWQoZm9udCkge1xuICAgICAgICAvKiBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIG9iamVjdCBjb3VsZCBoYXZlIGJlZW4gZGVzdHJveWVkIGF0IHRoaXMgcG9pbnQgKi9cbiAgICAgICAgaWYgKHRoaXMucmV0YWluQ291bnQgPiAwICYmIHRoaXMubUNvdW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGhpcy5tVG90YWxDb3VudCA9PT0gbnVsbCA/IHRoaXMubWF4U2l6ZS53aWR0aCA6IHRoaXMubWF4U2l6ZS53aWR0aCAqIDAuNTtcbiAgICAgICAgICAgIHRoaXMubUNvdW50TGFiZWwgPSB0aGlzLl9jcmVhdGVMYWJlbCh0aGlzLm1Db3VudC50b1N0cmluZygpLCBsYWJlbFdpZHRoLCAxLCAwLCBmb250LCBQRVJTT05BX0ZPTlRTLkNPVU5ULCB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMubUNvbmZpZy5sYWJlbENvdW50Q29sb3IsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IHRoaXMuX2dldEZvbnRTaXplKHRoaXMubUNvbmZpZy5sYWJlbENvdW50Rm9udFNpemUpLFxuICAgICAgICAgICAgICAgIHJlbmRlclNoYWRvdzogdGhpcy5tQ29uZmlnLmxhYmVsQ291bnRTaGFkb3csXG4gICAgICAgICAgICAgICAgc2hhZG93Q29sb3I6IHRoaXMubUNvbmZpZy5sYWJlbENvdW50U2hhZG93Q29sb3IsXG4gICAgICAgICAgICAgICAgc2hhZG93Qmx1cjogdGhpcy5tQ29uZmlnLmxhYmVsQ291bnRTaGFkb3dCbHVyLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFg6IHRoaXMubUNvbmZpZy5sYWJlbENvdW50U2hhZG93T2Zmc2V0WCxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXRZOiB0aGlzLm1Db25maWcubGFiZWxDb3VudFNoYWRvd09mZnNldFksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5tQ291bnRMYWJlbC5vbihUZXh0RXZlbnRzLlRFWFRfTEFCRUxfUkVOREVSRUQsICgpID0+IHRoaXMuX3Bvc2l0aW9uTGFiZWxzKCkpO1xuICAgICAgICAgICAgdGhpcy5tQ291bnRMYWJlbC5vbihUZXh0RXZlbnRzLlRFWFRfTEFCRUxfV0lMTF9SRU5ERVIsICgpID0+IHsgdGhpcy5zY2FsZSA9IDE7IH0pO1xuXG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMubUNvdW50TGFiZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGZvbnQgZm9yIHRoZSB0b3RhbCBjb3VudCBsYWJlbCBpcyBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVDb3VudEZvbnRMb2FkZWRcbiAgICAgKiBAcGFyYW0ge0ZvbnR9IGZvbnQgLSBUaGUgbG9hZGVkIGZvbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlVG90YWxDb3VudEZvbnRMb2FkZWQoZm9udCkge1xuICAgICAgICAvKiBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIG9iamVjdCBjb3VsZCBoYXZlIGJlZW4gZGVzdHJveWVkIGF0IHRoaXMgcG9pbnQgKi9cbiAgICAgICAgaWYgKHRoaXMucmV0YWluQ291bnQgPiAwICYmIHRoaXMubVRvdGFsQ291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aGlzLm1Db3VudCA9PT0gbnVsbCA/IHRoaXMubWF4U2l6ZS53aWR0aCA6IHRoaXMubWF4U2l6ZS53aWR0aCAqIDAuNTtcbiAgICAgICAgICAgIHRoaXMubVRvdGFsQ291bnRMYWJlbCA9IHRoaXMuX2NyZWF0ZUxhYmVsKCcvJyArIHRoaXMubVRvdGFsQ291bnQsIGxhYmVsV2lkdGgsIDEsIDAsIGZvbnQsIFBFUlNPTkFfRk9OVFMuVE9UQUxfQ09VTlQsIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5tQ29uZmlnLmxhYmVsVG90YWxDb3VudENvbG9yLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0aGlzLl9nZXRGb250U2l6ZSh0aGlzLm1Db25maWcubGFiZWxUb3RhbENvdW50Rm9udFNpemUpLFxuICAgICAgICAgICAgICAgIHJlbmRlclNoYWRvdzogdGhpcy5tQ29uZmlnLmxhYmVsVG90YWxDb3VudFNoYWRvdyxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogdGhpcy5tQ29uZmlnLmxhYmVsVG90YWxDb3VudFNoYWRvd0NvbG9yLFxuICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6IHRoaXMubUNvbmZpZy5sYWJlbFRvdGFsQ291bnRTaGFkb3dCbHVyLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFg6IHRoaXMubUNvbmZpZy5sYWJlbFRvdGFsQ291bnRTaGFkb3dPZmZzZXRYLFxuICAgICAgICAgICAgICAgIHNoYWRvd09mZnNldFk6IHRoaXMubUNvbmZpZy5sYWJlbFRvdGFsQ291bnRTaGFkb3dPZmZzZXRZLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubVRvdGFsQ291bnRMYWJlbC5vbihUZXh0RXZlbnRzLlRFWFRfTEFCRUxfUkVOREVSRUQsICgpID0+IHRoaXMuX3Bvc2l0aW9uTGFiZWxzKCkpO1xuICAgICAgICAgICAgdGhpcy5tVG90YWxDb3VudExhYmVsLm9uKFRleHRFdmVudHMuVEVYVF9MQUJFTF9XSUxMX1JFTkRFUiwgKCkgPT4geyB0aGlzLnNjYWxlID0gMTsgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5tVG90YWxDb3VudExhYmVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhpcyBsYWJlbCdzIG1heCBzaXplIGlzIG1vZGlmaWVkLCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVNYXhTaXplQ2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Kn0gc2VuZGVyIC0gVGhlIGluc3RhbmNlIHRoYXQgb3JpZ2luYWxseSB0cmlnZ2VyZWQgdGhpcyBldmVudC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSBsYWJlbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVNYXhTaXplQ2hhbmdlZChzZW5kZXIsIHdpZHRoKSB7XG4gICAgICAgIGlmIChzZW5kZXIgPT09IHRoaXMubU1heFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubUZvbnRTaXplU2NhbGUgPSB0aGlzLm1Db25maWcubGFiZWxTY2FsZUZvbnRTaXplcyA/ICh0aGlzLm1heFNpemUuaGVpZ2h0IC8gKHRoaXMubUNvbmZpZy5sYWJlbFNjYWxlQmFzZVBlcnNvbmFSYWRpdXMgKiAyKSkgOiAxO1xuICAgICAgICAgICAgaWYgKHRoaXMubU5hbWVMYWJlbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMubU5hbWVMYWJlbC5vZmYoVGV4dEV2ZW50cy5URVhUX0xBQkVMX1JFTkRFUkVEKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYWJlbCh0aGlzLm1OYW1lTGFiZWwsIHdpZHRoLCB0aGlzLm1Db25maWcubGFiZWxOYW1lTWF4TGluZXMsIHRoaXMubUNvbmZpZy5sYWJlbE5hbWVCYWNrZ3JvdW5kUGFkZGluZywgdGhpcy5tQ29uZmlnLmxhYmVsTmFtZUZvbnRTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubUNvdW50TGFiZWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLm1Db3VudExhYmVsLm9mZihUZXh0RXZlbnRzLlRFWFRfTEFCRUxfUkVOREVSRUQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aGlzLm1Ub3RhbENvdW50ID09PSBudWxsID8gd2lkdGggOiB3aWR0aCAqIDAuNTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYWJlbCh0aGlzLm1Db3VudExhYmVsLCBsYWJlbFdpZHRoLCAxLCAwLCB0aGlzLm1Db25maWcubGFiZWxDb3VudEZvbnRTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubVRvdGFsQ291bnRMYWJlbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMubVRvdGFsQ291bnRMYWJlbC5vZmYoVGV4dEV2ZW50cy5URVhUX0xBQkVMX1JFTkRFUkVEKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGhpcy5tQ291bnQgPT09IG51bGwgPyB3aWR0aCA6IHdpZHRoICogMC41O1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsKHRoaXMubVRvdGFsQ291bnRMYWJlbCwgbGFiZWxXaWR0aCwgMSwgMCwgdGhpcy5tQ29uZmlnLmxhYmVsVG90YWxDb3VudEZvbnRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNjYWxlZCBmb250IHNpemUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9nZXRGb250U2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZSAtIFRoZSBvcmlnaW5hbCBmb250IHNpemUgdG8gc2NhbGUuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRGb250U2l6ZShmb250U2l6ZSkge1xuICAgICAgICBsZXQgbWluRm9udFNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMubUJpZ2dlc3RGb250U2l6ZSAqIHRoaXMubUZvbnRTaXplU2NhbGUgPiB0aGlzLm1Db25maWcubGFiZWxNYXhGb250U2l6ZSkge1xuICAgICAgICAgICAgbWluRm9udFNpemUgPSBNYXRoLm1heCh0aGlzLm1Db25maWcubGFiZWxNYXhGb250U2l6ZSAqICh0aGlzLm1TbWFsbGVzdEZvbnRTaXplIC8gdGhpcy5tQmlnZ2VzdEZvbnRTaXplKSwgdGhpcy5tQ29uZmlnLmxhYmVsTWluRm9udFNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluRm9udFNpemUgPSBNYXRoLm1heCh0aGlzLm1TbWFsbGVzdEZvbnRTaXplICogdGhpcy5tRm9udFNpemVTY2FsZSwgdGhpcy5tQ29uZmlnLmxhYmVsTWluRm9udFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKChmb250U2l6ZSAvIHRoaXMubVNtYWxsZXN0Rm9udFNpemUpICogbWluRm9udFNpemUsIHRoaXMubUNvbmZpZy5sYWJlbE1heEZvbnRTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGFiZWwgdXNpbmcgdGhlIHNwZWNpZmllZCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfY3JlYXRlTGFiZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IGZvciB0aGUgbGFiZWwuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFdpZHRoIC0gVGhlIG1heGltdW0gd2lkdGggb2YgdGhlIGxhYmVsIHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4TGluZXMgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgdGV4dCBsaW5lcyBmb3IgdGhlIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYWRkaW5nIC0gVGhlIHBhZGRpbmcgbGVmdCBhcm91bmQgdGhlIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7Rm9udH0gZm9udCAtIFRoZSBmb250IHRvIGJlIHVzZWQgZm9yIHRoZSBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udEtleSAtIFRoZSBrZXkgdXNlZCBpbiB0aGUgZm9udCBtYW5hZ2VyIHRvIGxvYWQgdGhlIGZvbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgcmVuZGVyaW5nIG9wdGlvbnMgZm9yIHRoZSBsYWJlbC5cbiAgICAgKiBAcmV0dXJucyB7TGFiZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlTGFiZWwodGV4dCwgbWF4V2lkdGgsIG1heExpbmVzLCBwYWRkaW5nLCBmb250LCBmb250S2V5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGhoZWEgPSBmb250LnRhYmxlcy5oaGVhO1xuICAgICAgICBjb25zdCBmb250U2NhbGUgPSAob3B0aW9ucy5mb250U2l6ZSAvIGZvbnQudW5pdHNQZXJFbSk7XG4gICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSAoaGhlYS5hc2NlbmRlciAtIGhoZWEuZGVzY2VuZGVyKSAqIGZvbnRTY2FsZTtcbiAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoIC0gKHBhZGRpbmcgKiAyKSwgMCk7XG4gICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5taW4obGluZUhlaWdodCAqIG1heExpbmVzLCB0aGlzLm1NYXhTaXplLmhlaWdodCAtIChwYWRkaW5nICogMikpLCAwKTtcblxuICAgICAgICBvcHRpb25zLmFsaWdubWVudCA9IFRleHRMYWJlbC5URVhUX0FMSUdOTUVOVC5DRU5URVI7XG4gICAgICAgIG9wdGlvbnMudHJ1bmNhdGVNb2RlID0gVGV4dExhYmVsLlRFWFRfVFJVTkNBVElOR19NT0RFLkVMTElQU0VTO1xuICAgICAgICBvcHRpb25zLm11bHRpTGluZU1vZGUgPSBUZXh0TGFiZWwuVEVYVF9NVUxUSV9MSU5FX01PREUuQVVUT19MSU5FUztcbiAgICAgICAgb3B0aW9ucy5yZW5kZXJpbmdCYWNrZW5kID0gVGV4dExhYmVsLlRFWFRfUkVOREVSSU5HX0JBQ0tFTkQuQ0FOVkFTO1xuICAgICAgICBvcHRpb25zLmF1dG9TaXplID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBsYWJlbCA9IG5ldyBUZXh0TGFiZWwobGFiZWxXaWR0aCwgbGFiZWxIZWlnaHQsIHRleHQsIGZvbnRLZXksIG51bGwsIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzcGVjaWZpZWQgbGFiZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbCAtIHRoZSBsYWJlbCB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFdpZHRoIC0gVGhlIG5ldyBtYXggd2lkdGggb2YgdGhlIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMaW5lcyAtIFRoZSBuZXcgbWF4IG51bWJlciBvZiBsaW5lcyBvZiB0ZXh0IGZvciB0aGUgbGFiZWwuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZGRpbmcgLSBUaGUgcGFkZGluZyBhcm91bmQgdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvbnRTaXplIC0gVGhlIGZvbnQgc2l6ZSBmb3IgdGhlIGxhYmVsLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUxhYmVsKGxhYmVsLCBtYXhXaWR0aCwgbWF4TGluZXMsIHBhZGRpbmcsIGZvbnRTaXplKSB7XG4gICAgICAgIGNvbnN0IGZvbnQgPSBsYWJlbC5mb250O1xuICAgICAgICBjb25zdCBzY2FsZWRGb250U2l6ZSA9IHRoaXMuX2dldEZvbnRTaXplKGZvbnRTaXplKTtcbiAgICAgICAgY29uc3QgaGhlYSA9IGZvbnQudGFibGVzLmhoZWE7XG4gICAgICAgIGNvbnN0IGZvbnRTY2FsZSA9IChzY2FsZWRGb250U2l6ZSAvIGZvbnQudW5pdHNQZXJFbSk7XG4gICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSAoaGhlYS5hc2NlbmRlciAtIGhoZWEuZGVzY2VuZGVyKSAqIGZvbnRTY2FsZTtcbiAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoIC0gKHBhZGRpbmcgKiAyKSwgMCk7XG4gICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5taW4obGluZUhlaWdodCAqIG1heExpbmVzLCB0aGlzLm1NYXhTaXplLmhlaWdodCAtIChwYWRkaW5nICogMikpLCAwKTtcbiAgICAgICAgbGFiZWwuZm9udFNpemUgPSBzY2FsZWRGb250U2l6ZTtcbiAgICAgICAgbGFiZWwubWF4U2l6ZS5zZXQobGFiZWxXaWR0aCwgbGFiZWxIZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9ucyB0aGUgbG9hZGVkIGxhYmVscyB3aXRoaW4gdGhpcyBwZXJzb25hIGxhYmVsLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfcG9zaXRpb25MYWJlbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wb3NpdGlvbkxhYmVscygpIHtcbiAgICAgICAgbGV0IHRvdGFsSGVpZ2h0ID0gMDtcblxuICAgICAgICBpZiAodGhpcy5tTmFtZUxhYmVsKSB7XG4gICAgICAgICAgICBjb25zdCBmb250U2NhbGUgPSB0aGlzLl9nZXRGb250U2l6ZSh0aGlzLm1TbWFsbGVzdEZvbnRTaXplKSAvIHRoaXMubVNtYWxsZXN0Rm9udFNpemU7XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5tQ29uZmlnLmxhYmVsTmFtZUJhY2tncm91bmRQYWRkaW5nICogZm9udFNjYWxlO1xuICAgICAgICAgICAgdGhpcy5tTmFtZUxhYmVsLmFuY2hvci5zZXQoJzUwJScsIDApO1xuICAgICAgICAgICAgdGhpcy5tTmFtZUxhYmVsLnBvc2l0aW9uLnNldCgnNTAlJywgcGFkZGluZyk7XG4gICAgICAgICAgICB0b3RhbEhlaWdodCArPSB0aGlzLm1OYW1lTGFiZWwuc2l6ZS5oZWlnaHQgKyAocGFkZGluZyAqIDIpICsgKHRoaXMubUNvbmZpZy5sYWJlbE5hbWVBbmRDb3VudHNQYWRkaW5nICogZm9udFNjYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1Db3VudExhYmVsICYmIHRoaXMubVRvdGFsQ291bnRMYWJlbCkge1xuICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gTWF0aC5tYXgodGhpcy5tQ291bnRMYWJlbC5zaXplLmhlaWdodCwgdGhpcy5tVG90YWxDb3VudExhYmVsLnNpemUuaGVpZ2h0KTtcblxuICAgICAgICAgICAgdGhpcy5tQ291bnRMYWJlbC5hbmNob3Iuc2V0KCcxMDAlJywgJzEwMCUnKTtcbiAgICAgICAgICAgIHRoaXMubVRvdGFsQ291bnRMYWJlbC5hbmNob3Iuc2V0KDAsICcxMDAlJyk7XG5cbiAgICAgICAgICAgIHRoaXMubUNvdW50TGFiZWwucG9zaXRpb24uc2V0KCc1MCUnLCB0b3RhbEhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLm1Ub3RhbENvdW50TGFiZWwucG9zaXRpb24uc2V0KCc1MCUnLCB0b3RhbEhlaWdodCArIHRoaXMubUNvdW50TGFiZWwuZGVzY2VuZGVyIC0gdGhpcy5tVG90YWxDb3VudExhYmVsLmRlc2NlbmRlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tQ291bnRMYWJlbCkge1xuICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gdGhpcy5tQ291bnRMYWJlbC5zaXplLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMubUNvdW50TGFiZWwuYW5jaG9yLnNldCgnNTAlJywgJzEwMCUnKTtcbiAgICAgICAgICAgIHRoaXMubUNvdW50TGFiZWwucG9zaXRpb24uc2V0KCc1MCUnLCB0b3RhbEhlaWdodCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tVG90YWxDb3VudExhYmVsKSB7XG4gICAgICAgICAgICB0b3RhbEhlaWdodCArPSB0aGlzLm1Ub3RhbENvdW50TGFiZWwuc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLm1Ub3RhbENvdW50TGFiZWwuYW5jaG9yLnNldCgnNTAlJywgJzEwMCUnKTtcbiAgICAgICAgICAgIHRoaXMubVRvdGFsQ291bnRMYWJlbC5wb3NpdGlvbi5zZXQoJzUwJScsIHRvdGFsSGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSB0b3RhbEhlaWdodDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExhYmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BlcnNvbmEvTGFiZWwuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgQ2FjaGVkTm9kZSBmcm9tICcuLi9yZXZpL2dyYXBoaWNzL0NhY2hlZE5vZGUuanMnO1xuaW1wb3J0IENpcmNsZSBmcm9tICcuLi9yZXZpL2dyYXBoaWNzL3ByaW1pdGl2ZXMvQ2lyY2xlLmpzJztcbmltcG9ydCBHYXVnZSBmcm9tICcuL0dhdWdlLmpzJztcbmltcG9ydCBBdmF0YXIgZnJvbSAnLi9BdmF0YXIuanMnO1xuaW1wb3J0IExhYmVsIGZyb20gJy4vTGFiZWwuanMnO1xuaW1wb3J0IElucHV0TWFuYWdlciBmcm9tICcuLi9yZXZpL3BsdWdpbnMvaW5wdXQvSW5wdXRNYW5hZ2VyLmpzJztcbmltcG9ydCBJbnB1dEV2ZW50cyBmcm9tICcuLi9yZXZpL3BsdWdpbnMvaW5wdXQvRXZlbnRzLmpzJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9FdmVudHMuanMnO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIFBlcnNvbmEgaW4gdGhlIHZpc3VhbGl6YXRpb24uXG4gKlxuICogQGNsYXNzIFBlcnNvbmFcbiAqL1xuZXhwb3J0IGNsYXNzIFBlcnNvbmEgZXh0ZW5kcyBDYWNoZWROb2RlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGlzIHBlcnNvbmEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0aGlzIHBlcnNvbmEgd2lsbCByZXByZXNlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIFJlbmRlcmluZyBjb25maWd1cmF0aW9uLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJhZGl1cywgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heChyYWRpdXMgKiAyLCAwKTtcbiAgICAgICAgY29uc3Qgc2l6ZVdpdGhCb3JkZXIgPSBNYXRoLmNlaWwoc2l6ZSArIE1hdGgubWF4KGNvbmZpZy5zZWxlY3RlZEJvcmRlciwgY29uZmlnLnVuc2VsZWN0ZWRCb3JkZXIpICogMik7XG4gICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSBzaXplICsgTWF0aC5jZWlsKGNvbmZpZy5sYWJlbFdpZHRoU3BpbGwgKiAyKTtcbiAgICAgICAgY29uc3QgcGVyc29uYVdpZHRoID0gTWF0aC5tYXgobGFiZWxXaWR0aCwgc2l6ZVdpdGhCb3JkZXIpO1xuICAgICAgICBjb25zdCBwZXJzb25hSGVpZ2h0ID0gTWF0aC5tYXgoc2l6ZVdpdGhCb3JkZXIsIHNpemUgKyBjb25maWcuZ2F1Z2VNYXJrZXJTcGlsbCAqIDIpO1xuXG4gICAgICAgIHN1cGVyKHBlcnNvbmFXaWR0aCwgcGVyc29uYUhlaWdodCk7XG4gICAgICAgIHRoaXMubUNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5tUmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCAwKTtcbiAgICAgICAgdGhpcy5tSUQgPSBkYXRhLmlkO1xuICAgICAgICB0aGlzLm1TZWxlY3RlZCA9IGRhdGEuc2VsZWN0ZWQgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnRlciA9IG51bGw7XG4gICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm1UcmFja2luZ01vdmVUaHJlc2hvbGQgPSBNYXRoLnBvdyg4LCAyKTtcblxuICAgICAgICAvKiBiYWNrZ3JvdW5kICovXG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm1SYWRpdXMgLSB0aGlzLm1Db25maWcucmFkaXVzT3ZlcmxhcCwgMCk7XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRTdHJva2UgPSB0aGlzLm1TZWxlY3RlZCA/IHRoaXMubUNvbmZpZy5zZWxlY3RlZEJvcmRlciA6IHRoaXMubUNvbmZpZy51bnNlbGVjdGVkQm9yZGVyICsgdGhpcy5tQ29uZmlnLnJhZGl1c092ZXJsYXA7XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRTdHJva2VDb2xvciA9IHRoaXMubVNlbGVjdGVkID8gdGhpcy5tQ29uZmlnLnNlbGVjdGVkQm9yZGVyQ29sb3IgOiB0aGlzLm1Db25maWcudW5zZWxlY3RlZEJvcmRlckNvbG9yO1xuICAgICAgICB0aGlzLm1CYWNrZ3JvdW5kID0gbmV3IENpcmNsZShiYWNrZ3JvdW5kUmFkaXVzLCB7XG4gICAgICAgICAgICBmaWxsRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogdGhpcy5tQ29uZmlnLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZTogYmFja2dyb3VuZFN0cm9rZSxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBiYWNrZ3JvdW5kU3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBzdHJva2VUeXBlOiBDaXJjbGUuU1RST0tFX09VVEVSLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tQmFja2dyb3VuZC5wb3NpdGlvbi5zZXQoJzUwJScsICc1MCUnKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLm1CYWNrZ3JvdW5kKTtcblxuICAgICAgICAvKiBnYXVnZSAqL1xuICAgICAgICB0aGlzLm1HYXVnZSA9IG5ldyBHYXVnZSh0aGlzLm1SYWRpdXMsIHRoaXMubUNvbmZpZyk7XG4gICAgICAgIHRoaXMubUdhdWdlLnBvc2l0aW9uLnNldCgnNTAlJywgJzUwJScpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMubUdhdWdlKTtcbiAgICAgICAgZGF0YS5wcm9wZXJ0aWVzLmZvckVhY2gocHJvcGVydHkgPT4gdGhpcy5tR2F1Z2UuYWRkQmFyKHByb3BlcnR5LmNvdW50IC8gZGF0YS50b3RhbENvdW50LCBwcm9wZXJ0eS5jb2xvcikpO1xuXG4gICAgICAgIC8qIGF2YXRhciAqL1xuICAgICAgICBjb25zdCBhdmF0YXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm1SYWRpdXMgLSB0aGlzLm1Db25maWcuZ2F1Z2VUaGlja25lc3MsIDApO1xuICAgICAgICB0aGlzLm1BdmF0YXIgPSBuZXcgQXZhdGFyKGF2YXRhclJhZGl1cywgZGF0YS5pbWFnZXMsIHRoaXMubUNvbmZpZyk7XG4gICAgICAgIHRoaXMubUF2YXRhci5wb3NpdGlvbi5zZXQoJzUwJScsICc1MCUnKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLm1BdmF0YXIpO1xuXG4gICAgICAgIC8qIGxhYmVsICovXG4gICAgICAgIGxldCBjb3VudExhYmVsID0gbnVsbDtcbiAgICAgICAgbGV0IHRvdGFsQ291bnRMYWJlbCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm1Db25maWcubGFiZWxDb3VudERpc3BsYXlNb2RlID09PSAncHJvcGVydHlDb3VudC90b3RhbENvdW50Jykge1xuICAgICAgICAgICAgY291bnRMYWJlbCA9IGRhdGEucHJvcGVydGllc1t0aGlzLm1Db25maWcubGFiZWxQcm9wZXJ0eUNvdW50SW5kZXhdLmNvdW50O1xuICAgICAgICAgICAgdG90YWxDb3VudExhYmVsID0gZGF0YS50b3RhbENvdW50O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubUNvbmZpZy5sYWJlbENvdW50RGlzcGxheU1vZGUgPT09ICdwcm9wZXJ0eUNvdW50Jykge1xuICAgICAgICAgICAgY291bnRMYWJlbCA9IGRhdGEucHJvcGVydGllc1t0aGlzLm1Db25maWcubGFiZWxQcm9wZXJ0eUNvdW50SW5kZXhdLmNvdW50O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubUNvbmZpZy5sYWJlbENvdW50RGlzcGxheU1vZGUgPT09ICd0b3RhbENvdW50Jykge1xuICAgICAgICAgICAgY291bnRMYWJlbCA9IGRhdGEudG90YWxDb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubUxhYmVsID0gbmV3IExhYmVsKGRhdGEubGFiZWwsIGNvdW50TGFiZWwsIHRvdGFsQ291bnRMYWJlbCwgbGFiZWxXaWR0aCwgdGhpcy5zaXplLmhlaWdodCwgdGhpcy5tQ29uZmlnKTtcbiAgICAgICAgdGhpcy5tTGFiZWwuYW5jaG9yLnNldCgnNTAlJywgdGhpcy5tQ29uZmlnLmxhYmVsVmVydGljYWxQb3NpdGlvbik7XG4gICAgICAgIHRoaXMubUxhYmVsLnBvc2l0aW9uLnNldCgnNTAlJywgdGhpcy5tQ29uZmlnLmxhYmVsVmVydGljYWxQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5tTGFiZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tQmFja2dyb3VuZC5yZWxlYXNlKCk7XG4gICAgICAgIHRoaXMubUdhdWdlLnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tQXZhdGFyLnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tTGFiZWwucmVsZWFzZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLm1UcmFja2luZ1BvaW50KSB7XG4gICAgICAgICAgICB0aGlzLm1UcmFja2luZ1BvaW50LnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubUNvbmZpZztcbiAgICAgICAgZGVsZXRlIHRoaXMubVJhZGl1cztcbiAgICAgICAgZGVsZXRlIHRoaXMubUlEO1xuICAgICAgICBkZWxldGUgdGhpcy5tU2VsZWN0ZWQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1UcmFja2luZ1BvaW50ZXI7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1UcmFja2luZ1BvaW50O1xuICAgICAgICBkZWxldGUgdGhpcy5tVHJhY2tpbmdNb3ZlVGhyZXNob2xkO1xuICAgICAgICBkZWxldGUgdGhpcy5tQmFja2dyb3VuZDtcbiAgICAgICAgZGVsZXRlIHRoaXMubUdhdWdlO1xuICAgICAgICBkZWxldGUgdGhpcy5tQXZhdGFyO1xuICAgICAgICBkZWxldGUgdGhpcy5tTGFiZWw7XG5cbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBJRCBhc3NpZ25lZCB0byB0aGlzIHBlcnNvbmEgdGhyb3VnaCB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubUlEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSByYWRpdXMgdGhhdCBlbmNsb3NlcyBhbGwgZWxlbWVudHMgb2YgdGhpcyBwZXJzb25hLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc2FmZVJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc2l6ZS53aWR0aCwgdGhpcy5zaXplLmhlaWdodCkgKiAwLjU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpZ3VyZWQgcmFkaXVzIG9mIHRoaXMgcGVyc29uYS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVJhZGl1cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByYWRpdXMgb2YgdGhpcyBwZXJzb25hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyByYWRpdXMuXG4gICAgICovXG4gICAgc2V0IHJhZGl1cyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubVJhZGl1cykge1xuICAgICAgICAgICAgdGhpcy5tUmFkaXVzID0gTWF0aC5tYXgodmFsdWUsIDApO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMubUdsb2JhbFNjYWxlICogdGhpcy5tU2NhbGU7XG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLm1SYWRpdXMgKiBzY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLm1SYWRpdXMgKiAyO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZVdpdGhCb3JkZXIgPSBNYXRoLmNlaWwoc2l6ZSArIE1hdGgubWF4KHRoaXMubUNvbmZpZy5zZWxlY3RlZEJvcmRlciwgdGhpcy5tQ29uZmlnLnVuc2VsZWN0ZWRCb3JkZXIpICogMiAvIHNjYWxlKTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSBzaXplICsgTWF0aC5jZWlsKHRoaXMubUNvbmZpZy5sYWJlbFdpZHRoU3BpbGwgKiAyIC8gc2NhbGUpO1xuICAgICAgICAgICAgY29uc3QgcGVyc29uYVdpZHRoID0gTWF0aC5tYXgobGFiZWxXaWR0aCwgc2l6ZVdpdGhCb3JkZXIpO1xuICAgICAgICAgICAgY29uc3QgcGVyc29uYUhlaWdodCA9IE1hdGgubWF4KHNpemVXaXRoQm9yZGVyLCBzaXplICsgdGhpcy5tQ29uZmlnLmdhdWdlTWFya2VyU3BpbGwgKiAyIC8gc2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5zaXplLnNldChwZXJzb25hV2lkdGgsIHBlcnNvbmFIZWlnaHQpO1xuXG4gICAgICAgICAgICB0aGlzLm1CYWNrZ3JvdW5kLnJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cyAtIHRoaXMubUNvbmZpZy5yYWRpdXNPdmVybGFwLCAwKTtcbiAgICAgICAgICAgIHRoaXMubUdhdWdlLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgICAgIHRoaXMubUF2YXRhci5yYWRpdXMgPSBNYXRoLm1heChyYWRpdXMgLSB0aGlzLm1Db25maWcuZ2F1Z2VUaGlja25lc3MsIDApO1xuICAgICAgICAgICAgdGhpcy5tTGFiZWwubWF4U2l6ZS5zZXQocmFkaXVzICogMiArIE1hdGguY2VpbCh0aGlzLm1Db25maWcubGFiZWxXaWR0aFNwaWxsICogMiksIHRoaXMuc2l6ZS5oZWlnaHQgKiBzY2FsZSk7XG5cbiAgICAgICAgICAgIHRoaXMubmVlZHNSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgcGVyc29uYSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVNlbGVjdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGlvbiBzdGF0ZSBvZiB0aGlzIHBlcnNvbmEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIC0gVGhlIG5ldyBzZWxlY3Rpb24gc3RhdGUuXG4gICAgICovXG4gICAgc2V0IHNlbGVjdGVkKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubVNlbGVjdGVkID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLm1CYWNrZ3JvdW5kLnN0cm9rZSA9ICh0aGlzLm1TZWxlY3RlZCA/IHRoaXMubUNvbmZpZy5zZWxlY3RlZEJvcmRlciA6IHRoaXMubUNvbmZpZy51bnNlbGVjdGVkQm9yZGVyKSArIHRoaXMubUNvbmZpZy5yYWRpdXNPdmVybGFwO1xuICAgICAgICAgICAgdGhpcy5tQmFja2dyb3VuZC5zdHJva2VDb2xvciA9IHRoaXMubVNlbGVjdGVkID8gdGhpcy5tQ29uZmlnLnNlbGVjdGVkQm9yZGVyQ29sb3IgOiB0aGlzLm1Db25maWcudW5zZWxlY3RlZEJvcmRlckNvbG9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFnZ3JlZ2F0ZWQgc2NhbGUgb2YgdGhpcyBub2RlIGFuZCBhbGwgaXRzIGFuY2VzdG9ycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGdsb2JhbFNjYWxlKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZ2xvYmFsU2NhbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2xvYmFsIHNjYWxlIG9mIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBVc3VhbGx5IHRoaXMgcHJvcGVydHkgc2hvdWxkIG5vdCBiZSBzZXQgbWFudWFsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSB0aGUgbmV3IGdsb2JhbCBzY2FsZSBvZiB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBzZXQgZ2xvYmFsU2NhbGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLmdsb2JhbFNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLm1EaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tR2xvYmFsU2NhbGUgPSB2YWx1ZTtcblxuICAgICAgICAvKiBIQUNLISEhICovXG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMubVJhZGl1cztcbiAgICAgICAgdGhpcy5tUmFkaXVzICs9IDU7XG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSB0aW1lIHRoZSBvYmplY3QgaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIHNjZW5lIGdyYXBoLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBvbkVudGVyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHJldmlDb250ZXh0IC0gQSB1bmlxdWUgc3ltYm9sIHRoYXQgaWRlbnRpZmllcyB0aGUgcmVuZGVyaW5nIGNvbnRleHQgb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgb25FbnRlcihyZXZpQ29udGV4dCkge1xuICAgICAgICBjb25zdCBpbnB1dE1hbmFnZXIgPSBJbnB1dE1hbmFnZXIuaW5zdGFuY2VGb3JDb250ZXh0KHJldmlDb250ZXh0KTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9uKElucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfQkVHQU4sIGlucHV0TWFuYWdlci5zYWZlQmluZCh0aGlzLl9oYW5kbGVQb2ludGVyQmVnYW4sIHRoaXMpKTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9uKElucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfTU9WRUQsIGlucHV0TWFuYWdlci5zYWZlQmluZCh0aGlzLl9oYW5kbGVQb2ludGVyTW92ZWQsIHRoaXMpKTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9uKFtJbnB1dEV2ZW50cy5JTlBVVF9QT0lOVEVSX0VOREVELCBJbnB1dEV2ZW50cy5JTlBVVF9QT0lOVEVSX0NBTkNFTExFRF0sIGlucHV0TWFuYWdlci5zYWZlQmluZCh0aGlzLl9oYW5kbGVQb2ludGVyRW5kZWQsIHRoaXMpKTtcbiAgICAgICAgc3VwZXIub25FbnRlcihyZXZpQ29udGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhpcyBvYmplY3RzIGlzIHJlbW92ZWQgZnJvbSB0aGUgc2NlbmUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG9uRXhpdFxuICAgICAqL1xuICAgIG9uRXhpdCgpIHtcbiAgICAgICAgY29uc3QgaW5wdXRNYW5hZ2VyID0gSW5wdXRNYW5hZ2VyLmluc3RhbmNlRm9yQ29udGV4dCh0aGlzLnJldmlDb250ZXh0KTtcbiAgICAgICAgaW5wdXRNYW5hZ2VyLm9mZihJbnB1dEV2ZW50cy5JTlBVVF9QT0lOVEVSX0JFR0FOLCB0aGlzLl9oYW5kbGVQb2ludGVyQmVnYW4sIHRoaXMpO1xuICAgICAgICBpbnB1dE1hbmFnZXIub2ZmKElucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfTU9WRUQsIHRoaXMuX2hhbmRsZVBvaW50ZXJNb3ZlZCwgdGhpcyk7XG4gICAgICAgIGlucHV0TWFuYWdlci5vZmYoW0lucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfRU5ERUQsIElucHV0RXZlbnRzLklOUFVUX1BPSU5URVJfQ0FOQ0VMTEVEXSwgdGhpcy5faGFuZGxlUG9pbnRlckVuZGVkLCB0aGlzKTtcbiAgICAgICAgc3VwZXIub25FeGl0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGV2ZXJ5IHRpY2ssIGRyYXdpbmcgb3BlcmF0aW9ucyBzaG91bGQgYmUgcGVyZm9ybWVkIGhlcmUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjYW52YXMgY29udGV4dCBpbiB3aGljaCB0aGUgZHJhd2luZyBvcGVyYXRpb25zIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyQXJncyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW4gd2hlbiBkcmF3aW5nLlxuICAgICAqL1xuICAgIGRyYXcoY29udGV4dCwgLi4udmFyQXJncykge1xuICAgICAgICBpZiAodGhpcy5tRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMubURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1PZmZzY3JlZW5DYW52YXMud2lkdGggPSB0aGlzLnNpemUud2lkdGggKiB0aGlzLmRldmljZVNjYWxlICogdGhpcy5nbG9iYWxTY2FsZTtcbiAgICAgICAgICAgIHRoaXMubU9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgPSB0aGlzLnNpemUuaGVpZ2h0ICogdGhpcy5kZXZpY2VTY2FsZSAqIHRoaXMuZ2xvYmFsU2NhbGU7XG4gICAgICAgICAgICB0aGlzLm1PZmZzY3JlZW5Db250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMubU9mZnNjcmVlbkNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMubU9mZnNjcmVlbkNhbnZhcy53aWR0aCwgdGhpcy5tT2Zmc2NyZWVuQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLm1PZmZzY3JlZW5Db250ZXh0LnNjYWxlKHRoaXMuZGV2aWNlU2NhbGUsIHRoaXMuZGV2aWNlU2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5tT2Zmc2NyZWVuQ29udGV4dC50cmFuc2xhdGUodGhpcy5zaXplLndpZHRoICogdGhpcy5nbG9iYWxTY2FsZSAqIDAuNSAtIHRoaXMuc2l6ZS53aWR0aCAqIDAuNSwgdGhpcy5zaXplLmhlaWdodCAqIHRoaXMuZ2xvYmFsU2NhbGUgKiAwLjUgLSB0aGlzLnNpemUuaGVpZ2h0ICogMC41KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGUodGhpcy5tT2Zmc2NyZWVuQ29udGV4dCwgY29udGV4dCwgLi4udmFyQXJncyk7XG4gICAgICAgICAgICB0aGlzLm1DaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fcHVzaFRyYW5zZm9ybSh0aGlzLm1PZmZzY3JlZW5Db250ZXh0KTtcbiAgICAgICAgICAgICAgICBjaGlsZC5kcmF3KHRoaXMubU9mZnNjcmVlbkNvbnRleHQsIC4uLnZhckFyZ3MpO1xuICAgICAgICAgICAgICAgIGNoaWxkLl9wb3BUcmFuc2Zvcm0odGhpcy5tT2Zmc2NyZWVuQ29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdDYWNoZSh0aGlzLm1PZmZzY3JlZW5DYW52YXMsIGNvbnRleHQsIC4uLnZhckFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhpcyBwZXJzb25hIHdpdGggdGhlIGRhdGEgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZURhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIHRoZSBkYXRhIHVzZWQgdG8gdXBkYXRlIHRoaXMgcGVyc29uYS5cbiAgICAgKi9cbiAgICB1cGRhdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgbGV0IGNvdW50TGFiZWwgPSBudWxsO1xuICAgICAgICBsZXQgdG90YWxDb3VudExhYmVsID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubUNvbmZpZy5sYWJlbENvdW50RGlzcGxheU1vZGUgPT09ICdwcm9wZXJ0eUNvdW50L3RvdGFsQ291bnQnKSB7XG4gICAgICAgICAgICBjb3VudExhYmVsID0gZGF0YS5wcm9wZXJ0aWVzW3RoaXMubUNvbmZpZy5sYWJlbFByb3BlcnR5Q291bnRJbmRleF0uY291bnQ7XG4gICAgICAgICAgICB0b3RhbENvdW50TGFiZWwgPSBkYXRhLnRvdGFsQ291bnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tQ29uZmlnLmxhYmVsQ291bnREaXNwbGF5TW9kZSA9PT0gJ3Byb3BlcnR5Q291bnQnKSB7XG4gICAgICAgICAgICBjb3VudExhYmVsID0gZGF0YS5wcm9wZXJ0aWVzW3RoaXMubUNvbmZpZy5sYWJlbFByb3BlcnR5Q291bnRJbmRleF0uY291bnQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tQ29uZmlnLmxhYmVsQ291bnREaXNwbGF5TW9kZSA9PT0gJ3RvdGFsQ291bnQnKSB7XG4gICAgICAgICAgICBjb3VudExhYmVsID0gZGF0YS50b3RhbENvdW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubUxhYmVsLnVwZGF0ZVRleHQoZGF0YS5sYWJlbCwgY291bnRMYWJlbCwgdG90YWxDb3VudExhYmVsKTtcblxuICAgICAgICB0aGlzLm1BdmF0YXIudXBkYXRlSW1hZ2VzKGRhdGEuaW1hZ2VzKTtcblxuICAgICAgICAvKiB1cGRhdGUgZ2F1Z2VzIGhlcmUgKi9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBwb2ludGVyIGJlZ2FuIGlucHV0IGV2ZW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaGFuZGxlUG9pbnRlckJlZ2FuXG4gICAgICogQHBhcmFtIHsqfSBzZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgLSBPYmplY3QgY29udGFpbmluZyB0aGUgZXZlbnQncyBkZXNjcmlwdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVQb2ludGVyQmVnYW4oc2VuZGVyLCBldmVudCkge1xuICAgICAgICBjb25zdCBsb2NhbFBvaW50ID0gdGhpcy5nbG9iYWxUb0xvY2FsUG9pbnQoZXZlbnQucG9pbnQpO1xuICAgICAgICBjb25zdCBkaXN0YW5jZVNRID0gTWF0aC5wb3cobG9jYWxQb2ludC54IC0gdGhpcy5zaXplLndpZHRoICogMC41LCAyKSArIE1hdGgucG93KGxvY2FsUG9pbnQueSAtIHRoaXMuc2l6ZS5oZWlnaHQgKiAwLjUsIDIpO1xuXG4gICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnRlciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm1UcmFja2luZ1BvaW50KSB7XG4gICAgICAgICAgICB0aGlzLm1UcmFja2luZ1BvaW50LnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlU1EgPCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzKSB7XG4gICAgICAgICAgICB0aGlzLm1UcmFja2luZ1BvaW50ZXIgPSBldmVudC5pZGVudGlmaWVyO1xuICAgICAgICAgICAgdGhpcy5tVHJhY2tpbmdQb2ludCA9IGV2ZW50LnBvaW50LnJldGFpbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgcG9pbnRlciBtb3ZlZCBldmVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJNb3ZlZFxuICAgICAqIEBwYXJhbSB7Kn0gc2VuZGVyIC0gVGhlIHNlbmRlciBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2ZW50IC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGV2ZW50J3MgZGVzY3JpcHRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlUG9pbnRlck1vdmVkKHNlbmRlciwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmlkZW50aWZpZXIgPT09IHRoaXMubVRyYWNraW5nUG9pbnRlcikge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBldmVudC5wb2ludDtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlU1EgPSBNYXRoLnBvdyhwb2ludC54IC0gdGhpcy5tVHJhY2tpbmdQb2ludC54LCAyKSArIE1hdGgucG93KHBvaW50LnkgLSB0aGlzLm1UcmFja2luZ1BvaW50LnksIDIpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlU1EgPiB0aGlzLm1UcmFja2luZ01vdmVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1UcmFja2luZ1BvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1UcmFja2luZ1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubVRyYWNraW5nUG9pbnQucmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1UcmFja2luZ1BvaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBwb2ludGVyIG1vdmVkIGlucHV0IGV2ZW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfaGFuZGxlUG9pbnRlckVuZGVkXG4gICAgICogQHBhcmFtIHsqfSBzZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgLSBPYmplY3QgY29udGFpbmluZyB0aGUgZXZlbnQncyBkZXNjcmlwdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVQb2ludGVyRW5kZWQoc2VuZGVyLCBldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaWRlbnRpZmllciA9PT0gdGhpcy5tVHJhY2tpbmdQb2ludGVyKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFBvaW50ID0gdGhpcy5nbG9iYWxUb0xvY2FsUG9pbnQoZXZlbnQucG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VTUSA9IE1hdGgucG93KGxvY2FsUG9pbnQueCAtIHRoaXMuc2l6ZS53aWR0aCAqIDAuNSwgMikgKyBNYXRoLnBvdyhsb2NhbFBvaW50LnkgLSB0aGlzLnNpemUuaGVpZ2h0ICogMC41LCAyKTtcblxuICAgICAgICAgICAgdGhpcy5tVHJhY2tpbmdQb2ludGVyID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1UcmFja2luZ1BvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tVHJhY2tpbmdQb2ludC5yZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tVHJhY2tpbmdQb2ludCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZVNRIDwgdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChFdmVudHMuUEVSU09OQV9DTElDS0VELCB0aGlzLCBldmVudC5wb3NpdGlvbiwgbG9jYWxQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBlcnNvbmE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcGVyc29uYS9QZXJzb25hLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IElCaW5kYWJsZSBmcm9tICcuL0lCaW5kYWJsZS5qcyc7XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB1c2VkIHRvIHNhdmUgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiB2YWx1ZXMgaW4gYW4gb2JqZWN0LlxuICpcbiAqIEBjbGFzcyB0dXBsZVxuICovXG5leHBvcnQgY2xhc3MgVHVwbGUgZXh0ZW5kcyBJQmluZGFibGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYW4gaW5zdGFuY2Ugb2YgYSBUdXBsZSB3aXRoIGl0cyB2YWx1ZXMgYXMgdGhlIHBhc3NlZCBhcmd1bWVudHMuIEVhY2ggdmFsdWUgaXMgYWRkZWQgdG8gdGhlIG9iamVjdCB3aXRoXG4gICAgICogdGhlIG5vdGF0aW9uIGB2YWx1ZTFgIC4uLiBgdmFsdWVbbl1gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi4qfSB2YXJBcmdzIC0gVGhlIHZhbHVlcyB0byBhZGQgdGhpcyBvYmplY3QgYXMgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigvKiB2YXJBcmdzICovKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubUZyb3plbiA9IDA7XG4gICAgICAgIHRoaXMubVZhbHVlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMubVZhbHVlcy5wdXNoKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubVZhbHVlcy5mb3JFYWNoKChpZ25vcmVkLCBpKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ZhbHVlJyArIChpICsgMSksIHtcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHRoaXMuX2dldFZhbHVlQXRJbmRleChpKSxcbiAgICAgICAgICAgICAgICBzZXQ6IHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubUZyb3plbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBpbnN0YW5jZSBjYW5ub3QgYmUgbW9kaWZpZWQgYXMgaXRzIHZhbHVlcyBhcmUgZnJvemVuLiBUcnkgdW5mcmVlemluZyB0aGVtIGZpcnN0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlQXRJbmRleChpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubVZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICBkZWxldGUgdGhpcy5tVmFsdWVzO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnJlZXplcyB0aGUgdmFsdWVzIG9mIHRoaXMgdHVwbGUuIElmIGEgdmFsdWUgaXMgbW9kaWZpZWQgd2hpbGUgZnJvemUsIHRoZSBzZXR0ZXIgdGhyb3dzIGFuIGVycm9yLlxuICAgICAqIE5PVEU6IFRoZSBmcmVlemluZyBtZWNoYW5pc20gaXMgaW1wbGVtZW50ZWQgYXMgYSBzdGFjaywgbWVhbmluZyB0aGF0IHRvIHVuZnJlZXplIHRoZSB2YWx1ZXMgYHVuZnJlZXplVmFsdWVzYCBoYXNcbiAgICAgKiB0byBiZSBjYWxsZWQgdGhlIHNhbWUgbnVtYmVyIG9mIHRpbWVzIGFzIGBmcmVlemVWYWx1ZXNgLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBmcmVlemVWYWx1ZXNcbiAgICAgKi9cbiAgICBmcmVlemVWYWx1ZXMoKSB7XG4gICAgICAgICsrdGhpcy5tRnJvemVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuZnJlZXplcyB0aGUgdmFsdWVzIG9mIHRoaXMgdHVwbGUuXG4gICAgICogTk9URTogVGhlIGZyZWV6aW5nIG1lY2hhbmlzbSBpcyBpbXBsZW1lbnRlZCBhcyBhIHN0YWNrLCBtZWFuaW5nIHRoYXQgdG8gdW5mcmVlemUgdGhlIHZhbHVlcyBgdW5mcmVlemVWYWx1ZXNgIGhhc1xuICAgICAqIHRvIGJlIGNhbGxlZCB0aGUgc2FtZSBudW1iZXIgb2YgdGltZXMgYXMgYGZyZWV6ZVZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAbWV0aG9zIHVuZnJlZXplVmFsdWVzXG4gICAgICovXG4gICAgdW5mcmVlemVWYWx1ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5tRnJvemVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlcyBhcmUgbm90IGZyb3plbi4gQXJlIHlvdSBtaXNzaW5nIGEgZnJlZXplPycpO1xuICAgICAgICB9XG4gICAgICAgIC0tdGhpcy5tRnJvemVuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCBvZiB0aGlzIHR1cGxlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfZ2V0VmFsdWVBdEluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB2YWx1ZSB0byByZXRpZXZlLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFZhbHVlQXRJbmRleChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tVmFsdWVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggb2YgdGhpcyB0dXBsZS5cbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBieXBhc3NlcyB0aGUgdmFsdWUgZnJlZXppbmcgbWVjaGFuaXNtIG9mIHRoaXMgdHVwbGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zZXRWYWx1ZUF0SW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRWYWx1ZUF0SW5kZXgoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubVZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFR1cGxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvY29yZS9UdXBsZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBSZWN0IGZyb20gJy4vUmVjdC5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcyc7XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBib3VuZGluZyBib3ggaW4gMkQgc3BhY2UuXG4gKlxuICogQGNsYXNzIEJvdW5kaW5nQm94XG4gKi9cbmV4cG9ydCBjbGFzcyBCb3VuZGluZ0JveCBleHRlbmRzIFJlY3Qge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0geCAtIFggY29vcmRpbmF0ZSBvZiB0aGUgYm91bmRpbmcgYm94J3Mgb3JpZ2luLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0geSAtIFkgY29vcmRpbmF0ZSBvZiB0aGUgYm91bmRpbmcgYm94J3Mgb3JpZ2luLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gd2lkdGggLSBUaGUgYm91bmRpbmcgYm94J3Mgd2lkdGguXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBoZWlnaHQgLSBUaGUgYm91bmRpbmcgYm94J3MgaGVpZ2h0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5tVmVydGV4MDEgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHRoaXMubVZlcnRleDAyID0gbmV3IFBvaW50KHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICB0aGlzLm1WZXJ0ZXgwMyA9IG5ldyBQb2ludCh4ICsgd2lkdGgsIHkpO1xuICAgICAgICB0aGlzLm1WZXJ0ZXgwNCA9IG5ldyBQb2ludCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tVmVydGV4MDEucmVsZWFzZSgpO1xuICAgICAgICB0aGlzLm1WZXJ0ZXgwMi5yZWxlYXNlKCk7XG4gICAgICAgIHRoaXMubVZlcnRleDAzLnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5tVmVydGV4MDQucmVsZWFzZSgpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1WZXJ0ZXgwMTtcbiAgICAgICAgZGVsZXRlIHRoaXMubVZlcnRleDAyO1xuICAgICAgICBkZWxldGUgdGhpcy5tVmVydGV4MDM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1WZXJ0ZXgwNDtcbiAgICAgICAgZGVsZXRlIHRoaXMubUZvcndhcmRFdmVudDtcblxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IHZlcnRleDsgd2hlbiB1bnRyYW5zZm9ybWVkLCB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICpcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IHYxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tVmVydGV4MDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZCB2ZXJ0ZXg7IHdoZW4gdW50cmFuc2Zvcm1lZCwgdGhlIHRvcC1yaWdodCBjb3JuZXIgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgdjIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1WZXJ0ZXgwMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGhpcmQgdmVydGV4OyB3aGVuIHVudHJhbnNmb3JtZWQsIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgdjMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1WZXJ0ZXgwMztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm91cnRoIHZlcnRleDsgd2hlbiB1bnRyYW5zZm9ybWVkLCB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lciBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCB2NCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVZlcnRleDA0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhpcyBib3VuZGluZyBib3gncyBvcmlnaW4gYXMgd2VsbCBhcyBpdHMgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUgb2YgdGhlIG9yaWdpbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFkgY29vcmRpbmF0ZSBvZiB0aGUgb3JpZ2luLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgd2lkdGguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0LlxuICAgICAqL1xuICAgIHNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMubU9yaWdpbi52YWx1ZTEgPSB4O1xuICAgICAgICB0aGlzLm1PcmlnaW4udmFsdWUyID0geTtcbiAgICAgICAgdGhpcy5tU2l6ZS52YWx1ZTEgPSB3aWR0aDtcbiAgICAgICAgdGhpcy5tU2l6ZS52YWx1ZTIgPSBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5tVmVydGV4MDEuc2V0KHgsIHkpO1xuICAgICAgICB0aGlzLm1WZXJ0ZXgwMi5zZXQoeCwgeSArIGhlaWdodCk7XG4gICAgICAgIHRoaXMubVZlcnRleDAzLnNldCh4ICsgd2lkdGgsIHkpO1xuICAgICAgICB0aGlzLm1WZXJ0ZXgwNC5zZXQoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLm1Gb3J3YXJkRXZlbnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib3VuZGluZyBib3gncyBvcmlnaW4sIHdpZHRoLCBhbmQgaGVpZ2h0IHVzaW5nIHRoZSBwcm92aWRlZCBib3VuZGluZyBib3ggYXMgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRGcm9tQm91bmRpbmdCb3hcbiAgICAgKiBAcGFyYW0ge0JvdW5kaW5nQm94fSBib3VuZGluZ0JveCAtIFRoZSBib3VuZGluZ0JveCB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICAgICAqL1xuICAgIHNldEZyb21Cb3VuZGluZ0JveChib3VuZGluZ0JveCkge1xuICAgICAgICB0aGlzLm1PcmlnaW4udmFsdWUxID0gYm91bmRpbmdCb3gueDtcbiAgICAgICAgdGhpcy5tT3JpZ2luLnZhbHVlMiA9IGJvdW5kaW5nQm94Lnk7XG4gICAgICAgIHRoaXMubVNpemUudmFsdWUxID0gYm91bmRpbmdCb3gud2lkdGg7XG4gICAgICAgIHRoaXMubVNpemUudmFsdWUyID0gYm91bmRpbmdCb3guaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMubVZlcnRleDAxLnNldEZyb21Qb2ludChib3VuZGluZ0JveC52MSk7XG4gICAgICAgIHRoaXMubVZlcnRleDAyLnNldEZyb21Qb2ludChib3VuZGluZ0JveC52Mik7XG4gICAgICAgIHRoaXMubVZlcnRleDAzLnNldEZyb21Qb2ludChib3VuZGluZ0JveC52Myk7XG4gICAgICAgIHRoaXMubVZlcnRleDA0LnNldEZyb21Qb2ludChib3VuZGluZ0JveC52NCk7XG5cbiAgICAgICAgdGhpcy5tRm9yd2FyZEV2ZW50KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGlzIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBnaXZlbiB4LCB5IHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggeCBjb29yZGluYXRlIHRvIGluY2x1ZGUgaW4gdGhpcyBib3VuZGluZyBib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSB5IGNvb3JkaW5hdGUgdG8gaW5jbHVkZSBpbiB0aGlzIGJvdW5kaW5nIGJveFxuICAgICAqL1xuICAgIGluY2x1ZGUoeCwgeSkge1xuICAgICAgICBjb25zdCBtaW5YID0gTWF0aC5taW4odGhpcy52MS54LCB4KTtcbiAgICAgICAgY29uc3QgbWluWSA9IE1hdGgubWluKHRoaXMudjEueSwgeSk7XG4gICAgICAgIGNvbnN0IG1heFggPSBNYXRoLm1heCh0aGlzLnY0LngsIHgpO1xuICAgICAgICBjb25zdCBtYXhZID0gTWF0aC5tYXgodGhpcy52NC55LCB5KTtcbiAgICAgICAgdGhpcy5zZXQobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoaXMgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIGdpdmVuIGJvdW5kaW5nIGJveFxuICAgICAqIEBwYXJhbSB7Qm91bmRpbmdCb3h9IGJvdW5kaW5nQm94IGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIGluIHRoaXMgYm91bmRpbmcgYm94XG4gICAgICovXG4gICAgdW5pb24oYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgbWluWCA9IE1hdGgubWluKHRoaXMudjEueCwgYm91bmRpbmdCb3gudjEueCk7XG4gICAgICAgIGNvbnN0IG1pblkgPSBNYXRoLm1pbih0aGlzLnYxLnksIGJvdW5kaW5nQm94LnYxLnkpO1xuICAgICAgICBjb25zdCBtYXhYID0gTWF0aC5tYXgodGhpcy52NC54LCBib3VuZGluZ0JveC52NC54KTtcbiAgICAgICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KHRoaXMudjQueSwgYm91bmRpbmdCb3gudjQueSk7XG4gICAgICAgIHRoaXMuc2V0KG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCb3VuZGluZ0JveDtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvZ2VvbWV0cnkvQm91bmRpbmdCb3guanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNyBVbmNoYXJ0ZWQgU29mdHdhcmUgSW5jLlxuICogaHR0cDovL3d3dy51bmNoYXJ0ZWQuc29mdHdhcmUvXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgSUJpbmRhYmxlIGZyb20gJy4uL2NvcmUvSUJpbmRhYmxlLmpzJztcblxuLyoqXG4gKiAyRCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2JqZWN0IGluaXRpYWxpemVkIHdpdGggaWRlbnRpdHkgbWF0cml4LlxuICpcbiAqIFRoZSBtYXRyaXggY2FuIHN5bmNocm9uaXplIGEgY2FudmFzIGNvbnRleHQgYnkgc3VwcGx5aW5nIHRoZSBjb250ZXh0XG4gKiBhcyBhbiBhcmd1bWVudCwgb3IgbGF0ZXIgYXBwbHkgY3VycmVudCBhYnNvbHV0ZSB0cmFuc2Zvcm0gdG8gYW5cbiAqIGV4aXN0aW5nIGNvbnRleHQuXG4gKlxuICogQWxsIHZhbHVlcyBhcmUgaGFuZGxlZCBhcyBmbG9hdGluZyBwb2ludCB2YWx1ZXMuXG4gKlxuICogQGNsYXNzIE1hdHJpeFxuICovXG5leHBvcnQgY2xhc3MgTWF0cml4IGV4dGVuZHMgSUJpbmRhYmxlIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBNYXRyaXhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tQSA9IDE7XG4gICAgICAgIHRoaXMubUIgPSAwO1xuICAgICAgICB0aGlzLm1DID0gMDtcbiAgICAgICAgdGhpcy5tRCA9IDE7XG4gICAgICAgIHRoaXMubUUgPSAwO1xuICAgICAgICB0aGlzLm1GID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1BO1xuICAgICAgICBkZWxldGUgdGhpcy5tQjtcbiAgICAgICAgZGVsZXRlIHRoaXMubUM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1EO1xuICAgICAgICBkZWxldGUgdGhpcy5tRTtcbiAgICAgICAgZGVsZXRlIHRoaXMubUY7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gaW52ZXJzZSBtYXRyaXggb2YgY3VycmVudCBtYXRyaXguIFRoZSBtZXRob2QgcmV0dXJucyBhIG5ld1xuICAgICAqIG1hdHJpeCB3aXRoIHZhbHVlcyB5b3UgbmVlZCB0byB1c2UgdG8gZ2V0IHRvIGFuIGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKiBDb250ZXh0IGZyb20gcGFyZW50IG1hdHJpeCBpcyBub3QgYXBwbGllZCB0byB0aGUgcmV0dXJuZWQgbWF0cml4LlxuICAgICAqXG4gICAgICogQHR5cGUge01hdHJpeH1cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIGdldCBpbnZlcnNlKCkge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5tQTtcbiAgICAgICAgY29uc3QgYiA9IHRoaXMubUI7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLm1DO1xuICAgICAgICBjb25zdCBkID0gdGhpcy5tRDtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMubUU7XG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLm1GO1xuICAgICAgICBjb25zdCBkdCA9IChhICogZCAtIGIgKiBjKTtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXgoKS5hdXRvcmVsZWFzZSgpO1xuXG4gICAgICAgIG0ubUEgPSBkIC8gZHQ7XG4gICAgICAgIG0ubUIgPSAtYiAvIGR0O1xuICAgICAgICBtLm1DID0gLWMgLyBkdDtcbiAgICAgICAgbS5tRCA9IGEgLyBkdDtcbiAgICAgICAgbS5tRSA9IChjICogZiAtIGQgKiBlKSAvIGR0O1xuICAgICAgICBtLm1GID0gLShhICogZiAtIGIgKiBlKSAvIGR0O1xuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3J0LWhhbmQgdG8gcmVzZXQgY3VycmVudCBtYXRyaXggdG8gYW4gaWRlbnRpdHkgbWF0cml4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZXNldFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubUEgPSB0aGlzLm1EID0gMTtcbiAgICAgICAgdGhpcy5tQiA9IHRoaXMubUMgPSB0aGlzLm1FID0gdGhpcy5tRiA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZSBjdXJyZW50IG1hdHJpeCBhY2N1bXVsYXRpdmUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eCAtIHRyYW5zbGF0aW9uIGZvciB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR5IC0gdHJhbnNsYXRpb24gZm9yIHlcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZSh0eCwgdHkpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgdHgsIHR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBjdXJyZW50IG1hdHJpeCBhY2N1bXVsYXRpdmUgYnkgYW5nbGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9zIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIGFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHJvdGF0ZShhbmdsZSkge1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBjdXJyZW50IG1hdHJpeCBhY2N1bXVsYXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN4IC0gc2NhbGUgZmFjdG9yIHggKDEgZG9lcyBub3RoaW5nKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSAtIHNjYWxlIGZhY3RvciB5ICgxIGRvZXMgbm90aGluZylcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNjYWxlKHN4LCBzeSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybShzeCwgMCwgMCwgc3ksIDAsIDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGlwcyB0aGUgaG9yaXpvbnRhbCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZsaXBYXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICBmbGlwWCgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oLTEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGlwcyB0aGUgdmVydGljYWwgdmFsdWVzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBmbGlwWVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgZmxpcFkoKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGN1cnJlbnQgbWF0cml4IHRvIG5ldyBhYnNvbHV0ZSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhIC0gc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gc2tldyB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBza2V3IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZCAtIHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZSAtIHRyYW5zbGF0ZSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGYgLSB0cmFuc2xhdGUgeVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgc2V0KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgdGhpcy5tQSA9IGE7XG4gICAgICAgIHRoaXMubUIgPSBiO1xuICAgICAgICB0aGlzLm1DID0gYztcbiAgICAgICAgdGhpcy5tRCA9IGQ7XG4gICAgICAgIHRoaXMubUUgPSBlO1xuICAgICAgICB0aGlzLm1GID0gZjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBtYXRyaXggdG8gYSBuZXcgYWJzb2x1dGUgbWF0cml4IHVzaW5nIHRoZSBwcm92aWRlZCBtYXRyaXggYXMgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRGcm9tTWF0cml4XG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeCAtIHRoZSBtYXRyaXggdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIHNldEZyb21NYXRyaXgobWF0cml4KSB7XG4gICAgICAgIHRoaXMubUEgPSBtYXRyaXgubUE7XG4gICAgICAgIHRoaXMubUIgPSBtYXRyaXgubUI7XG4gICAgICAgIHRoaXMubUMgPSBtYXRyaXgubUM7XG4gICAgICAgIHRoaXMubUQgPSBtYXRyaXgubUQ7XG4gICAgICAgIHRoaXMubUUgPSBtYXRyaXgubUU7XG4gICAgICAgIHRoaXMubUYgPSBtYXRyaXgubUY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgY3VycmVudCBtYXRyaXggd2l0aCBuZXcgbWF0cml4IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGEyIC0gc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiMiAtIHNrZXcgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjMiAtIHNrZXcgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkMiAtIHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZTIgLSB0cmFuc2xhdGUgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmMiAtIHRyYW5zbGF0ZSB5XG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0oYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikge1xuICAgICAgICBjb25zdCBhMSA9IHRoaXMubUE7XG4gICAgICAgIGNvbnN0IGIxID0gdGhpcy5tQjtcbiAgICAgICAgY29uc3QgYzEgPSB0aGlzLm1DO1xuICAgICAgICBjb25zdCBkMSA9IHRoaXMubUQ7XG4gICAgICAgIGNvbnN0IGUxID0gdGhpcy5tRTtcbiAgICAgICAgY29uc3QgZjEgPSB0aGlzLm1GO1xuXG4gICAgICAgIC8qIG1hdHJpeCBvcmRlciAoY2FudmFzIGNvbXBhdGlibGUpOlxuICAgICAgICAgKiBhY2VcbiAgICAgICAgICogYmRmXG4gICAgICAgICAqIDAwMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tQSA9IGExICogYTIgKyBjMSAqIGIyO1xuICAgICAgICB0aGlzLm1CID0gYjEgKiBhMiArIGQxICogYjI7XG4gICAgICAgIHRoaXMubUMgPSBhMSAqIGMyICsgYzEgKiBkMjtcbiAgICAgICAgdGhpcy5tRCA9IGIxICogYzIgKyBkMSAqIGQyO1xuICAgICAgICB0aGlzLm1FID0gYTEgKiBlMiArIGMxICogZjIgKyBlMTtcbiAgICAgICAgdGhpcy5tRiA9IGIxICogZTIgKyBkMSAqIGYyICsgZjE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgY3VycmVudCBtYXRyaXggYnkgdGhlIG1hdHJpeCBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbXVsdGlwbHlcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBtdWx0aXBseSBieS5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuICAgIG11bHRpcGx5KG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obWF0cml4Lm1BLCBtYXRyaXgubUIsIG1hdHJpeC5tQywgbWF0cml4Lm1ELCBtYXRyaXgubUUsIG1hdHJpeC5tRik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJwb2xhdGUgdGhpcyBtYXRyaXggd2l0aCBhbm90aGVyIGFuZCBwcm9kdWNlIGEgbmV3IG1hdHJpeC5cbiAgICAgKiB0IGlzIGEgdmFsdWUgaW4gdGhlIHJhbmdlIFswLjAsIDEuMF0gd2hlcmUgMCBpcyB0aGlzIGluc3RhbmNlIGFuZFxuICAgICAqIDEgaXMgZXF1YWwgdG8gdGhlIHNlY29uZCBtYXRyaXguIFRoZSB0IHZhbHVlIGlzIG5vdCBjb25zdHJhaW5lZC5cbiAgICAgKlxuICAgICAqIENvbnRleHQgZnJvbSBwYXJlbnQgbWF0cml4IGlzIG5vdCBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCBtYXRyaXguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGludGVycG9sYXRlXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeCAtIHRoZSBtYXRyaXggdG8gaW50ZXJwb2xhdGUgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCAtIGludGVycG9sYXRpb24gWzAuMCwgMS4wXVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9IC0gbmV3IGluc3RhbmNlIHdpdGggdGhlIGludGVycG9sYXRlZCByZXN1bHRcbiAgICAgKi9cbiAgICBpbnRlcnBvbGF0ZShtYXRyaXgsIHQpIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXgoKS5hdXRvcmVsZWFzZSgpO1xuXG4gICAgICAgIG0ubUEgPSB0aGlzLm1BICsgKG1hdHJpeC5tQSAtIHRoaXMubUEpICogdDtcbiAgICAgICAgbS5tQiA9IHRoaXMubUIgKyAobWF0cml4Lm1CIC0gdGhpcy5tQikgKiB0O1xuICAgICAgICBtLm1DID0gdGhpcy5tQyArIChtYXRyaXgubUMgLSB0aGlzLm1DKSAqIHQ7XG4gICAgICAgIG0ubUQgPSB0aGlzLm1EICsgKG1hdHJpeC5tRCAtIHRoaXMubUQpICogdDtcbiAgICAgICAgbS5tRSA9IHRoaXMubUUgKyAobWF0cml4Lm1FIC0gdGhpcy5tRSkgKiB0O1xuICAgICAgICBtLm1GID0gdGhpcy5tRiArIChtYXRyaXgubUYgLSB0aGlzLm1GKSAqIHQ7XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgY3VycmVudCBtYXRyaXggdG8geCBhbmQgeSBwb2ludC5cbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFwcGx5VG9Qb2ludFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIHdoaWNoIHRoZSB0cmFuc2Zvcm1hdGlvbiB3aWxsIGJlIGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgdHJhbnNmb3JtZWQgcG9pbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgICAgICBjb25zdCB4ID0gcG9pbnQueDtcbiAgICAgICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgICAgIHBvaW50LnNldChcbiAgICAgICAgICAgIHggKiB0aGlzLm1BICsgeSAqIHRoaXMubUMgKyB0aGlzLm1FLFxuICAgICAgICAgICAgeCAqIHRoaXMubUIgKyB5ICogdGhpcy5tRCArIHRoaXMubUZcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmVyc2VseSBhcHBsaWVzIHRoZSBjdXJyZW50IG1hdHJpeCB0byB0aGUgcHJvdmlkZWQgcG9pbnQuIFVzZWZ1bCB0byBjb252ZXJ0IGJldHdlZW4gY29vcmRpbmF0ZSBzeXN0ZW1zLlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYXBwbHlUb1BvaW50SW52ZXJzZVxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9XG4gICAgICovXG4gICAgYXBwbHlUb1BvaW50SW52ZXJzZShwb2ludCkge1xuICAgICAgICBjb25zdCB4ID0gcG9pbnQueDtcbiAgICAgICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgICAgIGNvbnN0IGRldCA9IDEgLyAodGhpcy5tQSAqIHRoaXMubUQgLSB0aGlzLm1CICogdGhpcy5tQyk7XG5cbiAgICAgICAgcG9pbnQuc2V0KFxuICAgICAgICAgICAgKHRoaXMubUQgKiBkZXQgKiB4KSArICgtdGhpcy5tQyAqIGRldCAqIHkpICsgKCh0aGlzLm1GICogdGhpcy5tQyAtIHRoaXMubUUgKiB0aGlzLm1EKSAqIGRldCksXG4gICAgICAgICAgICAodGhpcy5tQSAqIGRldCAqIHkpICsgKC10aGlzLm1CICogZGV0ICogeCkgKyAoKC10aGlzLm1GICogdGhpcy5tQSArIHRoaXMubUUgKiB0aGlzLm1CKSAqIGRldClcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIGN1cnJlbnQgbWF0cml4IHRvIHRoZSBzcGVjaWZpZWQgYm91bmRpbmdCb3guXG4gICAgICogVGhpcyBhcHBsaWVzIHRoZSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgYm91bmRpbmcgYm94J3MgdmVydGljZXMgYW5kIGNvbXB1dGVzIHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94LlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nQm94IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYXBwbHlUb0JvdW5kaW5nQm94XG4gICAgICogQHBhcmFtIHtCb3VuZGluZ0JveH0gYm91bmRpbmdCb3ggLSBUaGUgYm91bmRpbmdCb3ggdG8gd2hpY2ggdGhlIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7Qm91bmRpbmdCb3h9IFRoZSB0cmFuc2Zvcm1lZCBib3VuZGluZ0JveC5cbiAgICAgKi9cbiAgICBhcHBseVRvQm91bmRpbmdCb3goYm91bmRpbmdCb3gpIHtcbiAgICAgICAgdGhpcy5hcHBseVRvUG9pbnQoYm91bmRpbmdCb3gudjEpO1xuICAgICAgICB0aGlzLmFwcGx5VG9Qb2ludChib3VuZGluZ0JveC52Mik7XG4gICAgICAgIHRoaXMuYXBwbHlUb1BvaW50KGJvdW5kaW5nQm94LnYzKTtcbiAgICAgICAgdGhpcy5hcHBseVRvUG9pbnQoYm91bmRpbmdCb3gudjQpO1xuXG4gICAgICAgIHZhciB4TWluID0gTWF0aC5taW4oYm91bmRpbmdCb3gudjEueCwgYm91bmRpbmdCb3gudjIueCwgYm91bmRpbmdCb3gudjMueCwgYm91bmRpbmdCb3gudjQueCk7XG4gICAgICAgIHZhciB4TWF4ID0gTWF0aC5tYXgoYm91bmRpbmdCb3gudjEueCwgYm91bmRpbmdCb3gudjIueCwgYm91bmRpbmdCb3gudjMueCwgYm91bmRpbmdCb3gudjQueCk7XG4gICAgICAgIHZhciB5TWluID0gTWF0aC5taW4oYm91bmRpbmdCb3gudjEueSwgYm91bmRpbmdCb3gudjIueSwgYm91bmRpbmdCb3gudjMueSwgYm91bmRpbmdCb3gudjQueSk7XG4gICAgICAgIHZhciB5TWF4ID0gTWF0aC5tYXgoYm91bmRpbmdCb3gudjEueSwgYm91bmRpbmdCb3gudjIueSwgYm91bmRpbmdCb3gudjMueSwgYm91bmRpbmdCb3gudjQueSk7XG5cbiAgICAgICAgYm91bmRpbmdCb3gub3JpZ2luLnNldCh4TWluLCB5TWluKTtcbiAgICAgICAgYm91bmRpbmdCb3guc2l6ZS5zZXQoeE1heCAtIHhNaW4sIHlNYXggLSB5TWluKTtcblxuICAgICAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdG8gYW55IGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdC4gVGhpcyBkb2VzIG5vdCBhZmZlY3QgdGhlXG4gICAgICogY29udGV4dCB0aGF0IG9wdGlvbmFsbHkgd2FzIHJlZmVyZW5jZWQgaW4gY29uc3RydWN0b3IgdW5sZXNzIGl0IGlzXG4gICAgICogdGhlIHNhbWUgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYXBwbHlUb0NvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRoZSB0cmFuc2Zvcm1hdGlvbiBpcyBhcHBsaWVkIHRvLlxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG4gICAgYXBwbHlUb0NvbnRleHQoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybSh0aGlzLm1BLCB0aGlzLm1CLCB0aGlzLm1DLCB0aGlzLm1ELCB0aGlzLm1FLCB0aGlzLm1GKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG1hdHJpeCBpcyBhbiBpZGVudGl0eSBtYXRyaXggKG5vIHRyYW5zZm9ybXMgYXBwbGllZCkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzSWRlbnRpdHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBpZGVudGl0eSAobm90IHRyYW5zZm9ybWVkKVxuICAgICAqL1xuICAgIGlzSWRlbnRpdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faXNFcXVhbCh0aGlzLm1BLCAxKSAmJlxuICAgICAgICB0aGlzLl9pc0VxdWFsKHRoaXMubUIsIDApICYmXG4gICAgICAgIHRoaXMuX2lzRXF1YWwodGhpcy5tQywgMCkgJiZcbiAgICAgICAgdGhpcy5faXNFcXVhbCh0aGlzLm1ELCAxKSAmJlxuICAgICAgICB0aGlzLl9pc0VxdWFsKHRoaXMubUUsIDApICYmXG4gICAgICAgIHRoaXMuX2lzRXF1YWwodGhpcy5tRiwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIGN1cnJlbnQgbWF0cml4IHdpdGggYW5vdGhlciBtYXRyaXguIFJldHVybnMgdHJ1ZSBpZiBlcXVhbFxuICAgICAqICh3aXRoaW4gZXBzaWxvbiB0b2xlcmFuY2UpLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpc0VxdWFsXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeCAtIG1hdHJpeCB0byBjb21wYXJlIHRoaXMgbWF0cml4IHdpdGhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VxdWFsKG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2lzRXF1YWwodGhpcy5tQSwgbWF0cml4Lm1BKSAmJlxuICAgICAgICB0aGlzLl9pc0VxdWFsKHRoaXMubUIsIG1hdHJpeC5tQikgJiZcbiAgICAgICAgdGhpcy5faXNFcXVhbCh0aGlzLm1DLCBtYXRyaXgubUMpICYmXG4gICAgICAgIHRoaXMuX2lzRXF1YWwodGhpcy5tRCwgbWF0cml4Lm1EKSAmJlxuICAgICAgICB0aGlzLl9pc0VxdWFsKHRoaXMubUUsIG1hdHJpeC5tRSkgJiZcbiAgICAgICAgdGhpcy5faXNFcXVhbCh0aGlzLm1GLCBtYXRyaXgubUYpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCBzb21lIHRvbGVyYW5jZSAoZXBzaWxvbilcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2lzRXF1YWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZjEgLSBmbG9hdCAxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGYyIC0gZmxvYXQgMlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzRXF1YWwoZjEsIGYyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhmMSAtIGYyKSA8IDFlLTE0O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWF0cml4O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvZ2VvbWV0cnkvTWF0cml4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IElCaW5kYWJsZSBmcm9tICcuLi9jb3JlL0lCaW5kYWJsZS5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcyc7XG5pbXBvcnQgU2l6ZSBmcm9tICcuL1NpemUuanMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL0V2ZW50cy5qcyc7XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBib3VuZGluZyBib3ggaW4gMkQgc3BhY2UuXG4gKlxuICogQGNsYXNzIEJvdW5kaW5nQm94XG4gKi9cbmV4cG9ydCBjbGFzcyBSZWN0IGV4dGVuZHMgSUJpbmRhYmxlIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IHggLSBYIGNvb3JkaW5hdGUgb2YgdGhlIGJvdW5kaW5nIGJveCdzIG9yaWdpbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcj19IHkgLSBZIGNvb3JkaW5hdGUgb2YgdGhlIGJvdW5kaW5nIGJveCdzIG9yaWdpbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcj19IHdpZHRoIC0gVGhlIGJvdW5kaW5nIGJveCdzIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gaGVpZ2h0IC0gVGhlIGJvdW5kaW5nIGJveCdzIGhlaWdodC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubU9yaWdpbiA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdGhpcy5tU2l6ZSA9IG5ldyBTaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHRoaXMubUZvcndhcmRFdmVudCA9ICgpID0+IHRoaXMuZW1pdChFdmVudHMuR0VPTUVUUllfVkFMVUVfQ0hBTkdFRCwgdGhpcywgdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5tT3JpZ2luLm9uKEV2ZW50cy5HRU9NRVRSWV9WQUxVRV9DSEFOR0VELCB0aGlzLm1Gb3J3YXJkRXZlbnQpO1xuICAgICAgICB0aGlzLm1TaXplLm9uKEV2ZW50cy5HRU9NRVRSWV9WQUxVRV9DSEFOR0VELCB0aGlzLm1Gb3J3YXJkRXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubU9yaWdpbi5vZmYoRXZlbnRzLkdFT01FVFJZX1ZBTFVFX0NIQU5HRUQsIHRoaXMubUZvcndhcmRFdmVudCk7XG4gICAgICAgIHRoaXMubVNpemUub2ZmKEV2ZW50cy5HRU9NRVRSWV9WQUxVRV9DSEFOR0VELCB0aGlzLm1Gb3J3YXJkRXZlbnQpO1xuXG4gICAgICAgIHRoaXMubU9yaWdpbi5yZWxlYXNlKCk7XG4gICAgICAgIHRoaXMubVNpemUucmVsZWFzZSgpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1PcmlnaW47XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1TaXplO1xuICAgICAgICBkZWxldGUgdGhpcy5tRm9yd2FyZEV2ZW50O1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9pbnQgYXQgd2hpY2ggdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3gncyBvcmlnaW4gaXMgYXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IG9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU9yaWdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2l6ZSBvZiB0aGlzIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAdHlwZSB7U2l6ZX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWCBjb29yZGluYXRlIG9mIHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94J3Mgb3JpZ2luLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1PcmlnaW4ueDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBYIGNvb3JkaW5hdGUgb2YgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3gncyBvcmlnaW4uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICovXG4gICAgc2V0IHgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tT3JpZ2luLnggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBZIGNvb3JkaW5hdGUgb2YgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3gncyBvcmlnaW4uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU9yaWdpbi55O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFkgY29vcmRpbmF0ZSBvZiB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCdzIG9yaWdpbi5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBzZXQgeSh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1PcmlnaW4ueSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBib3VuZGluZyBib3gncyB3aWR0aC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVNpemUud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm91bmRpbmcgYm94J3Mgd2lkdGguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICovXG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubVNpemUud2lkdGggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm91bmRpbmcgYm94J3MgaGVpZ2h0LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVNpemUuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvdW5kaW5nIGJveCdzIGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubVNpemUuaGVpZ2h0ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGlzIGJvdW5kaW5nIGJveCdzIG9yaWdpbiBhcyB3ZWxsIGFzIGl0cyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFggY29vcmRpbmF0ZSBvZiB0aGUgb3JpZ2luLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gWSBjb29yZGluYXRlIG9mIHRoZSBvcmlnaW4uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQuXG4gICAgICovXG4gICAgc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5tT3JpZ2luLnZhbHVlMSA9IHg7XG4gICAgICAgIHRoaXMubU9yaWdpbi52YWx1ZTIgPSB5O1xuICAgICAgICB0aGlzLm1TaXplLnZhbHVlMSA9IHdpZHRoO1xuICAgICAgICB0aGlzLm1TaXplLnZhbHVlMiA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLm1Gb3J3YXJkRXZlbnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZWN0cyBvcmlnaW4gYW5kIHNpemUgYnkgY29weWluZyB0aGUgdmFsdWVzIG9mIHRoZSBzdXBwbGllZCByZWN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRGcm9tUmVjdFxuICAgICAqIEBwYXJhbSB7UmVjdH0gcmVjdCAtIHRoZSByZWN0IGZyb20gd2hpY2ggdGhlIG5ldyB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgZnJvbS5cbiAgICAgKi9cbiAgICBzZXRGcm9tUmVjdChyZWN0KSB7XG4gICAgICAgIHRoaXMubU9yaWdpbi52YWx1ZTEgPSByZWN0Lng7XG4gICAgICAgIHRoaXMubU9yaWdpbi52YWx1ZTIgPSByZWN0Lnk7XG4gICAgICAgIHRoaXMubVNpemUudmFsdWUxID0gcmVjdC53aWR0aDtcbiAgICAgICAgdGhpcy5tU2l6ZS52YWx1ZTIgPSByZWN0LmhlaWdodDtcblxuICAgICAgICB0aGlzLm1Gb3J3YXJkRXZlbnQoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9nZW9tZXRyeS9SZWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL1ByaW1pdGl2ZS5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQuanMnO1xuXG4vKipcbiAqIENsYXNzIHRvIGRyYXcgYSBsaW5lIGdvaW5nIHRocm91Z2ggbXVsdGlwbGUgdmVydGljZXMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgYWxsIHRoZSBvdGhlciBwcmltaXRpdmVzIHRoYXQgYXJlXG4gKiByZW5kZXJlZCBiYXNlZCBvbiB2ZXJ0aWNlcy5cbiAqXG4gKiBAY2xhc3MgUG9seWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFBvbHlsaW5lIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5Qb2ludH0gdmVydGljZXMgLSBUaGUgdmVydGljZXMgb2YgdGhpcyBsaW5lLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIC4uLnZlcnRpY2VzKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1WZXJ0aWNlcyA9IFtdO1xuICAgICAgICBjb25zdCB2ZXJ0ZXhBcnJheSA9IHZlcnRpY2VzWzBdIGluc3RhbmNlb2YgQXJyYXkgPyB2ZXJ0aWNlc1swXSA6IHZlcnRpY2VzO1xuICAgICAgICB2ZXJ0ZXhBcnJheS5mb3JFYWNoKHBvaW50ID0+IHRoaXMubVZlcnRpY2VzLnB1c2goUG9pbnQuZnJvbVBvaW50KHBvaW50KSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tVmVydGljZXMuZm9yRWFjaChwb2ludCA9PiBwb2ludC5yZWxlYXNlKCkpO1xuICAgICAgICB0aGlzLm1WZXJ0aWNlcy5sZW5ndGggPSAwO1xuICAgICAgICBkZWxldGUgdGhpcy5tVmVydGljZXM7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwYXRoIG9mIHRoaXMgc2hhcGUgdG8gdGhlIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJQYXRoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQYXRoKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMubVZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGxldCB2ZXJ0ZXggPSB0aGlzLl9nZXRWZXJ0ZXhJblBpeGVscyh0aGlzLm1WZXJ0aWNlc1swXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh2ZXJ0ZXgueCwgdmVydGV4LnkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDEsIG4gPSB0aGlzLm1WZXJ0aWNlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0aGlzLl9nZXRWZXJ0ZXhJblBpeGVscyh0aGlzLm1WZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8odmVydGV4LngsIHZlcnRleC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNsb3NlUGF0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWxsLCBzdHJva2UsIGV0Yy4gYXMgZGVzY3JpYmVkIGluIHRoZSBwcm92aWRlZCBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfYXBwbHlSZW5kZXJPcHRpb25zXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hcHBseVJlbmRlck9wdGlvbnMoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VUeXBlICYmIG9wdGlvbnMuc3Ryb2tlID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwVHlwZTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBvcHRpb25zLnN0cm9rZUNvbG9yO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlVHlwZSA9PT0gUG9seWxpbmUuU1RST0tFX0lOTkVSKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsbEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gb3B0aW9ucy5zdHJva2UgKiAyO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3Ryb2tlVHlwZSA9PT0gUG9seWxpbmUuU1RST0tFX09VVEVSKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBvcHRpb25zLnN0cm9rZSAqIDI7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5maWxsRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbGxFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IG9wdGlvbnMuc3Ryb2tlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5maWxsRW5hYmxlZCkge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvcjtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFZlcnRleEluUGl4ZWxzKHZlcnRleCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5wYXJlbnQgJiYgdmVydGV4LnhVbml0cyA9PT0gUG9pbnQuVU5JVF9UWVBFX1BFUkNFTlRBR0UgPyB0aGlzLnBhcmVudC5waXhlbFNpemUud2lkdGggKiB2ZXJ0ZXgueCA6IHZlcnRleC54O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5wYXJlbnQgJiYgdmVydGV4LnlVbml0cyA9PT0gUG9pbnQuVU5JVF9UWVBFX1BFUkNFTlRBR0UgPyB0aGlzLnBhcmVudC5waXhlbFNpemUuaGVpZ2h0ICogdmVydGV4LnkgOiB2ZXJ0ZXgueTtcbiAgICAgICAgcmV0dXJuIFBvaW50Lmluc3RhbmNlKHgsIHkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9seWxpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS9ncmFwaGljcy9wcmltaXRpdmVzL1BvbHlsaW5lLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL1ByaW1pdGl2ZS5qcyc7XG5cbi8qKlxuICogSW5pdGlhbCBvZmZzZXQgb2YgdGhlIHNlbWktY2lyY2xlIHNvIGl0IHN0YXJ0cyBkcmF3aW5nIGZyb20gdGhlIHRvcCBvZiB0aGUgY2lyY2xlLlxuICpcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IElOSVRJQUxfT0ZGU0VUID0gTWF0aC5QSSAqIC0wLjU7XG5cbi8qKlxuICogQ2xhc3MgdXNlZCB0byBkcmF3IGEgc2VjdGlvbiBvZiBhIGNpcmNsZSB1c2luZyB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAqXG4gKiBAY2xhc3MgU2VtaUNpcmNsZVxuICovXG5leHBvcnQgY2xhc3MgU2VtaUNpcmNsZSBleHRlbmRzIFByaW1pdGl2ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZSB0aGlzIGNsYXNzIHdpbGwgYmUgZHJhd2luZyBhIHNlY3Rpb24gb2YuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQsIGluIHJhZGlhbnMsIGZyb20gd2hpY2ggdGhlIHNlY3Rpb24gc2hvdWxkIHN0YXJ0IGRyYXdpbmcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIC0gVGhlIGFuZ2xlIGxlbmd0aCwgaW4gcmFkaWFucywgb2YgdGhlIHNlY3Rpb24gdG8gZHJhdy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBvYmplY3QuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmFkaXVzLCBvZmZzZXQsIGFuZ2xlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1SYWRpdXMgPSByYWRpdXM7XG4gICAgICAgIHRoaXMubU9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5tQW5nbGUgPSBhbmdsZTtcbiAgICAgICAgdGhpcy5zaXplLnNldChyYWRpdXMgKiAyLCByYWRpdXMgKiAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1SYWRpdXM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1PZmZzZXQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1BbmdsZTtcblxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlIHRoaXMgY2xhc3Mgd2lsbCBiZSBkcmF3aW5nIGEgc2VjdGlvbiBvZi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVJhZGl1cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHJhZGl1cyBvZiB0aGUgY2lyY2xlIHRoaXMgY2xhc3Mgd2lsbCBiZSBkcmF3aW5nIGEgc2VjdGlvbiBvZi5cbiAgICAgKi9cbiAgICBzZXQgcmFkaXVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tUmFkaXVzKSB7XG4gICAgICAgICAgICB0aGlzLm1SYWRpdXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZS5zZXQodGhpcy5tUmFkaXVzICogMiwgdGhpcy5tUmFkaXVzICogMik7XG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0LCBpbiByYWRpYW5zLCBmcm9tIHdoaWNoIHRoZSBzZWN0aW9uIHNob3VsZCBzdGFydCBkcmF3aW5nLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tT2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBuZXcgb2Zmc2V0LCBpbiByYWRpYW5zLCBmcm9tIHdoaWNoIHRoZSBzZWN0aW9uIHNob3VsZCBzdGFydCBkcmF3aW5nLlxuICAgICAqL1xuICAgIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLm1PZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMubU9mZnNldCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1JlZHJhdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFuZ2xlIGxlbmd0aCwgaW4gcmFkaWFucywgb2YgdGhlIHNlY3Rpb24gdG8gZHJhdy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGFuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tQW5nbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gVGhlIG5ldyBhbmdsZSBsZW5ndGgsIGluIHJhZGlhbnMsIG9mIHRoZSBzZWN0aW9uIHRvIGRyYXcuXG4gICAgICovXG4gICAgc2V0IGFuZ2xlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tQW5nbGUpIHtcbiAgICAgICAgICAgIHRoaXMubUFuZ2xlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwYXRoIG9mIHRoaXMgc2hhcGUgdG8gdGhlIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9yZW5kZXJQYXRoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY2FudmFzIGNvbnRleHQgaW4gd2hpY2ggdGhlIGRyYXdpbmcgb3BlcmF0aW9ucyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSByZW5kZXJpbmcgb3B0aW9ucyBmb3IgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQYXRoKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJhZGl1cyA9IHRoaXMubVJhZGl1cztcbiAgICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlVHlwZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlVHlwZSA9PT0gU2VtaUNpcmNsZS5TVFJPS0VfSU5ORVIpIHtcbiAgICAgICAgICAgICAgICByYWRpdXMgLT0gb3B0aW9ucy5zdHJva2UgKiAwLjU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3Ryb2tlVHlwZSA9PT0gU2VtaUNpcmNsZS5TVFJPS0VfT1VURVIpIHtcbiAgICAgICAgICAgICAgICByYWRpdXMgKz0gb3B0aW9ucy5zdHJva2UgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIDApO1xuXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQuYXJjKHRoaXMubVJhZGl1cywgdGhpcy5tUmFkaXVzLCByYWRpdXMsIElOSVRJQUxfT0ZGU0VUICsgdGhpcy5tT2Zmc2V0LCBJTklUSUFMX09GRlNFVCArIHRoaXMubU9mZnNldCArIHRoaXMubUFuZ2xlLCBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRpb25zLmNsb3NlUGF0aCkge1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2VtaUNpcmNsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZXZpL2dyYXBoaWNzL3ByaW1pdGl2ZXMvU2VtaUNpcmNsZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFVuY2hhcnRlZCBTb2Z0d2FyZSBJbmMuXG4gKiBodHRwOi8vd3d3LnVuY2hhcnRlZC5zb2Z0d2FyZS9cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBJT2JqZWN0IGZyb20gJy4uLy4uL2NvcmUvSU9iamVjdC5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQuanMnO1xuXG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgdXNlZCB0byBkZXNjcmliZSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICovXG5leHBvcnQgY2xhc3MgUG9pbnRlckV2ZW50IGV4dGVuZHMgSU9iamVjdCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZSB0aGlzIHBvaW50ZXIgcmVwcmVzZW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkZW50aWZpZXIgLSBBIG51bWJlciBpZGVudGlmeWluZyB0aGUgbW91c2Ugb3IgdG91Y2ggd2hpY2ggdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSB0aW1lc3RhbXAgb2YgdGhpcyBldmVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB4LCB5LCBpZGVudGlmaWVyLCB0aW1lc3RhbXApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tVHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubVBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB0aGlzLm1JZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5tVGltZXN0YW1wID0gdGltZXN0YW1wO1xuXG4gICAgICAgIHRoaXMubVBvaW50LmZyZWV6ZVZhbHVlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgb2JqZWN0LiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBvYmplY3QgcmVhY2hlcyB6ZXJvLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tUG9pbnQudW5mcmVlemVWYWx1ZXMoKTtcbiAgICAgICAgdGhpcy5tUG9pbnQucmVsZWFzZSgpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1UeXBlO1xuICAgICAgICBkZWxldGUgdGhpcy5tUG9pbnQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1JZGVudGlmaWVyO1xuICAgICAgICBkZWxldGUgdGhpcy5tVGltZXN0YW1wO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgdHlwZSB0aGlzIHBvaW50ZXIgZXZlbnQgcmVwcmVzZW50cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1UeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBwb2ludCB3aGVyZSB0aGlzIGV2ZW50IG9yaWdpbmF0ZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICovXG4gICAgZ2V0IHBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tUG9pbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIFggY29vcmRpbmF0ZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVBvaW50Lng7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubVBvaW50Lnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBudW1iZXIgdGFodCBpZGVudGlmaWVzIHRoZSBtb3VzZSBvciB0b3VjaCB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubUlkZW50aWZpZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVzdGFtcCBvZiB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdGltZXN0YW1wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tVGltZXN0YW1wO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckV2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JldmkvcGx1Z2lucy9pbnB1dC9Qb2ludGVyRXZlbnQuanMiLCJcbmV4cG9ydCBjb25zdCBGT05UX0FXRVNPTUUgPSAnZDA5R1JnQUJBQUFBQVg3b0FBMEFBQUFDaHF3QUJBQUhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJNQUFBQUJ3QUFBQWNhNzVIdVVkRVJVWUFBQUZNQUFBQUh3QUFBQ0FDOEFBRVQxTXZNZ0FBQVd3QUFBQStBQUFBWUlneWVrQmpiV0Z3QUFBQnJBQUFBV2tBQUFMeUNyODZmMmRoYzNBQUFBTVlBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFBeUFBQVY5NUFBSk12SS8zcmsxb1pXRmtBQUZpbkFBQUFETUFBQUEyRUlubExXaG9aV0VBQVdMUUFBQUFId0FBQUNRUEF3cTFhRzEwZUFBQll2QUFBQUwwQUFBSzhFVjVHSVZzYjJOaEFBRmw1QUFBQnhZQUFBc1FBdldpWEcxaGVIQUFBV3o4QUFBQUh3QUFBQ0FETEFJY2JtRnRaUUFCYlJ3QUFBSkVBQUFFaHVPWGk2eHdiM04wQUFGdllBQUFENFVBQUJwMXI0K2JvUUFBQUFFQUFBQUF6RDJpendBQUFBRExUend3QUFBQUFOUXhhTGw0bkdOZ1pHQmc0QU5pQ1FZUVlHSmdaR0JrT2dRa1djQThCZ0FNdUFEM0FIaWNZMkJteTJTY3dNREt3TURTdzJMTXdNRFFCcUdaaWhrWUdMc1k4SUNDeXFKaUJnY0doYThNYkF6L2dYdzJCa2FRTUNPU0VnVUdSZ0RReXdodUFBQjRuTTJTMzByaWNSREY1MmRxWmViNVBzQWk2Z05FdllESVBvQUllOU5GaUU4Z1BvSDRCT0lUaUpjYkxDTFJkY2hlN0tVSVcxdGIrY1BkYXZ0dmM2YjExbCsvVGVpaTZ5VTZNR2M0TU13SGhoR1JCWm5YQi9GQ0YrOHVUTjV6am5yRHNOZWtJREZabDR4c1MxZDI1WnNjWlhPNWRLNmlLVTFyWG90YTFxcld0YWx0N2VxT0R0VFhpYzZZWXBwcnpMUElNcXVzczhrMnU5empnRDRubkZuSzBwYTNvcFd0YW5Wcld0dTZ0bWNEODIweWxTQUl5Um41L0lvbzZqU3JCUzFwUld2YTBKWjJ0S2Q5SGVwWWxVTEhETmRaWUlrVjF0aGdpeDMyMk9lUVk2cUpPY3Rhd1VwV3NabzFyR1VkNjFuZmhqYitSd3pPZ3ExZ00vZ1VmQXcyL0t2Ui9laUxXM1ZKbDNETGJza3R1cmlMdWFoYmNCRk04UmVQTUJDS0IweHdqenZjNGdiWHVNSWwvdUFDNXpqRGIvekNHRDVHT01VSmp2RVRSempFRHh4Z0g5OVh2ODZ2L2JieTR2S0M5U0toUlY0UHpGL2hQU2dlU3l4R2swdkxLLzk1N3hOaStjUHpBQUFBQUFBQUFmLy9BQUo0bkx5OUNZQlUxWlV3L082OWI2bDllN1YxZFhWM1ZWZlZxK3B1Nkc1cWJYb3RtcDF1ZGdRRXhCWkZrVVZCUVJBWFNpRXFpQnNvNHQ1b1JNa3lZeGJ6SlVhY3lxYVRSV0lTWWphLytkb2tKcG00akpQa054RzZIdCs1OTFWVlZ6Y042TXo4SDNTOWQvZjEzSHZQT2ZlYzh6ak1iZVk0WWhQaHdVa2Nsd25hZzhRZXRBK2h2SnJkakFjM0M0RlRtMFh1RkVmL0llNlNNNXo0akpEamFzRGpsSkE5R0hjN3hWQ3dYa21tRTBFN1VsTEpicFFJeG11UitFeFQ0UzZVOVNtS2J6aEhueWhidUtzcEhQTUlPVThzTE13SVFYU0JVNUlLL0JFTzcyZ0tlYXAxdW1wYUJ3ZDFjRkJIRTNqc1RndXViOGJKYnB5SWUrekNhRzh5blVIcFJOd3RjdFBXWGJYaXFuWFQ0RFh4Nm1XRjBWNmxsbVJOdGxpYkVEZzlHSi9YNUhJMXpic0NYbEZjOVg2aG96S0F2RmFYTUNDT2IrTXdhME1PMmlCeFFlaTNqUXZRSDRLdTFrY1JQTUlLdGpuUzRRRHZkcmhnR054OFR2MVl2VmY5R0Vub09pTDFKOU5oOWRoWDNycFBQWDM4Mm11UEl3SFZJdUg0dFRlalpSRU1DWkNrSlZaenlYNEZMYjE1Sk1XMXg5WFQ5NzMxRmZWWWhNNEdkeVluY1FMSCtiZ3ViaTdIUmV5aXhFc1czQVFqZ0tKS1JJbmFuVzRZNjdTOUV6Y1RtQVBSNWZTNFBiVjhCNDUzazB3NjA0MHlkbTF5VW5ZNlBUQlF1VUJFL2R1VGlleW1Wb1JhTjJVVFQ2cC9pd1JrczVBM3kwZ1FUYnBUV2JOODhGdHZpTzMxbVdZblFzN21USDI3K01hMzBwZmtWdmVleXZhdVh0MHI1SHRYQndnWHJqMnhwNmwxMHFUV3BqMG5hc01Geml6TGZBdzc5SGFkUVpETnoyODkvS3d3eVJkeE9DSytTY0t6aDVzZUdEaWRwN2w1V29ZMng3UnZPYzdQY1R3TWFUT2ZnaGJHYTdHbm04Q0UwakVsanlZZGhmc05vZjdPRm5Xbys3WnJGNFREQzY2OXJYdElmYWZ3UU02QlYrakNsMTV4NzlTMy90RTBPeHNPWjJjMy9lT3QvLzFPNFhtdDdDL0MzQTF4OVJxTXlsQWNuYmVJQUU4QTBJeE13VFFUa2ROeGp5ekFtUGpVaDVZaWwxTjJxVDFxRDB5b0N5OVZINnhxUXgrOUxYZktiNk9QMnNpTmJwLzZwR3FTeks0YTAzdnZtV3Bjb2dYOURhMnBka1gwczlGckRRM3E1Tmw2dWo1d3VXNDloVjQ5aWhoaGFrbEVLTFhqM00zZ3Q2QzR1dUw0Y1hVRmlzOUdPOUdONkRYV3JvWnpOd3M3VVVNM3VsVzl2VnY5aGJyeXRkZUlvZFRNK0hsYVNkdVlFK2pZdStncWpoUWhKQWtEN3c1azRyV0VzNGtCeFpZT0NOd3R5NGMvdC93V2UvUE1iZjI3MGNiZC9kdG1OdHZQY0crcjMzNzdiZFM5ZDlQamoyKzY2T0ZITmszUDVhWnZldVJoOGkwdC9HMFlCeU5kUHhKZFAxYXVqbXZoZXJqNTNLWGN0ZHd1N2o3dUtlNmZPVTVJSlpVbVZDL1dJS2U3QXdFSVg4Q1A3RW1GUVhnUjVOSFkrRStaL2tMMWpWMDRLS2Y0MkM1MmpnZlBLYjRDUnowRW5zUGNTSXhRa1ZQTlZhYTZVSm13NUQ1bWkwYUVSWk10UjZGSHgzTVdmSmdWck5JblB4Sitlc1JKS3BPbzQ1WlM0WHpwRkt0YllBdVdwOEF0VnM0bjNabEhqVkFWR2pOaUY0Z25YSDlTNVpMOS9Vbk1uaU51a2p0WERPYm9sdG1mUlBTSmYxVGhHZjdSdVdJNHRqRFpYbk0yTEhMSXBiV3FDMm10c28veGo0My9uL2FQclE5emJURTFIMnRyaTZFc2ZZNjRjYTdTVjhpZE8rNlRwNngwb3dCejBnZjZaZGxaR0hHU2NVTXZtS0NpTUFDaGNlZmlmM3dXUHZtb0NoQXp6TUlJaEozbXpoMVg2ZjR2anRXb29ZQno2a2JPSXQ3SmY1bHpndy9PQjBtc2IwRklTZllnT0JIMDhLaEQ0cDMrd29TNy9BdjhkNm1IL0g3cVFBcStuL3JKWHhhd0tQOWRhRDMxKy8zcXIvQUQ0SVZ5cnpuemdlRGdEM0FoamdzN3JVaXNqK29STFZ0Slp2U2p5M2M3SlQwU0hLeGs5ZGZxcjdXU2tBS3VZbTFJS1piK2F3ZzliNnkvWElxR3UyajdSUWpPd1duYUREZHBEem90SVcxdU9tQmJoa2ZjWFlQZzdFZEZMSXM3RjViRmM3SjVTRFlEaWpJRTZNYUljeFR1MVpjNkYrNkZoODdLU1oxL3FFRElYbHpmZHc2RXJMSlBWczdEdFo0RnRaK3MvWVU4clJWblAxMnJXWHMvY1V1TFo3eElsMXNEbDZKWUVCYjVBTFFtbFhSazBtNlBXNVFzMFBwYXdCTWhTSWsySThBVlBXNEgzYk8xSFpyaTFEdFBxTDlYLzFYOS9ZbWRSdzQwWFYwWHNEYXUyYkJ3My9FM2p1OWJ1R0ZOb3pWUXQ3N3h3SkZDcm45ZFAvemgzT00wNWM0VHlQLzQxMUR2cG9DbHFmSHF3SnczYjF3SHlTSFh1aHZmbkJPNHVySEpFdGlrdm9MbkZOZ0dqZGtHRGYrRU1qNDRzaTl3a1RLNGFFQVNzV3QrMnI3eC9PaENmczVoeVZzYzdJRnluODQ5VUhJNHJsT1pFMlhoK1pjQ2MyUHFSdGNOMDVlRjBDRDBsMVBNSTFEUHlId3dldUlhOENlVmV0SHBqbE1JZ3ZVcHdZdzRZVVpDc0VaRkNmN1RWc055alVvVWtKUW9SUk1CbDRlZ1prUUhBeFp3cGhTYWdGV2NCbHlmOVJBV3RDY0RhRFJRQVJTRnRpQUpnbW9CN2c2ZFBIVG9KRDVrTTMxRGRvWm1HZlRWOTd0TmxuMFRXbXhtcWViZkxDN2tuOVJ3ajhGcU1kNGFsWFRXV1k1cXkvOHkyMnpHbHl4VnNha0d2ZThCdDlrOE92RzllcXZaZEZ1WUpmWlpJVEYyMHhvT29VMy9abkpqZnpvU1gyN3lHU0wzNmpkNnJIZkYvWGJ6MTIydURYcmpkV21EMldSMHJheUtUNnJHTGpOTDI5dzhlYUhKWkRDSDd6TnNxRXhzMko3UVdiVEVyWDdzWW1jSDRLMGpPRWdITjVXN1NzTkRLbWRadUlCZkJ0cldXVXRwMUc2RWdqQzZRVkVTR0tTVkVaWlFhVTFuR0MwTFk4ak9FSWVGelNrODBEbmN1ZUdjeFVwSWxsZ3RoUUdVYjVVTTZuY01Fcm5XWVJsWTNUc00rTlFBQTUzVURPczhlc0xNczg1QUtZdURCQ3JBeUhJT2Q2R1dmSFc0SDJEZUh1SG5iTk5qckg4SWdvZjdGOSs0YlRINU9xdjl1VWd5R1huT29hMS9Id3pZbFFMaFpMYitXZGVnNDBYOEs2Vkg3Z3dBV29pZERGRUthNVNTQmxBcTdzY3V1d2MyRmNCUDFkd1p3TGtBVjhVOXVBZjluMjZkbVpoMWhmNUN2OGxrMW5YcnNBSC9PTEE4OERlMk5INWp3RGlnQmloaVN4RmROSVI0aEg2dEtuaktIRDJXOEpUQ3YrZ1Exczh4Vk92d01wL3ZSOStoZlZQWGZZM1MvTnJlU3FkWWhwYkR1UVZRNnhxRFFIb2tlMUNKd3BtajlTSm9GMTcyeDlwaXA5aVpTbkt4QWY4ZXRNTmdVbDh6b2N2VkFVQjhPSDZQZnlCMk9rZmpSVGk3WS81cDZsMDFKalRaZE1yQnc5bU9CaGxUZzVUWHBoUDI3Z2tqbUsyMjd4VEJock0xbzRBRjJXcFJJTTNaTU95bXNMWER6azVnazlCMmhDRU5IQVlQbkZKL2VlckFnVk1vZGdwZGQwSjlTbDJ0UG5YaUJMb01QWTB1STBOcUdXNG9MQlJVU0hXZ21BTmZXcG4weEFrMmozSEFsK2JCOW1nSGFPZFFpalFqU3FaSXhDVnFkSTR6Qk5STkZJSXB0U01SRWFpZGV0Z1lFSVhjZXJxNXNHUjA1d2pSTVVSdWZwa1hPYzB2bVozSWl4eW12NWtjK0tQbVF0YnNRRTRJVmorRWNDZHltQXZaWmg4Nm9nczcwV0lJc1VMSVVVaGloU1Jvc1RPc1EwZDgyTThqZGpLcGVkNWtzd0Z0S1pzUlpRT1l6OEJ6ZHJxYmQ4cCsyYXp0bTJad25uNnZ1MFJIaUJRSnRISVJyZ3N3bE9KZVdIckxvNmJkNDQ3MzBOV0gzQkxGWTVDU29Xd21EU0JjOW1CYzBEaElTR0d2b3dBT0RFbERQN216L2ZIMnU5QWJzVGIxbS9ZNk5ldElPOVJzbmQzZWlJQTBRNVQ0NGhxUEpyVmM5QThGUnZDK3U5cmdEOXNiYXRTc0xLTjhUVU1VNVJuZGxLMkFGUzhYWmppQXM5eXVNcWk0N0FuWUxvckEwbzFzQ2w4QkwveUFRZjJXMFd0VTgxYWR6cDFuQ3dmK2ZsU0dtUU1Iem9JYVBHQXlxZC9TNjFIV0pqc1ozRmpVUVFlT1YwRGE4Yk5BWjV5MmFudWN0aGxxTEFpS0NhSnp0M1YxUlFzTnFBZWFqYkxXbjU2M3FRODYxVUcyeVEwNExDWVQ2dEhyMWJ3TmZYeWVwbUlHRXhRRk1MT1ZIMnhHVVJJa2NIZ0ZQY0hJQ0RSa1pHMDM5c2h1Y2daMUlvSk9GanBQd2d0MVhvcXllRUR4bllLTnF1b0RROHBIc3I2VTRZTXFuQ1ZHakQ1VWJmREtQNjNXTWk3a2I3dTdjS3lxdnI2cThNdXVpakd5Y3RWY1ZNUEQyYUZMSzB6RDJKeGoyZk9EZ2NLUTFXNnpCUUxCT2h3NDc2TEh6ODV4cUhtOVRvN2dYRVIyeUdyK2grZGI5YWpjcGtSNUw0b3FQVWdKMVZzdzRHeUpPRDN2NC9SZ2wwUytqR1FtNGp5Yy9ZRGFjUlJTRyszMnVuMFBmcitFZkcwL09WdXlXUTE3OVVpM1NmM0JGMFpRdFlOSTNuQTdRTGpBcVZtZkVvdlc3dHRiUlBIV1hXckErbjI2S3NPZUIyaEsxSWI4SjNaZXUvWTJXRVNWK0V5WW04bFdBZWFDOVdGQVdFYjJhNkE4NEppTmw1R1Qwc0pPc3E2VThad3U1T0NDck8xd1Z2OFJaZFYxNmdjSDFQL1ljSnVjcE5NRkswL2VPL09ybDkzeHB4bkdSZ0JIczF4Rit3ZWgwTDFpNEd0bWVRcDZGTWtIa0hQRDdaQU5EUWxZL1p2NmxXdXV2RTNXaWxDUzh0N2VXYmRmWjcvQ0l4T1pab2VRZlh1MUFMT0VUR2d1ZEUxV0tDanF6c2t2NE5BWWpEUjFBZjlZdWpSMUFiODhobXNsbjhXRjBnaUJjejE0aUI5bUhzTElqUEhka09nVTgxQ3U3eWkrTGhvb0YvZlhjVnlGOFFJcm9oT0V1WWRwZmZ6Y1NvWXZXK084eGsrdm8yczhSWGQ3VnlXUGlOS0NjUDVTU3RBTnk1bWlyQ1JiSXJvRFNJYzJJMTBnMWthNC9QcERoOWFyUXdXMlgyT0l6bjhkNmRSL2ZEM2ZSdUV5VzZRajdGeUd3V1Y1dzRQdExxMWhneFNyYnNhaGVvMFBTOWM1eFprQlpVN0U2YlVDMUo1bEhjcjJyZThUOGxYVnYzaTA2NVpWZDgvT3F4L2FiVDZsenRYKzNqYzJ2SFNyRWsvdnVtU3gyYWNJM0N6bHRJVjJuUCtMTWl2VjE3ZXRJRlJWVzdaT1NFNDRvRmQ4K0E4Qmo2Vm1SM3VIM0poc1ZCamRYK0tsOWRFV1dqRWcvcTdST0dvTi9HQkJwSklZdGhyc2N0YlI0N3lNbXBWZ0RHZ0VETDBxRXBoaXJ0UDVEZmZlNVNQWTZNd2I2cWZWdktEK1F2Mnkrb3NYYXFiVjN6QnpKRzc1WHZjM25KMTNES0VrNmtmSm9Udnd2cU1QVGdvdTNoQVlRVDRETXp0Tmw2NTVFSW1QUDY2ZWVuRE5wYWJPbVlFUnBEU3dZWEZ3MG9OSEgwYmUxM2Z1ZkYzOWs5YXZBT0g0SWNEaDJMNEZ4MklaZHVHZ2NSTTRxMlgxSytvcHRnK0xhQzRzVlg3d05GM2hhQzZFVURSenJyWUdLYndFK0J3cmErTDRwWEhhUkRMR2RiS1pzT3NEejdoMW9OeEZNd3hXbitLdHIvZlNuK0t6R21hTVU3SHFPTHpiTDBTcVhUV3VxcGJlbGlwNFYwZUVhZ2E2c045OUErWnNKbXZQYkc3RHAya1RIS25GVUhZbkEvUTJJOTdHeGdHRkI0RG9zT0VvSmNqTEtUNXhqOUJGbjl0dk5sVXIwVGJubk1XTDV6amJvb3JQYk42UFBxZit6QXhnR3BYcXBPYndUZnYyM1JSdUJpZUwvTmtuSDRXTWVrSXRkQWlLTCtxc3NhYWYrZm96YVd1Tk13clEzL0UxTmFudVdna3hZUTl2NXF0OEs1RU54WkZ0cGE4S3ZKNHdKRm5KbVJpUlQyR2UzakVhWVdlVk9RK2N1SFZ3NHJmQU9VZlhxaXVVa3VFWGhCOWl0SW85U04rQTd0dFJNUnhvdDFUSUhySUhYWWtVMHBMWVVRNytrUnlRWHBUc29EL0MwZWNacnBEamN6a2FyZWJZdXdEL0JmalJJTUxSYk1NSTdVTEZmRFFXNTFRV1R2bk1FSWhaUWhwTWZ4eTdCeXlkRFdmM0k4bzFGZnZTUWZuamlaQTlJZjgzZmozd0x4QllYVmYzQlB4MWQ5OWFWOWZEL3A3bzZZRy9XOW5mNnA2ZTQ2dFgwMlE5UFVMdTFHM0Nydi9Tajg2TGRxWS9KTHpMOXVpYUNoNUZFU01DQ3FKTWlTRTN5c1BtMkxlZXZ5R2l1cUxKVktTUVVsTDlTVFNZeWluNGh4SGVTQ1A3MUd3cW9qb2pFZnlqU0M2RkJwUDlLYVdRanBadzA0ZWtEY1c2VWhlcVRkQkNnZnFEUFpIR2hSS2ZvQlVveDRMRHpiWG96UWlOeTZXR1BrSDdraXpRWHdlWm9ETDhBeVdsTlp0d0JzQjVib1EyTCtHdTRMWUN4QUpOWXFGMEZ5em5UQkxXcnBMcHhtd1pLL1E1MWdGUm9rZGlYU3JtazBRUE8rWUJEWSs2QlpHNWUxQmFHU0hsS3Z6aVZURzMrcjU4L1pUaHRYUHY4M3ZkSW9JekVadGNvbWVDamdpWStJbXJrVWNTejRkNXVZVkhPb3d0YmxGbk44dk9ZTlNQRkRQK2VNNEN0L3BCZU9ZbHc0OVZHNDBHN3c3eVdFMWFoeVpJV0RuOVBtK3k0QUZ6RmU4Q1IyRVFIT3ZPQ3VIcko4OGF2aUc3Yk1POHFaMThzMFZYTFJxZDFRWmxnMktJNll6MVluaHp2YjVaTUljRTN6WkZGOUxybkQ2ZEtSS01Wcm1SU1BTYjV3emZzSDI2MVZZOW84NUhmdU1PV1d2TGFJdWFMenUxdTl1SGhlSzlNSXA3TkM0QVk0UHBHVnhvWUFIbk5iL2Y0d3BHbzBHNXFqV2t6bFJuaGxzMHY4c2o1UFRtdHZwVGY2OXZNK3NDNkhsMWVaRDZCVDM0OWFXOVBDZHFlNUVKYVA1T2ptdlFOaFBHOXdtV1FERmpMN0tzTlF3dFZEcWVpMkJaeDFnVUZGMkEzV2NZZm9QMHJvWFBhWVNvYkI3U2NKY2hzN3hsUHVBeGVEQTI0RC9zajJYbmIwRWMzWFBhWW9NRmpmYk1xZ05tZVpCaU00TkFRZy9PMzRJRGxGbHgyRDhRTzhOdEtjb0JhRFJ6a0d1QUhsQ1JDOENqaThqQUNBSlZabGNWK2RBMk12dURZOGMrT0VhR0tNcDBLa2VmUXdsNWJRcHpxYlZ5b25EVkNEK1pEQnlqU2ZIc1ErdUhXVG9DejdzbXpadzU2YTdUT1ZTV1dSamhMV3U0M0FLWUpSSUh4Q21qUU8xOFJrWWRpQkpvRHBnNUtvcUFLQjlTZE5VRHdzOUxnUGpIdTRWVUVnNjNpQWhZVFMxSlVDNGxqUlJESXY3NTU0SS9uaXdyeTRaL2dEMjlyUW5GOUQ3eTlxVjA1UFhnZ1FicjBocW5WZDVuRlZHUG11MVgveHpsZHlPUHpxVTNDOTJMa05ydFcrdnZVUG9Kd3UzLzNxNkxrQVhrSjJvM2p3dkROOHlYakFZNVdvZlg0Wk1XU1EzTVV4KzV0UDUvdDA4MFdXdEVSUmJzdk0yQ21rSitBYzVnZzBsbk8vSnRndHZWOTZ2Y2RRNmcxcUo2aDFObktkTFI3T3h5d1E1L0djZEYzSW1BUFJsdEJ0cExnczQ1eFZwRUdPNElYY00walBYWnlSWitOOStKVWpaSTI0SW9pUWJKYW9uTGFTRVNBQSs4UW14a2NOT2NYclNqb1hwNjc2V3oyMmY3RVVZNnNYSHFvcDFyRXUxWGJPMk5MOUNod3UreGRYOVlNb29DY3ZQaFZITkM0TmVnMysvMnJQRE0rTXpOcTlxQ0U1ZDBweDU5ZmNhMnA1NWZOZUdGQ2V2VmE2d0JOUCs2M2dtZFFUdHZTSjFNNnJiUHVRUy9LZmw2dGk2WmNYV0gzeHovUWFKNnZhOTVlUE5xM21zMTFVYjhMYTY0UU41czBwbjFBbzhXWXhuNTJwZmMwcGRjTnJrOTRBMjkrdEFWVDEwNTNTKzZOZHFVcCt1em5lTmNkRStEdGVoRDBWUXpqbVlvYVFwZHBuY0xFdlJReFBDa0hHbFJxcWViZDRqT3M5MDlmMHExMzR4MnJrZmVybm15SFB5blc5cGIxOTdqRnl5MTkwVjBKbEdQcTIrMFk3ZkRncEQ5ZVdJMk5obHJ0dnIzVFV0OC9kYUxKRm0yaEhvbG5NVEdVSlhaS0pDcnNGNFE5RGdhTjBTc2NrdXczZnhnNGUwbCtqV0xMckk2K09vSkdlTEVqaEY0UFFWdHJ1WnVnZG1MdTYzYWJSaGR5OUN1SHUwbWpESkhFS1VCS0MxQWwxRTNCbmgxTXhBVkpVREpjTFNaMEg3UXZkampkTUFjbHdBY3lndFRHSVpkZ282SVBZa3BRVWZobkJHNkZnelo3ZUliUVlmelZtYzcvQnpCQlFzcVBSLy9KRzE2RGVZdGZGOFlSY1Jhbzh1aWErU2RQQmFpTlZVMXhHWkdva21XYXJEOTh2aThnQjd4Z21DSVBSOFdTSDIvK3ZzcE1KUEVmdkZHcnl3aXpCUGp3OEVkVHJrMjZHdTA1Q0srcDMzd0YrRzVrbXVZNDg5VXcvd2lKSmlOQ0cwZVdsQmo0U2NzMGMrYmpuUjZnaEhpK1lXWjFZV3ZIckZkT3l2b2FyTEZEQllyd2s1SEF1bXJBejVMSTdwb0xYcHc3VFpjN2ZFN2VaUFhZdDUrRmZZNTBDNXRqQW5qQjF6R1BjUnhjbkVjdzd6SFBXWVFVd29kRkRhSWRTamxwTXZnSE9QWWpaT0FBek9Cc3RFamlhaVlFTDB3Z2VYVERBT2RDanJkVG5wN0FsT2tBQjVONkYwaXJNQmdVb0c4QzdXeG5ZRXVROXoyb0tkeVlDMEd1OUJWZSt1Q2pZMTZCSXR1M0hHVjlBUUpkTVI0NDhNTmY3TnBZeXZVbWpveldkN240N09aVHBQWktwQmhqZ2hXODloUW5vWUt1MkRNTWVKUm9HTEk1ODVBWmhGalhsaVlPWnpNdlByMHJQR0gzTGIxbisvOEFwRnFkTktjV1F2VGdxbmFhTnEram8zNXFUUFJDV25pYW5PUjlJU29LMXdYd2poVUYzYU5HOGhwZk5kUlBBMTJ1L2JmdVdPWE9NWDNNWk1XRVl1U0xhZVpkSW5BbUt1Szd4VHppVnd4anFYazRaa2ZFVGE1OGdMTy8wZnQxc1FUU2E3WWJ1WVRTdEk2eklmL2YyajNXQm1GQy9sSHQ3dHl0Q3ZIK3I4ODB2OVAybnhoOTZkczgzbDRkV052aiswWDhJOEhOK2VMdjFEZkVTZWJHV3A3am9jSThhZVlSd0RrOXhSM3JwaHp1WWZLcGFIcngzTU8vN1hzNU1jTkhUOGJ1NHMvYTB3MVBqUzk1MGhxRXJlZmRqVE9HcDJjYkxibzFTRzlIZ1gwRnJNc2dQOWoxa09STmVVMGUvTFpzZTZSTkdTSWlsTFE3SDc2dUhEUEtqczViaCtMdkgrTm4wTWxaUDY3ZlJ5Z0hXU2NRUXMwVVRqMmFidUlUL2hwQ1pxNENMaFUvYWZvb3NablpQTERkV3orR0JWVjZsT0p1SzVCaUhHWkpDNXFObFU3MUUzSHRoZXkyNDhkMjQ3ejI0K2hnNDVxa3psS21VU05ka0ZHQjQrV1lvNXRmeFlkQUFTNlRFOUpHajFnNFdxNVpqcVNsRDVKeDRHc1NpRVl5QXFXTmxTc2VNYXd0WEZ1OCtEbXpZUDg1bE01bEIzRWdFMTh6UG9oMHBFNFdDa0Z5ZHRvd3MyRnZKck5zNlFvQUlQSEJveUhMSUhUakpYTjU0c3lpNEMzdnl0czRFU2c4cXE0Q01jRk0xSEpsWENoSkdEcENGQjBvRnVBOUliMjJSRWdINGl5Z1FFVFJCdFd2cnN5aDI5d0c2VENieVY0NGxvcGpRYUg4K3FBOEc3a3FEcHdOSnhPS2U5R0lOV0dIQmwwMDFRR04wMzFBM1ZnT0k4RzhWQXFjaFFOUHFzb2Y0NFc4VTllay8zd2pPWjBXQkRsYVNpTThVMDBJUTEwS0tnK2FPdVoxV05WRHdiUkJQUThta0NLc2hYY3BobkRwNEtLRWlUaWpFMG4wUVQxNUNpNUVwbEtpTmV6dTZwUkY5VGNnL1N1aVR3NDVsWnFnTTlxTjFENFA4KytPOVQ0OVp5UUI1cUg4bCtCMmlGUnBaNmg5UzVvZkRwQzc4b3AwNUlBbFJNSEJJNTQzSmh6b2hxM1grS0Ixdk1EWkRuNzF2ZGhUajJwTGxkUExoUzNYSHlOWHg5UEpuVCtheTdlSWk1RXVYQVFOUVV6SHB2Tmt3azJvV0E0MWRmMzRra1Yrblh5Z2R2MXo5ejlxMHRxNit0ckwvblYzYy9vZDJuclZmd0g5Rk1FR0p2TWRYT3pvRlhhYkhJS3pLVTdnK1RSb0UxbFlLeFV1S0h5UWdXV0pxRDdic0ttWElJSlp6SndaTWZXdzFzSE1CZXdxMC9iQTNhMGV1R3g3Y01NeWttMkoyMGx4RFRKNHZDNGh4a1lFZ0F4ZmRZYUcwQ0J3b0E2eEs5YXBRNnQ4aThBY2gwTlFERnRBemhmTHFmdzQxZTBVcllmcTVKc2RpaEdGRFZCa05XOXQ1cWhGQnQrWFIwcVFGSFl2d29GVnZtaGxBWGw4V2YzNUUzY2lyR3l0cFBpR2pwTmo2ZktubEZhek9PV3RmdkxMaFFLU0tMc1pxdWVTdGQzUy9TR2hVa0hRWmVGWEttTDNCbXo3SnZiWmhBM2wzcm44UHRzc3V0OU5jZFcvNkI2L1BydEU0bEh4OXNNQnZma3hwRGtDblhNdTNiZmkrc0hZY3Z3eWJDVDQ1QmFLUFZUTmxjTHZucSsxTXMzWllQWmE5UHAwVnRxRHZhTHh2enV2ZW9MSGlNMlcrcXZHdGpUTm1uSndJTEZVOXFqYnJiQlFKSmtxZSs3WUs1Ym1PU2dmYnhwcFYwOGUyTHBUaVpyOS9HanBSeEh1bHVlVVlPWmlLUG4xR0FXUmVjZmgzL3E3ZldxaTd6ZWErQ05KSHdudks3eDR0WHF0MGRQcFFHWHAxS0ZxVFFRSFRvSmViM29uMWdHci9veFpLV0ZhSG96VkI2ZXlyZE1MWjR6ak5WRTJVY2xBUUxHV2dxNm5HTHBsS1diTStOSmxhN3BtWXhTa0Y1amVSQXM5ek9jbkFRY0ZWQWg1cVFQUUl3QWFXVk9HWEhzb29CR1V5ZDlRRFNpMFlqRGozNjY5UExvMmlyNEFGUVBLTTM0VU5EczZCaFpLNWM5blNFL2szMCt1ZEN1NXl1azVmWEM5YkxKZHlyck04bjRWYjJoc0tLRWN3UEd2Y0tncjlBUGFScGIvam1xWVluU0diRmMyOWwxNGxkbDMxazF0NStqQ1pEWTVDdTBzN2JzTFBLN3FzWnBTN0pjOCtMS21tWDVQTFhCNkk0VXovcDZzN0JMMkVPMUp2UklaTjFpYTNUZHFUYzh3YUJIYVBYZ3l3cTFacWRQeVB1Y1puQ0ZLMlE4aXpqTVdmTDR3bGpWSDY0bytjKzBBSVp6bFQ0aE8wTDFWRkpBU2dsMlMvV2NWWXM0aW1JYVZjNUlYbEViTzArNWE1NWlEeVhXVzFHYVNJY09Cb2luVDVrT0h3d2RIVG5vc0ltT3FRRy95aHd3Y3ZBdytmQ3JCbjI1L0JLY25GVyt4ejc2eXBSV05WNk5vOEhrM0xXRDQraklBT0dqQm4xbFkwYXRpZEZ0R2R1SWN1MlY5WTZ1Y1V4RmJMNmhCaEVKSXNCSk5jZkoycWJBWmdOVnpBaXR4eklDWXhUMmhGY3JwZ1ZQTEEyeHIvQUhUUlpLOFoyQnB6YWVqNTU1bEQ4cS9BRXdKazZQM1pyMGVIRS9vaHNwZjdEd1BwWmwrU2lkQ1I5QStSL0FjVlRtZjFaNHYvQStjMnBCOEtCcHRESlhRSmxYRnNzOFN4Q2RGcm9ZaXRMeXlsQUtLeHdLd0FkcERjd0QvN1VFTk9FbzJLZjNoeHpWN2drRjdab0tqOHNlMVBSNEVrRzdwc3lUc3NNSk1VcDZKMCs3ek1iOURPcy8wanhNTUN3N1Zud25XNHc1T3c5cU9sdVdxVUtlcU5pdVVtdk9ia09GTHRDNHRSWnAzckcxVlBhL2lkMmRKbHNRRlJkb29aSTFWc1lzczFMOHRnNUo3T2xPeEhzWWJ4TkdmRlFiYnBGZmZGR1dWOGpWUHVyd1ZZUHo3QkMwZTB6YjBKUG5TMTRNUVNmT09UWWVKdWRGV3d0b09LQ1ZySzBlMmtvcXQxalJQb0YzcklSNVY5ZjlGcDRySFE2MG5sYUI2eHpEWStVcTYvME9xRm05K3JkUXRjTVBoTXdobWFhYk02WU5sZkplN2R3TXdKakg2bzBsbXhFUUJ5SWJzNkpnQ0p6SmtnV1ZVc0Q1bStubXcyTkVRTXN5NDl5MVI1ZjlOV2YxN0pGTU5uMHFXSjlzN1l1MTlsek5JcHVDZ2ZyMnVpcVVHOVA2d2JKd09mNm41WWNXL2R6cnVFSTBUZk42azBHbDJlM2ZOalZNbytVdTJlR2ExREtuYXl3d2pQU0owbDd0cFQ3WlIwQ1A4Ym5MUUVqR2RIbVV4Qi9uc0F5VUJGb0hOR2xsY0ZkMEVKL1YrRUVJNUdnc09OUThlem5JdllQRkVNZTN4clozQkE1YW1PNVBXUmVrR1VYTFBCY0xraElVQWFMK1d1UXBxNGwwSTQwdkEvSGx0SkN2WEVZM3lwVFRRajRvZy8vaUpycVFOZ1dPYkdUTGFlT1J3TmdBZEwzaXV5L3k3aEhtUGZKdTVENGFQeVlBYytmS1hRNUFFODZkdlJnd1dpNHp4S1RZT1UzeFI5STJ4aDVZRUVudFNxSkluVmhoNVRyVDU1SkRuSDNBNERQczNRdVBBd2I2Tm96eHYzNCt5VVQwL2ZFemxmMVY1eGRQUGx0MldsK0JmZGVoNHFGeFRpSEtnK29LdXJ4L0xjdFh3dnNnb3B2OGxmTE84d3BUL2d6eXlFaGhLVmtXbXZmVUoyem5aemc5NTJCNndja29ZbmQyQXBPckJLQ0NobWs2TWtXTkhTR3dyR0RaTzNqdDl3OHNIYTdDZjczeldTQ2poY0RPMTlYZnFmK3EvbzRLUGNHVzBJWnFYc2U3ajl4UnNGNjg3TUFQWDhaL1dYbGcrTUduVVkvNnF2cGJKbUZaaTlwUkRYWFJjekI3SmdWdDZJT1JLdW9Pc2RuVitHb3BqYkhHVkxJUVE2eW1KQXRaRkZHVVBpcUdVTmdXaWVDNzZYMUluNktvdjhINTVCU2N5Nlg2MUYrSE40YjdJVzQvRTFiWXB5aHpsUFdRb0UvRFIxSkN2bGlmeHR0aVJ5OHE4NmkwaVdJVW9aQ1BGTFpGazRrb2xJOGloV3h5eXBRa3pxdS9nZnFWWkVyQmQwZHdOaDJoemVpRENsQ2tMd1cxSXdWcWh3eUZiWFJENTFJd3huMUNsbXJNbzFMSHlsaVBkdkFYdTBrUmx6NG9pV285L1pvVnhUb0NSZUc3UTVsMGhGYVhPazliYUZzMTNDSjE1a1dvTTFmUzlTNE5ackZiWmR5ck9MWlFLZTFsQ3A0d1V0U0JsUDVrTHRtUEZEcCtmUkdjaDdpdGREd3BqNmN2RWxGL0RXUGQzMC9uUW9HK1IwZHd6anlGOXlJdFIrV3BMUUljWXM2aXJua3pqbUxvcXlPWXNKZm9OWlZTVUVOckhudGt5NXJ1a0NEWXJUYVRaTEtTWGFtbjhmZUhnTXJDSEFHcVRLVmtGK0pNZGVtTHRnMnV6VXdUUTNxcjA2NzN3VWxaYy9TMU85QkJpb2xBS203VWVkcWl0Y1RqSHNIT1M4dVB5YW0xb0JMZVJiY1hqZW4yVjRQNjFmdGxUWmdXcXI4ZjljT2l2NDU0cUZ2OUtuVWJES2ovL3FJRUxYcmZ4OUtYaFhKcGVrZyttOG5pMGd5UTNzY3lKSldpREovNXpEM0NYNFhydGZhZHF4M25hamVUZXh1bkllZG9OODZPMnhCOGNOeG1jeVU1VEVIVFVTeXV4ekt3bGxkSUdZQW9SVVYxWndlWS9pYlZMNkVLSk15REJtTnRKREJlS0V0ZnJBdERYVVNqb2Nid2lXbTVwNW1ZSzU4dmxsUlNFdFZvVDBvL3BaaE9qQlVPdnVpSTNwc2dhcW83RStFTTdJR3p6eU9VMnh0SlUyMHdVUktFSHpSWCs3SytxNXJWanhpa3F4ODFYd1grNm1aa0FLY1doUXphSWpBVW85U1AwQjhnK0JxSWZrUjluYWxTSng2QjhHc2cvdEZIU3pFb3diU3pYeS9IVko0SGxFYVp5S1E0SGFVZGY2d09QcEdUVVJvQU9LcXNoZUFXYmNzdWJmbjR5dzV6M3V4MHdzT0JIUWFENVMyTHdXQjNXcjVoa1lXeGVNanAvM2pGSWp2TnI1aWRNcm9TYnpLSk9wMW9LaHcwV0sybHV5MW9WNVl6YzI2Z2x1ZFFMTW1lQ3Jyc3JpTGVsMkEzekU1M09NbVE1MFJjMHh1cjFBblRLQ3htNllTZHpnbk45RW5jVFFiVmZOaWY5NGZWdHUvYzZtdUNtY08vYklzMStXNzVkZ3k5QUhnVVRDOU1wNFpOZmYyUzNic3YyZENWeTNWdG9DNzBkWXZqcTIzb1pENnZUbWlycXE0bWE0L1V0UzFvZzcrNkk0TVVEU3ZCbEtaeHVQdWwzWE9mZlhZdXZCd2FuMHpTN0RqTVkzemxVRDB2TXY0c29LNVU2Q3ljb0Z4bWtkTjRnSWpxRDFBaE9pcVlxdWw5MHN0MVRPVjJ1bmxxZTBNQUhPY0w2bHUvMndtcnkrdXFYdTNjaTZTditiRGliRmJmL2MyYlF3L3VzeDd3MkZxYXVtdWFHcXF3anBEdU9kMStyRi8yOEN1Yk1sLzl5cGNmaWhxaXp2cW9OOW9Uc0JFbHFWeCs3RTZYRjFhY2Q3Vjg4em9rWHJwbVNQMzJwbzB0d3B4c2Z6YlV5RnRFc3hTYW0yNlgrV21HUk9yNm56NjFQZXl3RW4wMFlvamFQZnBWZTdhV2VCelFRNUdEZFpPQTFUcjJoc1hKTnQyb2h6RTRCZGpCUGRGYW50NGxqZHlUbmVFbXpSOFltRDlwS285VzdOKzdJcVA1ZW9ubUd5eExyL1B5dkQyWExKNDFhMlZpSUlkUXc1S3R0MzFoVFNsazllM0ZrQ0l1UWNlZHB6TG1RVzRTckVzbENydSt4ZzhYSlRjQU81c0xqVkhPcEhnNU9nc0Jqa29ucE9IdEVYT0gzK25TQksrNjNqbjhHZlFBT29rZUtMem9kOTd5RlgvTXYzT3BrMngwN2xlamhiK28wZjFPNTM3MEsyeEJ2OXFQcys5dFczZmpONmpLOERkdVhMZnR2ZGYvK2xjOE9lYi95aTFPdjkrNWRLZjYwMm1oUDZqdkl2YzdvV21oZDVCYi9mTTdUSzkyVUtJeTJYcXVpdXZpcG5JWEFlUm5taEZycW1Oc095TzBuVVh1S3FTZ1loZTB4Y0U0MHlxbFBINFphQ0hrNWhuN21ZZVRPcHhSb2hsQXRISFR2R1Zyb0MvUDRiMGp2VUIzb3ZYcXFxc25HUnltbmJZSjkvM25jcWZ6RWZRcU1sKzhNbTF3Q0w1d2JaRFlJay9lanJ3NmxIZEdaeHhTdC8zYm5KUG82aHV2ZjY3bjBuK2UvUDE3ZXZJYmFEOVZGVjh6MHMzL2tQRHhndW5saTIwem9OaStLYi9jVzlkZjl5NnkyUyt6bVdTSGpBMXE2OTN2eE5GSEUvZk1xTTh1L01JcmV4d2Z2UHlWNnpkbnYzeXBObmMyMko4K1pQQVVwQkExbHY0N2UwOGl5QzJWcFR3UnZlemdLKzVxWVZjeUc5OHltb3U3a3Bsd29ZaTlvLzRVVjk5aGo0UUlaKytjMFhrRU5pYlpRaDlvRC9xaFNUSWFKWXVhTVpqTjVJVlR1WjZlbXZyNkdpcStXeGNPRjgra2pjSkdxdmNIMjdjVnlTVnVkMVNQR09lN0NWR3hmNm9ReExZaFBkTGNIZ0dXdkRBd0lkdC9aRkN3NXlRVFQ2eWkrdTlxSVNXWUIvUVdiTlVmSHpaaVpBQzNpTCtOaU1wYkNEYm1MRGI4eUdCL1hoaEk1dnVQRkdiSmxnRVJFVE1hVmd2ZnRsc0c5Tmc0ZkZ5eW1VMlg2VkVLRWVUUjJXekduRmw0YXJBL1MwK3lNOW9keGRteTBDVXA2UG5jOVJ6bktVcHlSOGE4VWFXL3pMd3A3c2NWNlRKajRpS2poQjdMNUY2d3dwYUFPNGNDNmhBYVFGazFydzZPZGVNaDVzN1JKK0ZvaU9aV0IwZFVhU0JOT1J5eDBnSWprU2pYbnp6Rk5OaHpxM3V6dmF1UjlvSVFyZDVBbG1YTFpsRmdHTXBIZWUwTm9UaUFBa3pxbFJvZkdQNGlTMEl6NUN1QzU1NW1CazhFZUE3UTY0VUI3ZGxmcEdOZ1BRdERRTVZrdUMxVXAwOXE1aXZFRkVwMzJGMElpSnBtTVpyTzFQS0pvS1pLZ0J6bHlDQWNCYkNFTFpVU0RreVlyMXNzcDhhUGRzNTExeVlTZlJPR21IcnJLVUhVcTNsNm54MVkzN1lpMlIvdlRiWlhkeFNUVUMzb2tyb2ZUWEtHYTUzWDJlZ05OTmMwVE8xYWRzbU9hVm9aWXdKTHVmaTZWUzlPek14cXFHRXNobUdMbjVZQzZ3c2hJbGs4OWMxZDBVdSt5dUtwSHFMNkxiSzlsS0MyczZlNWUxUHZpaDBMbGlhQ0xQT29FQzM1eVAwTGJJY1VOUVdFQkZhVUtNQWVwa1JUU2xxaGg2Q1FvZVlSdWhGVnBKTzREOVVyL2phajcxWDExS1FwOW1xZUNNaUFUVmhxZFRWNGE0MVB2SGp2aDZqL2EzOURqNU5tOWJQcXJ6NnYrK2VwRmgxMk94QnY0NjNFZ25VcFQxdnpyTmpGU0R4MCsvdGZXUHY1MFRSL2dtbnl1cHdNS3lxZFpMRC8xSko0TnltZmJCZms1bjlQUGFMT1VvOThUOVBjYU9sYzFOell2S2l6UmZOU0EwUXFZeUJTSHovS2gvTzU3NnV2dlBnaTZ2Mit4bUpNOWl0dW5uZFRRb2p5aDY4Y1NWcVpyY2dmWHNHNXhLTjhnUEp5STFLbFpaSFNIZFZCeGhvK2l4djgrck1sN3U2emNrckc3OGh5b1ZwT2xmakRRK0pSOG02SlAzelc3WjE0a1BHSHorSUc0MTlDR2JTc0ZCUXFhNHpwWjFtaEdtNlVnek02UXJXc05CdFh6YVFUZGFGUm1xK2EzbitRM2ZxWEx1SlMyazJjUnEweXd4N0VENlErdmFzVE9LcEhwek5LUEFaYXdvcXljcWVNc2xiRmw4ZFptMzVRd2ptcm1uZTJPOVU4RFN2a2FSalZ1U3ZsZ0RYT0cwUzc2RVNEYUJCd0xEdkt1ZDFxenU2bHdtYkd2QUU5NUxXck9ZOEhzU0NVTStYMXhwRXM2a0FGL3lnbmFEclU3ZFRHaXladHdSZmZWR3RRRXVnZGNkazRIOFB6cUxTeDFpSGV3NlF1bU9VTzhpUDIrbEhRZS9vOXM1Y2Nwdk05RERTbXpWYU52L1FqamRGdHE3S1llQW54WC9JcFNXYnRRL3NqZVpYelJzak9Ub090bFlxeSs0d05kWk1Fa2dHMzJWSG5VcVRTSFZCUjM4MTU5djFSRGVOMTVQYXNPcDFkdFdmUEtnUlBQTGhxRHhrc01EL0owMmRnVC9sT1hGb0c1Y2hjbzBidGErZHlTZDJkU2lWUlRRa2tKVWVYTHkyclUxOW9lcXozZEw0K1ZZY1dnSXZQMXFmVVk4UDUxU2U2MUg4V1VMSGlBUHhtMVlYVXJZbVp2dHE2RU5vUGI5UStlT2tzZGF2STIvbUt4bEJlRG9meklwT3Q0UmdRamIzS0hibTR4WGxZWkdPdWFTdXVXZmxmSitsNnJiaUY1Ym55cGFzMmZpZ3JjU1N2MVZXNk94NTdVeno2WG5qY0FrZHVmY2ZjOGhadmRZdDJXSFFsL1NZellMZ3VPbWRCdTZhRkZiUW43Q1VmenNFSXdFL2cvc0VCTUdvZXFrQkY1WGVHZ2VJNm5ZTWQ3eFRRdkFXT2FtU2RwcXR4aEdmUnltWFo2WlVHUEZSRFFqMkFidEtYRWdXRTFFTnhIc0FyNll2eTZZQmtpYWJQMmhTNXRpblRxcVpNNzFxMTdDYmh0dC9PcjFuWmtycGlkbzNiN0hOdG1MYjFBWi8zd1gvYS9OMzlheWNCYmR4NGJQc3drMnNpK2UzSHlKTlYrdGhjeGR4NzA3SWFXZHA2V2J6dHVpNVVoZnUyV1hSOHp5SzBncXlldWYyeFkwc2Mrb2tJaitRNk51b3VORXoxVTRxWGV2WkVKa1MzaWt4S1lYejJrQ3RSc3JTUjRJZG8vcGRmcTMyblpkck9udXZ2ZXVaZi83WHdIZzFpSWdsUU9GNzhwd2ZiMnRDUDlZTUhQditud2hlMXVqUVNZOFFtRHNXcnFJWlpNOWRkcFBRcXNQWjBTZG9xbUFweU5pVWcydHdCNmlaQkFCT3BVb1ZlTTd3R3RDUVY4bkMweFN4L1lUSkh3NGVvZlU4K1Z6VHNOL3cyMVlpRGJnNS9OMXU0V2N6MXBVNXhxYjYrbEFoUC9HVy9ZM1V2UGN0amJUb21salQ4N1J5cVE5MXYwOHc4ekgvK2huMjUzR21XUWFCUE51ZXp4SU9NVHAxWmxIK2kwOHpJYmRvRk9zSE1zbVl6amtxZUlnTk5rOFJMT3NKRmE1Q1pranBsTFUreW13YzN5dzJOQ3pZWDMrUTdhK3o2YUgwVEdYakxQNjh4NWk5YzlzTHhaMTUvQmNVSG4zbDlON3A4Z0RUWEI5Yll6UVp4d1pLTEo1TVhCamR2WHREWUlHOHV2bFhPdmlZQWh3TmtqalhPOCtPbmRyLyt6Q0NLdi9MNk04ZGZVSjhZSUUxd3lOblhHTVM1aTFiMGFtd0U3b3hWeWdrZndnelpZVjUyY2NlNTA5eUlYSmZXUCtpWnZleXFzUFBqT28raG4wOXY1cWZDeUE5aU1rRk1Nb2dTK2JBNTBIcFlkb1dLQTFIeElGWVdWWEgyd0Y0QjVXc2xRS3ZzLzUzTUpNZWdpQnlDSTZGdmZaLzJWSE1XL1dOR1YzMmJKSG0yeTBiRDlaR1kwU1I1WGpJNmtLZSs0UWJKYkRUY0x4bTZiUjdUWVlPbG5OUzlneWF0YjZwTXFqUFJwS1pPcThjSVNYSHVJWk1qd2UvRXVuNkwwK20wOU92d1RqN2hNRDMwa05tZTRQbnV0bUpFb2tIa2QvQUp1L21oVDV1K2FNcm9ERVBDQVlENVZOR2gzdjhOZzR5OG9ZYldxVWE5U2FyZExxMlFUUnRidkZiREl3Ylh4Wkx1TTlWNmcyV2VlNExpUlhaalpWSmQ3UTNTQ29kbFkzTkZVcDNSMXU5dXJmZGdlMkZvdjgxYVhiV2xpaWN6Vjdzd2RxMmVTWGp3Vmx0dEVGSGpvUkU0SExnRW9tWTI0QmswemxOakpSLytWM0tWNVVZWUxoeGhVcTgya1dIRHpCd1FUSFlTTU9GdW5yRUk2RDBJTEV3SjhJVmFrVUlhVlZ5T2lxRUFYYkZoZ0VwWXU5Uk0wTXZxTi85bDZZcWJIdzNIaVZIR2dMUmpnWWhJQ050cVhJYWI3MzBaVFVlM291bTQ4OTZiRGE0YVcxaEFJdFZYaEdST1V6ejg2TTBybHFyLytmMzIyaU1vdHZXV096eTNIU0ozcTM5K2I2OXRlVXdQbENlUlJKR1hDQlhiY0VWaTNsay8zWDczZTN2M0Z2YnUrTWtzYnl6aVVrUUVrYndvU3NSaVE1SSt0dHkyaDEreFpOV0hkOHp0bS9sbUdlOW11bk9kM0tZUmF6T0kzbzRtMC9SK3Zrd0p3UkVPUGFVa0p2U3JHOEdCUTNsa3NDS2RiR1d3bjlpRTZTQ043S2QwVVZMS2llcWNRQUlxR3EyWnBPR1B6b3VyZ3dQWkFaODMwdURPOEVyVmhIQkQxQllJbUNNMUxaNVc0V2U3Yjh3THRTRkh5bWtOTk9VbTZSWEFUcjl3VC9pU2dXL2V0Tld0RHRIOUV6bkNhOXNuZVQxS1V6U3g1STRaclMrc082elpyTUc1eE56MkgzYXNXZTI3NFROTm5tbENQSkFLaFIyRm5DaFpkWFk4K3psZnJXMzJuRUI4ZWxXWEhhMEtYenduR0o0NzFlVmVPL2Z1SXhPYlluMHBuRXYxZVhmM3BhcHUzTk1ZbWJKdjJ5V1hIK2JLTnBpWUxHazNwUzByZHJRb20yczJIbW1OWXlKWkJHM0VCS3JuaHoxMEkxZFNWSm1Wbm9pbGJZNkpqVkliVytYakI2Q0dibUdTcXp5azVmRnFDbGlkS1Vlb1ZsaXpMTGY3WjBLcnA2VW1ZZzRFYk5HRzhJUXFoYys0R3lKZUh3d29Hb2pQeXgxZTkwSnJLSFRIa2tTMFBtYjB5cTBkYThQcUIyelFBdTZ0dVZldTNyei9pNmlUS1BwSnZLWmtxWEtoVmNqZVZUVTlYcWRFWnR0cWZSY3RtbzN0T3Fza0ZuS09jQ2dWaUF2VFBFMmZ1Y0czZWszSEQ5dm54cTg2ZlBrbE4weWJQaVVTWExONHFTcytkN2RYRzdmWWhBbFA3aFhtcm5XN3BzNE5CMmNYY1lJdmtpeWp5UUZYT3N1Nkw4bU90ZDRyREozNjN0bm1lU3ZYSnRWL25VeHZLWnNKbzlUcFFOWmJDQnliUUJObGluam1HSnZKWXE1cDZzQ3FkVHZXenZJNnVoM2VXV3QzckZzMU1MWHBtM2c2bnZaeTdwM0NBNDV6MkZNbVgxaDQ4K3htVzJMdVZML2I3Wjg2TjJGcm5uM3p3dWUvV1hnRHQ3ejhQRFdxN0JqUDNISVpKeGNEc0pmRUtENFhjYm90dUJMWGNCVURpbkthN2JpV2xHL015c20wR3pLY3cwaXdtbFVtcFVrdFN4VzlsUGVCcU9WdHUyamd5YUJjR0tLQ2lGbEdtT1RwdFZsZ2dBKzRmR1pOTUYwMk04L3Eza0syZHpYbUpTT09KMmtXU0J3bzJqZ0lBTEpiR0NycEFXdTRMclZGQlhSakptRVB3YzdIVG0zdFZvQktVZFJMaVZUSVRjRE5EbUxYV0RUMC9ULys4U00wWSt2c21aTlJ4eXc4KzQ4SGR0dzFHLytSa0Q5SzFzNEpXOUhKU3RSekovN2FtOGxwMDVLSjZkT0huMFAzUHZya3RyVzloZjFvaitJSVRYb0NYMStKYlRMZU43T1pZcVF5OVVoREord01uNkFOSUJacUNpeEtHQVdVVHRpTHhCMmwrT3l3Q3cwQmhnZC9HT2hNZFhFQzIwMm9XdWhYTi9xVUp5NHZtMTVNWHY0RUhrUk10SVBaSlZQL0NRalJHcE85R3IyaitHNzZIdVkwT2svbHZsZW12K2hlR2gzUC9tK05adCszVXRDL2JJVnh2SHUvRVpGY3pCcFF5SmJsajVsNU5DcDQra0pocTNiOWgvZS9JR3VpaW5oQXpaY0VjVm5Da2hBdU04aElGbEdoUnBhUDNRTFNmUFE2Y3NUR2xJZkM2VGxnVUYvdVUxSUJUS2VvclJBS05tS0tmR3BCYm40OEVFVFhIOXRPRmRrWnpDTFdFM1dvQ0xQRk1NRDBIeDBmRkZHaWtLMkFYSnpYSUZlbmdYV1ozcWV5NzJadU5yMXZTQUgxNTQ2a2drNEpUaWVYVXp2QkVMdjRLYzJEZGtmQ2RtVnFUNlRJV0VwVlVNWG9CM1BPY01mNTc1emg1dHh6UExmNG50ZTNOS2FVbXE2cGZkc2NsbUdZa20xOVU3dHFsRlRqbHRmdldkd1dRd0ZvR1dWMUJtSnQrSjZuZnpJdzcvbVBCbjd5ZE0zekozSXo3OTg2WDBnMzFNOU5wT2Vzbks1Wm1KbStjazQ2TWJlK0lTM00zM3IvekZ5c1RlTmgwc3RRZllYT0FxVnM2Z0NlSm5CeDdqYnVBU3BmRzFXb1dRVHRtVWxIaTM1UEdyckIzc3hmUzFVNG5Ca2Fra1pVZThMbGRJQVR6aWdMcHJjVzBHRjJJa05DWm9DS3psOUd5ZEE3VVpqbmJ1eHgwN1BIUWlSTlZSc3Fjb3lGWnl6eGtsNkFuMGNBSEVRU3hCWXNTWWhJT2pkR1JOUUo0a3BzMVBQd2F6WVp1ckFiWXllK1hkTjErTzZqRGpzUzVlU0VKcDJuSGd0R1lyU0lqa2FUcldsQ3dDTDVKczJaRlUxNWErU1pWYjcyL2UzR1VMOWM0MDM1bTdKZFNnalpIWTkrRjNHVit3VmFJRXBRdHlRMVM0VFg2UWcvaWVjeEx4QXNJd2xMT2ttY0tmRkVnaDl2czFtaHhUb2VUV2VxSVNlZlUvKy9KTEdaa2sySUlIMmRyOE9LQktOTzRxdmRmcjhrdHJqRnF0VGxNK2EzZDg4UnEyMDJ1MTF5MTRwenV0dm5UMTZXQ3R2NHVteHNEVGJaU0JJWjhaMlZlMUxKZGtLZXpSM2JCODV2djQ4WjJreG5LTGhwOSt0YUZMVm9WbVRCbmN1QzMrZGRsM2NocnV0eUYvbzhNK0xYU0lVdnFlVGxHWTRhTjBONUI4eFp2azQ1aHhHL3RsbXoydHJ3UUt5MFRHT0FxZVpsV2MzV2xzOVo0UXpBNENUdWNuck9NdFZraWcreWEyQ21sZytFRmRVNGRqR1JEbWRKTVp3aU1JNk1FMnVHZnJTMExLUEdZOU1rQnJXMERMVGdkQVlVZVpmRmFETG9EQVplTDg5emR2NnBvK21xcVcxN3B3enNtbFRsOXJxOWwxVk5mbnZ5aTFmZDl2UHR1ZjNEajkzOGc4bS9iWU93Mld2ZFZlSFp1YVh6SHYzMnpzNC90c3Y5em9WejRBUTBZWnNEdnpyaDd1cGEvMFNmWjZVNzRrRDZWby9Yblo0MCs5Ly80N2JZWUlObjJZUWFkMTE0NGkrUTgrNW4xVytlemt5b3FibDJ0bmU1SjNhazRkcWZuL2phbEk2dWVhMkd0VXM4S3p4bXJ6N0F4NTZvbElXZ3VuNU9ScHNDUGM2UU40NHVKNzVvdklqWmxxVjl3blRiS1hiUFUwczAwMW5VaWFtR2hwQnpHbDFyVjYrcVR2YlVMZEN2bWJ0TC9XQithNGpVR2gxU29pMWV0YXphSWpsQ1JpVmdKVFdXeVZNbkd5UVg2di91WGx4dnFkWTcydUtkVGt0TkkxODFlWVk4UXlRb1ZyMnNLdDZXa0J6R1doSnFuWThjdSthdTBTK282MGxXcjFxOTFtVjBFaEhTVGE3aUcyc3N6czU0bTBOZmJhbkhlNy9iajF5U0FjcTIxQkJyUURHR0hGTHBEQ3Zia09VdXBKakdENHpvaDZ6K3R4RVZrdTNIQks1MDd0QzR3WkVJN2R6V2JKaUltajFETzhwNGtIeGVZeWE1WVE0OWQvSEY2RG5UT2EyYWNLY1ZkT2lpaTlUMXdvcnoyemNaNGJITjVKWXhISktQVXJzVTlQS2ZHakZBWlFFQTZoUUF2V0cyb0lIeTRUeTFBalBZZHphampROU1hcDRvQ242M3dkb1ViakJMc3NsTkxyKzNEWnRGcVdGU2c4RkppTmRYN1RFWVcxUE4wd1RCTERsd0o1cjhXYkhWMFZBVnRrMCs2SEtQMmRhV0dRMmVhcCtYRUtjQjhrdWlHV2Z1dTV5NFRiSmtiZ2czV1ExdXZ5Qk9iSjRVNE4ydWc1TnQ0YW9HUjZ2NFdmVzFUdXlReklJd3JUbEZKbGZ1UzRqS1lvbEw0SHlmeExpS3NQYXdCZkVhcFVydnNiVlhGM0o3Mk4yM20vY1U3V3RSL21OYVhETDFVdFQvMkp2cVQ3K2cvdWZib2FhM1g3ajZhRjNRMzlTNCtlQzBlYjN6SnR5SVZyNnFPMzdIL29GTkE1R3JMK0hYclpsdThkK3VGajc0WDVzZTRQZmhXeTRUako0dmJlTVZNdUhleGN2N0h2cUtRUW5mY2Z4SzErVHJld3lNUHJqMFRJNzhDK0JOalAvTk9JUkJFcUwyWnV6YVhSdjVseWVXZHFKSVZGVlBuT0hPdlBIRmc4TGYxSC9NbW5WYy9XVkJqLytPWXI5KzZYV082VHFmZVk3TjZ4SnVGWGNGdDRHN250dkozYzdkcFVuWnVKeWNKR3BiVWJTYnA5UWFISmhXS21MZERPaUJoMjVGeEVQUkJDb0JnbG9BeWExRmxHOEVQOUtEMkNZSGF6MlZkTWpsSTdmeVBjcExqK2FrVk85eVp1SVpHbGNTM0ZGLzg2ZHFIMHBPWG5uWmxJYjVrWW4rOVZIbGtsY3ZzYVd1ODArTXpHL0lYclp5Y3RUZ2F1MmQ0cEU3bkU2WFRUUkprcnZKWURCM3o1cnE5aUJmOVovVTM1eTRpQmdNaEJqMElVbHZFT0VYMXV0MWVyMGpyak9aZEhxemFRcXhBWTFybldxMzJXM3QyR2JqQTB3UzZDZW4xV3ZuQ2w0SE9kaDEyVVRSbTU2Lys2THR5MVp1MGNlOFhwL1BHSmlvMzdKeTJmYUxibCtROW9yaHFRWkRVME1neGhPOXhTSUloamFQUjJreEk1NVgxdklPcnpBWFBYRDZKK2l5NFYyU1FBUTRlbjJDVVM4S1JvTWltY3lTNEF2cmpDWTkvR3hHZ1hmem9tVEdSak4yR1RIeDZrYmRkVVJHV2FaVzZLUW5SdHZyb2RnWVlDNWlUdkhCR1hYbzVLR0JrWThNQUZiT2JPNlFmRW5YZ05ya3liZkZLcXdlZm9PYTVDbng3SXZmV3FrcTJpRXI4YWJMZGJrWTFGRjJoNTNwUTlCTkw1T2lkdFNDTG5HSTdtT2FrcTFaRm5PeTJTeC9ETThCeE9VUWxMdTZkMFN0Rm9LSGhzenlhVTQyNDRIQ29GbW01dEp5bWt5TW9Pa0FCNmxWMzdJR3NGdGpjdEpqaEhFMUtRY1RWcC9iSVpSak1CY2VpVE14Ty9TYVFqRGVqR1ZIeloxVllleFd2L2xPVmRCbDl3bURLTHpsdWp1eEdUc2QvdnQ4RVdUNnN2bzc5WlpmVklXY0RoOUJJdm8vTDMzelRhUnBDYXZmOHp0ZHdhcDMwSFEzRGxmZFdlT3dtKys4Ym92NjF0UFZUbWVvNmhkb042cjVzaGxGcXU0RFFzbjg1amRmVW9ORlBWT3VlTGRXeHpWUURJY2JjNy9tR2Z0dG1XREovSExGdmxsaHJaYTN0ZlMydFBTaUZ2WjZxbEpoK1hTY2Yvd0ozbXNaL292RnkvTmYwa2JhOWozN3FneXhaRmJadjJkRGwvVnEyZWpmaHlXRHkxVFYrMzMwVzdQZGJpN2NXaVNSczFWeHZEclYyNXNxUEIxblo4QnV4a2RvNXBJTUdpaFZDRDh1WW9FOTBJTGdtTFlnZXE2bk0yVnI1d0VLTk1UT0NYWmV6RkZXU245U3ZWVGQxdDdMSzA3Uk1hbEZxWG4yQzgzU1JMbWFHT3c3V1oxRDZDdm85V1IvVHIxQjNZZHVKRG5HOTAzMm81VkJlZldHYUhCS29xT2h0ajFlM2VpNXJmT0dKVnZTcTN1cGpkRmNmM0k0VEY1U2Y5cWcvcVdSOFoyeVp6aVIzcVVaQVg2bkFHR2VaRGhWUGFWblVKQ3pKNXNCTWNBdUd5TnMyQWNLNkJEVFBjNlIwYXg2VWphU2cyNXc1SDVieDBXQnEyWVhiaENjNmtldEt4NTU2WkVWclh3ZU9wS0ZCYVptay8zeFJjdTdvbjkrUmRlMm9FMzN5cCtqWGNzWHZSQzRxTU5tbTMwVmFrVVRzRE94Y1UxUHo1cU5pY0o3NnNsa1AxMTEvY25HVlFjLzk1ZTdEeVBCTHp2cDhuUEtmdlgwNGJ2LzhybURxOWlheDRCTHFzSXRqRFlEeWtLMHNpY1Y2WmVZekxYRVRLelRadzlqb2RKbkpxMDk2NWpWUi9yMHVMVW56UTM1aFlGOXRRWlQ3T1dVcWE2bTRhVldRNE5KcW5QZWVhZS9zY0hRK2xKRFRaMHA5WExNWktqZE55WlZRODJkZDlZMGpFNkRjMk95WVRmTlptd1l5ZGJvSDExMGc4RlVkL2ZkdFViRHFEVGxiNUxSZFo3aTFvM2xwektwUXFvK0l4VnZOeWlERVBhOVNuNXFpVVVvRmhtcVJVM2VFcTdSTFZBOGs5ZHVmWUpsYnFwd2RGNjhrSzhOMTE0ODA5dnJOY2RtemF5ZFBqTVFtUFhLOXhZZUwzSlJVUjlBNHNOWEgrT0RqSlA2bWVPZjdTaXlVUU1HajlkVmJmSGlLU0Z6ckw2bFI3bmxHVGU2b1pLWjZweWNXdHcwdGV2dUNhN3N3b1ZWa3d1NWJMYVNpZHFmdXZwdzkyU05nenE5UTJNRTZtVzczK29uY3pLdVJkM1owQjA3cDNVZTVpckdKd1c3NEJhT2l5VHNtbDBpOXArYURHTTBnWXQ5ckExMkQ0cDZlVVI2MzhtbzkyNDBob3hpVkVZUDBpNWlORklqRWRSUUZ5cU81NmtWR1g0MkVBaUVwblRHYW5UOHJKakZpMlNIMjZXYmVURU1WeUVmbjllZlJIMGFaNVcvYk5tU1YxOUI2elJTcXkrbERuVjg5cFZkOTc2QVVCY0o4c2V1ZnZqd09uU0QrNWxibEo2VytwZzVOQVY3TGRVdXI4ZUFBcW0rSE01NTQ0MUJ2YkF3NndiQ0lLaDR1cVkyTFU1TmRzNU5KUHNaWXpVd1o3Yk5HN2hvVVRhckZBZTJBT1BVTWYyeC9VTC9sVzdYNU83RFYxOTF1SFBhemp0QzJlNUZyc3djQXVObmwvVjlYS1g5L3lKYzhhVmhvS1lhbWxFOXV5T1c3TnJOcDUyWjc5Vytkc2YrczZPTk1lckZpbE92V1NoU0xtbnRXNEdNT1FMNEM4WDZTbVRuMFZIVG5Ed0xFakJBUW81T2VXSDhLYjlxQkRCV2FKOHk3S3lFeDNNQjdkSlBBSjFsVUI0MVBrbXVrMzZ2a2VxcE1TRUF4dnVoL3kyOEJrRTRZV2ZFYXNwT2NWNDNyRGJxdzJXckU3QXZpZXkraDkyelVuWFVvc0ZhSnYxVm9VVktxYmhzdG5DZVdXK2VQRExwdVNJVlg1enM5QlE2MmVrNU45NDVackxaMnVtWWpyTUFpTE11QkxVaERXaEpGeHZhd2pRTlVtdWw4ME5xRWE1SDAwSjFEQ3RpK3BpWmRGSDFVQktkZFFqUkx3elFrREg2bVZRWVdqVWNsK1dWOU5zQmgxWTZIQ3ZSZW5DQzR6ajZpR3FFanFleGVWeFRWS1RwSWFsNkNIS0I0L2o1ZFRoWjI3Z2svZmdUMVlXRVJwVjFSbGtUM2ZFTXlsUnFIQW9DSzF0cmpHcGdHT0pIeGFhaTlTdVJlV3pUMXFaWjY0dU44WTAwRkZLcjU5VFRMTFlycXVsb0lxMHBQYWlzVmNzK3poQWVyYTk1VnMvTGxTSEwyRlpkeVZyck9FZGZDaGRxVndzYnJySndxS1pJNnZRZzFxeFJObENvSHVrNFBYZXdVVG03WFZlTXpQSTRNTUNkT1o4ZW5CSDlFbnU1MFhvUEZpVEZOZXZPY0w0cmxJM1NnMFFsNnBTU2loZ3RrZVQxRmhSU1lEVkRZa3BwcFpWb2drVkpRS2U1M1BSNG9GRkFoN2t0MkVxenczK0ovbWpxYnBTaTE1QWhONVA3aHlQWG5ZNjZXUXJSbzFnUXJhR2VGcG1tQlRMc3owMk42WWx1aWRMR2xCaWswczFwSm9JamFZVjRNbTZQUW9VQ2dINk0waU9kOG4weWJpbk5zQlBhTG5jR3RoVEpBMit4eUJSQzRLSEdIaGtmS0pQV0RGbkhhNkVpRmh1S3V6VnVFYlAzUnhrTlVGUkdpNk9FdUR1VFRvbFJRUGNvNDVybHBhTWt1dXJwSld3M1VSZy9qc3BzVWhxK0c3RlE1R1pDRWlGM210S2tTc2FkWVpYRHJrZmIyWTBBOFVxbUlJTjJTeHVOWitvQlYwL1RySlM3VEYvcEpKdVFkSWl4bTJHTTZGc2hhU2IrSGswWDdUNUtGdUtoVEVKbTNWS0JCQmFldXFBbHRRemJvelloNFcrc0JndVpocTBpRmdRazJpeEt2UjE3Q1BFU2JESWlVVy9CQm9PSXNCVWpRZ1JSSnlFaUVoRVRJN0hhREtLZVNBS3lPb2t1Q1c4Sm1mMDg4UUU1S21Fa0Nqd3h5cFF2TFFyaHFxQW9TaWFDaVI2WkpCS3lDbVplYjVBRkM5R2I5RHh2c3VvTXlHN1RJYjJnMHhHL1FhNldxa1VCR1ExbWJCR3gyUUExQ29LT1NBRUQ3N1VMUEk4SWJ5SE5yYUlvMkhDOVRyQ0lFblJJd3J6Vm9yT0pCeTZXQkI0RFlTNmlKaGtUTTdJaElrblFPa3pzWm5NUVd1NHdRWlU2N0VHSUlGSkZFT1pGN0xOaUltQ3NnMXpFWUhGaTBhYlR1MFZCeE5oc2NoS2hXbWN3MlFXclh3ckxXREJLV1BBSmtOQ3BzOVE1QklJeHI4Y2lRazRzdUFWaWhuSENTQzlpbzBtV0VMM3lyNWZNTWhVbU1QR1lOaDZHRVVsTm9sVVNzT0FsVlFLQm5na0diTlJKT2tUL1dTV0RBVm5zdkV1VWVBVERyWmNFUWRDYmRKSlFSeVJNZURlMkUrSXdHMnpFcENkMmJIWGJqNTk0Z01qRUlTSkpieVBZd0J0RmlVNFZSaTZyWU5JYlJRSERZaEtJVlcvaHpSam1Ec3VZSjVKY2pYbWJEWjJsb0tSK0Q5bVJ3WVFrblNqcVpPeEdBQlp1WkRNRFNHRVllcjJYQ05BVFNSUU1Cb3dRakN0R2dzZ2ozaWJ5ZWgwVzlMeW9sNGxvRVNTN1dXZmpkUzZSM1FQQTJGaXJCSjNlYk5ZTHlHSWxvb2RPck5YRVd3VXZqS1dCS2xjNG9BSUFCK1FCdUt0Q1ZwMEZtYXd3WnBKZWdrQURqMkJlZVNjdlZQRjZncUFGT21nR0RMZlZCMDNRSTRzazJQUThFVVdUU0N3d2tndnVsUkN5UVJlTXlHL25ZYzRzTUkwb0VPV1JhU0loTVIzQ2xGOFNFa1cvSGpZem1nYzdHNnQ0d2NVVHFFMXkyZHhZckhicGRXRlJNb3NHRElQT1ExL3JlVm1IekE0akVSMGlMK2k4bU5SWWcwZ1BjQ001ZUoyWDZERkFNVUFBNEFvMnN3bGFJQk9yamhETTZ4cHRocURkaHEwRVVmdWxBSTFFTHhyTnlDNVVPd2hQQUh5SllESEV3R1UzU2pxOVhrY2NzaDRKT2w2MjZhRW1JN0ZoazBHbmt5UVJ3NmdLT21Ua3NSbDZBQ3NOWVlNb0ROOGVmZ1RxQVdUQlJGdXJnMm1ta0VhZ0FsaFdXQlFBaXF0RVdMbEdyQ2U4RFRwRERIRnpuYjNLNnVhbGFoM1RqbkNkY1ltM01wckpSVFVoU3lpK3ZxaVJTK1ZYYXdITW1jUUVaK1BZdHlpY2t1RHlhSitqMEZBci9MbkNVcXFqdWw1UjhMSG93L2d0VDh1NzkyaktRTzI3SnRoczZtKytKVHg0azk1cUw5NkYvQjZTUnpaU0xWWjhiTTNEYUg5MDZoM1BhVXlsWUsyeDNuaHNhQU5aT2RQSlZYNlRVOVBqcUliVHRRTW9sMkFxaUVxL0MzekxkYXlmNXlqdXIrWjRiaGhjVkpvUWZ5SkxrTXhNUC93TlowdHNMMnIrNGcvbjhsRGFXd0RhK3lhQlkzS3FicWxzNW80cUhMTnZSY1dGbSt4MXFzeXMyNTNoWkZXbUg0RVN1RWIrVncwMXFsendNY04ybk94RGYwRHYxelJRcFdLK2ZNOU5tTnhsQy90ZVNjVVlCRjBsbTFNaFY1QjloMkRzMVNxbVh4RGcrT0szVmVnVlBQMFErc0FaS1B0amJuVXZHdEJZZUdpZ2Q3WEE1UXFjR3REWUtZTzBhNE13QkZUeEpOZTdXak1LWHZwZWRwR256K2t4WlJPNFJyNE1wR2NuVUlueGxLWktRVkxwSTBhYXpTd3JCRVcxOGFBWldheEExQ2ZRNWZkRHAwc2ZETHBmZlVKOTRuNDZRTVdQQWQyUExvY0EyV2N5eGVnZEdrdURMb2RNN0V0YWVaL0NMSUNSMzQyZnJ6WTZKaGMxQUVaejBSU3NicGFDMWkzSW1sd2x4K3ljMjdsSjNHUnVDcmVZVzhtNCtaUkFzV21jaEF3MXJGMldhUmVvOUl0Mjh5U1V1SFNscjFjejB4Rk1YSWtKRUVOZVhFeUJGejU5MVIyTE50OHM5dTNvbU5vcjhMa0ROdzRmdXZHQTVBcWtaNnp0TXZRdXVPT3VPeGIwR3JyV3prZ0hYTkt3WnBlUExDMUt4NUxnNWtWM1hQWDBRcUYzYXNlT1B2Rm1UZmdSQXhRdW5JY3VhMnp5UkdydUxsaDIzSDMzanRUYWJWZGNPalhXbEdxQ3Y5alVTNi9ZdGxhSU05bEN0YTc0cWV6Q1UvTVczaVJzdTdzbTRtbHFST3RaWkVsUDdYNXhzL0FoRitTbWNsY1hyYVVBS1Z6TE03SU5TTEVSd3k1cFZETDhVZ3JMbEVTRGlDZk5hWnI0Mmo0VExkb0FLQ3FQVVI2TGg3bUVGL3h2K0dPTnRTUmdsS1cybUxYS1o2b2pRZitKNm9hWS82Qy9NTVYvd2grTDFoejArOStvYmhpYml1eTY2T0RpSFRjdVByRjQrZktsTzNjc2VXUEpHRC9LeHFEMEFLa3orYXFzc1RaSk5vSzdNZWIvY2JYdmdCLy9DUnorNmdQK0tDU3FyaHVkcVBEMmg0c1BMTDdveDR0MzNMUjArWElvZWJTM2FPTXl4Mng3Y3hwY2NOUkFDeldwU0QrSXBWM0RTclZJeXIzOTFPazhiSmYzYnNWb3dza25FZXFZTWJEK1VNTnR6NlBjVTIvREhycm5OMm0vOVNTYThNSzkzWWZXOS9YVS9nVG9qZXRoelptWmZuMlFXbjFuVUpmUkpQdUxralpOOUJnSW9taktIcks3aEwrM1RWOS9PcmQrZWh2NmU3WmtXa3Z4WmRYMzFBL3h2Nm9mT25QTEw5NjE2MkpTaGU0cnlxUnRtYVl1Umwrc2k2RDcxQzBSYmR0QlJkbE1pWnZIcmVMV2N6dTRPN2o5WE5ubXY0QVlmNUh0Y1F3NXR4U1hPc1BaRTB3d2w4bG8xck52eUxEcmFJWnRVeUhoNHFSVDVtS2FtZUZtNUVRaVRycVp5U0FvaS9xb3RSVW9oRmx4UnhMa2lpS1h4SXo1Z3p0RGF5VWE0d3h0UktmOVJLak5tVzEyUzJIZU5Ub2VjT0kxaS9jOGNOZlNGVVpwemFJOUJ4WlAwNXQzN2pUcnB5MCtzR2ZSR2tsb2FMcG83d043RnErUklLWHVHdnhsaTkxbXp0VUt4SDk2VlhOODRhb3I1a1MxVi9QQ2VITjB6aFdydEJleURBUXQ4MzNFSWdDZTlJc0JQQVE3NXFBZWNENEw3eU1EdWNJL3ZvU05XRHNrZmVwMXpuRElsZ1dVYjNjdmp5YTF6cjBudFdUZWtwdjY3MDB0cVRQclo4L1dtK3VXcE83dDc5Z1luYjhrZWUvYzFrbUk3MFc3ZFZMV0Znbzc5elh1U1hTRTZhUFFrZGpUR0dZUFBOaHVERHQxTFQ1aUE3UUkvWHNBWjdQcXdpMERPc3p6TnQ2bjVyUG84RDdDYS9jdzJybFJ4OVZ6RVM1QnZ5d3g2aDZtZUVLV3RGVmM5blJDUWtFOUNzcjBFQ2wrb2pPWkxudkV3ZEtOVUdHSWZoRUMwVTlDVUxzQzB6cHo2czlSVTRFOXY0czZWV2FaQUhNeDhrdk55WmROQ3FCQThkc1RrQm5LVUw4ZSs3bjZjL3g1OWVmcVoxRW4xU21pWDYxQVhHeGcrQjk4VHZNeG5qWi9abzl3czNBenN3THRMRm5WMEN4M0ZBWDBpMW9iaURHYmtoVisxNWowd3MxUGJydnppdUcvYjNucnFTZXZ4NWNZdW14bVErSHArVmV1UDlCUGREMkxza3Q2Q3QvMDFkY29WZWhSUTdmTlpGQ3Y3TGx1MGZJdVBQMktoN2M5ZVFYUlhmLzRVLysycGZDMHdXVHJNdUJMNXg1YWYzWC84Tjk3bG1RWDllRHBYcVVtVUsxZUNYSGRCdlJvMS9KRjEwRmhhMGJKOWxFZDdlbmFOejZZUEIvN2ZzeUlYcjg5VVdKNWpkVkJIYXR6NTZGWUd2MGdFRWR5T2FkQi9hT2gxYXJkeU9WZ3VBa010NXFyMEF6T2xiOU55b2JmNjQreGp4UGxMSk1NcU1yZ0xDbjJuK1kwU3hHWXE3amRrWWRack1DK1dxcit5VDh3U3Zka1hEdDhsZGZyL01Cb3RSWHRmbzdkYTJuMmpqKzFaZS9SZHY3TzVhNnczdjJIOFp6c2pNOUwxQTZEZHI4VzVUSVVveWxwc0RsS3Q0WmphdWZPRVg2MlZXbDJiNmo5Q1I5VzNyU2R5bzBUV09sK2cyVkQ5MnNHaGdmTGhwVEo3OGFHb0JGTDA5cXdXcGx1NmQrNVdsangvYkJyYitSdWh1MkFyWUtNdGpxa2FEZk9wT3JGRVB1UUZaeEhzaXZJbUs3YWZVbTBtMTBPVTJadUluVzJJZkpnS3BHazJLWW9SVE1KK3dVSDRaWk5DOWYzVHA0MHVhYnBhcDl1VWxpMlRiR3RSM012VFhSaTlaRFkwdHZiVWxQVkhMckllMm43N0N1bUxacU9kZ2wvMXNiQllkRUdTdjNTQm9SMWpUUHZXaSs4VnhsVE9WcExGcXpxWFQ2eHhwL1Z0Um1tTmpnUVRoMWVmcjFwRHM0K0ZYWWtsaVNiSm5pcXF0czdFcE1YejR3dmJzNVVkYXJmMHNiTTRwREpEWmRmM25Da3dXU1A5TzlTTjZxM2xDUEdqT3ZJWFlxVlMzRnIyVjQ2U3JneG9pbkhwRFdqc05vSEpLZ3lEVHZZeXBjREpGaTBsbHU2amRNVVdpamVuTXBvMGtxZW9xMDNLdjBsTWtYbGo1a1VJL3FPMzlONngyY1FIOS9XZTYzQmFCRk1TeXp4MVBLZDEwMmIydHY3OCtucjJpUHZvY2VrQms5clpOYUMyUXR1dW03aC9zbFdIYVVicjdUV1dvWFF4S2J1anRuWnZya1RXeGJXNDl6SXQvZXlvWWxyVnJ5WTJ5V2J3c3FDbXpvZDFVQlRQdFMyc3FOOStleXBVN3Vkelg3dkdTNmF1blp0VzJ1b3VkWGg4c1JzSnAzRnZMRzFWb2xNd1BWekZOM2tTTmpscnZaMWRrMWJNcnVtZ2k5Nk9kVzJsNVVXelJBdTYxTThJM2xjb2pZZ2JwZEhydWl0MXVObWJjaXNDRURMNDg1NHlvTkYwN3RsOThqSWFYZFlzT0ZFbGJGMkRWc2pPbUt1N2t6dXFWKzZhR3R0V3kzQ25kbE8yWXlRUlp3WTZscCs4YnBsYlUydDlyRGRKVm1CNXBicm02Nnc0Q1d2OSs4QVduOWlkTFpvSlRxTDZMTDZsRGw5R3pZZGVHN2I5czR1dDgxZUpTeDFXRVkrb3k0RU1WNk9lSWtBalcvSjZ2VlZsaHZNVWZFZDlVODN6K3NJdHZnZHdiQy9yWDMyNC9QWEhGemFNZFVWUXBnc05SQXpWc3lTMTRTTW90VW54WXl5ZXVkM052VTNUMm1mSEFnMnQvVDFiMS93QkpyN2NsWDQxTzJsdVhGd25LRXN3ekgybXdMM2NVOXBGaU1xKzI0ZjR4ODdOdi9UL3JIMWpmMUdLUDFPZWNVbjZpdmNvMk5VN3R4eG56eGxwWnVTdTB3V1FhQWljV1diaHVqZXNsTWRjUkxMZUtFWFRGQlJHSnBYK1lWUnVnOVhuM21zYUk5Q1p2cVNUZFRDQnhDK0tNemt2VnZLZGt3am52L0wyNXNBdGxHY2ZlTTdzNWZPbGJTcnk1SXQ2N0FreDJkc1daSnZLN0Z6T0hFUzUwN0laWEk2RHBDYlFFS0NDS0dRY0lVQTRTYm1LdENRUXJsNUNhM2FBcVhjNFlWU1dtaE5TM2tMTFVmYmx3S3h0Zm5Qeks0T0h5Rzg3Ly83UG9pMXM3dXp1ek96c3pQUE04L3ovSDU0cEdnRDREUmI1b2NndUVIK1BTd1RUNTRVWStLTG9zaHllSHZ5bFpVclBSNzBCeTU2L3ZubVp2UkgvMEU5a3I1VFRkRFBrbXZmaWVGcjBhVXhmSzM0NG5Ya3BHZWxQRVN1YTM0K3ZWdzlBajFxZ3F3OUpMTHl2NWx5VWpQeUxPd1lDeHFyZU5td0hJdFZZRUlCeFNHQy9DSUJURkg4a0NEVFNtTkFLQUtQRWNrRmU4dXZndVNkUnUwdnRhemkyZys2TkpMZ000UnBySlJpVFRaQmh3MCtRZElneFIwd1dzbjRvdFRtN2crNUdLVEpLTEVBRUFtTDZIcGorc2RrbDBrTlVTYUhvS1VCd0w0UytBOEFXaXM0VEJqVFZCT3pWN3Y5NkNhdWxBSWdrSk5ocGxFWkhBWThFR0hWSG9jWUVaQWlHc2YvS2tZSWxRVlRFU2t4aDE1VWpYMTEwSndENHpWZzZ3NkhMWEVuTm01b2tyU1YxcjZXQzMvYXUrTlAxNngvOHVJbDVkMHpQQnBvZ0p3bGN1TEJteDdjdjZGbG1xQUpPbUsxclFzS1ZsbVkxK1VNZXVoc3NrN3JYVGJGLzVOd3cvNHZEMjk1YVU5anorNGZ0UGZlNlRWNCtmR2N3OXB5MWszdjNYdnBqejVmMkJMWXZyaTRkdUtXK1owMTh2TEpHNWFBaXo0NW9WaUJjblhyeXBQN003VVRGWEl3dFhKazhQM095bVh3cHBUNDRYVDVmSWUyd3JhKytZbS9UTjcxWkYvdkU3dlBLcDgxdzJoamRDeG5xWDNqL2h2dnY3eXZHVmZPSHExcG1lOWM2YlE4bFI5anZIT1IvK0Z3UFFqL2FkNGRGM1kyOU95NmJPTGEyNzJzVHFpd09LVFdSWWZmdWZ1U0IvNitzTm0vZldGeHpZVE5jNmZXeUN0WDM1b05STTdadHR4RVhzUFlpVDViUkZEaEJHb2RjVnhxTXhaMGdwRm9JSXBrSEZ2RUZoa3BvZEkzY3ZMaDkyajMrUG14VlZkZHRXcHBTKzg1Ti9ZUERQVGY5d3BZZk82NTU2SC9nSmd2dzhJZHJ0QStaMTBzY00xTDF6U3RXWTFYWDk3YWdiT2RCeThiSnQzaStlOGVMY1V1VTdHQXJUQ1BGTnZyNElrcnQ1WDBNRHJ1aS9yc1FSc1d3d0xSU0RSaVkrLzRzZnpUTjIrVXYzeCsyN2JuZ2ZsRzRIbnRWOXNmM25WaTU4NFR1K1plZVZaN01ZZjBxc2NOOUtvVGI1MDQ4UmJjK0tiODdGTTRJeWdENXVlM3BYNjIrYUozaHQ2NXFHclNvcG1Cb2JZMm5PZkVpZXdhSXNab01GQ0ZWQVhSQkFsMUtlK0k0U0NqRWlUcSthdGdYU3VzUlRxRlJmbUNjZGlPelZjM2FrVEgwZlBKTFRmTUtEUGlkY1d5R1hzTzc1bFJwbXhnV2QvaHdTVCs3cGprNFU5RHJtL0ppZ09QQVlXVFBTQzF2enRvbFFjK3Z1cmdSVE5uWG5SUTJjaGxrTUlYeU9TWFR1VDRna0lxMWdDRDlCdkttSW1TSVhnR3FCZ01KY2tKak5hWmtBaFpFbjBXU1VzZ0pkVmxjQjZRMmtqUkNlVmFVZ1VWQVFFRGtBd1J6SUVVeGh4SUFlSXJJU2tPK2NxMUNTb0pNVUtBTWN1c3EwSWJZTTArOXlBbWtYOGZLY09ubklRSkpxL01DcENnQThBRUtiUHlMQngra3lsOFNIM3U4TmlhSW9xSytJaHZaQkR6UVk2ZVcvdGhUem9wc2VlbWs3QkhvYzdPem5kTWNyRGZLSG1abnNHa3hMeVd6ME9DKzJlS1ViRG4zQ05iVlJ6UlRzUGJPRFNpMlg2WDF4Smp0Q0Y1RG5yY0dkL2RzQnVwMTlLVVdzWXp2RHQ2NUhOejhjUXVqRWFTKys3dERzYmhnVTJRMkw2RE1Rd2RSdkVDVXc1SllFRUpzZUtxTkZIS1FubEZBK2k3dkdISytSRUFJdWRQYWZnUm1OcFF2ckpUdm1LcGJrSjVTOHlCcHVkWVMva0UzUkw1Ui83VzgrYk9ZRk1UVnRDTlF4OFRMM3hYVGVqZnE4cXFhMnFxeTNiOUlRd1d6RG9Za1FjVGZIVlJpU2lXRkZYemljK2NaZGUzemV4ZFR0NzVJMmc4TzRmRS9aV3IrQloyeFZVWGV4T1NGWDJGb3Q1bThZbm1hdUN6QlVpSUpWZ21Qd2xXZ0hYejRKelY2MzY0bXJsV2ZtcjJncmI1TnIzOEZCTDdRU2UwbGsxWjEzYjBUZnJhSVIvOVIxRGJ1WEpsNTdTenp4NzZJUDBTRk5mdm1CVHhSTkx2Z212QmwrUEhIL1NPcnkvK2MrYTlLZU5ySFprVGNUaDJTVGlFdy84amVOVU4rL1NRdVlQalJ5enpZNEEvQnFubU8xK1hQN3I5SWZubGMzbWcyYTh6bWZuT3QzZjBQbmRnOXV3RHovV3VmSHp5L3J5VitiMGJnSFQ5N2FEd2RicFFma24rNlBXZDErM1RGV2dPYUtGdVJTL0svaWE2YXNyRUEza3I5NWVzMmJqemRWVEcwbE0yN20vc2I3RlBtMjhZYUMwT1R2VndPTjZYVlkrMU1pUWNtbldvWGFpS3c4Z0JyTHAySkRBa3RJUU5ZK3piREJiczM0SWJDTy91amFIeVU5UWVvVlNBTnNiTWFPaEMycTEzaVM1amFhSGNXNmpWMnZVZTJoUFNtUzA2QzJlRmdnQ1dqcFVWM0R4RzFqMkFLc2VyVkJ1QzBlQTV3U0RBbHJGeWdKNGxRQ3VITXBsMUlYU0IzcTdWa3BVeUk3cVYzbzF1cWtFM3QwSDBHUFNzMFZsUnFjYkl1dWNVVlk3cUVzNWhlQ2oreEppOUZWczJwdWRpcTdQQ25CU3JBamlLbmZoN1lDN2hraEU1TWg1eHdNd3JkaDlMaHZrZEpBa0xNdEFybTYvWGNPN2FLbjVOODNLenRmdldBMVp6QlZ4SnpxUmZJUnVvNXJ2eWFpbHc4Z2NCNldxTVpnWE9BVjFmWGdQSW1lbFFwVWMrQXZhNEtnVzNTOTdMem1pZWNhQzBlMGJ6RmtISjhRclpiRmZ5cGVUQlB4UVZmUUM0Si9GTnJ2bFNmand6TGlpWVczWTgvMUZJVUVPeUQ0YWs1Mk1LR24xSnpCeGljbUJjR0g1Z09Cb1hBWW51a252bE8wNWN1M2VoMjFsMTg2N3loa2t0cjRKVkowNkEyWGtZWGF6Sk9RcWs2MHR3Ty9ncnVKMUpYdm4zL1p0ZW1WYmJzMlIyMnpraFRuUGwzNEg0OTEvbGdMdHNsakZ3dTM0TXdrZVA1dFlnY094R0k3VTZ2eGJaT3RTRjhGdjREaFFGOE4zNENVajhveGZMcjh2L3ZxT3Y1K3lBdjdBaU9uUDZMVUIzeHgzcE96RnV3dkV6b0N1d2pkOExWZUVhSnRuNzZObzVOOWZYejdOS3hUcWg5OUZYSC8zci9yK2ZBV3BoOEpzem95enN1dUFFR2gvQUtZcStDSTFoUHNVT3F4Z2c0aEtyR0NkVVozZzBTdEJCSFBDeVhkU25QeklXTVRxTGhYbEI3bU0wb2xGa2Y4MDR6V0NxNUdLUGdxczBqRVMvYkhVTzdpcUFiS0daTGwwRDlDWW4zU0NJQlJhTlRxNVpDZk81UCtZUFh3OUZTZytTVDBlU0k0OTVqQmh1QTdrSlhzSHpzZmxVRkVHZXFpOVZRZ3A3Wklxc3lJNjUxMVVIbFgwU2VGamFBekZ5WDJsOWZqaGlLcFhKUGNaZVhWY3FjeTArbXVxcVM5WG5aSk1VMG1ablVZdFZ1U2pqOEk2UmN5eXhXbVdWRWF0TlhNWVVoTDNKd0loZE1wa3B1QVF4Q3M4YTJDUUViQ0UvVDI1SEoyOSs4K1pRWFdqbTZwbStWdG9uR2ZXR21rV05IUmVVOHpaR2J4SDFqSTB2MzNIRkRySXJXc2p1QlIyTmkyb01lcU1FS3FsVFlQNVByd0xHZ2Z0OElFMlZWWlJoMzkvbjA4ZDdiNzY1RjRzd3RUTm4xc0lPZmNnbzZhcXFwalhyU2ppTGhTdlJOVS9MVDFkVjZTUWpDNThDbGl1NnIvL3pBUWpmV2duaFNpeVVNbG03aWdacHhHNnNnYkEreFpiaUc3Vlk0c3ZHY0xjTUowVWhxL2Mwa216eHVydWN4T3lNYWJLYUNWT29EaFFvbDkrQlZNN1lVbC9Lb0pUTmhPZUNKRjdLQi8zQW04V0tUWitMOHM5UGszZmVyeXpUWTlPSzBZVG1nNTZzWEVtNFlNeFVLYldVMkNaSldMbXFNNkhtVjZNYXJBcFRkaVJHOU4yNEZYdTRaYUV4c0daSUFyYkltOHY4WVhmeUtGRWRJQnlRWE5JNWRiaGN0YXVtOTAvYWVQbUJ5emRPNnRDTjB5V05IeG1UYU51UlhGZloxTXhVRnhSVUd0dXFyTjNMdTYxVmJjYktnb0pxcHJtcGN0M2k2NTc2NlZQWExhYkp5bXRWTGJxYnQ2dHU2a1d6S2l0blhUUjF6U3g5aGY2VzY2NjdCVzFtcmJsdGMwM1gxdHJDV05EdER0WVZPWnhWdFJWMWRSVzFWVTVIVVIwK0ZpdXMzZHBWcy9tMlZVYzNUNWl3K1NnWi94WHNXUmVKUVNITDFEbmJrTUlqU2R3bHpIbTRsS0Zjb0xvQ1oyWTgyUzhaRFFiNTUxb3RTQkNxeUI1TWhraFFKay8yRTVUZkhnVkZFdlNnV3FCL09wUVBNeTRtTUVLa0JIMFpzRWl5dEp5RmhNeGdCQkp1b2lpSkFTN1BXWUF5dGl4TUVNaCtoMTJacFVSaGdOeDRBSk5SOW1BeXloVTZtTEUyWDNVK3RqYmZEdWltS1N2NkRvL2Jlei9zRVVUUVErdzgvWVFCc3g5VmE0WGhiV0tEM3Z0KzNHTjhHMVQ4K0dEcjRiNnUxdUlUbzhzWUpvN0xDajVGMWc4M29pSkNuTGFNK0RHb0ZlN1M1UlgyTzhyWUwrQ2FvUHdHZ3lES3BJMUJqeVIvZHBwQ1p2cTdHdisxaU9ySldYVFlySzhHSFVkZktRRXBVRUFKY0JTbU40NDZBUDU2TTJobVlUSWNEZHNQaGV1d0Q2YUh5VHAyS0taZUpxUzRiZWlEamIwZDlzYkptL28zVFdrbzJBY203eXZvTyt5dDc2NzNkdlYya2Uya0pnQVluYWFqdHpHb2wxT3FHOGZ2aUFsNzk0VUhEbHpZc2VmdzFpV211bzVYckt0YnVqZHQ2bTVaYlgybHRiaTN0N2cxY2JodmNWRVovcmpMaWhaanZJemNYc2NPdjI1Q2NWMlpaRnF5OWZBZStyZXFRMGMydGx4cGl4azVTUytPMUIrTGxmR1dZTUlTbFdLVW1IM0lGNEhlcFRlbStPS1ROU0hsN2VGd1ladHloa2dTdGRtd2hTa05DbnowdmUrSFhKek8waHpBYnUrKzR1TkFjN3pZaDlPQlpvdU9jNFhldnhjZmFwaUNXb2RXbkE0U3JTdHQ4dllqSDM1NFpKLzF0d2NKcElhbkJFbHhvbndlV2IwN0pLS2RFZy9FL0dBSGYydmRSdzVlYVZ2WmlwcEc1ZnBVN0twWW13MHF2bEZzRGg0ZDZVNlJyQ3VVaXFFZXlYaEV5ZjBFMVpIcEg2S1NpZ3NVcFBZdFRhQ0RUQktEeHUxYlNxUDBJSkszRk0rbmdhSFUwbjBzdFErMWFTNUdMRElpUXV6N1I0WFJpZThaQ1BhOUFyOFUyVENoeXZaKzhxWkpaWUZQNmZTb3c1YVA0RnZsa3B1NkU0bnViNy9rcWNOOWcxVGZZVDd4NFpIRXZxVVk3Ukl2d2h5aHgvZHZrcFBwRkhvK28wVjl5b3ZiQ3c1Z2RxNGNGbm9sTlZHUkJ2aHNoS25TcFVpWHNTdllLOFBUYkRabm5yUURrMU1hQ1BCL3c1UjhHQVVjeFVLUjQyaVlPTDRQdTlxeHFYUVNmUlpEWCtHUGdOYWpEd1VxOExBOXhCbXZmMlQ2VzhLWkFkSG9UWHYzSFZmc3Zrcjhpb1JtQXdVRGR5NWhOTENOTkxMekZoL21SQVhxREcvSkFlUXErZGdSVnNDUlZrSDJPUFp6VUMzdnlkS2V3bjNnQXAxQi9wVUJyQ0x1RFJRR0hjNUF6Z2dpSE1pazhvK0tBck92c0tkME1JbnZ3aEVyZklkOFJaRUJOQmhPaWd5RnhZR1RGTjJUTVJvSi9UbnIzaWtxbDhZUjMxbjgrdEcycEllcG4xRnZVSCtrdmtBU2xBa1VnMHJRTXBxM09qcGlueDJ4UHpML1NON3FrZWZQdFAvLyt2b3o1UjlaWDR3SWJzbDRXNDdDWXNLODBsa3hMWWZYVGVYU3AvTFM5R21Pbnk3OWZ5TS9QTTN4NFdYRytLbTRiZ1FZaThwbmZ4L0kxdlJmb3l1ZWR5ejlyekVPanBYNlA1VlJIdXRnN3VmazlSaDBkRUFSNFBMY2dmRUs1SGQ4TTA5UnY2ZSsrbi8vbGZ4dmVtbldMeU92dnhhQUROOUFJRHJjMjZnRlJHeWo4ZTBqdnF3RzgzK2xkMy9mM25jS2E4Sm9ITVJwcFJlU1UzbmxTYXIzeS9STmtFQ2pKT2JCU2Z3ZjY2Tm42RkZEMXpOSkx4Nnd2WU5KMHEvb2xGTFFucDZzWTVXU3JzeDlQb0JjSVErRWtOQ1J5UEtZWTl0ck0wWUd5cmUrRWdqWGpEZ25rZGVYWlk4SVpDZ2tiTm0zV1J0VEFDQ0dHV2hEeERvYlUyeXoyV21ZTEx2SnI0RGtuWUxtbHp4a0tYTGdGU1N0RTFPM2dwMmZTV0t1eWxUR1hrdStHNWYwb3BSdzlTdFdISFVKRDJtNGtQK2xRWmMrUnZacDc2ajc0Q1Nzd3VhZmpPVVcrM1QydXhMb2JzUmZQWlRCbGxCdzY4TlVEZm9XTzVVb3lqTlcvWHRKaFVSN0dxT0thVVZhVEJMcGgwa05wdnB6MHFJWEhRVDlZOWZtOCs4VUlqUDRIQVFYSGxzcU9DUGdBNG9JWGs1SEk1WUFId2hqcTJBMEhJMWpRMlkwSG5HZ285RW1xUGo2Z29pRFJkbzZud1R5aDNML1FFTCsvU1RjL0QzOWlVUi9xc2ZyVGFaU1NhKzNKNFgzaVRBMENRUVRBNkFuZVZBREUxNzBQMUxEQkswWDlBOTRVMTZOTStuVW9PMEE2UGRxc1NLWThCYU8xeEg5SWFINm4zQ29GeExyQkJaemJiNW9uTFJuT082TCs1Q1loUEcycDBjWk5ERWtrMGMrVEhqQmdKZE9lUk00M3VJVUZaMHVKMUtwMUlkSFFDS1JUS2E4UXdQRE9GTXg4MG1PTG5XRTM2TUNEMEx3RDBmaEFCRS9QcG5LOGRiQ0RITnF2dTAycGRpdU1BVkd4b2FGQndRWmV3SFEvekhDTjNGRXViNFBsK3RZNVpKVFN0bFN5ck9VVWlWR2xrd2hjMDBvcFJ0K0FXd2NYakNJNU93WjlMK1lDSkxpeG1HTmRpUVhMcThGekZnSDRWWmRyYzZsazZ0ME92QVdTdFRxZFBJT3NCOGNHUFB3TVpJaVI5Q1BrbVdIdkVNMzltRlNMaU1xMTM5bXlrWGxmRnR5bkxyTVdBZmhYUHh3NWI3NzBSUElUY0ZicUZ4akhZWXpsTEtTdmYxZ3YxcmlLdDNZaDNHNVpsQlhNeEZtN3JEMkdzNFBJWTUxa0ltY3FkYkREbjgycXFqNCtlRDhNUTlUU3JtT29YSnR6Vyt2RVJ3VDRsZ0hVYmxPVzkweERzTmpvMTh1eW9FTE5zWmhQQmFoL2dXM2t2ZUlTNlVGSSttV1VVZFNjdy9yTi9Sbll6Y1dHZDlRMzRCenMvZjgzcDNnZEcrYjNITUdNRElSZXE1eXovL0JDd1RubnU2ZDRIdFdvbnR1elpYemV6WStYWG1hNWxUdDBJcmNXSzNncGVhajlDaTJmS3NucTVIWHRZSm8zaGlDbHhxL0pTSUNseUMyL2ZTQTE2dVFwSHU5YVFLUnhPRmdMaTlOWklvaG5KV2VnVjNRZ3JOYmpIZ01FWnE3UXpsM3REd2ZFQk9KV01kajIzQkxRd0RrWWMvaHNtSVJVSlVaSTJ4dEhSb0JyUkhRbjNWeW16allMeGtaOHZqQkZGNEk3VmRnbS9ycFRXWnp2OWtNS0FVOVZFRy9wWHR5Qzl6UzBGeXlXTjJEWnFtc1B6aWp5RG9PTkxObjVaemdtSzJXdjJTZzREejhVRzBCSTYwMFZnNExieTFaUUJoUVZwU0hjQW5vMTRZNTZqRktBY2k2aVVQeFJqL2QweUZwZ2lZd2tzSUF2RWtBa2FoVFNLcWpTQjNSYndvM1FUOFkzMVVuVThycVExM1hDZ1UzaVRTQnN0NVB6L0I2dlVNa0E0Ti84K2NmUFNvUFJhbE10YTFBTVU1bVdaNXZ5SkxTSGpvMGlwYVc2YzhqclgxdUxLd0hkVTczRWZhZlhIMWFZUlBJRUIxbmFjank2WDdHemtCVG03cmxaUGNtYk9JbnMxbWk3M0I5NlVEM0pqcDVtaE13Z1E5djZvWXA3QnBBcHI3RGZVajRWYktQY1p3YXM5d0N6Rk56a0t4SDV1bDhtcUx2emtCVG93cTJxUnNrY2JsUGM0SkpwUk1qU3d4SWlVOXpIQmRaZzJUNUJGa3YxRklXZ29xR3Y3OG1OZFpBd2RHcHpVWU1acUlMck1yeWF5N2VZT3djaXRjZUZLWkg2N3FtOThFV3hiaCtKZGt3YVVJVjBEZDlxSG41dnVYTDl6RmZxcVozQmRCczc3NmxtUFZ4NmI1ZjlrM0hHZVgvVXFSMXhaQ2V2Z2JmY1BwMCtoLzQwdVhwZTVTVFNraUN2RVc1TWlQSFp2c3NsWTkwd1kxRUpWRjlHL002NHpEK1dtQ2xNYVNDQ21LSy9jSFo4dUgrVnpaTHhDdWgwZkZpMm1UZ0RXYVRoV1VEclNzMzMzTGJTa3hhSzFNUzFpSFJCdzkvZlhjVTlQOVEvalB2ZDJrdFZwTTJ3SFhFMS9Sdm54OHJOdUNZWFpJTi8yQVVWL25jSDJTeFpDbnkzZFZRaS9CTUlBQi9GYWdqTEh0NWFZZUNLdVVQSy82UkhoclRsZEdTbFJlWWdMK0tDV2NzWThxNk9WNVdKNHUvTUZuUU1xK2xBUC9BVzdMSlp3NmNQKzdXS1E5TnVibjgvQU9KbFlkK01PZUJPVDg0dERJeDBCSzYvUHFmSDE0Nk0zbi9nU3Y2ZksxWHVDUG4zTHZoK3J0djJMZiszZzBSOXhXZ3QzdGVSOGU4NFQ4WFhmQ0FUYSszUFhEQm9rdW5Wd3BDNWZSTGdlYU5pMlpzYWc1b09XbGM2K29KdTk3ODdNaWNSZHZXenBvWDhNNlp1WGJid3RuOXc3OHJCMzRMNnJpSHY1cnZISDBWdGlTa2lxY1RPZk16Sm8wZFJhQTBBTW01UkJaU0VQNTFKS09Td21PNW5jVThsbUVjSVFYcUZCQTcxTUlFdEJmRWdyN295SUloeFpYTk1TL2xsNHRZekIxMjdxdm9ZS3AwaVV2K25SaGxFcVZMQzBCSUhMeVNwakxZaGJqUWdLbzR5RFpVeWUrVkgyb2ZUR1hMalRTN1ZPd3N1d2t1QzVRWHl6YzZ6WUdLWXJEQi9uaC9yaXBIUVZOMDBqMnRqZktOMFVtNXlpenRyNmtpOHhxYngwZGVTSlZRZFlSbGlKaFFRd1J1aE9CQnR3SVBHQW5xUjVtcm9GZUFaZzlFSTcrWVQxSitYdkJsK2VXZ3h1a3FxTllVWFA3QTVRV2E4YlZPV2FmNDBreFhmR21tcnozNm1UejAyZEcxYUF1WXo0NStQSkpvL2JVTGI3amhRblFEZEp2dVZhdTZYVTV6TlhpalQ3bWFmUG95dm14dDdqWm91Qjd4M1k1ZE56dUI4VlBzL2RqakFuOHUvNE82YVp5MTQ5VmFWUmU0bkJwY1Z6bitQNnRicEtEYW5LbVdCdDBHVlJWcS83ZDEweFBmL1hKczVjLzRJZUl1OXYycmxBeTUwa1RmaEVtWEhQcWYxVVF4Q29Jbi9rZUZWK1U4dEZGbW1mYnZ0MExDalBEdktqRlRBWDg0d0NrUUVMNWFPaUVLS1ZGSUNxSVM4WkJKd29SYUdYVWp2LzEyNnREN2gxSnZ5MitEaXJmcDVOc2dOZW9hbkZ4SHFxTjZlQkdjOG1RU1ZJQUhBR1l4TjJYWFJmQllqUDJvOFZ3NWwxcEJiYUIyVUplU2xkZDdxTWVJRlIvVkNRMEhxQjd4dkhRNEw0M3lvUGVHMHFnV3dkUG5PZVB4MDZYWi9MUWxtNDdpZlltd2s0MjBDWmg3ek9oZjBqeGdSdi9VUFlZeUR5R0JrZTR4cDdQbnlRYU12WnZaeXBTNm45dWkyMjdDRjN5THB0WHAwVzhKZGlaRzBBU2JTSTR2ODM3VFg0NDZKSSt4bzI2QXNsSC95ZjBrbnhuSG53NGw4UjkrRUkxL0ZaRTZvYTdWMmFreWFnR1cxaksrUWJ5RjhJUVFiQUF3d215b1dnY3owWEhZMFpUSm9rZkVpZHRySm1JTURlN0pCL2ZQYVZ2OXdQSmpIMzkxUEg3MnFuaThzS0xoZ3NGekEwWEUzbFVVUUgyTFRRVjAvTzl1V2pTNU1ERjVVK05hK2FzVkp0RnM5aFlIRmw1OWIrZW1YMndLUlhZZXQydUxpNHZCMzJEdkVtOU4vT0wwZzV0TndRSzNZS2MzQnhvdGd3S3h2LzNUMG9pTjJ0dlRiRmhrbVcwQndlY3BYTlNvMVVoQitISEFhaXR2Q2JYR3BVMEcxaXhhY2V4UHB1NHM2c0ZsVkMwMW1kcUN2ME9PdDhVazhvdlM0U2dhS3JXb09XeWtVZzRicWhjNmllcHFzLy8vYWhZNjhjUXJyejMyME52djBwLzg3VWFyeE5ZYmE2VXFWMFdnd3U1d1NXdWYyQ0JaeTJvdU9QYmcva3JmRFlNUC9hL2FDanBUNWpYUDlJQkhYdENjLzl4R3VmN3BiWlVEbkpZdTVKeTh4T2taaHY1RFkxVExIYmRBL3JrbG11Zkx3T2YvdTRiRWEwdElMaUhyQnlVS0crZUk5UU83ZFdUOEtld2NhMEZCeDFTS3doQXhoTko0MUJvMzlpcUtYSmtYZVlmN2NPV3A2L201ekdmaytRMHF4K2p3NVRXN1ZZdG1kRXlTaGdQcE1ZVDFtTVdFNjhkYWJkUEJTZktWak1QUWFqUXlZTHVTZ0ZlUFdZSDlZNjlFTWI2VFg2R0xMWXpEeU9xVlJMcDM3TXJsZk9PZnBXd1lVd2ZZTXZBMHVFSVl0NUlBMW1FaUNzVlBVc1R1ZWlNeTJkQVRrQ2hMRUd3VWNidG9YRmplS2ttYzBWOGVMZVEwVm80dWdPVTNKdDY1YTNnZWNOdnhCOEdMa3pHNmlpcDdZMGZ3U2ZJV0hBa3dvL0dtM2J2ckRSYWdjWUdEOTAyWlpSd2NrVTgrV2Zqelk0cXNDazhkNC9hd0E1U09La1YxcUVSdFQxc2NMQjNXQW9uZ3R3WUo1eEZtUElwaHdpTWtnVXVzQnpCM0F5RGZQdEZ6cEFtME5odkFWL0tOQzFpN3crS1EyK1EydExHekMrUWJ2R0lsK1BlSDFxSkMyNGZnMzVVaWJEOVpwMnNHRTRkYWloOEFxeWFDcUh5bmJQQUZEWC8vdXlIb3cxeEozamlQcVpMR3lRMmRmSnpLWU84bWlZOHhsUVBWOS9reDRCdFFzQy9ZQzlOSlN5bXJzN3ZUS1h0QUoxcFp5bWgyaXlhZXVXZVFDa0EyWUljSmQwV3BEaVo1U1JpWHdkckVzamxFbzBrOVFmRFhBcDlpQWN5YStYeXFMNFdpNk9aSXFPT285K0YxUE9MMFVnbm5wcFBvN3hpVHpKZ3FodnFIV1M3b3VmOUcvVVdyL1pvWWRsRFczNkcvbmp6ckJ0MlRaK0g0V3F0RnVmODlkRXlrVlA0aUpzZWpNajIzamlLTzhCbkh2a2NLUjB3UklBdGdSTjJMWjhZNUd4NzdrRmpNUnRVREFQdE5aZjdCcDhubTVyb0tPTkIrUlhKdVJSM1NSdXNxMUUxc2RYeENWMW5ZUW5hZDVCTG1hYktaU241NzZoWVh5QjllSENvdmJaM2tLbGhjaHhWM2RJaXV5NlZsazZ2WVVoQXNhNTZsSGxTdzdwTWtsdE9JdFBjZ2tuU1hVcjNVTm1xdnloQ3NyanphclE3Rko1YjR1SVR5NUVVMkc2TVF4dUJhYUZEQXp2OXhPeG9aQUo4RnkzRUFQa1NjRWR2VVFBUW03eFlnNzlic3NJZUNwMDVSZXFkZXF3VVVmbm45Q3RQU1FGNHNMQXNWQ0J6NVVadnRDMkJ4ejNGZlgxZ29meTRHYktCN1h2cW1MK1F2VkRnZElLSmo4aU1xWWc2WWFZUFg1TjBtL1UvbDF1Q21ZUThFMmxNVTZRbUFiQ0o1NGJnREpILy9CUmdtQjh5eUJVVDVjemRRd0hXQTlJVU5QV29CWEM0Q1VRWGNrVC8vMG9hS3RPQjhjb0g4RTl0NmhUU0t5cnZsZmNNZWhzZURIdlNSREpGMXpXYkZyM09ZNVJ1UFprTCtVZUxvcnNKQ2s3a1V4RVVmZGw1Tk9aRTA0eVEvb0xrNFBLVWlQQzZPOWt5MnZUT2JhcGUxVENnUFREV0tCdU85UmxiVEQ4WjMzNzEzRG5CbUxuRENxYkhsVGMxdXUyTmVnYVU0S0ZYT3ZUN2dicXd1U3hRVm5HWFc3Tlo1akVEWDJudFRSdGVHK0h2MllCNnRmT1FMaGFZM001SFo4RGRMajV6ZGtzb2FjTWlWU0dTb3NGRWlxWERSS0VCa1dkZ0xrRlFOWStsVWlGbExERXRLNEN1a1ZxSWZUNVozWk1SREpGclJwOE4wU0kzaHpyKzlweENFOFc0WUZJSWd0c3dHZ1hjQW44US9ESmNtR1drQ2lJWkhMSXFWMlEzb201bUc2eHJBMGYyRTR0QUVmTkdJUkFlaVBnSjVFSW0xUVo4dFFFdkE1aVB1eEV6bUhZVVZEaHNTcVJPSjBwZDhjOFNwb1dsQU0wQm51azJXa3k4OHN4OVlyNFEyZEpEV0ZGd0Z3TzZuWDRXZnBtV2FxWnQ1MXN5NnBuR1JLc0crM2hXY3UvNjhLMnFtTCtxSzAzKzkvLzZoTXEyQjVyWFE2ang1UHdnQTh3TWZNU0d0UVdzbysrZ0IrU3Y1dC9EKzE5MkZZcUt2dmEycTFSZXFDZXZkUzRORkUzYXNxbC9lMUZqZTdPdFc1aUVXKzVEUmUxSGRPcjlmM2RqVDE0Mysvblg3ZTFwbTZPRjE2ejdudkNzbXJWbzlqVGx6MWQ1NzNWMEpSdGRzNHZyMnhvNXdONmtYUUxyWHhheUNOMGNGc1ErN0hTL0RrQjRSSXZNWVhqbE5ndTQwSlQvQ2ZXWFNGd3dsUTQxcEt0Um1SbWthcFdtVUpqaDdUTlEvdlhDSXFoam5SMXNHYlpYMXZ2ZkpXTnFyWUdRUjlHeU1KMnZ6ODVnVUpoU3R5OFVlWTJJZk5XNmdHdmpEL3FnRlkyUmdRUmNITUdjQ2xna3RFcWFLc2VIbXgxZ2JDZ0VRVWhBV3p4clhXZGtSUE04TDdIci94YjFWTGZNQzR3TG56SjUzdmlmb3FRcDJyemlzRFdxTkFFSllIS1FQcitnT1ZxSGo1OC92UGdmbG10ZVMrR3MxWUZuZ0RGUlUyaHRxdXN2bkxBRlB6c2FuTGdyZkhHYVIyS0dMTmdRN0tqdkh6VnE4WkU1NWQwMkR2YklpNElRTWhBQXcxSWhMMVpJMFJEMGpucWJLWlV5U2NObEZ5UGRJOFRaZmhpMmRPS0NIS1B4MWtwVjN5cXVtOFpUZ0pWT0MxODRrNWZmZUl6Q0U2bm9Eb042VDM4UExCd1JrRVNWT1VjZmxiNDVqLzFzNmtmeEFmc2E1VDNHdTNPY0VVejVRaGd3RnY1R2c1S3lWcVgzSGorK0QrQmQ3MXlLNVppdnhkMjNITXp1NlliWTRXcUI0MGZPbzBmTUtPYW9DWVQ0Zjg4QnVEUUlGQkIyWTF1QVFEV2E5Zk5QeGZmRll6OW5uUEVQS082byt1OCtUMGJnL1I2ZGozaUpiZVdmNit1UDcxdDRIWjYxWnQxR3BRQlI2NUp1Uys0NUxQUkcxSXE1aFZUVjJ5RHAwcFF2ZkFtL1JIWEFOejgvNlNTczhTWDdGendGOW5aTEZLckNFOERLTFJjNGs1TVNPNVg5THRhL2F2MjFQMUd3b05KaWplN2J0WDlXdU9MekFCRXdPWHRzMjdXbjZrVFMxNE1GTEw1clQ2Y0tNYmE3T09SZGQrdUFDWldCVTVTVXFpdzhSd0xZQWg4L2lDNDd3ZmhpOVB5SmlTQlgwc2luVW9taHlPWWsrdjV6ako1M25CSW9KTDA0U3RzWGs4b21ZUVUvWm9DTklla3NCTHdIUklQSmRYbnJtSURGUnNUaVNpRERuS2I5ZHBOMW9Jdk1PSUxtdksrZGZIbFJoSFlOVk9OUnB1R050UElxUkI5VFBHc2VsWlIya2ZlaGtrTURGUU1Xem5QNmhRV05nYURtaEYwNVJHNjlUSnIvZHE3eE5tNmEwV0JsTHFkbm9zQmhZcVg3Qyt2cUM1ZnVXQzZCSzBJTVV6YUNyV09XZDk4Z3BzNVlIUFZEVXIzVThzbldJVEZXMHQrOUJ6OGJxcG1rK1RZQTMxRHAxM3VrVEpvbGxGYmhXdm1LOUNIc0FyOFYxS3pubDVSUzdaR1d1YnNDS3BWY2FzL0FSQkIra2FtUlR1UHp4V0FrMlB2VVRRUlU0YjNwMDloWXJGT1FrcnpYb0UwWjJ2dnhmOHQ5cFR0QW1MSVlCblJuczZ1aytEdVlCVnJBeWlzUUtrdC9LTno3VzNTTmZadFlOTUZyODBxeWdZRDdRSmlRclNBclF1bVgyczlkSUdmOGg3b1NpYndEYWg3bVN5dkhXaC81b0g4RzM1azdjS3ovNnFMSFFYZi9ncS9LanI4cC93ciszTUVOcmZ0TFVYQVlIMHl5ZHFQZjZocWJReitBL01HVjJaK2ZQaHZ2QjRBR0hDc1pqZFVqRHltRFZjeVFhSmQvVVExKzlWcExrMTBCRWt0WmlqYTVSa3NDTFVoMzh3WWhWemF2eFdSQkIrZW9rZkVXamtobStlMXA4ZGVYNTZORmhGWkRlb1ZYQjMvT2ZEMTlEajFOdWgyNExJdkpycENEMDVKSFB4NlhDUlZPSytScktoNjg0MC9OQlBKYUpkbEVnOExVam5zOWNuVmNiS1ZkSk1MSUJnTklDSXdzTFJoWmdqSGVRYVg1dHBpRkd2b1BLVWZWU1hzTElwZVhQU0NPTWZHRnd4eGh0a0NDeEl4YlN3K0tvWjJGSW1vREVScUpCeVJjR1Bwb05NbjNtb2F1cTRXcjdDODhiSDdhRFBnYXNxMDFmWkpMcjJXUXkvZFAwTCtpakQ2Yy8vU2dhdlVyK2REVllCYjFQZ0hkT3JyejdidEovRGFjUzNIK3JHSEkrTFpSOFBJdnVLL25pUGlDeEg4ci9Ibm8vUFhrS0dGY0VmZ2crN2hpYzJzZzhFeHFjaW9hM1YrU3ZnQjZzdnY2dXU4QmNNTzVuYWx1WmVZV3pZMzdldDZxTVE5V0FRNjBVSG9WRDZ3R09QTFU1VHdHMVJUSldia3NyaUdmQWF1bVVNaXF0dFdvWWczN1pEbm16WENkdjNyRk1LekFhS3hveGUrd2FqV2wxKzFjM0tzSjI0K1REYngrZTNLanMzUGhWKzJxVFJtTUhQWUxJZkV6R3BxRit1ZCt1Z2RwbDE5NS8vN1hMdEZBNWFaWE1xNWZzdHNMTGlmUitqMy83Wk93Tk9YbTcveDV5SUgyaGRmZVMxV2JKS2lyZlA1RWJBcU00dHJBL0oyRWlWWkVFQ0ZzdjQ4MlJlbmxWeVVDbCs4cVp4QWdXY0lMd2VUMkRTNDZmTHFlRzI3TVVIWjlJS3ptazI1Q1hNOXU5bEpsUy8wNW5FMUVnYklGZGpYMENaeXRFcFdUNS82RXpHRVhncHdwazdkbWc5VU44UFp5WHZiUWl2ZWVNbGgyeW5vSkU5eVNkd2RNYXBUR085SjBlNVV1ZHJDOGw3WlRDSHFCanAybHZKalhtVDlibkJlUnd2VWFWdzNLRy9meHlqUFVEY21VQXZ4MHJtYzg1elZOdUtvcXRybG5mRjB5MFNleEVoQ01CRU5rakJLdEFDV1p4SU1mdGpLaWNHTTNRQ0JXWFlmQWpvL3pNSjRMVllyejFmVDBRalVtakZWek1ydjNKSi9LSHR3cGFuV2g4RlN3OXdaTVRPajBvenZlTVZDTDYvWitBS1VaZ1JlZEZvSC8vVnFQRmFyd1ZGSC95azdVczBPbklVZjZFZk8rclJsR25wVjhiNlMrWnMrRmhuSk44Qmd3eWxCTnlIcUpMakdKSmVCUzdXQlg3dkY2ejJXSWFoWnlmdmttY0pvS0VKRXJCZERJb2FiVG9YY1pPUmJsWDJKZUpMSWZlcFpiTnpSWjRrRmFXaEdPb2JmbHdSZ0ltSzJFT3V4VXBDczNwNStYbndYcllod1prekQyU1Bvekc3VDR4Umw4NXREMjRJYmluZmxOLy9lNWdrTDRTN2V6R08zdUNUTFA4ZkJwanJlS3I2bkJ1ZkZVZHZoNWVPN1F0aUM3cTM0VHliUWpTQjRMb0lyU3pPN2hoV0xzb3V2L0lrT1V4ZkZrVmgxbDZsRjh0OFY1VmxoaUdlNnZtK1BmeSt2YXdGWVl6K0hYaEJjb2hzdVpESzBodU9ZZXVaRDd2S1J6SXJ0Zkx0WVFXVmNsSjc4Mm5RRVhqSkNvUmZaSzltQ3JFZnRibElBZFdqcjNCQXpuNlgvcWtXSnJDUVZjMmpjYlFyeldEUktwVXRMaEFRbXhGcjl4TjN4ZkVLNmFpMVpUU3cyUXdXQXlTZHJ1YzlKSzVETW5CNkJrVTdtMVNadjFHZFNYRVZJSVdINUVRWTE3cy9wVXFMWEhMS1hSVE9lV3lvRWZLS1VIZmI5UnFXVW9TaHU2YTVwWFJmVUd5T0JTRVNYMUtzRXJEWllHU1BGa0FoSE95d0tqUDhCaGNxODd1bGYrcGlnTllKbHFiL3hZL2cydFZXUURsVVRMZkt0RS95SCtmdVhHZlF5TzdUWDJuRGg0N3BSTjRCZEorV3RvQ1ZESWowMmdmdVJ0dXJxdnZBVzhKRnZrRGkxR3dnSUJGSG9SZWVTQTlRQ2VYRmhiZVhOaGR1QlQyRDJObGZlam11cDU2OEI5R2ZJbGd4SmVrRTlBTDBMY3BEOENlcGVpS213c0xsL2FjN3JzdndQNjFxdDhsenhWbkdJUGlRRmxBR05OcjIwdmc0ZE9mS2cwQjdRZEZ0OEVZSHRIdGV3QlNJc0xqaW5BKzBuSW9uOFJhWUZsK1NYTGxDT0pZYVcxbTBDa0Nmb0ZWbGlqaXNUREVKTWJLM2lpRXNzOUFEM29wL1o1dzZZNWZYSHAydlU5M3YxN2dPVHRkMFZmMXdGV2xCb01MaG9ZMTEyTW9QeG9KZXJDNXBEL2N0cUpuNTVybUovNW9vTFZPc0hKSFhYVi9tWVdGcVdHTmxSdi9JWHF6SXVVaDloUmdBUlkwZVFQVjgzQVlEUlVPNU1CQk56SkZlL05jREVjNUlJSlVNZ2xtcGY5MGlrSWErUWZFU1ZISkRWZU1tSkp6ZUc0WThhcFN4ZXRRUGhyVURDTkhpcEd0eEZ3b091U1VORkdTVXc3UlVncVRwVGVyZnA1RzdQTTUvTTNSeXdMRmNzTHRCcW5pUUNEdEhlWVVPbUw4R2xFbVpiaFFCNGt6bDhsU21rNldXa1FIbWlVbVNpRGgySDc2TW9GN0FvRkFNVWk1M1hLaVdQN2Q5eThUOFZOVzdMOHhCemhqbVJMNC9nSGxXYi9QdDRXTzZOeDM1VFdsQmJkdCt1ODBHWW5KRmZUcnczbU9zU0R6TDFTbUhqUWlPZXljQ1FoOHdFK0ZzeUoxS0o1TnhpakMxbzJFYm1JdVpURUlpQ0tFbzRKeURpV0pGNTRKeGhUVGhvMk45SnNCMnFCbkdhUGtkS01YSUgwcTM5MjJBamZRUkVpMzQwS3RiQWRuRDZ4ZHF0ZHlkRGx0TnpLTXlWcmdMaGIydkZRTDNqWnJkYlNUZGN0T21nYXZtSkNFNElTaVh0NDkvcFdMeFpMaVFwdVpZWTFHdzErT0dHeVlwb1ZqV1phQmdQMUFNbTQyU2czalJXR0xJTDRGS0FkNnZ2RUlOczhDbXFGcG1OeGtNQWhiWE1FT2c4RzBTVy9hdnA5bTBJVUFzanl2NnVQMEVHcVB0cHhYN2ZDVmZRWGxCUnNDY2ZnV1I2aXdPZFZoVFlGY1YxZHk2Q0hVNUIyQ0tCblBYb0ZydXVMcm56MXpHS2tJNjdSR280NHQ2Nm1jM3d0cVNDRFpHK0JPVWJnYnZjaHI1ZXR3enNPb2kxMHNHUzhWeEQ4ZS9jTnVUWUh1WWoyQVdyYXdaSG5YdTZKd3FWR1NMM3RDQVRVR1ZOMHBpbjRMNlE4ckZaNzFySWlKdlJqYk1QQ1RZN3dDMFl2WFcrbHdsUVliNnJKclRaaWxXNjJHU2lXSm9ZWG90MzUxUkJRdU4wb1RkM1YzRkxBVzB6cmViTkxDelh1RHdkbTdQTUh1dWxpNGNtYjF4SEZWQlpibjc1Q01sd3RpdzRiMlpwR3pHR1pyVElLUmRzUmJGNWF0dU1CU0ZweGVWUjJ0NzRsUENyckFpbHMrY0QyTVcrTmhiVVZseEltZWRia09RajFjNWRJc21GVlk2eC9uc0puRmdMdGlYRVBUdEhFSDN2UThqbUdpSCtIOHZqSXpKMW9QbVFDdG84VkFrV05CaDZzaTdBNUlvdFZSSFdxZHNFaDlaM3ZSTzJ2TnlPQUM0TzBxVTNDWUNtZWRoK05aQVNhVWtjTXpvZURsd083QTFwcTlvdkNBNCswZjNROUtCSjNHOWt1elZuNGRZMzFzMm5lWFhaNVAxdFR1YVBqUDYzRFJhUEw5ZlZKdE9ZcTB3YksxZ25qd2NldWo4cTFtVVRTQWphOXFqUmNicFFWelJBR2QyQ3daTDhONVViSmxya2hBRFpHb2djcUxwSFZmUUFYeVYyRktzdDFORVRscU1jSXlVbDhsa2tiamFpVFR6V3k1RG1mbDRKS0hVS2NnTVlyQXEyeC9JLzlNbzlHSnY1QjA3MHBCM1RqK1p4cmJ6eXc2clViKzFidWt6LzBCK0pVdHFncVlKZ3Jyak5KOFVlZzFTbkNpMld3VzVZV2hoYzVGRm5DdlpCWXM2ZWNrWTY4Z3pwZU02d1JSZnRJb3FiejNpdDVSVDNSMTNQRXhWMHAreWJLZE1mZnBaRlBLcU1aSWUvdHdWRmNmMkpoK1NYNElmRXNXTEhuSmVIL0dSSjJ4VzBQM1MvUzZseTZTRStBdWVjOS9uei9Ta1EwZHVCR1ZmYnNnNXZFUGFTZ0RrbllLMEdoN0h1b1pVa0N5V3gxMU1TbnVjL2dpNFFBK2dKUWc1WUNpSTlLa3g5QUJXbUdTcHJPbHpZMkhkT2E5K0tSaFd6dFBaeGNjZUd5cmg3T1BUQWNBYkF2STczdkJYVmNHSm9Nak0rK2VqWTVzOU1udkV2enVkKzdsblVlYy9BOVAzSSsyZWd2c2Z4UFg1MkhmTlhoejdtSldwelB2ZDdGbmdYVm44ODQ5VG40bE9IY1o2OXB2MXVuWUpSdHhsdXY4ajZFeFl6NG9SK296Z3htK0hrb21rMm1rU3N2dm9CMTA2Rmd5NlVXOU5IMnowd2w3MGErZ2c3MUUxbFpXbHNFaWs5SGdsRzhHdlU3bDEyQTB5UStvR2JCK1czK0tZdjZLMmpGQ1RTV1lRM1pNZkNJd3ZDMFE5WWR0QVlzZmZVWnhKQVZaSXFHQUJUc29PbXJqMFlndGhvRlFQVFJkVjhYNENRaHBiU3VIZDlEVWdIWmFPZVphOGNidDI0eDhaT2EyaStmYzJsMTJxemhWZXFsNFk2M0d6T21NWFJ2ZlR2aHVuVk42NjZ5ZHZTMG5QQlZUbWhmVnp0Sm9Ha01kTlJPcWFqelNsSUtTNXRyTzhnazgyK1NmV05FVUtoSHA1Sk5kaFlldm5ITE81R283YzJvUURGR253Rk1SY0FpQTRvNTdBUmo2R240MXhCYzNuWjIrbzZTK3BNREFRZm5IZ0dZTlpwZS9DbnpqaS9nY09nNEErVFUwUFdnRVIzR1Znb3RCc0NYVWVFbHM1SGV3U3N4ZzNwVE1VSFlCM0N3STZRZnFTNkUzQ3hIaFJlcmdid1ZCN2hYczN0TDZ3WUVNNG9QQzU1RzlieW42YnFiaU5uWDRMQmhVZm5pTXR0VXVuUUdtZStRK2V4dzlzOVF1ZE9RWHBmNmxzYUFvUnFhWkVzR09pNXgrUGxkYWpGbVY5bVoxTXlDTWxjVHlweC9WYVRlSFVjNUxxSW5VSEZTakNLWUdDdkJvTWdJS0RsTkdmVkltSGFKVnNaam9LdFlHTUlVQjlvTEJMQVlBQ1I4Mm5ERXFZWWFDY0lDUDRLMFVrWmo3ZnpMVmdLbndtUFNYT3Zubk9xTkJMNmZ3U2x5SytMSmd0NWVPOU5OZ3MwR0xTZE1NNGw4dmdISDVXczZrRjdTMmI5NlNCNlpYLzZ0NnV2emg1SS92L3BqcC9WMjFtYkVDdjJIUWt3R0JNa3RXbGtCdm5Pd1hML3ZrTEdnUnRWb2EwRnYvc2pqOXVVYlVRd2gzMEpmMDlSMDgyTmNIRDZmN0ZOdFBmcjNyY0wyRHVYcXpwNjAzR0ZFeitqdmI0WHZVKzQ1aHRaTk8yd3JaYXY5cHJGckxRN25xTVJlUGFnSWRrcjkyb1A3clYzSFRzRjdXUUhWaURMbmdkN3ppNFNzR0l4MGh6clFQQjhhdU11UE5YMW5BcW42U2RPUWsyWkZKNXdRcHNuT0tJanZvdDJlc1d1ZEJ2Ly96REVsbHVzdlUzNVNyLzhoYW5yNDlScTJnbkdHZkdWWUIyVHQyYThEK0VYVWUxaHE1ZHZKbXE3SmxyS1lBVzg3Y0FLVFBzNityZmI0ZGV3UUhpWkdmV081UDMrZURWZ3p0SFE2RjQ0b2NHZzlnWGtJMTZnbC9BQmpBQU1rSTJPMEM4NUd3RXhjMTFiVjJkdFJPVHQ5NW1rcC83cXJ2M2o2cHRjb3BoazNtWUdqZUdqTzB6YTdvKzhIQmMzZmQ2NUhMN3dlUTE0aXRjMUs3L3RqV04yMUxWMnpCV0hXT3QrNDRkMDZOV2NOdjVobmo5b1dPd212WHJELzBIS3plc2dVOHdqdFpzOEVvTmk1NEpyMkZHbFgzT1BHR3p0WDl1OGU1RWRXVHZxczV2a2ZkMzh5djN5Ky9veUVZdGZLRFB4cXI5a01qcThsR3hteVBERzVrUWwySFhacDU2NHJEeHNoMVB4YWpETnA1TytFUzQzaU16UXdJYlM4eEd4TklRZ3pIQ2hWRVg1c1ZrNEpCSGk4dlVTR1hPeGgwdTBMOUlaZE1iTHpBNndveC9YRVRYV1d4bU1MYXhzUmxKVjJXaWJjdm5MRXI0QXFWRkRoN2F6cDhva3VyNWZXRlZzbFYxVm50TTJtQkpJbTBvR0dBYmVZV1lyVkI5NFR1YkFBSCtsM1FWdUh0YXFsdmFRaHVtdFFGaTkydWNnQ0NMbmhKUVJEQ0xZbUZQckU1V0JhdWFMWkt0dUxhMG1hUE05UlY0ZWVjVm1HTHV1YVB4djBFaVRGenF6aU0yWmMzVW9NUDJtMUVHNFlPN0FSRDRJd3grUzlVYUl6VkpzSHQwVVJqRGpYeXgxdFAxeERyNDJEelRQbHZqRWFnUmRFS3RDWmZkV2VWUzdJVzZubXQxaVg2T21wNm5RVWxJVmRnMTR5RnQwKzBkSlZjbG1qVWhrMFdTeFZOWjFvaS9SZWxEVWg3UE55eWFPWVd3ZXJrZ3FVelFrNVBjMmx0c1UyeU5sZUV5NExOb205aFlndUV3UUo0aVNzSVFMbkxYUXk3Sm0wS05xQ0c2L0ppRlByTVdvYVcySkhLcVJiVUdxdXBpNm1ycUR1cFI2bGZFRjRUN0JtUFY4a2lHRm90aUFSRzlIK1VSWCtxRVMraUx0OWJXTlZIQ0dYQjRpTmVaYkJaTXl3eGFFQWtUckJGSUdDem90eDFzVHJNYVlTRE5HcEJIYUdsODNrSk9xa0tmdWtsL1F5SjkzdzRRTUF3YlJGTWRFbzh0cEM0cEN6Y1lTQU9pMXFPZ0ZxT1VRdDROeFZaekdaTDBkTVRKNlpmNko0MkUveWtQUnowYWJtSkFBaFdPMmpqRGVNQ3Z2WjJiOGs0QXo4SWFZTTdXbGRrc3hhdGRkc3U4enM1SUYrU1NFQ2JwSnRZZm9YOGQvbXpLeW9tNkt4VzNZVHkvVEMwdnh5bDA4YXpwa2VpTTNtdkpxQ2ZCbnkyb3BxSTIyWnpSMnFLYkUrMHR4TTQ2M1pPais0T3ZzNWY0UG5ramxyemdQbW9QeEw1NjJSNU1iaC84aDc1dXRMS1Frc1ErT1YvT3FHcEdEZzNIcXF6bFkwckFaL2RWVnBtZTFKYkpOakYwcEM3NlpJbWR5aFUxTkExSWVJQ0JwdWVycjg5RXJtOUxrMy9aRzVGRTJzeXNVMFZDNDg5TXErOEdhZWJ5K2ZSVGFEMGw3OTBMSFdzaS8vNmdyMk5SZWphUnJKeE40TXQ4bCtLemRBSnpQTHZnNks3RW1pR3IrR2lyd09ObDM4aDhiS1ovckdFV2tYdHB2WlR0MUVQRXowZG94U2lkODBpb2FldU5oakJlTHFXaUcrTTE1SjVlVkhVTzZMazVRV2pBZEpoV2tCazFJdU5ZNFliUDlxdEpReTRQT2NsWFFSRGhxTmU0U1U5QkVSb2RIY01uaHlSTW4xUDZXZTQ3d1hINktIMEsyR0gzZTRJZ3psbm5UWFV1RUYrYWYxcTRGMjgyT01XYWJCWVk2Z2FId1BIdEpaWWJmbml4WlhqWXhZdG1MTUVEV3RWajduRDdSM2h3cUx3cEtsSVVZSHAvZ1VMNEJzdVlWSGowMm5YMDQyTGpTNlVibm9LZmt6U1E2NjFGNjRXcW9PRmZWUEFrNFdoanZaUVlXR292U05VQ0dZdGlkWldHVFZMQUMyNlBhRGtQOXZ0b05MZVVWWFZjWGo1OHZTdndPZnlEOHBzdEJlY0kxOVk0d3kyTEgraDAxVWZleSs5Zm53ODdwNXJqT2hLSmkxY055c1lpUVJuSFVPYnFOdXRwWC94MXFSSmIwMU9ML3gwVzFNM1o3TngzVTJiUHNkcDNtcmxVWm9SNU0zeVA0QnAyb0YxOCtSdkp6ODhHMTBkNm42NEc5OWtqbXlNdHdhZEVYQkF2czRIN2VWZ3QrSkxpWGx6LzAxSk9Qb2ZjSW9HSFpkcXd4bUZHYThLMnpLTE1pQUc4RUU0WC9lMU8vU0Z6YXBMQTNDWFFhOTFmRkhxb2wvVzY5TmZnbTY5VG1mL29zd3BIeE1oS0FqL3cwNnZFZVZwVlg3TVc0QmVvY2xVQ1ZhYmJVTm5nZlF0Vm91cEVwN25wYStwekl6Unl0Z2taZmxGOEhvUHRpRFlhTTZCdmJEaWdCd0Jka0QyWW1HQXhIREhLT1BMSGx2eDA2S0cxK3grWHF2Vm1KOHBsdWc0YjNuV0k4bHJrTHB0OVQ0dDhocXRQQVJ1MGZ4KzJDSTFEVDd3NncyVzN3TDVoNEpnTEtGbkd3THBNSlI5QWFSZ2cvY0IvRS96RmFNeGF5Z2RUekgvUnFsT3NvWXYxVExGQUlQZUsyejJSUUJUYzVxQWdQUUVYNmlrR2lvekNlclpMU0JFK09aYnVVZ00vZ3A4SkJjKzh3Qm82T3dFWHNIbjlIb0VUZ3FqVWdJZzhTV0NJSGk4VGg4YUlRYmxLOTZRM3hoZlUxSVNuT0FjblVQd2drRnc4OGswV0tkbEdacm1kR2FIaVN0WUdrOWNONjcwaXV1dWl5OUdFN0xEcE9Ob1dzSXMxUXlyOHhhTU9tL0c1MFZLd2NIaVV1d0JZbHZGRE1qRmFGaGdiTUFXNXFNZzZrRC80amF0QVNuc244cy9rdTFzaFd4SCtyamplckFBQUxBd1BSc3NrRVg1eDJ3Vm1DTTc1QWZCUXZDSi9HTlpwRnZrTitRL2d6YjVvM1BrM3hNKzl1QTVQYUFRczZYSkh6Ry9sZjhzdndrRStaL3lQK1NmZ3lKNmoveHorWjlnUEJMZTlXaGMrb3I0bU9qUnlLU1VCK00vQnl6b0x4aG5lVXhKaXY5b3dHdXg1eHVySGJ5N243MnpmMmlPanpiNTBvdmE0VHZ0NmY5ZUM5ZXVmUTk4a0pRRDZVZHBidzhZU0NkaHN1S08rMjZIcmtQeXNldmdrN3ZTcDNiUnU5SVg5OEJMVHQ1MTVNZ1l2aGV6cUhVNUw1Y01HRzBHNTdiRUgwSnlFWmFPYUx1VlUvcUFoNDdWMnJIMEJPS3RkSWlnMkdJNWdxYk1lZU9jT1RmTVpkdzB2Qi9MVDMvOE1aZ0s1c1M2WXJFdWVZcHc1ZFFMNXhmVmRsbjFKaGEzSEd2U1c3dHFpK1pmT1BYSzA1K0M1N0c2ajk1Y0pNY1d2Zm1SamlWcDhESk9RenR4NkFEM0trLzVtRHdrbHZ5ZXR4MStTajV2OVAxSmV0aDNiU0k0SHlQOVpTTFp5TmRNdEFxaE9sSytOSERyUlk5Y2RORWo4Qkd5eWZBWUtWL2cwQVA0bVBvdi96a1F6VjZZQjF6eXNSRXRpTVI5dzF5MXFGL0w1OEhZY2prcVI1ZjNRaDBZSEltVWNFaCtmUUErbHA3UkQyckdpay91Wmk5aDcwSDZCSTZ1Yk1kOUFkaTVNSTR6aXFGM1Y0WEpjdEZMUkc5VFF1KzVoRVc5QVR0T0kybFJJdkVRU0lhazBmelZCcEM0NHdHY3hCSGNoU0E2ek9Bem1ETWpYc0ppM3crNldyTTlHaTRxREpWMHhqY0tMNjVzbTA0ejF5OWRzdk1qNjlTS0d2a0QrYlB5cW9Ub1dScHYvdWo5dHVqU0JScVRzYUprd1JzdnJLdWFNaWRoTGZCeTRoOWhmTURHbVo5d3pXY3J5bjFEOHEzZkhETFpqQ3dQdFFHYlMwc1grZXRMUEx1UGcxMWczRzNOWmdEdmErdnlXdWJNc1lpR0pzdUdMUldGRjA1YWt0Um9ib1k3M1FHdHBycUcxL2xkaFFFdFgxU28wUVNHUk5lYTlrN3IrR3Jhb3JINm80R2U1ODNhRzI3Zy9QWDAwL2ZMVGs5ZG9XVlB5TDNKVURUT1hhZXRmV25YUTFOZGxSNlBTVjhsQmhkV2RWbGJDUTZzOHE0MFpMUnZSRG81WWJjT0VTcmlXSnlFczVOUWZRbTNEeDR6c2ZLQlJsV3BMaFlLbzQvR0JBaUhJVzdZR09aVFlEbGVhV3NQalk0eldGY1JSd21HM1hOS3lrRjVlTjQwemFKOWZUU01WMDYrOWtscmU3aml0Z2NyUXUwMlk1WGY4K0pidnBMYWVqMXJ1a3Z1dmR2QXVrelZkM3o3bU45anVseHJLZC8wVy9rZis1YUh5aU9NeGw3Q0FRMG5HdGMvQnVnbm5NWEZ6SGhRT3N5YWQydDVsZDI2WG5URVdpYWVaMWphWHJQSVdqd0hOTnBjSEd1MWNueUJWWEx5U0xGZytZSTB6WWNMbUw0K3puQnIvV3gzMVNwcFFoLzhWZFFlOTdXNURYNlRkYnluNDZxWFM5ZzZxMS9mYlMxY1lyU0diRUFQYWtmTVE0RHF3REZncUZuOTJCNkloNVVxR2tsaVVkU2ZDTUtneitheldEMm9CZWxIdWgyUExPNDl0bW1tNzRHcFd6ckdXMW5BTS84TlpzaVBHcjN0NDJlKzhWbWdGY0Q2cFJkYzBBaTk3N29XTHR1NHNKTGw1VVZENlpPZXVxZ0h3SHc3djhJZ0cwWlRXeFdNV254UjdOQ0JCajRlQ1lUNFdhMWdsQzEwVTJ0RlUwbGRnUTZBVTlSeERXQUxvbXM2OXBZdnZHM1ZwTXZCM2ZudE4vMHBPM0NVam5PQWEzNEJKdXNxRnZRdUtMaFBYdDZ3clc4Q0JPT1o2dUcyVVBwVUFxWlIzVEZxajMxc2xSNStaVGJLZCt1TWdrNit3NmpSV2xXOFFLUzBtZVdrVGdlU1prbGlpTTFpTU9OVFFzRTBtOEwzVlAxV3NyREpjVFZJREthejk3R1pqV0E1dmp0WVpXUWthWkE0Y0RNRElUTkFONWVUWnVVZEpRRE5VM1NhM0RPRGdwL0J3SGNvNEJrOGhVc3dvbEJ3WVBnelZncWtCb29mTXFDNWxIcFB4UzQ5SEQwZnMrcWtjQkZHbEFwZWlwcmlUa0dUWHdYVVFGbC8vTTJvUFVNazZsRlY1N0N3SHZEVE1LcEsyMWhtSnhxZndoRUtNdHlxQ3RHZHcycG5ONGZuWFpLc1diSmdRc3ZzMlpHYmI3eCs4K2FqVTlmMytpdFhycDJ5WTNsZDNhekFoQVB5aDBXZXRsZ3MyRTVQbi9ZSW9ORU1NMkgzN3VlOVhwOGY3YkQvL09qUVFZL0g3NTlRa21pUExOOTgwWXZNenBicDA5dGlvcDY3OFp3TjQyZ3p6Uml5L3Z3RWkxeVJEaWhnQ1ZvSW01TzZoVDlLTDhCL1hISm9PM2J0Z21KNiszSllDZjhyZlM2TXBuY01mYjRiM2tpZk4vUXh2QU83ZFN1NHMrd2VNdDhYSWtsMEJ0S0JLS28yUnVZblJ0Mnl5aXltZEc0RnlwSUVWTFpnZFpjc0xvU0pqUkFIV21MdmV1ekpXb3pkR0hDZ09FKytEUFhEcUxXREQ3d09oOWNPam52dGRxOWphTENzdVdsQmN6TXpLMUU1dlhsQjg0SG04ckptTUswcUFYKzhJVG0wS25uT0ZONWc1S2V1ZUh2RlZONW80TUZoZkw2NXJMeVpLWExnK3lqLzNtZ3VrK2VVTnplWGd4K1hOVXZwdFZXSlArTzlQeXUvaVNwNEs3Z3gvc0wyN1MvRUx6WHluR0ZmV2RrK0E4Y2IwemRtcmlwdmFrTHpLSmE3dmlXY0d5YktEelJJRlFpQ0NPZ0UveUI0S2dGTTZWVHI0RUk4cWhRSTRYR0g1L0Q0M1VvM2d4QVM0TEhBbzhnN2VKa0VuY1NTRDVucFFqRjFPUVVQOG1qVWo4ZnFvdWd3NTdBR3FsQTN4c1QwSE9aQXdwb2hUd0tnSExWMmpnU3ZraW1XeG1NL2phY0VvSENjb0ZraXBNd0lhUHJFd1NNQ1hySEIzb1pXQVpJaDBZNno0UGRBU2ttOEs4blZIbWlMb1JrR0RWam9haExJanpNUUEyNE16MEdSVnFSdzRBTFo3STVhbmtPNkw2NFNvMHhWNFRvMDUvdHgwbUZGRjlkaFlTNGdZTEVmVGZ2NERyVXg0SUc0T0lCQXM5QUV2QWdOazJHbEtmQURjQ05nNlJCRVNSRng0V2plaWhxU2xCQ3Z1NUhWdUJBK1NkYmhVTDNqeXZ3WUlXQTJ2SnJYVGlSUGNsdlVScmhaMVJ1ckxlMWg0VTE2TGNOSzdGTEdwSE5xYVBrMnBBWFFOSy9UTWhZR1FBZ2dQVC9POERRTmVhQUZ1bWtCcDIraFR4OHVOZ0c5MWlZYWpVRHdGOWdaeHFvUG01bzREV2N2Q0JicTlDS1NLaXdGZHZNR0VXakhGZERBWCtndWdrQnI0WFVjbytjdEFGaWRGaXNBZHEwbURJeXNUckRyM1BicU9DeHplMW10bnFXMUJtdW50c0pWRUVQVGdybWd6Qkx5Kzl4Mkk0UWNwK2VOZE9Hc21OMVdacWVCcDhnb09tWnBJT0EwTmk4RE9ZYUZzS1NLTFdXc0Qyak5kTEZIVXlaVWhSa2pCMmlycnVxQ3l5b2NlZ05FeitSc3RBTkNDN1NiU2tEN3pQUmR0SjdUUWxwSDAzb2EzQU8xRm83VnNoeWtoVEpScTM5Y1o2QTVocUVGUmdOanJKRTJhYlVzRFlFT01veEcwQUN6QU9OV08rU2RqcUFycEFtdEtMU3NEWWtPbmQ5VHNVRHFzbFpNS1lrVUZ0MmJrQklsNVU1VzV3Y0FEZUU2WVlIRjQ3UkZ2UkcvMWloQ0E4c0FQMDM3clpjRW5Lc25PTXJMYWRHcXUzQjhSNldlUVlPZjZPRTFRWHZJZXA1Z1lHQmRkM2hDdEsra1lSS0w1SVJWOGNVbUpHN29kVzUzekMrNlJhMEE3U0hSYkpWMDlXZVZOclYwUnNmcncxNmZqeGFBWUhLWjNjd2FJQUhPZ0haTnRON0l5WE9BeHNLeUdqMXFYeDJ0d1M4Y3lyZUtUbE9CMjF5azgvUGw3UGp6ck5hMnU3ZVZRcVp5WjFXNHVWZzBnTlk1bmhLN2JZSmZRM3NBcUswRDlNUUN5Y1F6Q2RaVGF0UFNtajBtcEVEeURSTUJhQ2cyVlJSRFdxOEZSWkxkQThwS0dKTmdjQURCeFdvY0pqMkFGbURRV3JRQ2gwcENjOFdNeENBSmxHRk1EZ0FNWnNta1piU1FaUm1PNW9IUTdETG9XNHUxTkYvUU5yNmppSHVnUVZ5cmNkcUsyd29MSlFDWUNXc01Yc1p4dWRaVVZVcWJtbXFxbkIwYXN3YXlXcjdPYkpvYTBuQlZCZTFJM1phMmVXM3JGN3ZFb0ZkUGwxbGNFR3BaWUxMK1FzUFRESzNqZUFETmNRYUlBM3FMQmpBTVlOdzBDeitGbkFhYWdOSElNVWFXbzFHN0FlYmtTNFlDaDkxdXNScEZScHJtTnZPaXRzaU9lako2UzRYZUFnQ2FqYWhuR3l4NngwSzllWHl3Ukd0Z2RLTGYzK216c3JUUlZNWTVEWGE5cVVPd2FMa0NEZWNWYUs2aWJrTFk4dE82YVg2dDAyd3Z3blRlYTJNZDFtdnJOcjE0MXE1eUd5aHlseDNwV0xGajgvcW1OeGZXVENtRjBCOUVyYTZSREVWc1VKZ1huN3g3d2hUV1Z4TW9RTlVxME91blRURVVSenh1dlVtTmo4ZXltRUI1a1J4ZFJkVlNyZFFDN0ZVVURORUJiUFRISEdOMEtNejQ4Q3p0VU9pQTBWaUNCZ292RytMeElBZjhmSXpGOHp2YVlhUlFHRjlGUnBOV1VPdGhITEZoRVFSbEt5RTB4MjdZYzBYQTlQU24rMXBzWHZuWDhtR3dxTHYyK2dPN1FrRkdYSGZCUlFkU1hsQkZ2Ly9XcnhhTzIzakQwRC9RcEE1blBmTk4xNnhMdDA3YU9hWFo5QkY5Q0dpdDdkTjNUeXJBcXhBbE15WjNORWZMUGJxZEkvU3dFbndsWjV1eDhKb1orc1B3K3ByV1pieHcwWWVMRjkrMnZFTXdBdlkzNzl3MzRaODNmZEZjL01YSDAvOUNud3ZBZGZkS1AzcmJOU25XYkpQOWYzMFVHQW9TRFoyRjBUTFdpYm9YamJRREZyNDBGaDZqMm42dDFIS3NmMVRSMVFCekowZHFQYlRpZTRXWmlDR09oeTBHaEZzZXg4M1NHVHRLSzFTSXR6akNOS3VnejJHcEtJWUpHVVdNUGNmY0dHNWNOS09tMTFOWUpwb09sbmVVbGxTNHFoczJQZFRUa2R6WUhwcTJvUG5RV1hadjk0VEk3SnF5MnFMYXlIOC8yUG1EalJQQmhnK1A3TzJkMFhtdFBQamNSbk8zdWdOWXZBUGVxNTBicTNEcW5UeHZOcnNzTTV3K3Z6TlJHVjljVmR5MnNiTmxTWE5RS0xFTDF0Snd4RnRaNlcydVhIcHBjUEwyZzBjKzdEWnZmQTZ3MTNiTzZOMnI3TWlEZUlmbzV4VklkM2lGeExLMFVSMGs0aXBqRDRrVGZQSmFRbE1jeXJOeXh1S2NEcnVVRUFkZmdBbnRzdkNwZE13RjZMOEcyVUpidXQ1UnpJR0F3K1A3d3U2aG5VYW0yQ2IvRHE5R2c3TkUvOGVtR2EwTXg5bmR0VDc1SDBhdFJsNXU3elRFdStiUUY2eEkyTzlrV21jd00zL2g4UHV0ZzQraEIvUzRURVdtdlMwMmRHMVpVZEQ5ZWFlOFcvNlZ4VzZyc0Z0MVd0bGR3R3Z0WGV6ZStJcSt2cUZQTGFBQlhFcU5XSGRRTkpWUm5wcG53RGpGZG1raU00TUIxV0tiM2VzUHVVNFNrd3lMZmxNTXNmY09VWVNZSEJKTExySG4wa0l1VXlnVFY0Yjlyd1lJLzZOaWhRclRBWnRrSjM1TXc4aFo2dUpTTkVDcmJHMGs5aHZKOHBtWUg1YXFMNDBVL2JueWEyM0lsWnBZMVY4MU1lVUthYit1L0hOUnBMVGVES2pPZFNDNXJoTlFacm5uMHYrNDlOTC9BQU9sOWVWZy9qNTVqVWwwaGVRdnF5Wk9yQUxta0VzMGdkdjJ5VWZMNjB1TG5DQzVZWU9jZE5JOStJSkxsYkl5dUt4QjRvbXJDcnVCMDJ5Vk5zdmlzMUgxM2ZXSmlVc25raitVM3RRTms5MmI1QUZTR2pvaEt6eDVQVU9iU0VuZWxNZmpMWDFRSmhoL29MOTcweWJ3V3E0Y3ludTBZVmJCSU9xU29YQW93MnFIRjl2c2pwTDhCUjRXTERkYmlxcExGN1E0UzVxYlNwd3RDOFpWRlZuTXpLSVJBOHluNEQzN3RKNWlGNUpYU2tzTC9jQlYzRFBOZnMwWVkwUUYwaS9lWmsraGZ0U0pWLzRJWVJzYUVHcGJRUkFOS3pqT0xSd2tNZFlzY1FzT2hyQUxKNVl6NDBIaUk4ekdDZGs4d2ZCaGlTT3V3ODZtbHR6MnpxZnYzTFpFMllDTmpGbCszMmdTNVBjZjEzbDFqOHZ2Q3lhai9MNlpZYldQUDY1bEdUTW9RU2RCeWVOYXYvWnhVSUpPZ2hMMUpOVG5ib00yVVJQYkk3OXUxdW00NWQ4WWpkOHM1M1E2TTZqdFlVMFd3emZmR00zb0xLaFZ6aG9NeWxuNWRYVFdiUHptRzRPcSsvMlV2WmdTVVErbGduaGN3OE1hUjBiQVNHMUprR1BVb1U2TWxSQkpHVU44WU1kaElva3puOGZxbjVSZmZyejMxNmZXSHYxczcwRTBYNGFXeTVjTjNJNHBacmUrQU1SYktpeWliOEdTUXlkdk9QKzhjY1VDL3dtcVRlekoxSDNOOG8vZjNmdlowYlc3ZnZuS3YzYStEZ3B2dndVNFh0M053WEhqaW1lK3NmV0drNGNpWXJGUXFtQ2JjU25WcGwydWVqQVNjNzV2bEIvL3FOaVdSQjZhQmx5Yi93V2pNeWZKR1E3ellQMVFnZitqaGdqU0I3SENnaC9tY0RnSWpvZjNWRC9YdzZhb2lkZ2JqQ0w4RHJ6RGJpWGRBSTJMNkxQd1Y4SHFEUFZpRzFCSkg1cUFKWXkvajJLQ0VLUUNCQUVmQmhMZ2VrS3VnZlkzSlVtTWlTK3kxc1RFbGVPVGtUV2RUWUxwS1d1aFU1Sm95OHVOQ3R6SE1TbFVKeDJqdTQ1SmRTSHAySUJMbnB4T1BndDB6OEt6NmtKSGQ1eVE2aVJKZW9FMWovTzZNRGljT3h3MkNtL1l6R0xVK3VjdC9iaGlJZVZDNVRieTd5QjEyYlBQb2cvODFDa0s4THVaS2RSbHhHY1FyNmZocFV1c1dVQ2s2ckZjQ00yTk5CcjFIVlpDZ1lHWGZmQVJwR1lSNEJ3a3N1QTVFdjk2Nk5wNEswT3dJNGpDaFhzSzBtbXNCQStHcklyajFUekYvZ0VkUWFURDhMc2R4NXpqU2ozRnZGVGxaOERWdFRUUGE4cENweWhud21yMWREZE1jTkk2cDJRQ1BNT0lnYTFURG05ZTVpelFCYzdwdmJxWm94bFRHUkFOZHBZMWE2eDFKbk5Sckx5MDBBZzVVYXRqb2NCekJjMUcwV3lQL3NlY3FOVXQ4QkFKOUp4RjBJaitzdFpnY3pXRFJITElXWFhBRzY3bDZHOFNIM3Vqa2JJR2R4a1NhZUdsWjdHbWtLZUFZYTBHZzIzQnBHb05ZSjJCU2VXbUFvNlZhR2JjaEhhblUxZDZUVC9ncmpiYldVNUNzaVpENjIyMUd3cUxtaGZWRkxKQVU5TFkyMWs2MFdqd2E2RmQwcnNnTUxDV1lsOWozZUtRdnRWZlhheUZqS3Q4U1d2dmhUb1RCaCtoQVdSTldzSVYvQ1B1YTNZNnBTTWpYalUxbjFwUFhZeSt4cXhPakdkamtrVDZweU9EOTRrYU5WZ0ZTbmlPd1I5aVBGWVNSSG92R2hWeGJLMklkckU2Nk1GT2E5Z29qejVib2xwQ0QxQUJRMk5JdTFSVXlpQTVSZzZoRTFobHh5bzZ2QWViZm1mYTdHTEg3RzBhclZFbzRpMGV3Zk5FNVo4MmJwaGRYWDJpYitNS3BDUDJ5NmNPL1ZIK3ZhRHRCK0RRSDBFUWhLWWQvTG1jbGorVy8vdWR2VmNtSHdTTHAwMm9aRGpCeEhGWC9xYXFzaEt5Z3M3UXNMUmoyN3dDU1ZQdVFBV3pMbXB6bGpHc3k5a001aStNaExXMU1aZW1zS1MxOWFHRmhlTU54WVc3L2pua24yd1NYRDcvSksvN05xT2JaZlhHWW9IVkwxL2JVK0ovWnNXeXBlNmlKNXA3YnBnc09ENDdwR3l1NmJqMjB0N1c5aDFQbmJNVk1Na0hmekF0Y1oxZ1FMMEFOclcwYlRVS2V0U2hHdGZERmN0MzFhT25vekswOVJqUjA1M2pXT09zbnZSV3QwdXNkYzk1dkdOU1ZPU0s2NnM1MS9SODJXSUxwYVVrekJkUCtHMlJwdTNCYTU2UXg2VE1KY0RNbzRIU1ltZEU1dHlqTHp4LzlNQXYvWUZmeXJlbFgzM2lmbERDUko5NE5mMFlLTG5mdjN6NXdtOE9IdnlHYlpIZFEvTFpxOTRGem1mQnBOK2t5K1MvdnJzS0hCa0NmL0g4Um41V1dldERzc05PSktkdHdHc3ZOQlpWT1lvbktCOW9MQllnTmg4QTlISEZjSnJGYWJZWXhLSlZMTkw3R1FGcE9HaDR3bXNqQXY2UU9aeGtkM29YTGU5ZHRYeFdzOW15V1Q3eXB1UnlTY2RBK2RxU3Fjc1hyVnd3MTdmbHBjdTN0QlZFWGJ4OVNzZUtPUXNTbGR6a2kxY3VhSW40N0N4ajBMaW4xTmNKb1VqbnVjMGxMR2NWTlR4U2o0VHEyS0lWbDNUQWNNdk0rZk82bWl3V1J5M25uTjY5WTlzMTRDZmQyMXE4dE9BcDBPaytrcjhGcmxBQmVPZTRJR3FNRmRQMnpLMjJCbVoyVlZ6YUQyaElXNHJxcDIyZFhHaVJ4alcxdGRXWXpEczdPZXVrYVpzMlg5MVIwTmw5MXFLNWsyTW1FN1BVeFR2YW9vM0YwREh6NGprdEhoRjlQdlQxVi9DT3Bxb1FyRUZpaXczSkxuOWpLZUpKYmlYeFZVVENBb3JQUHJENUxQZ3ZhTXN3TWpGLzJ6cTdRUjVLZnpGN0svT2J3YkxNMzliWjlNelpXNEY3NHZ3ZDhyK0FjY2Y4aVdEeUtlb1VtSXArcm1wdm43ZGpSNTZjaVJIS2F0VDRvREZwVE8ybkNlNWlraXFSYVlaa1V5RXlmZkM3QXIzZ05XUHdtUjc5cm9DdllUS3hXdGJoYkt6NVpLemlhY3VLT1V0eEFYTlVySmpKdFA4N0N6dWdGaEcwWVdaVWhaRlZQdldkcFIwbHZ5dHJwcmxpanBUZlIxa2JxSkRMYWxIQ3ppeFdIRVA3SFFGcUtleGJaVkREeGd5aG9SZS9SendZajc3OTRsd2N2bmdheGdEVm5sdjJYYndCYW5ROThING5mWURxNDc0TXllUTJLb1lqUVlrNGhxV3h1QVBQclZRRUM2VU9NaHJSQ3BCWW5KQ0xZa3VENUxQNWNMU1hSSjlhMnlpLytlenQ4dGUzbmZpUlplY2h3RCt6NTUzdDBOMTRpakthU3kxZnlLWE9JTjBETmNLQzJNVGx2UjFCY0wrODNneCtWV3I1Q0N4NzliRS8zQWEwdHo4Qnlsb3ZqZjN4c21ma2IvZCs0TnFTNUFQZ0E1K1QxbHNLSW0zTEowNDZtNWYvbUV3RzVJWmhPcmJDNnhNTGgyajArbmpzUHFrc2F1S2xVWWNTbTRYdENwSTR5anZSb0R2Nlg3TXJRdlAxekZXQjhyRFI2OW5idE41OWpydXVTOTlRYTJvMmRmVGM4YWYzVHc1N24zdC95Mm5rZjBrOURlOC9HUHYxY3daK21iUEgyVjczV1B6MzhjZEFDTGpCeGNNc2FDcWVBeW9qMW4rdGtGSFVzS3lEVVJ1STVxY3pZVmhJY0NsQ2NoOXJ5eVFzTVVvOXlTU2ZrNC8vckY4UTM2VTVuZGJvK0NTekZRVjBFT3d3dVJ6eURuVnpIRERrS0V6OVRENytuQ2pBVlJNQnB6TW5IWm9weTdLcGsxaXJmR0liYThWN0Z5N0xKT1FDSTdEK0ZIdjY1bUsvQXlyNnRFME5NMUlxa3gyTXNsYXg3eGtQTGl1c2xuSS9VWDU3bEJpVW5qTkdoNC9LVCs3MFhkSGlhbHlzQnVONGhnbmpYN2RpZllzcVNuQVZVR2lOc1k4OTZpMCtJc0VRVjFUQXg5SGs1c0NSdmo2Tzl5UHhGQWlnSE5DUldqb2dZWWhlNEdFaXJDOEV6em52emlUNnBQbkdHVE1hZWNtWVNONTVIck80N0JMejRwMlZsVHNYbXk4cDQ2TFIyUjBkZy9QcHI5LzdvbUdUdTFBZWNDMnU3RmxXZE1jZFJjdDZxaGE1Z0pjUnFtczdTOEJMUTlwdG9EK1JxUFk1QzZERmFZRUZUbDkxSXNIYmFWT2tvcVFpWXFMdC9GREpwaExQK0J2R3k3OEpsWTEzT3JGWEtIZ1RESUEzc1ljb1kvUVYyTG9UNnZlQnNVVG1FUDlrL0xGaURWR3hJaUdsTXBmTUVEUzBBVHFYREt0dXJFakR6Q1ZWZUR2VUVGSThCb0kweTM3Uk9uZlpRL1g4dkticUdhYTQvSEpjTTYrNXVzc1V2NlhJMWpJN1huSDcrdHRkOXVZNThZbzdvc3FKR0lqRk5QTng1dWpkTm52ei9PYUtPOWJmNnh3YUFySDE4c3Z3bTlrdFovdWE3cmU1bWhiRUt1L3J1OWZwd0lsN290cnVGblR0LzBmYmQ4QkhWV1gvdjN2ZmUvT210emU5WnZxa0p6T1ptZlJPZ0pDRUVIcG9vWGNKSUIxaGFHSURGYVdvS0ZFUkczWXNLTHBaKzFwUUY3Zmd6NEs3dUx1MnRSY2djL25mKzk1TUNNaitkRC8vL3o4dzc5MzZ5bjIzbkhQUE9kOFRBMlZ4NlFoeWxkZytpN2x5ZER5L1oyNFBLWkxJdXowaEdWNlJQMVFUUnkrV1N0SHB1YUJpL29WN05kbUNKdFVGT2lKQWwzWmtYd2JTcnV4RDZSNmI2Y0JwdkF4SnBKcE5CS3JCUUNVUytvVGI0MzBwTnEyK2ZscmhjNFhLSEhscG1LNE5seWF5KzNyRHBWV0J3c2REdEVQdDRDMUdnOUhDNHhBTkZMNmE4M1ZOenB3QWgzd0cwenIvb0VGWnE3S2tRU2xxSWM0VVptYVhsNFlEdzYxWlMyeVFsK2xrUk9rRm4zajRvSGs0bFpFbENyWUhMTzdOZzZrUjFGUnFNVVh4ZUFVTFFnRWhreFpFUDBHTnVLZEJlQ2UrUDhrYjlNWDl4SVczYU9LSnFYMldONW1GTlJCL1c4ang4VmdKbGNYZ3BSb1NrSjBnWG03aVZKWS9qdU5CNGdNRXgwM3JHOENpRi8vTlNsbU4xTTYwb004S2NuZzF6Nzg1YkwxU0o2RTF5dmFWOTZCL3BkTzRMUGxjTVBMbEc0QmlyanpSekRCS2lSNzM1aG9rK1JJdzZ6WjB6NlhYVEhuN29jOHIrdTRBQzBETDE5dTNmNDBPb1J2UklSSUNvMEVucVBya2lpcytRUytnQStnRkVvTEpPM2YxOFZQQXBVREtoeW9kbmFxekZGMU9zOURqQkhJZ0Ewbzlyd1pTOUJTUzByV1oxSjVuNW5XTlNDZ3R2RjNqVXZyWitjZFNxeVJzWGhiVDhlQUw3NkI5cytDQmUrZm53Skx6YnR3aVBNeXBKNi80QkZSZDhBeVp0VWRvZnozUkZ3TTZOdWduWThTZk1Fb1lvNEV4NndBZlNBUkRNY2JNVktPdlQ2SnIvdndITU9uNGNmUXBpSDFHUHhCSWZYZkRpdHVCOFEzaW9qUnAySi9hY2MxUCsyMEhneWV1M2ZNUEY5dU9hdERxSlNPYm5BYzlhek02NW9MZktTVVZwSW9JOG9EUmwrN0N2aGp3NktLNkFiOXoySEZzSmhpbGUrbmVaTGJqdE55Um5RUjRUVXBtL2xjNHNrL2hqQW9KRHZ5TUF4SUtKVVVFa0xOVUN0LzQzRStFSnlVZTdaSVpYOUZKbVdpN1R1Z0YzaVIwbEFUUG1pS0p0TCt0QUxHNk5SbzRQcTNqaVhQSlpCdFBCREordlNULzFqTUgwWi9SZnZUbmc0d2VWcHRLVEV5NzZVd1BvMlJTbCthV1Ntckt5NkZjcHVuVnlPU3d2THhPTVJZOVpqSXhYVGliNllKSDBJdURsZy9DLzBIbDR4d0h0UVZTaEhuRG85NWJadnFIRGdxaTRXb0YvbE9EUjRLRGhnYmZXak5IV2lBRlhRQ2dIdnorQzg4bTJSdEVuUmJBRXdFRkg2UWdrV2RnTmt0dnJxWVRKRmhNQU8zb0NhcnEzT3hhVlJpZGZYaFNlU1N2b1diYjczTUMxM2V1TEl6SFNzc2R0YjQyK1E3WWtLcFNLT0FMZzhCTElIeTFSclBvUy94a1ZaL2U4T1pZdFRvMHZmeHkzYzlwbnpqc3g4SWFTZ0VQR1dYaWZoY2VXZjVvbHBuRFR5RVFlWmpPb2hNZW1vSi9VajZCSG5ydlZuVHk2S3BWUjRIalZwRDNsM2ZXUExuaGY1TEovOWt3ZHNma0pvOEV0Y0IvTjFRZFIvZjNrZ0tnSERpT3J2ckRIMVpzL0FqOS9OSEdvaUVUT3dLaVhwazRUeEM3VnkvVkprZ2pURVE1TUNnbzBaUDl0WWcvRGRnY1lkTVVweWxCZ0cyQ0lkNU1QSHdMMkthWW5xSWxYTnJRdzR3UFREVGlqNVZnYnRBL1lKYkFzNE9KR2F6VlZxTi9WMnUxRXIya2FOWEtZb2tlSFN0cGpzV2F3ZTlpelNVNGRLWnBobi9qNHpXdmtzUkEzUFlCTHhsMGFJT3ZKTklVY0V1QTVhV1hnWVZ6K2NHc2k0eEhzRmlycWE3V2FDV1M0bUxKdS9oaXVDOTFCc2cxU3pxS20veWRFbURQRDVURW1tT1JZdGFJWHVVNkEwM0Z2bktOM2JuOXRkZTJaMWsxWmM5Y2NFRWNPaDhIU3lONGN5THpxZEJPM25RN2tXWUtaSnJKeFBhSEVrTGpCRU1KTS9sMi82R3BSR3Y3MEMvMWx1ajdWYXJZRnpHVml0V3lPVWR6V0MxQ0JkVUYrYlg1b0VNOC82VXlOOGU5K09iNC9TRGZUZVF1UmNabmRVemx6WXRjZWJtVldUYjI2M3Z2KzFwaWRZUG9lZmdUdS9GRjhUVWxrcHdjeVM1M1FZRlFNMzBlbkZQcGJtTytDMlhsNGF2bjVyQjY5TDJrTmFzeXh4VlJXYzJySDNoZ3RkV2lLZ1luTDg2WHVQRHNReENaRTJud3NYNjFGT0VGUlpVVEoyQmphVVdWS3NDRmpLUURuYWNtT2EzejBwNUxIVUg3N3FVZEk1YmFEYndkWExtTG5Eb3JMNzFqS1JoeElmOXkyRjQ5dkh2UmNQU0p3VzQzckZ6ZHNXUnhPOENMcVlPUGY3UjZuY0h1NE5mWUhHdmFseXdCRDF6STFaQTU2azR1eVU0U25sdkFSUklmV2pTeDczZGVMencweDNveU9lYUVtTVVFSzBkVjlqM3k2Qmt3QkFkU0R6M2M5d0s0Rmd3NTgrZ2pmWnRld0NsMDZYS2lIcFBhKzlEUFp4NEZjblE2dDZJaUZ5NjQvOXZ2RDE1UmZqdjY4ZEV6cHg0R3lxcHk5RzFPUlVYT1FINkY0SDFRQWVKbVhIU1BlaEg2bU8xTjFhS3NTWnRnTHpneGFWUHR3Ty9iQTA3QTNrMlRVRmFxZGhQalBGOWhUNHAvTmluRi9BUDNhQm0rajA2d2RnOEl1RGxrZWZCWWdVOEg4RXBCRzZNeG5tQlQ0SDhCSFU0YkdCN3lSdW9MTUdRTnVPbk5OOS9zZ01iVTUyQUllb29rM0F3Tk9HY3dPZ3dHcjJIKzBaY05EK084eGVoYVhHWXdQQXhjYjd5Qi90YlhjV2ZIZmpHeFB6aGdmTWtFYk5RaTRsdUlFdGh1WXZNeElLUk5BM2x6dWdTeDdZQkMzQ2RHZnNHSW0xcGl1WFpIVGd6OWtBN0FkUTlmWnVETmliRnJqMFhyTDd2N2tjdWFHNTQrbHFpNmpEYWZwMFRabU96VUFLTU9qRWhPSU9kVU1WQStSN2VWVDVHa05tY2Y1ZUZjSFBYM1BZV0Q0T2Z6MjFkT1paK1ZjVy9pK1hRamRZUjZqVHBLdlUvOW5mb245U24xSmZVVjRVRmRORkhRVjBPdWdQVVJUVklYNXdZbUhBMktCaVFsaVdxSXB3ZkNvZ3FhTjR4SWJKTWxFYy83QWtkdHpsRFlVSkpHNlNDQ2toQ1pRQVFiT1hOQ1Rac1RCVnlvQU9ZUTF5dVlMSFhCR21BMFkrSk9XaVBxTEJHRlZjeWwwZVNDK0lrRXlpNWg1b0FJVEIycWhsRThORWttSDhXcE1hTUcxRURtNVdGWFRwOWRsK3VaVURtb2FOVmVmMTZsUFZRd2ZhaGN3c2drZVp5YjFkTVNBQUFuMWRHK3pWa2hENlJoUlFLUFJQL3VLdXZNYm9mRWlGeHVyVVduQnYrUUtveThuV1hNRW8yTnUxT21zK28wVHdCd2w2bnd1c0pFb2J3eGwrMm96a3ZrR0l4eWl6SkNoL045b0lyVmNXcUpuSk14bk1hbUwxU3ZtNkFOTjlZNEIwdVZXVmttcGVtbnRZNjhiS3RYN1ZQa1NqbVlQYnp2a0xvMFQwZm4vaFE2SEpmWm5XWXJYTFdtcWhhZEtsbzRGTnhPKzhxaXBReG5IRjduUUlPNkpQSjhKWC9NTGMrbVZ3RkkvazJoQzV0V1RCMVNPaTlSNVVyVWFBTjdIeml5Y3lwa1dCa2I0SnhLbHpWZzh0aHFzbHR3bjVCcjNjMG1WVm1WRWRwaWs5YmRaR0JzM1NhdHhrelBVNXRVY29hRlFKV2xDNWgwR2hNZDF0cWU3Q24yZTJtRFJhdm44NGJhc3JTMFd1VjMxenFzNFRCVWFQN01HcVVhQ1NiZ0ljMkFYSmZIVm1BZktaUGxPd0JlZ2FaTU1mcEQ1bnhkR2QraWtjWEczUFZ5TGkyVHkvZzRwK2diWmN0MXh3dEsyWHdGN1ZjK1VvVGUxZ0JPbzVCeUlCZXFPSGlwUVFlVXFiVWpsWkppQUlRcml6eXVIbyt4ZjFObVRKTk5vamJoWlMyWTNnMGgrck5rSTErd3RoVFVtc1ZSSnFqVWNiaVRDTHJsY1ZCQzBHdUkraDJSeHdCQm1ZMG9Jd2hhY1lMR2x5Rzkxc2RLY0w4VHVtd2l6Ujh4MTdLOGEwbnpobHBXcXRCd1FPcWRQeTJTUFRhWFUrYnhCbk9zME9Jc3RxbGxPak90a2FobFdqV3ZzUHNVVWprck40Tk91VG5mNVVsdTlOdUhEaC9YblZpNkg4SVdaME5UMmE3bHE3TnNiWFdERGI3Q0xJY3p0dlp0OURsNkcvM2pUOGxRUmNld2prSmUzZXlyY3ZuenBCdks4ZzdtR3YyakcwWW1RaEZlYmZJV1l3N0RJTTl5MERUanNYUEt6WVZxalZ5Wlp6RklPUU5VTVhKR1FrT05XcU9UTUVwUWFNclBkNHdjQmNMbDVXRUFicG5aWFdMUTFiWFdBbEExdEJyUTNvTHNsVWYzbzMvK2JzSFNWNENqWi96ZGF4Y1BxM1hLcFFGRDJPSVlQK0tXb0xQTnJySU1Hcko4M2YzVVFPd3RGMTRsTzZtVmVEN1FRRFVJWmV4NUUwSE1WWnM1aVFHVEV6VTBiY2FFZ2xkaWNOTmNJU3dBaVFJUlJ3aVBmNU5vUkJvaTIra0pNeUhBQ3VtRW0waFVYSUEyU0RpVFlEbE10RVUxZEtnR1ZoT0ZHbHlSS2VqWjdhcDdZTFMyZStqb2xlTUhtUXJxbExzVmdVQmdUc0MxKy9ibmxIdVVnVG5OQWVlZW50MjM3M1kxNXRtYk9sZU9ibG1xSEhVL1BYdmw2T1lsNmpIUE5DcDJDMlZjZTNyd1AyZHRvYkZsSnB6VllpdG9VT0tNNWpsQ3h1MTduQTFQalZFc2JSdTlFcnpWczhkVlcyQnM2bHcxZWtpM2RzeURkY285aXNDY1lJQVVoSHB5eCthNTVJNzRuNnZoOEZnTmZyQlYwNW9OaFdkMmpsNDFlYkFqcjFFb01pZDlRMWZ0QTZNVlN4bHo2NldLMFU4MnBKODNuZFdRYnhzMmE1WG90MFBFekJoRWphTW1VRk9vMmRRODZrcnFUcktmRXl3VVhOV0ZSR1hPVUZwRE1SRWswNkhFSUNweTRuK0MwVEhSdmNSamdjaUZCQjFQVVdXVEZoUTBmYVJVUXBDR0pTS3NPUVFDT2hhWTZSQ2VkczJBMWVGUFNHNGhJTUtJK3lKQ1hXSzZqUWNYMEFtaTdGQkpTQ2RvdHlSMGJDUVBaeHAxY0Rzd0d3eDV1VndqMDlBd3dzSzRhVW1MY1lOYTF3aWxzNlFoRjRTQXRaa3RlamtESkFGRmVlRU1LSzlYeUt3TUEybXJnN2FXMUNvdll4blZXelNuRExwY05yT2FBYlRIVU9UbmRmQzVtcXZQL0F5ZlNEVXp4MmM5UHVPdnMvS1BvUUpZaFU3ZkZnOXYzRkh1R1RYOG14cXBYTW80UE16UUJ3WlB1VzYweGgyUWc1MTlwOVdwQWs3RkVvVm9EV1ovQ3lCbWRDc1lBM2lONXFReWc1T053ZGx0VXpTUWdjdzR5eE4yMTVVeTRJVUtLZEc3azdNY3grZ2tPaWlodFZvZjlERzBIQUNsRVViSzJNZ0loNlFFZ21Kd1FxTXlhNVMwV1dQRHc1QlJLK0dPditla2J2b1hJLzAwRlhmRDY5MnBmN2t2cWFNcm5nSnJUK3RVUGZVanJjcTJBazZHcHc0OURCUTcvWndPTTlMSk0zLzRVZktkQ2tBbUxnTVMxcThHeVpjdm1XOUVrd1Y3NHd6MkFySHBHMHlOeFQxaEJiV1YyazNkVFQxSjlmYnY5UFE3aDJYUGh5d245QVB4N1dRODUwWlB4R1BYL1VyOC8zZDVYZ1FXOCtoQUZ0blBUSklEZTZLOGFkZTh2cDc2eWFWaDJCUHVjdXh4aEZOWkF0RFJmendBNnY4dXY2c25YSnBLTXNuSjllZThLOS9wWFQ0b1JjM2JOYmxlUW9WTHcvZ3h1c0pua3YzVmdQcGlRWFRSMVArbUFOZ09xTkp3RDZLSU4yK2lReStoMHJLYkdtbzRuZ01XVWVzRkQ0SVBVYitqM3FJK3dwVFlXYUFCYmxBSWFpNnk0OWZ2SkZGc2Q5MS9HYWYveSsvNVcvckhoVUErLzdmWCszLzVmS3lnckhKRzFGTHBQZWQyNEg4L0pIOXJ3WE1IU0Ezd1RQU2Jhd0hxdjcrVGhBcmFUZ243WEJKOFJBTWdaNy85dGVDai9jR0xReUJkUEhoR3dFd1JEdkMvcU5iM1g1UTlENFlKODVxMVo3Vk1MOXVGUjBtSTdCaGVvRlJIWkowWlpTR3p5WkN4TW1YMm8vZlR1blhvZllmRE9keHhFblNmZExRN0hLaEhWTEI3SDczZjk2cWdXcGRFU1VHMXJoVDRTUUhIeVpPa3dpZWliaDJiOXIxTTlsT2NndFJvQkpGL2lYd1BwaDBKWHdKRVh6RWd2WVN5RVVaUExDcnc3T2Z6NGd6aU5DWXdvRFRCQmdrSXZtRkVjZ3JUWjhyZ3VLcVd0Wlg0MkxxbUV0MDNxclZsVTVOd0FGY3RCL3FudkRYMXVZMWYxZFNubXAvc3Z2dHRNS1JxWExCeVRTczVyZ1V6V2tjMWJXb2hCeVpjT2I5dDZkNmg1SGhMNmxqNzhrVjdtOXRYTExxMThBWDA2ZEtDS3FlaWMveU9NY2NlWEg2c2JYNWw4eTFMOFhIbzNxVnpWclEzNzEyMHZMMzUxa1hFL3Vvc0JZa3ZjS09JdWNpYjBzYnU0c1BqWjRlOVM2YmtRNyt0MSthSCtWT1dqTjUxMzY3UjlOZlh2eFRvZTEzUUJJc0ZYcm8rK2QydHQzNTNEbE1rWTNma3hsUTgwTEdoZktBaUgxRkVVazFqaFFpYnFKaHFTY0prS2xrTG4wNDFwWnJZMDM1M3F0WlI3MGpWdXYwRlFkaHJ5alBCM21EQkpEQUpydjEwTVVJSXBpaGZwUTRsdFZxUTFGWDZhQ3BjcndhVVZIcVdVdGVMVUhuNC9sTFJqOGs1cTJpY3hRYUU1MkJCK2h6S3hNbHpzV1RIRjlPc1lpRDlnQUhoZ0o5U1dIenhBUXBPaEdyQmpXZ0JXc0MrT3lDU0o0WVBvOEZvTUhzcTZFRzExbG9ycW1Wb3lLYURubUN1RHp5S2Y3M211Qm4wK25MQm8vNmNybDVRdnIvN2dRY2VTRzNMaEZiZUJlVDd1NTk5OXRsVUZlcnlWMnRQcU5VbklQNGpaMjIxSC9RRWE3VlBnK3Z3c1ZjdTc5WFdCbEgzMDlwYVVhYUNwQlFMOFh2TGNMc0hxUUtxanV6V0dqMDBRVFlOMHBqQ2kwS1BGek0vbE5nak9ZL0JGUEJFWWlVK1Q4eERlSFdmSjBBOGorRWNvY1BTUGc5WGlnQTQyOWZaTFFGNzlBZHFsdXMrbUlFTy96a0YyS05YdlRrVHBpNVplaVlPd20rK2d2NElyRzBUbmtOOTZIUFlNZmFLWlRVSGwxeGFQSEpKc2lsMUsvUEFXdlRIdVowdnBKNnNUYUEzZ2ZRdmJ3UCtpZyt2MUxrV3JZcmNmZWk1b2EzWC9jWFJzRzdDNHgxWkIxWU5Xek9xM0piK2hwbjlUQmNWb1BMd213d1cvUHhjc0JyeXd1NFQyVnNnR3cyMEw0WXBWVVA2eE9JeW5uanNITG9QZ1NhaUkyWWZIbnE0VVFaS3dvNmhiV0Rkc3A1cjU0ZWFSN1UrZk9lS3FZZWZYUXZsalVQQUxXRG5odVQrMnk1L3Mvb3F4ZERpeFFyRU5NMEROZWozNTB2QjBQVjlYeTVkZkZ0T1NYZlo4QndkZXY2cHpzbm9rZU9MNTJTMURKSWJOajl5Y09QVy9iL3poc0VscTB2cmdidzF3MnR4R1p6N0VFRm43ZmRhSU96Qm1qUDZaeUZDbVlNQkNFVUpBK1VEd2h4U2lNZVZvRDVEZ0d3cFNjRzFyMTE3N1d1cGJUdm0yTzF6V3V2YzdqMHR4ZzVEMXZMQmMraTNIMXUzL3JISDFxOTdiQmY2NFFnYXBueCs4NnFucmY4QVc0WlBWcGtJeG9EaW1TTkF3YmhKL1d2UFBQZjJEa21PZTNkTGE2MWI2cEZXRHFVL1d2Y1lydi9vbyt1ZlJUK2kzMjk0ZE0rbEU4RUR0eFpCc1BzWklFVS9VT2Z4amxMOFBnMVVheG9KZ0d5ZlVpSTNLSmd2eC9GRHg4OXRoRlZsR0k5QUpQMmRPSnE4ZlNDenZ5eTJDV0VPMzF2U3MzaHhEOUplMmxFNjJWcFNVTG5TYW9sV2RaZ01IWFNmK0NVT0dtNllNdWRtT1JpLzY5aXhYVGYrRVg0czQ0ZFZvNytJSCtpbjdhOXUyelpqNWpZNnUyZnhrdUh0aTlHckI1YVdGeGtNK0JxVkt5MGVGaTRVUCtaTmd5YXV2R1oyMzdHZHU0NjljeU42RGdSV2dIZHhPdXFac1czYnE5dTNFYlR4czJNa1g3Rm5LUlh1bC9tWVR4NG1vQ2JSWEVBUXZtSUd5bVRISERPdEFUVFJibzBuUW9CWUd3SE1vZEU4YVFFZ29RTWhubWdsc2tUcXhLbFpMb2hURW5RZ1FSVFgyRGltNmsxMG93YWlpWGpzS3ppTnpBdmI4ZzdkVURPMXlFMHp6K2tnSi9VTnYwYVNQS0lzNXZXRGI1VCs0eGgzMzkvS1VxSEM5OUFML01lRzlyQ2wyRmRrS1lLNzM5VXJUS3F3djhyVHBQRCtFNVN0M2Y0K21yVGIyekdvVXFjRE85MXhwU0lFRnFIclRFNjZMR0F2YmZaUDVKU3dIRzJaT09UNnVhT01SakRUVnFuVDExdzJKdlVadXNucG94bU8zUThXZ1hrUGFFMG0rdEVhZE0welNqREQ3V0Nnd1pSbmphT1gwTTVBbTgvZ05abmtlbm9JV1BEQ2x5UFIxWVl4NDIrZTFLQlNBZHF1MFZTSmZhUldLdlo1c3EvYmNBNHRndmZnMWlKRUpOZWZNdEJ3MUpNeElNMDRFc0h0UjdxSG1hZ3dnQk9UTjArZXZIa2ovZk40YUpHbEtKa0ZzclNRaFBUcXJ1NmU3ajRLSDdyVStrMlRISFBOZDB5anFXbDNtT2M2Sm0wQzYwaWh5ZUFFbUNubGVXbktLa1lwaEVuMkpIRzltUlNQbUo1TDR0SjNUbDYvZmpLYXRFbTBxNVdTNlRaS1ZXQSt2blVBci9hL1BMQ0lzK3hKZThReTh4bTdXWER1M2RNcFhOYWtUUmQ5OUtTSWlwY2tMM0RxdFBpNE13YThOK01SMG1CeTB5VHlFclhrOFd2RjQ3bVhPRUhJckJQa1ZWQ1cwRXhnbzlnQWZjOElVVXdQWkdFZTVZVHdmcFNmREZSWEJ1dVBiQUlSOTJrSjhtYjlSOUdmTUZFaUZJL3NpYUFOUllEY2IwVzlWcjhjb0lndHlJTWRud2pIbDhneFNXRGhrM3pROWhMWWdZK2ZnQjJkSlVIZHRxRFY1N01HdCttQ09QZUcva09TNXhHdUVFUUxoY09BdWNaSTVWS05naTVNR2pSSm5PWFRadGp4QkU3MURFak5FbEo1bk9vWDloUDdTek9DZXo0d1VEVnR0dXYzYU12Tk9YWVRtN1Y1MGQvdTU5VzhvOHYzSmZyRFRidUtmRmJPdFhvRE1MOWpVVnQ5QzhMcjBLTVB2OUZqZG1lN0ZjNHREKzREK2JPTnZEUDN6UXZoNTV1eStLVmVXYTdCS2JYUFZ0aS9DQnUzNWFpaVZwL1VzMWJsQTdwQzg5QmhoVnpBNWM2UkJocXJsTmtUTGhBR0FkR1hMZjRtUEtHR2lWODJqdVl3angzQ29RU2Y4REFVZXNjQ3pJak4yKzVDeDBDaEJYMEt6dUF3eUdmZVNUM3RSbE5kNkNzWEtJU0RYV0NmQytoY2VPenA4TzhhR2NWY1NxbnhDa3M4MmxkU1E2aFIxRFJxT3JVWWM2VGJxT3VvMjZpRFZDLzFMdkcyUlhxcGx4aU5raGtiUjNFemtyYmxhSU01NHp3Z1JuWUh2WVhFdGpkaEpvbzRzVkNpQk0vMnRKa3orSVQwS0tiWnoyVzQwNG83T0lKelpJRG5ESUpuSk9JaTJaUzRNQ1pHUkx2d01rQ1RiTElHOGtTTWFlNlBZWHJWeEhQRlFnenlzWGphR0YvQWJ4YW9PcEpBQ1VJS1dvdEpTSlZjcGxhcmdVcG1BamtLcFVxcWxhcUFYQ0dScVJVeTJaa3ZEQWFvaGpvZFZJK3oyYUJVWmpiTHBNQjJ4R3BWeUtIUkNPV0t5V1l6VktxTVJwV3lDOGZWRXBuQklKT293UWIwa2RFbzU3UVE4MHRhVGo2WjV4VlNITUp4cVdJYVRqUHdPS0tTeXBUZ3lwYzFHZzFtQ2RScWpVRXpYYTNXbXJSQXFRUmFrK1pQYXIxTkR5UVNKWlRMRkZKT0RabFpCNWIxL1Z1bGQ0enVlZ0c0ZExHeVpRZjJmd01WY3JWYW52cmhHN21xNUJoczFrcFpWcXFWcEo0Rm53TTVwNUJ4S3JBZ3VVNG1XNWVVTmIzMXVreisybHN5UERJLy8rRkxoZUxMSDVSczMvY3ExZmQ5S3ZkblAycGwzSStmU1dUSUJCZWl6VDl5Q3YyUFlLMWVNUnpsZlM5VjhOK0RkM2xGRnBKOGF6UitDMDdMVktxVURuNkc0RmR5alZyeEZVQUt0ZHFGREY4b3RGckZGK0FMcFZhTHBQOVU2ZldxSmN2Z1dsb2o0MWlwUG5YanNydWdYa1Z2TXN1OTZGU3Y2UUNWd1NlZ0JCL0dkZ0dCbEtLeS9BazgxWkFkK2lwZyt0OWpqQUJPTFVaTDRwQUg3NEc5SzQ2aTIxQVh1dTNvQ3JEM1YrS0hRUStZZGpRVFAwcFRZMGJkSitwajNEZXE3NzRCRVpBeklNTGs0Rk5Tak9IVGdQMWNuckpSUG1veUhqdVg0ckd6RmM5SnY5eXZNM002RC9HbkxDaGJFeEV1RUtSbFpCTlh3aG5GUFhNT0NuNzdpRDA3SU5ZaFJySUhTMndPS21CRXNML0hyNDBQbUxKUUF5QXg0MG1PbUx6SDhMK1FnYU5KMFJDNWlvUU4rc2lZTEdHUE9NTDlBTXJKY0pkak0xZ3BWNkpYbEdBNnNUVkxVUkI1b2hYbE43aTBhZ2drZFVXWDEzeHcvMDNqTlNvTFlPV01iUEpvdFF5V0pCcjlGcFZLNFRZQ3MxSXZJOGJ3eWdTeWw0eU9EZ1ViTkNyOE9BSkNoUktzM2JvVG10aVdxTDNVQlZkWUxtMHBValBNWm1HTExRUERISFkwb2l1Y1NsQ21QSzFuS0dMUWRwcUNJMnd1cnRpRW1Tc0FnbUdQcFFLZDVwU0FrZHZDcy9ObEdnaEhkMSt4cnVPV1NGaGpMSlJBbW5XdEdiUWYyUzJYaDhmUnEzTTZ1UUFkWmhpQTY1cHdlNlRteHUyWUtHNVlPR1pScWNMaUFJQTZyNStKMzJqVWIvczJ2SkVBR3VQV2owWEo1am9PQzVCK3RFUURmQ1VGeERVYkFWWW50SjBQdHpnZGpmMXFTODl0MnI4dnlkR1FvUUZMSi9mdGIwTHZkazVuSVdUdzAwdmdkVXV1Z3l4Z0dBalo2WjIvb2RubzVQelVmUENKd2FhVldtaXZETm5oenZuelViUEJaaVRPZHRrc0dmU2tQcEs1SlVhanpRQ2VtUC9MZGhqNTI5cUJtQUw0Q0tnbmtRWkROL0NST0MwMmhnRGhSc1FOaFVDSTgvU3ZOZ0xJQjlaaHMxazVpMSthZ1N4SHoyOEJ2c2JlRnhyUXA4MnpHU1dOZXhjalVjeHJRUjgyUHZ2OGIyaUd6K2JOdTUzanBZeUU0V1RNN2ZQbUFSMnd6WisvaitNWkdsOUh1USszeWRmb2s0eU96TUQzTHhWMGdYOXJDMkNPVXZUVGpTa05ndXdJZkRveWNnblk0cSsvY3hZWVBPbktscHlHNGMwMVJSM291b21BWGJHeXhGMWE3ZjV0TDNpM3hwenNHTEhTenM5UC9RbFlnRkx2NlJqdjFsenNuWEtveUcrY2VYU2VXTUlNR0ZGZHl2Q3JyOEFrKzZoZXN2blIzdE9OYWRMZjhOeWdGL1gya2lySmJsS0ZJR2RtbmpXekwwT2VOMEUxQ3lqck1aK1JqZm1jNmJQeDE5L0JSOERGZFVDd0VCYTBvT044TEVxY0pNSTBHUTJUUkVtUS9PaksvL1h0a2tsRXdXM3pwZGQvZUwzVU9EMDUzT1E5SXZoNlk1SUQvc0N2dlhFeWlhZXlkOUNkZHV2SWhRdEhXdTAxb0RXWnRDR2I0Sit4WCtkMXdMY3FvMW9FYmJiZnRFNFlNMTRqK3gwM0pPSUU2RkViRXBIVlRGb0JkU1VVSVY1QkN3QkpNUWdwdjk0NU1aRkRmRWNlMkVRWWcwMEh0T0NRbTkrd1FSczNHRm5kakJrNjFxaC8xbTRZTzFZZkQwSytwSVNIdk9HM3pFNEZVbFBxQkhFbGViZXdiM3kzSmpYWXNnL3MyV2VVNkhReDR4cjAvQnBqVEt1NTBUQ3BieElQL1RGRDJZMWxocGhlZDVFK0hmMnQ0L1RDdlNFMjAyb0NHbVkwOHV0TG9lQ0ZHQWxIZWdGcEZyVU0vUVJrc3QrMGp0SEpURjJBanhDL2Z5OTVmeUR2QkhMWlJiNS9naHBHOEpOKzA1dFZFOXRSUUxUZmlZV3BZTDdpTVhHMDRMY0lFRlYzWXI2SXFWeE1LUEJpV1pJWit2V1AzeVcxS2FJS1d2ckVFMUlhQjJ6U3Y2bnh5NnJWZjdzd0hTMVhhZUJWMEtTcVNaOS9VNHZnS3dUeGxiNzdEbDhoaUs4RThubjhoNDVkbUo2UzRDdlM1Tkp5SE9qN1BRNWduaWQwZGpkN0hMY1gwZERGNUpFRWlvNTk1SmpyTWRrSTdaUUk5bnRjeDRPQXFDUU4zTzVqajgrY1d2ZUhPd3JiT3h4MWMyY3M3UnByQjNiYnVGV3JoOSs3ZlBzZGJ4OTY5TGx5enRwUVVhZDNsMGRpdFgrOG94cSs5TEw1Q3ZUdDdiYjhJbDFzeWJVZkF3NWM4dFo3YURmNjZ1V3VlNzhjQXNLSGUzODQxcnR2UFdDVW9helpJOFoyVHAvdzlGL1NNbjFPbk5ja2xCeHpVM3JNbVZvSk5nQVBkQUUyRVpLQlFHYkRHZk51T2phQWFSU2RJZTFVakxBa0lndjlWemdCUFlvZS8vM3Y2U2dPZlljZWJRVmF2SGg5ZlRWb1M5M0Z2UGw3OURoUXBlNmlvOTYrTjQxNXhyNDN2VjQ2aWdNNEFTeENsNERaSC9rM2JPaDdIK3c0OU5IbFR6enh4S1NQd0d4MENmcHFBNEQrUTJBSHVpazM5V0cyT2ZXaFNnVzk1bXpvelRaREw2YmtQelJuOEZyeGk3QXJjYjhjSy9aSllkZk81OG1GZ29Takg4Q0Q2TjNyY1NZUW1HZWlyWkRCQzNleDBmUXVIcGZSQWZONVJhOWEwa1ZYZm5FM282SFBEQWFRdmUrTFN5WXE5eStiMGpvTWhCNDdBQ3gzZ3ROdjNMUDJ5dG5hR21WRGE2SzFOWlkzb3E1dTZJakZkYXZ1dm1mTnRkTW0xYmVVdERlWDVRNnZxeC9hc2FobTlYMndyK0NWMWZzL0JmSi8zblhKMC9GUTd0STd5bTgrY2p2NjRrNkpCWDI5ZXZ0MHcxQjFYVU04MXBqVDJOSFJtSFB0aWxYYnB5Nm9yWStXRFJJVHRwMXZmeUJpYnhLcm1nVGhQODQzR3ZCbjRWZUptQk1nRVN4SmhDUmFLZ3NmdlNGT254VVhmTXV5Wmp3QmN5WURmTzJYcXYrd0YyMisvL21PK3pxZVAvUE44dzdIODUyd0hxd1ZFMTVMdTRxbFp6emYyZm04UTBKZFJGTlkzVWtxNGFxa3d2MW9jK281SVFFRVB4WXJTNSsvWDd5Y3NGK1RKVG5CL29XZ1FJQnpDazU2b3N4UEVYeUNyR3F5NVIrS21SaTk1TVNWLzBTOXFBZjEvdlBLNTBINzBRL1FCMm0vdHJQUUJ4OGNCZTNQdytUREpQUEtmNExhaC84RWxuN3RQcG1QZXY2eFVYUmp1L0Vmb0N2L3BQdHJ0STNvaFBONFB2czNic1BwdUtmSDlZbElNUjZGaktCTUloaXdBMkxtVGpZMUU4UjhJeTVvQXhHQ2tXUUtBYlZnRlM4YXV4Y3dtT3VKbW9wZFVyTStyVnZPUy8vNkVndWs0ZHBTRHp0MFNHUk9hN1ZXRzNKbzdDcTFQRHMvUjYyYUUyb3o4Q0JrTk56ZTR3blJqR200d3pFN3I0UG4zVjVEb1dmOGlNRW1ZK1ZRQzVPVlU1eXRWcWs1ZVRoL2VIRmpicEdEQi9TSDZKS3poOUdoejdmQVhjZkJhanhDcE5GWksvYnNQREE0RXRLNmRkcm9waVV6WEU1cnNjY21rU3pWTmRuc1JZdXkzRTgrWHJEWTZ3a00xdW1XcW9jNG5hVzNISzdOZHhzOE9tMXM3WXExM2JOSFZ1bDBLdHJwclkrME44K2FzM0V3U3FFWi83anhaOUFoMGoxQ1gxTmlQamRNdFZPVHFBWFVLdXBLNmliaWJ5UG9KNTRUOEgvTTFISDRHTlFtekJLT3FGMFRLMFl1RmsrRTRnbHpuT2FJSVplRXFPNlljUmRNQkVORWE1dDBTNUtManhGOEFYd1pQRkdtaTRYaWZrcUxqNkx1SmE2UUlGV0VXcVFyVUFPTVlSalJPT1k4TlhoNjN0dm90bm5senJ5Nkc5L1gxYVgrTnRKa0w1czJyY3pGZC9oWWFmazhkTnZicFhXNjkyK3N5MXY5cVZyOUwzZkQ0YkxPb3BLSkpVV2RaWWNiM1A5U3F6LzExQit1R0ZlVXR5Q3ZhRnpGNFhxVVUxZEtpZ2Q5WmZOQUY2T2RWbVkzamZUN09uaFhtYW5NRnlRM0thMTdCM1FCMWRhVDZFVjBBTDE0Y3V2V2s2QVNkSUxLazQ5ZFpJRE1xcGU4ZGRCYkhDbTdKMitNRXVvY2xTV2VRK0RtUTU3U1VzZU03b1hvWDk2RGIwbnFnWEpNM2oxbEVUaWhQV2RNVHZ2RTFqc2E5Ti9JNWQvb0crNW9uU2drVFdxNW8xSC90VnordGI3eGpoWVlySWVLTVRuM2x1YVVlZzYrbGJvZnpUcmtLYWwwekY3WVBjTlJXdW9KZW5ER3ZUbGpGQkRmR3ErZDVNbTJEbnhhdU85aTJ2bm5aRmtjcGNWVTN5QnFMcldVYURjR0RFUktISTNRNmJNcEVaUDRNbXIzUm9MK1R3NEVYb1N3SFdRYUZqaVFVSnlQQ3F1R2o5QTNiRXpFalkrWW9qRWZTU051QmNqMEd6WDZjR1ZhRUI2SmdwajRoUzVRWWRPaytkTm0rWnRiVy8zQkEyMWxrY294eXl2eWd0bUx3NDB0dVNlNjJ1ekZ4YTJkOHNEZ0t5RzhrZ2FuWFhpYWwvbGtjK2xybUVvL29MV1llOU83UzRPMTZOV2lJY1dScG1JNFk2Qkk3R1I5VFMzWU9YcFVaelJ3bWRPNVpFeGtqb2JXTmNZc2RHQldmb05QZTZTaFZzMjZMWGxTelNYRExRNFptbXBQZ0UwRlpuTVJXaG1SclRKMmZBeVhkUmdzN3NKbE5JREhBL0dLb0FXKzUwL0VBLzVZZk9RRkdLOFNxaEhQUTBjRURHeXRzSWU1Z0ZwQnZIcjR2TVMvQWsxV0pCSWdJMFB3cEM0Z3M3QkdyY2NycUNiSENQTVFTOHZ4elJIZ0kxcjFvU2hSdFE4WUJWU3JtQzRhOHdxSS9RU2VIK2RFamNSVm1NNlExdndXMXo4NDhxN2JEdTZ1cUt4WXUzWUZVUGx6dFR2V2hrUDVnOGVNR1p5UGRnNWFmVW5kRXcwMVE2WThkMDFYeHpUd3hJY004eUVESncyZVhkMFpjVW9oWjVFWWcxMlN2MHZ1MTVTcFI0K3RTbjNkVmxiZVByeWkzRFJqemt4NllsWEg5VnZCbTY4cDViblo2eDh6UzRNaGQ3Ylo2TW9mV1liZXRwYk5iNzZya3NrZXZkREJXTzRkY2ZYaHdyN244c2ZEcVpPOW5nbXBXOFkvOG1Jb1hOazFyZ0pNWWFEa3VaYTRMM3Z0Y3d5NllST2p2blRzMlBLS2NkUXYvRkxMZ0kvR2t3ZnRBN3JvTCt3OXNvRzgrMWFMSWVlV2xZQ2JDZjl5bmxLNkFYeUh1MExlUkZDS2VIU0V2dXA4MzdObFp5bm1GZnlObkFKV2tBZ094a0VpQVNQYlhrRVJ1WkdZcEJBTGNRRWJSb0NkSk5xN0lyQVEyV1FXd0krSllnVW1RdWptSmNNcm85V3huL0tCM2NqaVlhSTJCcHNhdzFXRHRZdDd3TC8zb3U5dXEyMHdtbG5XYjR5V1RYMDAyZEtTZlBSNWZDcVJxNExaOHRwSmUvKzYvRGFnWWd3OWkzME53OUUyWkRGNW9OMnc3cnZmUGI2eHNuT1lMNmQ5Y1FFZTJOL3ZWYk1CZkdkR2xhNk9UMU9YekRHRURXcCt6ZllWZjkwN2NTOWVCL1hwZFpBZ05hY1ZaUk1FV29SWWJrdmNSR3VkakdOZ1RGTlZCSVhTeHhGNFRiT0kxcFIyS1NNbzJ1TGVKanFXSWZ2cEFsQU1FVldJalJUVEFyWFVwQUk2OWVITHJqNjhaVXR4UjJYRTZ6WW9RVUpQTTYxalEzNlpVV2RVYUFFbXNpcUdHa1ltcEpCaGEvOGRXenFpVmlOVjEwcXpIK2p3TlM0ZlZXZHdLeW9NakJ6Q29wVXFscEhxaDJZRGhxSE44RDNlWXlqWG1xcVZWNFBjeXZxRU1WN2UxalM5dlp3ZDJhQXVVUUtXQlV2K3NDQjNpY2FRWlhSRHdOdzh5QkFveUdFc2txbDZFODlDQm9EOE1LMnh4UVBoa0JPYUFJU1FWanhiVFJ1eUd4Z1ppQmNBUGtOM1ZXTTY4M2tCSjl5RGFlU2hBb2JzT2FKOW9LZ2JYandaNENCRCtvTXdPRU5jd2s5UVJRaXlITkZlTVl1Z2MxcUJValhCeGtoMmJuMTlialp0allidCtmbjJjUFNMWWpFRkhpd0prWlJRQ2ZyUkhib1huYnpUN1BQWWlxcnRIYkxVRVBUaEM2RDFwWWRCMlRHNDZNcGxpVmQyTlpJQ2R3TEh2YmNEeC8yTXZDTVNEWWVpYUlvakw5L3V5TThEWDEyWWNCOXpNenExdDYyWnB1V01EcTUvNzNYZ3ZoYzQ3dHo4YWFwbTJaL0dQcjR3c08xYjRQcDIyN2J2UlB3U3lWbmNOSzYwcjJHQlp3M1FJa1JTRFBNTUJEbEx3SGFRblBSSXpsS3NYYTFUcUZERnQzcTNTc2FiNmE0eng5Q3lBQTI5a3FRR3J3Zy9XTUtuS2FkV3loNUd4ODBNNXpHQVNZeXZiL29kNnV3d1QvZkt6dUVsbkdWL3dweG8xbmwzQlptN3B1OEplTURLd01EN3ByNUJmOVk3MVRMZWhNSUJtdlpKa2o3MCtnZW5aNEYyZWdyeW5ydjdYOUJobzNEM0YzK3Z6ZzRaNkY3amFUV2IyL2ZTbFhCOTM5L1BtM2RLaERtQjBCLzR5NG04Yk5TVVZ0MFhOUHJ4VnpWeG1abElnQXNXUGk1N3ZrTmIwWHhmUXEwK2lrN3VQWWhlVzhnQjZaVnlqWlliK3U2S09jOWVOV0xFVmMvT21YYW82VXJpamhyVjJvTGhrR3ZqZk1EZnNCYzRqcVpPWjVUM1RnaEthTFFEdlVxd3VhN2ZMTGRLcjVKQitaUTV1UHJiK0NxRDY2OXloY0pFbDVCNDV0NHdjOUhxbzN0UXZ6WmZWMFovN1p6K2lwM3dGV3FvRmVod2JRRTR6NXBzSStvVEtXdUJCSjkxUDdqK0FzRWhTK0hNZ1lYUWs3K1FEVmJqZXoyUDc3VUYwNU5wN1ROaGxzUXpDQkhUQ1dDRVJ0cGdkdEZwcm01Z2lSQnVONEk4RERKdW4vQUlFN2czb25WdTVJbG96MFBtSXI0a1ZBQXZYa0s0cm1SSDNpUDVlUS9uV1d6ZXZIS3RCd0JWSURVcHFBSWdvSzJOaEsyV3dzTUZ1ZmZsbUszdTdMakdRN0F2V2FsYXBxa3M4RnNzQlljTGN1N05zVnE5dWFVYUg2NW9nODlZY1VXZmZrVFVhc1dYekQyWWE3WDY4c3R4cGxkYldlaTNKRGt1MitwMk1YSzVjUVhZYXBRempOeUl0bTAzeVNYQTZiYmxjVnlPeGVWaTVYTHp5akk2bnk2d1I3d2hpMFRPT0lTOFBKdkxEaVZ5NDlXbzE2aWdhWVVSMUY2TkErWmdPdE1CV0xuNXFyNFJLNHh5RGpwZHRqd0JZOGh5TnNrZzNNWjVhZndJd2Z6a25JSzJyejlFbE85Rk8rRjROc0c3UUFGTGhMRkphTDkxZ2RWL3JjKzJ3T2E3WWRxNit0cHg0MVl0QWhId2tkWFBOZ3gxMWdLSlZSRTdrN1Q2L1ZibStUUFY1QXkrVmhhV3IxcTIvY0RLNWRrQnY4QkhrRDVGRGZBN1FqU0lHNmpCbU5veGVtS0JYMmdLZTJLODBSY2paL3JDdkF2M3luQTU0cVlTZEtFZUtMalhTdU82OWZUMW5EZ2hvVkpaSjg0bDBzbHpZVmg3NGtSZkQ5a2hIUUFpRndRNERxbGtzZy8vbVBOeUVEVXdsaTRteXJmVHZ1bUpOZ1h4SG9MYmtPRHM0WmtjcjZNQjBqbXpjRHFlblZqTUNiRnhwbmZMTTgrZ0g1K0JhTS9FZFRpNFpkMUVNQWNTdURjU1JIc2dCSE1tUW9vVWVXYUwwblJvRE1rYWM4aWtGS3Zoa0FVbm5qZFdBMVNNb3Z5aURXd2NzMHltcUxpVmpKY2FMdU1jTHlFWXhQN0NsSStsTGhzM3F1b2JDTCtwR2pYdXNzc2VYZ2UvcVI2SkErTkdWbjhEMXowTUxodElLcVVlWGxlK1VxdldyaXhmOXpBdXdtbFhsbDMyOEdWbEs3WGN1TXZvRXdQcEpxNmZkOVRoYjExTnRWRGpxQm1ZZTZBb1lkdFgyT0VWQkJPSk9EQVRuRDJOZ0lCd2pwR0xFbHoxaUJ2d3d1WnhXbXZXaEpmT2diRzQySGVGK1RPVVZsMFJwT29pdGt1SkNJMW1nSU1NUmRZRkIvTGtCcXRLa2FQM2JoaGxwWjhxK0w2UjUydkhFOXhVOURjQ3l5ckFxVDV4ZXkwZjR4dlB5SlVxK1FTWlRHNlRkOHJmVjFnVW5YSzV6QzZiSU12U3F3WGdreTcxZzNxSEh2L2ZQWUVVbGVOaU5ybU12amxpa09jZFdHQXRrclBoVVJ1OEN2QkF3WGVOK0lLMXR6OXhiZVlld0VWd1g4Zlg4bndqeUV0WHhGZTJmeVVjWlVMS004SzFlOUszMHVzSFplNlBueWlOUzBEYWxxRU01TXVEQUV0NzRBVmJRQ0JPeklCNWN6QmtaZ01KQ1pmZ2lWR3dPY0h5bkNtU0NQRUJPQlc0Z1hzaHVwWDk1UjRRczNEbnJLOXJMdC8xVlF4OWpENk9mYlZyYS9YWHMzYTZRTlBWbHk3N2NkbWxWNE1tK1BiYmI2T0htZVJGR053elExNC9RNDgvQVJxVVIxdlc3dHUzdHVXb0VqMTdZang5NXZYTllmVG5RYUhRSUpBVHBnVGZkV24vMEJtYmdxR0MxeEN5dzNBSDlTaDFoTXdPR2MvVmFWZnVGOFRCcitRSE1rcE52bDhyK2V2NW5sZ0p5d2pBRHRVTVhnRmRqTzZDSXJwK3g2RkE5QklwdW9vOEY0UzFGMDFPUGU4SVFoaTB3N1AvVFMyUVRDRzBFVzFNSVYyMGZkdGpRQVdxZ2ZMUXR2YW83bHlab0IwbDdjRVQvVHJ3QTd5TG9pVVhTOTBSdEcvWVlBK20vb3NxNENxVmZBNEVNK1VxWFVuTHNOYnlRS0M4ZFZoTENScDdyc1FvZkVsODRYNjVYeG9Yd1NCbzc1U2xjY0Q2NXlXZUlCb1JRVjhtUVJBbFJNeWdIOXFON1EvQjNxQXRhRU40UWo3RldlQy9DTHl0R01VeitUMFdydTg0Z1RvQ1dRVHNOeE5pZWxNNFB5VXNGWkNpNTVwVHRiQzNMNG5TaXdKZUpDZ3pTS1RkblpPalNPY0t6K3drRktlQkk5cENUQWpnQlNxb3J3Rm1RQVNSbkhDVy9FOGdnQmJ0NnJrVFZSeEd1eDRIODlZVzN0bXpDMXdYbk5jY1FOMmZnZXVEODVpSzROd2c2c1psQ3RjS1JRNkRsMGlaNndQTjgzSGR6OEIxQVVIMmJ6MnJsUHhUOE50bnBNb0ZyMFFEVVJBdTR1dlN4V0xxSmk3QWU4Yk5FUmVzWnZHbzE0dldkd2xhRVB1bi9TWHdndk1GRnpDbjF3Q2pMaEUzMFhQWFA3b2Uvd2MvcnVzY3YzNzkrTTUxSDljT1AzUFB5SXJjQ1lNblJNYzdSc05HdTRTeCtiaEZiSTI1TVRnNE9yU3ErZVZWWjBiTnIxODJwMjBNQTZRZURqQmpoODlaVmpkMzVKbFYxcHdRbzZFbk56Q2ZOa3cyaG5Kb3g4Z1ZLMGFPV3I1OFZQcU1mb2EzakIzYU9ERTF4ZXcxYVhCTjRKRFFWdHNFZ3BwUFN4UmFzOXV5Y3piNis2SEZ2cXpDNkdMUUJLQVVvQWVYUkFxei9Fc09BZnZzbllFU081VFQ4SWtoczJZTlNUVnI3Q1dreldiZzlYQnZXazVMOENSd3p4TGNpZW40QkxIQk55YUFEbmc0SW43bDZlVDEwSDM5OWFrelkwRFRjVXcwdDZHbmp4OUhTeFl5YmFnTlBFcCtLU21pN1dmK2VmdzRjMStmQXJYaDgrWEFJL2JoOFdjQmV4K2J3cHhnTHA2MTJxaVpaS2FDcEtrRklrcmtnZ1VBejVCRUF4akJyakdJNDNneElpSXVRQmJBVUpBV3dEblRmaDRJNW9YZzVNWlB2cUNleFZFV1Q5b1NFVzFWVUtuQnhXZ1dzTXBRL0t4UHhRQ1dxZHdOS2pURlZvdDlGMTI4RW4ycDgvRktWcXJQOGFtZUhadzN5bXlseTdoN293R2IrcjVDTmF2ekZZSGxyN2RKSGFsT3RxSzhGRjB1dFdlRDF2S3dqQTdDVzJpbkJyM2NZQUhtQXJYTEJab3ZpOGdjZ2FKZGt1UHIwZnVxTEtsc2NvN0dxRlRMbXg5cjRoVXllZkJrUWhNYUI3M1dTTXZqamJEVnFmZktjdEdSK0o4TmFxTWNHRnVORVdPdURvVHE3WndKanBobDBJMkRZM3oyM0VrYXVVK2YrdjJySVlPOFJTT0ZtQ0FwRElPWjk5ZExlSjM1Z3pMQnZsK1U0eVRQczMyd1V6NU10eEtmTmZqckNWU2VUb0I1akozM0l6U3NzRW5vMFJtNDh5QWRQREdHUWtTU254SXNOVmdLWWFMcDNBOFRlY0dTb0NSNW1sS3dyMk9hcnJ2OVZMSzlHMUNrMGxsTTNkR1VVSS9xbDhjTHY3NWF1bGNFRW1acXovUjYzRUhtdlRPQ3JpcFRtOFJWY3lnVjkyY0JiOEdONTdZUm1DNUxqMXFqSWVIRnpFcmFpaVpCOVAwRUlEQUIvOHJuSmM2SUJmSWJyeTFDT284cEdCeE80NEtkUzJjTTRSMlhkVncyQjdhczM3aCtHSzNmTFcvNzRoOWZ0TWwzVTJjVnlpdit0V2YwL2V0bmxFUGRMdmxtc0JJa3djck44bDFJb1hnTXJVZWxhUDFqQ29WdXQvd1p5RUFiWko2UjcxYmRZTWpLeThzeXJJM2d2MTE2bGJ4MTNMaFd1VXEvQzJpbGM2Zm5WVmZuN2RJcjVadDM3TmdzVitKRWpleldmZnR1bFpHQ1Q3L3h4dE9rSU5HQ0UreG1oSDNNZ1ZLcEdtb1lOWkthVHMybjF1REJlWUZQT09xL1BCTnNTQkhWTGhJZm1EWVE2MDQ3UUFkN0lJMExrc09JWGdSNFhUZ2g4VVFQR3hpN2FDSTlyR1ZPQy82UE12VXo1bmdzUGdwSnI3ZVVuQllrNXl3K3h1YUp0Y2wvOExwd1FxOFBqRjAwTVpVRTU2VDM4S3lZMVN2QVVvdjhCcnBMU0tPcDB4UXBKeUZINGhIdkxNVitKU0c0ZW9PRWZSRG84UkdZUEFJZklCaEJrWTNKQ2lDNHZ4RW1FS0prSWJwME12aENtQW1raFNaS1pEVFNNVkg2bGQ0MEZubnpyRUdXU1VBMlpEMWp0TkF5bjk0dlk0T2J0c3grcUh0V3pLSUFOTU1NdjZtZy9jUEZWM2QyenRERGtVQ0JqcHVjOUwvWWZDY2M0MTFmTkg4eHZYclVTdFRvc2ZIb2dNYm1jUmxMVDNSL1ZCcUE1dERjS2J1YmFpUTBvQ3NlbTcvaDA0NHdCS0JMbXZwUjdqR3h2M01HYlh6MmZqS0hoOUpyclp6UzR4azhUTGdxTThWN0lCM0V6SitFZzNROG9lZjFKRVVHdERUeGJ4TVVkUS8wNExDSEIvSXVWTC8rYTZYZVFPOHZiaG4rU0pnNTl2SG5JTmVIcXJJUnhjeVoyWURldDQ1Z2VDMlliZlN4UytrdUc2WmRaNEhEb0VUclE3ZTg4anlJQThjSEo5RkJjQzA2a3VMUlluZ1RIVXIxb25Gb0xTeUNDcEFQN0ZxcnpZQm1pN0lSbVdnM29xRXNsQVB6T0lJZmV1Q0xFd2xpd3N6U3VHOXlURUJ3QzhSSEFSM2xmYXhnS1VMQUhZeWlpakJuaXBxSXVyZTRpUjkzZ3dCbTRlaG9JbW95Unkvc3hkeVRWNmxMYUVaSkswOXZMRmZVb3U4aFNBRE5IVHJiOGlGYkh3SnM0TUNjQTNEUG9QWTFld0hZVVJTc0RJMXBNcG1iRjIyOEZWNVRuRmRjMEJUWGdONWtuZW5IQjMzdnNwcWJreTBsUHd2ZFNZcVAwQnZZTHBObnlSTXJRU2l1R2o0Uk5ZOXZXdUZFRUc1SXJZTWJ0ZmJsazJjTk1mdU5yaXlQNGpvdldEbGpYcVBWYXpSNWdGVjZTengxcU12VVREOS9ScmdZSy9STlMzL2JFR3VKWENwSzFXSk9meHllQ1daVGk2blYxRjdxS2VvVjZoUHFGRkFBSzI3VFN0QU14b0UxNEdxeUM1MXh6b0dad3lEVUp5UlFiNDdyWWNpa2g1eXdweDRUOXRWQU5PWXpSbzBWTUVaOFN4dWpNWE0wUVJ0elFhd0NHS09oU0RRUkx5a0UzbHdjaVVYOUpmMUNmWC9FN0dQRXVSakg0dW1RMSt3TmVZT0NOQVZQczhXUm1LRGFXbXcybW95Y2cvaUw5MGtDVVNMSjhuS2k5Mk44MVpKb3hBbUVrOUVjSlZCTUdUYTdCdUE3QjBtR09TSHUvQXI3NkpnZEpjOGZGelo1aWJka0g3NE1lUVhpU0R0ajVVWHlRdVJPMFhOM3dWY3hwVE5Eb2ttUmNOMExiM3BlaFhSbUpvL3orc2lXRDlrTk1BaWJrd25DR0NlSWNEVVlJdTBVL0FXK3o1VGtUYk9mdldMRWlDdU96TGtwdVdueWxEdlhUWnl3ZnYyRWlaTTJUcG04S1huVG5DTWs3OW5aTjhHWm5JNmpuUXdya2JDMGhHR2xrS1lKS0lyd0J3RWU3R2RNSmw1dk11bDVjRmNsMndTMm1qQjl3K3RQbS8xbXMzOHIwWmtrNWNpZU8yQ2dVQW1DMDBkY1RtdVdSdTIyYUZ3dWo4dnBjUjF3T25VMjRtakVvWG0wVUcyMm1nMUtrOGZtS2xSWjNGYUR5dXB4ZWpaS1ZTcStxTWpsY0JRYVp6cURJWmZIcE5ZYnZkeE0veWF6MHVWeXlxVXltVDdrY2ZKcXZVNXZOdXQ1cmRyZzhCeDF1VFIyWnlqa2RLaTNtSlZPSnlrbVhlOTBha3BESVlkVDNVWTBoaUdoU0NGRE01REVoQ2NrVHoxNzRBQmk3aCtObTJvMmFaYlI4MEVWcUJ3NUhSMUQ3MDZmRHZKQS9wcjU2QVgwd2p4U1lzNXNYS0x2T0UzckRDcVZRYU5Tb1RKSXkxbEFXa0hGNWdVdFZqMXZHWnZsRmdOV3Y1V2NuSUFSbmdLSzdVT1Vic2t6NEljWWpmTXNGb04yNnpDL2Z4ajVOVFpvRGVIcXNNSGlsVUJHcmxGWTFCYURod1IxYXJQT29yWnlwaXA3ZHJhOUtySTk3TTRLOFNhTlI1a1Z3dlZiZkl5RHdSVzFGaFd3QkMxS2kvYnF6S1ZXWjdLdmJsdzkySkJkbVcyZ3lSY2pMUUtGcHlCLzVKdERRWmNhTUo4TW5BcEUvL1RDWENESHN3SForYXVueGxMVHFIbDRKcmlNdW9xNldmQnlTQkJoQllmZkJpSEFFa040WGNZNVBKdVdJY2ZQRFNuQlVhaUljUzJNS2tHV25GYjBpV1VHQmRDcGdSS3lublAwUWtEd1JNOG55T2hMLzBCVTBMd2l0NHY5UW1vSXl2ek9TcDJ1eXVHWGZGM0xHMnBPalp3eGZNcVU1dnhLVjEwZHFNMU9PSTEybzlQaXpTN0xxL1FYQktTOHcxUmt6c2tiSEswRnBrQjJjVTFOUVc0d0hHNmVQYXM1aC9tcGJoOTZFZDJMREFoSlBMWmczd1B6ZHMyYnR3dkE2d1ozamgrOC9lMm5WaXhkdXVJcHNMVjlia3QxNmRRNkdmQzBKbjZXSmxwYkU5elBpVmI0VTlSamU5L3VWcFhNWE5JOENUMFdqSTRIcmY4SzV4bmtlclhXYU04TEpNSytiSzFLb2pRWjdIbmgycXJzMWtCZHBLZ2gyR3FZdVdObTZrbW9DWS9ic2VHYW9pQjhrZHgwbmhTTU9YRUMzU2NyN1N4dExrT1BYYU50S3l4QmoyMkIvalBLMHJhMlV1WjdmQ1RrdUw3LzIwRk1rYXN4SCtyQTlIZ1FjNlBEcVFuVVVlcHZlQVpuZ1F6NFFRMllSbEY4TkFRU1pETEc4MXJBSERPWGtPazNFaEJQUUR5eDBSQng2czc1UWtaZnlNZjVlTHpLUmMwSllGQXozaUNlRUVNY0p2VE5DVnpONk5ORmplTEYrbzI0ZEhoaE5BdHpQU2I3RXhHeUYrT0M4VXlpem1jTWtmL0NWRWpXWGlIRzlmTzRRZ2IrZVl6NGM1TWZKOWdnNGJxNHA1R0ZRc1JKVDVDSE5rZzRGM0JpRHA5MERmSW9FVUZFSjZTVnhBdG9JZEZNZG9VR1BDWkJjQk03TUVHOEt4QlJwWTFFaG0rS3UwRENLTW5rU1FSNVJEclBCV2hkcGptOHNSS2M2ZzJxR1FIN0lpRzBUbXpGK0h4WTE5eDA1L2J0b0dyNnMrRlJJN09CSjZkalJDNzZqQnpCNitQeitrejFrOHNtYjdadXRUWmQyblhKdk5HdGNJOUM1N0NFTE5teWRlMGp6MUtBYWU5NGF5SDY0UGp4UFRmZXlMNHI5cTFGMW9UMVBYNnhBVHJsY21BMjEyYVBsbGxMclgvM1BuSElldGg4YWxENG9LVTRkVTF1N3N1bWU5dkVicmd5Nm5va1lVWXZ1a3ZmTVRkK0ZvK2dPOEhZUk1reFk0WDdRYW1VZ2JveTl6MlZxWHlMeWFxdnMzZ0gxZDFjVkk0K3R4cHR1anFBbVZhenZxbjJwbUxNbC96MXI3dHZ2QkY5V1E5L21yVnVuZGRiSFBHV2hEZXU4UHVLaTMxZldXb3Z1OHhqRGVRR3JMSHdodVgrOHVFM1RseTkyWGE1ZGRpR0xUVmNqc2F0MUVuc2Z1ZkVxUXVuTDZISExFaGRQbng0Y1NMZWRzbnhTcytnc0xNS2ZPdXNEQzRvUk4rOGkvOHFLNEVHblFYZ3FhZFM3eHBjQmhVSHdZVE9UcUFaUDc2dkZHaktjTDNVTzU4a2hnOVB3QU5WVlFVRmhZWFRnWHFNV2FrRXNLcXF2QnlzenNOL0p2dzNkV3BlM21OZ0t5bVo2alNsLzhyTDBlVVZGZU5WczZZejByRVd5eGx6V0Niek91UDVIdU4wb0hHQmV5dzQ3bkhGWkQ2TlNjNU5BeHJnVEYySzcxcUs3d3J2UmQ4QVRlclNNZVZXclp3TCtrTTVaVmF0REVnQzZwbStjcXRLQ1ZoRndFVVNEWXdFMXFOdlgzKzlzbkxMVlJWNGRwWHJuSHd3L0NmOE5ha2pSOGo0VlBTUFR3WG11bng0WEk2a0xxRzJVUHVvQjZuRDFCL1MzcWpTKzBTNFMvczR3aEVReEllQjZRTG9DRWRMQ09ZSTBXY1RwR1FzSHhlU0IxaHY0ek11UVFuRk5TQWtRSldRM21zV014TGdOMS9KSU5iZ1l5VkNlVTZBTzBrUTAzRHhBVTBYenNQdzAyakE2WXNFSEFGYWg1bFZIVlRvVFRZTG1CTDFPLzBrOWZROXJkVTlQS3dEVWttTEFlcUJVcTgxMFdPbWdWZzJTVkhUOXNZaE13ZVZPeXIxakdvUUQ1NlhzcTBLYmw0ZXF4dkdTa1A1b0VPRm85UlpzSzYxZXA5QnVFaUhrdm5sUld5RHlFWHdla0F1OG9HcVdTRVVyZWZocWFGc0RwNUpvSUlQKzdrbDU5SFZ5d1BGV1k1QTFMTXl4d1htS3hqanZmNklFTjllRWVQUkhJbWN2MFFxcCtIVXZ3RldJdmVFRnd5dGFMSVlsREl0TU1wbDhyMjd0RElXTHRuTWRFdFZjdEJkbXE2aXV2U1hWWUNXMFlLRFFLMUFYWkNWOFlEM21mRHR6T0NqODVaaXNzZlN2eFpycUFnMUJLL0VFNmdGMUtYVTFkUXQ0anFNRjFSQy9iSyt1TEFLQyt0dWV0bmwwb2pjaEpZTkNzdHVJZzRTdnBpR2pxYk5LRVdGTGxaWWdQSGtxNHNTWEVsZVdNRUZLOWRRR2sweWNZNkJGeklrNmZvQytSc01SWCtCeVNtcE12SWVzOTdwS0FOUFhDS0pSRTk5VWQvb3p3cVcxK3NiT2xvTGl1b2FRdTRpWjRkYlA2UnJSRkVVTTF0ZEcvUUZ1dXE4NE5Dc3dpeGxEcmhTbzhvcWxNczM3YktWYWd0MzdZS1g1SWNIMThha20zZjVzMFpHcTFCZVFYMUJRVDM5Y0ZGa2N0ZWltc1M4bVJYYXNzRzVCalA3TXp5ZlMxbzFLT0NUblhDTm1mWnBSWjFWWlZMYlBOMVp3VkJUZVoxRmJkYTZyZnJGMllGczRGdTAxYmhFT3Z0L1J2bGRpdVZjNUNYcjFYU1dxeFJsZzRnYlBRVCs4dUhxc3BMU3d0UWE2MjVGYVIxNGtkeTVFSDIrdUtaMjg1SmtaU0k4MjgzemhXcjR5SGtmanFiVW1DZitWa0lKNDV3Z0srbk5wSUhJZm5DSWpaUUlZNW1zTXNCRVlFb0lHbHVjK0tlcVpvZ2JpY3ptRTE2OHpFVFZYbUtxK3JLbEJOWHVlbmNuQUpSV1d6RTZhellUbFFMNXp3L0w3ZEpST1BBMEgra1lWeFg2N0RscGFYdXBkTzF6TVhBSHpvRUgwZDVYUzFybTdkbzU3NkdzMFJWYTdkRFprbHE1WFhicVBpbVVkK0VDdDJkNWN5YmVjTiszVis4QnJJTTNFUDE2QTYvZk1Bbk14d1ZFZTdaejcySENkRVFiMlJYcWYvaW9ES1JkTTJwQi85c2xQRUU2b1NmV0E3LzZZb3o0S2tOVFA5RUxjeDdmTXVtbXppS21OL09pTytFUEI2b1dWWUdHVWIvNm9nK25YdzU4RG44ZXQ2eG0yb0lvU3FKYThjVTNQQU8wVTlGZTVwNnUzL3JpL1JqSGJMSmZ6cFVnbWtQRWQ2RXdoZXBFdEtkZml3TVBIaG9lQ2NkbS9BcUtBOFNYOFFHUkVQZHgzTVRUQzZRdUR0TTBNSnc2QVhxTE9EbDZRYzdSaS9UcUx0R0JneUJ3QkxFbVRWc1kxSWJiTkUwZ3B0YjNRRUdVa3hLcS9vY3cvZTlsTWdobE8zRzRyMlhrcW1VajZhZUUyOXdkS0NrSjNLMGZnR1djSjJnNkVsMEVBamxFaVpBdXRKTlFUdDZxZ2RwU0diRWEvRTg2S015Nm9VdFhsYjJKdmdUYTE3MGpaM2VVYXBkck53MjU1cEVudHpkZUk1T3NrTWo3ZmsxSEJSeGRHR25MeGVQbXJkZUJWbWJQSHBLL1VLdHR5aTErY3NmdWw0cHltamlaak03OU5TMldnWEo0TmZIVEtyd0QyY1FRYlBOWm9temlGV2UyOU5hdlhrQ2JyQkU5Y1pwTmVNVWtaWEduMWxJZXIvQ3VaSTRrY0JvQ251SUF1SEtLZm1QKzVKclYwNnJtVCszcUdRMUxtdGRjTTB6Q2MxTUtIV3pKdnNtM1A3TDViMXZHWGhHRUNpQmpsN05TRnE1a3JWbU84bkgxUldnL2VqK2pDWC95RVlWTm1pMEZVRDdyekJiQmo1L2dudytNQS9mQVV3dFdWeTA0TUxWNzlaWlhkSXNPVG90Q0VQTkU2c2Y5N3NGYmdmeVd3YlY4cVVTcFlCV3BteTJXa0EzSVFsWEwyekQxUHpIVFJOZkpvS0pZcVZUSlJuYVNTNEpTNERpNkdvM3IxOXNTOXZWOFpFK1BNbW1KVFpCQkE0ZzhuM2dFWVVNODhZcVpGdG9UZnhjeUVBSkdTZU9SeVIvUGtjdi9LTGZKNTZidUNzUmVQMHZWSmdOd3dsd3hiYzVIay9wZWdyVzlxVjRKZFFUOU5PbWpPVGp4ajNLaGJMSVdVSy9IaExKQzJweVBKNSt1RmNyMnB2WElrQ0NIekU3NzZPQ296RjQ3aUF1T0cweVVqMmphRWwza1JEVWpHZDQwTng4ZDJqSjExYnJISjhKMUZYMVBoN2FPQkF6NjRTOXJubHRhempXV1ZtdXkxZGE2NWxsekpOU2twcHB4cWF2WFREaThQamtLTnNUUC9OaXl3RFQ0VCtqN1NYZThzWnlOaEx5Qitra1ZmczE1OHREOGZqUTlBYUU2SW1Cb2loQ1hNQ3JFSU9rMmdwZktOR0N4Qy9KR29vTXBZc2R5QW9UWHhTT0VreUdhWnA3K2Z5SkhJMnBUTWJGek1zVmZSampxRkpYZkhuUzRjbjJXc01uazlMY1g1TGY3WFVaenlPTExkVG1DN1oxaXBsZUk1S2ZMNUJlMCs1MG1VNWlVK1dVVklSZlg2VzZ2Slg0UnhIKzE3ZDFucUNHbHNXRzh3K3ZnZzUzd1AwYVNSS2pqc0Z2c0pyV1d0OW9jVHF1VjE2cE5PTUVocEFvaFVOc3I1anBzWXU0RkJXMVd1Nm0zdlJ2MG90ck1yNXZXdG80Y0ZuUG1XYkxjNWNFYlcvNWpSQnp6Z3J5S0pYUzR4MGk4UUdDMkhmK2sxTThVbmc0QWRTb0plbUV0RHA1T01sUmZFdUsrbCtydDk0M1NLNnlEV3J3U1VwajhGN3crNFZrdHludUlIeEQ4L1JrOVRVSHZQUFRKcmUrSTg4MDd6OURzeWdYN1U5UTdlTjZCbDZjK1hMQXlNd3VscUZ2UkovUGdIVFNGSjdqem5zMmRlVGF5WkpDUlJvWmJTQmhoeFBpT0xCbkM4M0pVU0xzcXRSVVBsRTlSVnk4Y1NnTGc3VlZhblJFOHB0YUw3M0FDdFJwMVFxbE1JYkZNU0ovMnQ4UlJ6RmlxaTFDU0JMZVlFWFdHSlNIaVhia2Z0RVMwRWNGckZ4VFZvWWtURkJGdFd5S0F1aElwcDg4RnpWd3dKQkNTckZJdWQ1WDRBMkRRc1owVmM5dGFJbVd1WWtWV3hiaVZIVjBQenZyVHJZK01LTFdQMGpqQkpuVDJoaCt1R0h2OUszUEhYamQ3YkhsRlRybXQ2OG9SUzRNMUhXUEhOWmNxNkljV3RZMHVBa3FUaTlsZ2M1aWJpNXZvV29uUG1XMVh5U2Q4cytQM2dmaVU5dlhETDNlTW1Ec3V2T2pScnA2dnB0VEU5bmo5WU05dEFPeVkrOXJ1aWNIcWFUTXVYN29qL3VyVTlwektMTGM1djJKdWsxWjN5WDZHTnVjbzdQbnM5R0lqTU5hZnR4YU1GV1QyUlBjd1ZKTFp2dktaTUNrZEV2RklEQUx5TFY3NFRJTGlLa3ZheUd3VTUvNUVQM1N4TU15NTZFVnc2dmQ4NXZPSFpRd3M5c2Qxd01CUENzazlnNkx0YTZGMjZneG5PR0lISXl1bU5wbkxRb09HSjBmT2ZHSWV6VXg2Y09IVGt3eUt5cHdsNDVmdTJUK24rOUlDcWMrVTdVK1V0dVRNM3pQblBEOEdKeCtvbDZzQ0RxaFNRSCtoUnVNZkhKYzdEVXZiT1czWE9LZFU0OGkyc2VWTjF4WHVuTFZpU0hIM1V6UEFnaWNXWDJLM0xHd2Y4dUN5dWZmTVgyR2NVajZockRGa3Z4cCtjcjdCQTUyVzhZb1lvbEhxZk0rN2ZyS3g3eUVxVEp3SFIvVmFQSU1SUXdjdDdpVWVQQTB5eWJRZXEzaWlCYTFZdEc3RjFWZXZBQnZuUEh2Vk8yUnRTMUdaVlk0bUlXZzVWeUZ6NmtUZm96ZlE5NTBqcmdKM1gwQWZETEFucEFTMGZNb0N4THZEOU5NQXBsK3RIN08rL2ZlWjFYOXY1dEh6N2doUSt0SVpHdUw2OHg1R21QK0ppZ2MrRWV0TEM2YU9DQ29YL3M0MVJCUWkwWkt4RVlwaU1oOTRPSk9aRVVENWllMkI0QStPMEExWmVBckpJajdLRWlHeWpKSitnMU1JenlhNHA0M2kwUjlLaHdqZ1dqUUNUNk9Yd3o3TGtib2htNDhjMmJ6MDRUdWYxcGVCeFNBTFpVMmZhMlRaSTVzcnF4N1V5RTBhbzAvLzRLUWpRQW9xMFNtMEhaMGEzbFNIOXVrOUw1bjc3am1NVGdIdThKS1pWd3FxbFNBSkhodjlvYWdZNlRFQXhZU1poMEd5S2V1TSt3ajYrY2oxWDQydXVSRWtOOC9lK1NLUUhyR2dQbk9KV3VFRXpKU05tNDhBNGJyNFNsTWZxSm1HY20zNzN3Y2NXQUs0eEpQQmttQ1NpT1lkcUR0dm9GMDFKL1NjWElLblIxMGdUK1l6WUZTMFJKQUZ3L1A4Q1BzdXhMZlNsUkRKSnpFWE0vTVorVEFqeW02ZFExaWZ1VytlMmNjT1lZTXVKdWdLL3ROaFNDVU5Eb2NCSmczZ0lDbWNvdkFoYVowdGV3VFl3UmhnZjBRMjF3d1VBK1MvVUFtU1pxZlRqSkt1Z2dKNFNkamhDRHRTRTFKM0pXUERoc1dTNGhGTzZGNEVYbTViWGxtNXZBMlZ6eExXaFN0dzMvc1pyd3NGQkZ1QUVvZTg4TzB3RHkzaVdFVTlCQVZLTUNQd2lJSXNqNGtoa2pGQUdBTlJpUkwzZ1pBNGYxUUFnZUQwRStnZ1BKZXdUMGI4cVhwL0pPS0h6L21CMU55WFE4TDBOZVBRZXc4OGdvNDlaS2IvVEJMNkxoMEhRZzlzL3ZiQk9XQnB4TDlKdCtsOTlOYmRQNkw1MDU4bHVadHhIQlRmOHdQWU9mMklQd0wvM2hTTk5rWEhqQmtWOGZrajE5N3pFSHIza1V4NDlrUGZnTTIreU9qUmQ2TzNQdGdFNU1jamZpRUdpai9ZaEg0OEhpRjJGWXF6RlBORCt0dmFjZjlmSm1DSzAyWjlEUE9HZ3ExMEFYNDFncVZrSmhCN0VscHdUazJFVjJSZGtkQnBrVlpjVjBLc1VmemlSb1dMU1VRRStDUVJraHlQRXlOT0RvWWt2clRyTlV6a21kSUxqN0JkY2M1UVdGUVY1MDNtYWxZUUc5SkVTUnlLYVA2UVByeGsyVjNCTW5TTml3NTRsVGsrOU9ZK1haYW1jdFd3SXQ0d2ZQWm1yOXFjcFFxVzFUc04wZHVzRmFkdS9mc3RlL0IzS2tWL1dCcFFLbk1ieDQ3cmNHbzVpMWJET0JxcnNtckhCMmptU3BuVUEwZkVPKzcxbEVoYlM1WE9oNXk1OFNXakp6dFdWem16Nyt4bzIvUzhCRW9Lc2h1cWh3Y0dkK3lyR2g1VVQ3NnZiOCtpN3Azdk1aZWpwNHpnaFliU3Z1NTJhWTRWY2h5OVpSb2FMMmZCbFBkOWZULzREMXhqVTF2YXN0cW4xY2JScmRrMTErKy83MTRBYzR0YTlNVXhCZXZ5bGpoNGhvRTg3M2ZZVEphQ0t3YTVsN3FVU2lnL0NqbDFiT2plRVY1UHJYS09UdW45Y0h4aTVscGJzNnQ2dFFZY25kcytNL1dNVHFKZGY4bjFNNGRNRzdvQU5XbXFKMCtxM1lYNm5yc2twd3lvenZuN0krdWZqWW9MT1BFVWlBNWN6SHpwMVk4c2RJSC9tQk1Qa00wbkdBcDZzZ2lJdlBBRmlYOFBFK1BKSW1EdjFZREhOQ3l0ZTB0OTc4WTdEajk5elkzM3FGNW5xNkpsTlhKYlBEUUYvdm1vK3A1TStodE1kWVNreDBMRkNiRFFuUy9ST09DWTFLMnBhMGV6VnAwazMrWEtsK2pOa2p5d0ZmQncybGpXb21NTFhMMC9VMUI3MitQL2V2WDV6eC9zcVcxYXRheG9TSVAvNmdzVFdwNTQ2OVVxcVZJUGEyb1lqVXBhK2NvN2I3OVNKVldyV1U5V0hhTld5eXBmcGw4L1RhYXR6THJDZHVGMmNWSVZvc1pqR2lBOU9NQ2pvekRTQlkvRGFwQlo3RE9lSGVPWkNIMUM4QzNaMDQyK0ZnS1lZWDk3NjhrdElMbmw1RlpVUk9JNEVXaTdlNFFBZlIzU0NtVys3dTQ1a3lRaEZyUGxXMDcrSCthK083Q0pJL3QvWjR0V3ZSZGJsbVhKc2lSWHVjaVNiSU5sMlpoaWJNQ1lacnJwcHB0T2dJRG9KRUJDVDRCQXVCQlNDQ25rbTk0d3VVdENDaHpKUVE0U2tqaTVOTzZTWEw2NVN3NXNhZmpOekVxMmJMamNmZS83L2VNSDF1N3M3T3pzek96TW16ZHYzdnM4VUJQWmdaN1NLaGxoRVU4ZGFXRmFCQnNRTnNFR0pFZzBlS2llMnJHY2dGWE54d0dyVVZ6ODFxMnVuTDVPUlIxeUw0YTMzb09qU1V0SmVpZkpZa0dIRkdpczlHMnN0bGlxMS9rcURRSEV1azlJc2hqOFJrdlNKTVRkQnd6MG9Db2Z2T2FyUXNHMGlsTytxdFZibWpyT04yM1owc1FXTkcyaG4xdUljOEVIMk82ckxDNnU5TFVialYvanVLODd6MHNQK0NvcmZYQzZ3ZkJNZGlWOXFPdnBMWW0rQzJrME5XTXRRbnNLc09QL2twdnNDbmZEajNaZkJRSDRDaHdBWHdFQnNJYWVkWHhwSkxUMCtQR2xUT3ZTNCtCMTJoMjVCM0gvRkNpakgrcUtQNDY3ZzZrVGozRVFOWUthUkRWVGM2bUYxSEswQ3R4QTNVSHRwUFpSOTFGSHFBZXBoNm5qMUpQVUM5VEwxR3ZVYWVwZEFldVlJUmFoVEd3WDFDN0NQNEd1TWNUZ2xoSFFEM1RGT0VvWG8yMTJQLzRKc0JNNmdxT0xqcWhpRG9EdUFCSnJDbWpjSWg3WVRVNlVKNFlCNVIwQkJwaEFRR2NIZnM2TFZqZ21JMk1QQUJYdytuaWpSbzhmTW1rQ0doUElCN3dtNEJZNUhaekpJS0dkYmczSGU0RkpsMCtqWHNPNDNCTGF4K2djT3NCWEFPS09UZ1pNZmpGbDFwOWxrdlduR1h0U3NocTJhSW8xY0lIR2JFcG5UK3VUbVhQNjVCVDlXeUQ5ZlRiZFpOYUNiV3EvR3R5bHhYZC9iN0x4TCt1U0kyNndFUjYvR3g0SHpkcnN5RmhBbjFlOThySkNUVDhDVjcxR1o4TnYxYm4wazRBTmFhekdDTHhVQVphcEsrRUlNRWdjYWVIQVNMaVZSYU5rVndpK2UrajAwVWRZSUg3TXVoOWtmZllaZS9hVWlGbW1qdTYrQ1ArSXZtZG1kT1VXOEhYMkNPRDhZUU1Eak9KTG5CaldBbitrOVNqNng1WVhyTXY4UGMwOHRuWVFSNjgxcExId1BvbEVqMDVQaXNXbWRLMWVyN2NuaWVWZ0NKdW1sMGpBVkM1Tmo5S0FSc0NDREJXWUxSVW4yUTNvbnoxSkpJY0hnTjJvVU1KWDJMVElXVEFaSGxZekZsWWk1ZUM5b3JmQTJOZkZOR2c5YzBiZE1WekVWUStaQ2FUd2JBanVzQUEvZkpSVm9kUW5SUnhZWGdVcUgvcmsxWk5peGdkb29GYWNCQW9aZlBzUUtQdnVVekc4TnZCdFd0NzJlUTU4QTU0R1h0VjIrT1VudVdCTEI0MGF3b0RhQ3l3SExDeUVMNEpmUG9OZlIrNkFYNEdVUC8ycEg1Z3BaZEZuem96ZTE4QUk4aEtDLzQ4eDd5alMvVHNIQS9yV0NZcDR6NitudndaTno2K1AvSDM5OCt6NXAwSWVhUEdFS3ZPWXh2V253UFQycWcydnZiWWg0eG53S01Zd2gzcFBINEhlckVmajdYWktTang3WTNrTVN6R1ljVUY4QzRmWVhuU0JGcGxBU3ptRkN3NGp4Zm1wZ0lnM01nL0IzOEwwWmZxem9PbDhBNWc2dmo5Y0dYMWovdmhnQysySFJ4ZlJHakFsVXdtdndOQ3lHY3p2VHoreCtlQmNNUEE5UTMwbE4rczJtQXBQang1MUhrdzZlMmZsbUFYUjAzRGxnREZnSFYzVzBSdE1wZlZMeDgxWURvUHdZNlcrcUhLNDZTeW9uWGZ2aGlkanRFRk1zZjhndXIrWWt1c0VMejlraHlRSDZQeUl6Zlo3YlZpNWs0bkhNM2loaXhnWndUa2RUN3hEbWZ3bWZ0ckI5YXZQblA1aXo1NHZUcDhKcitJT3RnSDY2b0VEVndFTi8zdnR1VU9ySG51amJkKyt0amNlV3pYenRxZkd2SFBpeEUrQlAreTU5OU9uaml4YzlmNlM5NCtkZUlkZDNpRXVIYnRuejloUzl0cWFXYk02SGlxdFpLS0R0MjhmSEdGeWNoMXo1cVF6VzlsN0RsWkZobm1McHMvbUJENzZHSnFieDNiYVc0ejduOHVoYjdydUFsaE5RRm9odE1VS3VDdFcvWGk5bFJ6Z2wxYjlOQnhHQjNqbDFtRnV5M2NQZFdRODlOM3FtZExmTEpnK09BOWt2N28zc2x1NStjUXgraE9EMVdxSU9uQkNXb2VQMGUveEVUeU9qM0FZQ2M4aTRYM28rTkJEMzMzMzBPSTNpdExkQzM3VDUvay83NDdzclNxeGYweGhiVW5xUmxBazJNNElmdG9NeEZPYm5maHF5Nk1LS1I5VlNwVlRsVlJmcWdiUjVhR0lNbytteGlQcVBJT2FUYzJuRmxITHFKV0lRbTlFRkhvN290RjdxZjNVTWVvaUdoRlk5T01rUjUvZGdLM1hURDEvQVJPZitNTXVpUkovQU9PQy9jb1AzL2NhQXYva3JnbnJzeGo0Vy95Y2NRNkxnTjlZYWIrZ2p1Ym8xS2NESXBlQTlXODBlUU1lRVJaZWk2akl0YWlZdTYvOURMMlhQdHArWnFnei9xOUNOVk9WaG41V2NtNVdEWm1wbXJrYy9XNkxuU09WQzRGK0VUQXNBdnFGNUM4VzduakJ1ZWlCbnZFL0RsN1VtYkV6dW1YdEN5K3NYZmY4OC9DeXUzZDFiM2ZMSkRPVDFtZGlhcURFRWFnZkVzaktOS1RYcUJBM25pR3hLczFHZVdyQVp4ZFI3VHZnRTZDaGtqa2NtUXcvNGpMZmZodCt1R2pSbm9TL3U5UHo3Y3AwVHpyK0tleWU5SFNQUFgrQ0o5MkRmK1B6MHozcyt4azkvc0VUUXhaMWoxazBKS05ibnVqUDhmdzZvYlRnOW93c0NRZDBoa0p2UmJiVW1Kdm15ZWVCVEc5SUVobE5aVURGeUJnUkxUWGx4ZjBMTEVMamJ6dkJlOGp1c1lhOWxYRmV6STBzWmpRbTN0OTIrSEFiQXcrMzNYOS9HMmlyeUx0MkthK2lJZzg4bVJ1aWZ3cmxnaWZ6S3NBV2ZPOHdUdGl5NERCYjB2NUtia1ZGTGxlTmo3LzVEVHJHK05CTVJMOHVvL01ZUkwyNE9Od1IzN1UvVHdUTkdCK1FGYnhFVUlrUVNUSE5BWit3eVJGWFpSY2U4SFA3QUx2bmc0OE9qeml3WW1IempJWEw3eDEyNExmbjc1OTZhUVJuczRpVmh0N1Q0TTlyTm42K0dhU2NXMzd4OE02Tm00Nk5tYjV4N1VUckRJMCtUZlBIKzh0bWx4ZUpWWWJrWGs5Tk9BWFpVdWJGOTk3WWRlajl3TGpsR3pZdUh4ZDRmditobDJyTDJWU2RRWm5rYTV5eitNTk5aNEY2MU5hSEg5azZhdVcwaVdHblZhOGRyTC8vdkRQWGFWRHBVdnJVZEx6bVRGWEZlRm5zZnh6YkV1UmdqQ2lpd2tCOFVxWUNvaXJXQ3hDUUVZeEZFc2V5WjJObkhmR3dRUHdLb0k4UUozVkJFR0RpTWhVcmk1ZmhMSGJRaTZVV3hJY3ZDVVMvRm5USUJWWHlkMjNKSGQ4Qm5rdGk3c1ZKSXBUWlpYVFNKOThUeENicVpKV001UUY3MHV4aXV1ZUNBOUZFeFhLbUZWSkpUbVlGbjVva1ZSZGdqRDZ6MGx2Tk1nRVVWR2pUakU3ZTFZVnJqK3N0Nk9NUEUzcWJLcTVHVHp5Z21ZQ3hLQUQrMHpwemxLdFl0eHU5ZGpkaU1uV0F3dERZVkhUM2YxeHIzUzdneERmZ3g3dDBLT2NibEE3bmwvNC9yN3ZnUjBQZzM3RTNUam14TlVPM2RCTEc3dGJaSmJUZGFXY0lRKzhVdHN5Slp3K01VMkF2dWtEUGh4ZkFWVEErMnUrTzkyQTdiR09pS09iVnlPdjA4ZmZnRC9SOE1BYTJ3WFl3R29TVnREb1MwcFpwSXlFMXJRUmhyWjBOMnhrcU9vUGVINGt3TFBHM0VmbUczazhDSUR3ZFV0cDhUWVRTNjFsS2s2K2xLV3pIaVNySmY0L21vaHJxSHNUcFV4d1d5L051QWtYOTY0ZUFZQno3VHcvT3hFUWFCbStiYTd6WXphZ0JRNEJpSHcyTXBpdjF2M29sTURnNUg1NW1lQjM2eU9FeHc0WnAvZHBodzFENG54NXdvbCs3UDZ3OUx5RlY2QU9OM25veUxHd0RoVTlhOVpvUGRJazUvZXJyUUFoZ0V4K0krb3VRb2U2Zi9YN2w3bTM0YmtPRFR0Y1FBazVRWmk2WGxvRWNiQndPTDVaSnk4M3dUZml4RnQxcytOVk1XTE1BdVJrZmYxemNsMHNmYWlsRjJYV29KWFVxQUdKT0lOTmp2aUFGTjQ0UzdJQWFhMmN4S0NBV0RLTTd4eDRUY0hzeG9SV0lMY1puTVJZUmtCWkFnRnlOdkplM01uU29xUWszUkxnSlVEUXRIZGx2RW0vaEovVWJLU1Y2dWpMMHg4ZzVoVXlqTlNreVBEcXBRaWFYS2FRNlQ0YkNwTlhJRkp5Y2taRlU0SUZkdDBYMjNiWkxrdW9aNmh2em9aRisvUU5OM3d4YnJuVk83em5XWEZ0R1g4MEhyL01wSHpaVWpNNVdnOVp3Q0p0SWhjSjBFVXVMZFRTdEU5T3NWc0x3UEdzWG04VjZYczZ5eVk3MDVPUjBSekxMeW5rOWlyU3pQTTlJSWtkdnUvUE8yOG9YM2pGdmt2bEtLQ1RYWjVhVVpnZDNaRHVEUVdmMmptQjJhVW5tMENHZjI5Y2N1VHUyYnhCRnRLd09jYXd0Mk5wRlNXT3JDaGZaS0NFaVVFZUM0TnZWYVJOdXBVMTJMNWFFQnNoZU8rN3VNYUVFWXRWTmVLOEpjYkFCdStBaW5ZamJNNEgvSmhtN09DcXZYdmZ5ak45OHI1WVBHZEsvYVo0ejVRYlZ0MU1NWGxlWHRQSlpZZzRXSHJ4cFNtNHFUUzBhOGFuVnhiR3VwS2hkMzIraExtVWF2dmxmaTlidnVQdWRheGNXUFdXQ2J6cjBXczN1L053TnI3ekNoWUg0bGU0eWQvRDNHYWUyMVBHeUw0L01mNnYvN1BvdjE2VzQ0NUx4bEx4NWlOU2xGS1VhdzNsV2s5VXljNkVPdmRic09sR1JZcjRjN2RnNVA4MldobFowV1BEK1NrOXhlOHkvRVJmbTJoQ1BPd1RQaEhhOWtyWjVhQUZQdzRpVmJKUXNiMld4SjNRQ3JFRk1HQmxCVnBXb2NkS3BseGViTWJqd3lyTS93L2FmejY2c1dyeTh2em1YNWRMTVpVMmxtU3JBRkV4ZWQrckNxWFdUQ3hpZ3lpeHRLak9uY1d5dXVmL3l4VlV3N0RLSEJCTW4xSHExUGhEMjFUWVJYMWNWMDhyVDBzcW5WUlFPOFR2a0tDdVVvVFFseWFSbVpXa09xMTV2elVpVHM4b2tVNG9VNVlUeWt6djhRNWdoRURzVUN3djdFZmpucTYwRmp3ZytzZWhPbnpVcFJIdktqaUg4QkF4THR4MTkveFFnK0hMUm1Zd0F6WGtZbUZiRXk5Q01nSGNUN0RHTVNOb1VaTEFBblFLRm5KUmxvanUxeGRyb0RrNE5GaGdkWEwvWFJPbEdRN3BvVjRtV2RzK0FkODhYTzNSNXNyVy9Femx5MDduRmNQUU0yQlpjTzc4K0k2TisvdHBnRzZRcGtZUmhvNDlvdGZRWVdwdGlBTW5SYVhxeldRKythbkdBRXpzUGZxTFIwMXdXYktDZjBKdFRETERnNE00cjEzSnFRaGtab1pxY2E1aUhvMjlRYkppTEVOc2FDdWdwWHVPTjkrcE9RVjBuM3E3R0EyamlmWmJWWnVDOUl2Ump3L0R5NWJZdTBCZ2h1Tzl2YStXeXJaOXZQQTZ5bjRoUVFvL0RlejlNNnlmd1JkU1hFcElLNmtTcytnbWdQYmpwNjEwcTNTNzRaNjJ3bTRPZlN0d0h4YmFBM1gxQ0VtL0lkTHFISmh2QUpoQUR3dkVLWmFQVVhLdlpSVjRBMTYwZWUvRGlueThlSEl0T1M5NjlENnlHSFVSWU9TTmVOSGlkUTE4YkNtcExJcmoydm5lWENLbnhRNnZCYXBKTmU3aXJMcDI2S0N5bXplV0M3WnpXZ0pyUThDdE42SE5SUk9NTVVSeXNzbVBGVklOUUVsNFVMelFUM0hrU05hcUEyRUJlS3dRdnc4c25keDZyRU9rMGZRM2kzTmJ2V25QRnFlVWFuYWdpK21CWEpkamZEWUIvZVJpMzhvYUVSMGx3UXhMby84bkR3RENnNmFRNlJUOXIzYnBaK2hUMXlZNHJDVlVpL1lITU5WWFVRTHpuSEZONGoxY0RnOGY5aS9yaEx1S25NQkZ3NHZFZHJ4UkxZWnY1K05kWWZhdjY3ZjNiT3JrYTJONWRlcVdSdXJGSnFZMXVUdmcycUxPZ3IwTzZ6S1liaDkrK2RRVlJKOUljZkEva21KUlYvYUJXMmRHVStMWG9UdHZTMlJnOTVEK3BHLzUyQVRmZkNUbHM2Q1p0ajA4R2dVNmtZcit0ZXlOdy83b1IwRWRlWFR4TllwWVdTSUZrNW54eUJ4RWhHNzY1Y2RiSTJJMHhwWWZCcnNQL1lTdmhidkQyWWQ5OEtSRG5pbE9raTFvMmtUNGZMOWZzQ2JFYlUwcFdyNzZwRmJIc2g4YjZUbHlVS3FHQ1ZDM1ZRSFptakxUb1ZxVEQvaytJQ080aGFOWTBVbWlTZEl2VVRCRmhTRnhrNGdVYUxKUFRnQ0lVUnZNbllVdEVVTDcyYi9zU0tBYWtlcEFiRFhDZlBmZllZK2ZPQW5ka04ySmRXaGZOT0hCZ3hpSXlzOUxYNzFpMjdBNDY5Q0t1eFl2a0J2UFhnL0NISjlUZFNOSE5CT2tjeU5NWkZpMHk2T0Fmb3Urc0IzUFdyNGQ3NEMrbHg3NW9lN2hVYUhMRWtMT3FJVU5VTUFKaXRLSDA0Yll2anBWaXZnM2NFUEc0di9XajZxa0oxSnhiOVRuRVBvc29YcFRoOWpBQlllcDBkdXBoZHUrY3B0aUFBc1dFVVRFRmdWTnZOS0ZXb3dKNHR3dlJSUW9iRnBKT2JBV2liajJ0cnNLWUJuOTYvZ040dE0rUzg3dnJ4Wkk3djlpODlPUFJwUDhrcHV1Vi90d3VFZ2twOW9HUDBGOGsvT2t4QmlqZjlYMnlHVFVrMDRvYUVFWEFuMUFFMjVUWTF5YitFSDRPUnN5cEg1MFN6VGo2NmJMTmY5NnJFc1pnS0RIVndJbVNSU2dPSHRHN2t0c2ZKb2RISXFaVTZ3ZWd3cmw4Rjd3ZTRSRVhoR0lzYVIvQTB5Z0d0YUVvdHE4eEVMWGhPS3I1VjlvUTlabC9pekFSZHlOQ1U1SytSMWk5Z0V1TmUxOW5uMU9qTGhmdTBZUTIrSTluUDN0cHlkYWJ4dXpCNjdlYmtvSGlwYmFYZGozeGRteFVVbUVNRllDcXMyVGFnUVBUbHJ6SWxBcWRqMXgySDZlbzdaNkJrWlQwVllOVk53OVd6WXNnL1lHWGdTbzFmZFVrTWhxL2lYVkRNQjkzdjlLSFFldkRwWkhPcmdkREQ1ZDIweDNxUlpEakUrZE12bE5aa3U4K2V3YTZOQ2IvNlR4NmNadEU0a0ZFYU52Zzd2UHA0Qk5DL0ltTHZ6NnZmcmhOYWtZSkpkdUhkSjlmQjU4UTRrOWMvQ2Z6TEgyREpmTnNLZkhuYUtRTWVwb2wyN3BhZjhEWDlaRjVBZFJKcUVhOG5sM2RnbzdWaHc1ZkJ1NG40SWZITjM2K1ZZWXBDOW44UERKT0tNUTdhQzM0amxDZmNjS042MTIxWVZZbHdSYy9lUmorZVpkT3RldnJUUWVCOWdtMThObU9qUk9lZVZ1bmUxdklhTnd4Y3FNajNIMGVRaXM2UHN5dWp0ZUZvS0FMcFU0Z2x5SUs2L0VKM0piUjVQWEZOMEh0Y1RDcStMZmg1K3AwOENOSmlpUlBLbjBSZmhTajhmK2tqTUQxb2xTYWh4SjNoTHFxUk05RkZZWWZDVGRlRktnZ21vZWVBTm1kN1NORXZpaThKZkw5VGZNcStUWllQaVR3a0oxQWNCUmVFU0NXdDVNTndPd2lLUWw2UWV6alIvbUUxaVVNWXZRK29oTStGYzlVc1Y0U2ZiZkhPeEdCRGJNWVR4aUR0OGVZVWFxek8yTXRMd3BlNytRak4zZjFWblFDQ1hNbTdldUtSeWNxQVljdEk4SFhwc1lid0lxdjNnQlJKY1FBdzE1TkozRGNZNDZpSWdlODdTM3JWL25WS3lvV2JUbDY1a3pVanVPNGNKR2ovYmlqaUI3MjdaNlNFdkI3eVpGZGozMGJmUnpkR09rb29tTHY0akI5cThNN1lYaGR3QnFKMDlGMGwxc3B3c1pSNktYYVFKZllYZEFGWjRuUWxBQ2JDN3UySHFaMnc0azNaeHdHNnVPdWhxVW5abFJ2U3BWbXlLekc3Q0tuVXFMS0djUGJtdXZMcXh2SGhBSVRLZ3BURkI4L2RRYitQVGsxMldxa1ZkNGhPVWJtc1Rtbjdtb3UzZ2lQTkwxd2ZPMmdVSWw3ZDg2VW5JYWFJazU2S0czY1YyQ010Yko1Mks2aHdhcjJZTVd3b3BITlMyYm1QMzRhUnQvS2JTaklrVmpHTUtxRzJYUGpjdWtWcU8wMm9mVkVFQ09XVUFJeUNkRTlKK3ZzZ09DT3pFaTBFUUdwRU1FWlFoRk1JczR0SHpCcTR6QmtHTzlPUjVTUG1QZk1qM0swUmowdnYzVGo1QjExQXdEVFA4a2lTdUoxS3JHNHFDK1hYbDB5VVM1VnRheTUrc2pVcVk5Y2hlaTBmTWhQaHhGWkI2WjNsaTkvQjE3ZC85dmpjT0tXT2N2Zm9Zc2FKWnpVbnVQMkJmTjJ0Y3dlSlI3Yng4Z29EUG90dktGR3lvdHJRcjRDSGc2SlpZSk9hOTQ5ZG5WUU16Y2Rad0xQd2F2dkxKK3dDZXg5K2cvN1VjN0VyMHNNZjB6QUM5SVJHYkVidFFKYXNRVHNQcnNHL1RwTmxSTEMyazZjRWVLUGh2eXdpaStGZnlKYlNYMUpTWDE3VXNLRjhIZnZkUXJyVXVOZm1JRFMzRXR1c0xaNGlCWlNSbTFZWUVoVFhjZk9mVWVDeFoyRExXY29tMHVOY1FWQmpJVk4wQ0tKendQMnVQWUljWEJ1aUF1VE9HOThCWU0xVXJGbnZJbnc5Yzh4T2o4ZEFrMEtuVTRCaitnVXJRb2RQSUl2UUJPNWlOcnFpZ0ZWUFFPTGhuaUR6ZDl2V3JsT1ArU2VwKzhab3RkdEdQRlpjUjBkamdIOHcvdHZmbHJJTjlwYVhQZEQwWjIzK2FZdG1UcXhUNmFtSFAzVE5OVVZ4M1dpK1grUStubXBrUW4xd3oxUkJRUzBEQUVMMEZkY1FZWVlSbHNsTWgxOHhQMlY0d25jUW1KRmpUWlNUY0o4ZGRYejJlc1N5UmFKUWltNWZsMmlWS0FnRHZTSWlScWVkVHFIR1V6ZEtud0FERHlnMTFsU0xXWm5aMzJqbi8zelRMcGlublg2ZmM1aFRGZmxWNnpRaUZJOGRyOHpRUzlXUzVrSi9TS3NrcUNuSC91RThhNW43OVNrQVpRSXplODNxSFpFeUlrUWlBN3R1N0J2M3dWdTVPZjNSMFBvRWlPaGhRQW04d1RyREJyeDNYMmgrejlINFhBWGxpNm1ZMGFpNWNKNERYYmVickJMY0Y5MzIzMWVocWk4Nk5DczF0b0tmd2lBR2pnTkhrVC9wNEdhQVB5aHRSVlFvQTlZQWZwQWFzNGxFUVZEcmVIV1NDdURUNkExaXFxRnBxczRmUkhlZytjYUI2YlBMS2JQaUtjaG42cENjS3VkNGRYR1BZdWllck9ZNys5NDVxSmFiZXhvTTZyVkY1L3BRSHpaajhTSkU4b1owZnFYTjBiQzYxN2czbEZsWnFyZTRWNVl4NFEzdnR6ZVNudzJnZk1ZM3FrVGJ5N2gzVG1DTk9MVzc2Y1Qzay85eTdKOElmZ3NEVVhiR0NpNE5BMWhLNVJiRmt0dzlRcGV4OFdLSmw3RTkycnVSSFJvS2ZHL1lpR1lOeG95UWNUY2VXTWhpZEVrb2JFUGViY1R6OVVTSUVUU0k1S1ROR3FZYjBqVjY1UldjSU1KMGNib245blpsZ0lUN0U4blIyL2t3aFdnV3VOUXl1bFVsaDNiTVR2WkliNHF6VGV4aS9VVzFRMkttUkU1REtSMHY0NHZrdE1VVjVpdm1NaXAvdlFLV21VUndaL29idmpxcXA3NDZuWk5UMHoxZHFvSGtqcDdYTkIrUzZLRzN4Q0pIK1J1eE95VTg2bHFhaEFWQVNLZ0JTbkFpZWg4YjlBZkRBVVR3Qnl3RFB3WGVCMWNCbGNCcEJYbzgyR2tOQmZCU1ROeVdOcU5QVEc3WGFJQUNST25aaUloRFZaQThCdUJONTJQZ2V1NFk5dVp4UzYwMU9LRHRCVUFJK0tkalVLT3JKTTRxY2JZN1hoeEVUc1dDK3Ria3k4MjdlRzlVTVRHNGFrdUNMRDR4MTBjOE1TZVE2cyt2WlV4WVlBbEYwOHdsanlzT3dQRExBVzhRUVpiZDVrRWtTcmdEVmdMRlpVWUovSUdnWlhjSVNpb0RqM3ZGOTVwd0toOXFJQW1QOURqSTY0WlhpUUpYaFRSTWluZGJUUVZvZHB6Uk5IQ1JYeG5tVkRERkdLN012eEVBSEVlUHBHSnRKTVZ5MjRETGlybVA4Rlh6TGg0bjhnb3hMczQ5SFA3UkE3QmpZbFRSRHhjby9RaUhoV0FOZmt6VUhNVUIwRTVNSkEzRTh4QXQxTHNFTG1WREViRGNRc3hlTUZ2WlB3WVdkQ2xCQ2JoOHhDRlhmd1VZaEtNQkc3S2djcGtZb21MZWhGNXhtRW9jdUpxOFg2ZkFKZUhmVUNpckRpL2dBMnJGNG9KUGhXN3RNaytHalNrb0VvVjh5NWRzZy9RdzFLTXhsTEZxUFM4Z1pzTE12UGJGeXBHQ2tFUC9UYkljcVNrKzEzRkZxNWxTSDFMUzl1VXY2MUttWC83MHFIMFQySWREOGFHL1FXTnh1alE2TzlNb3dwSHZneG9UaWNXSlN0VGVJbk1rbXBWbUN3T3MxWXY0MzJOTW9sRU5aaE9kMWs0aFVmSjBOSXNxVXBscWdiQkJSYWJRYXdlYUNwakdKcmx1WlRDZ3FMTUZmbmwwM2Zlb2M4dXRnZmw5RERnbTl4N1JBYmdlSmFtQVZObXF0R2lpY015djNmL0pLVkdsaTBCckRwWHdWbGM2ZlFRcFVRc2IvUkplYURYbWgwV2s5SnVUcEZKeFJhRkNmNHNhYkN5S1JhOWJiQWpXZEhIcXVDWUVxOXFvRldaTFRNWTFkYnJyMWtiSkhhZEpTVXp0VnFSN0hDcXZBRlc4cEt5bHk0anoyTk9aaTZMTlF5ajBHVG1naVRZOXUxREQzMzdrSC9tTE1CTFU5ZW1TVmdPL2lSbVdQb0N6WXBFc3ZSTjhGNTFWcWxLeXpCU3J1L3JqSE1ETUQxMEFoZ08yaGxBYTZwVTVoSnZHc2Z5VWxvazRlVml0VmpIemlwbDVWYTFSY1Q4VnhMdHo4K1ZpeldTc2xRd2xORlV1N051YStRYzYvemVrUW9UKzlzM0poK2JKRExSYVJKNXJsUUhhRVkzZ3RiVDArQVRkZlZpY1dYby9Ia0EyQ05za2xJSEdKVXFXeWxKbzlYeTkvN3JUYnFKYTF5ZTdlcXJZYVFqdmY1MVc5Vk9YcEtzTTFaeHJOZVFFRzVNcVpRb0hIYlBYSTRia1o0UVpxdFU0cndVUjFHT1NUZHc1c3c5TXorYW05ZW5kNDBvYzI3N0ZWbWFTVk95b0I5TjUyY25KMmNWME16QllVWnRta3dxTWFhbVNxUkt2VEpWTExlZ1Q2YXFvYVY5ZmE2Y29GM2psQ1pyT1MzREFnN0lSSm1NaUtYdGFSa3RKYXQ5YWxNcU1LdVRsSXlTOWxoWXJhZk1WNk1RcXhSaUpiTWEvbVA0blZJZG8weFNLWldXSkUzeDZ0SVdoODFPUytrc1RvN3k0UmlVWTVMWXBiRlZaR2I1K2tub3dpUVY2a1FXdWNTaTFpb2tVb3ZWSUdhZVRFMjJUWFd1VE5XeFM3TTNsaWxzU21Wb21sb2xCWXRXTWRXYkNxZmFrbE8xckM1MTVkWTBaZG5HYkpGS1BiVlNVN2xxUG92YWN2UnN4dTNhcnRQeVl2MzYzalM5L3RqaUpjZU9MVmtNWGFnanBpeEZnMHJHRE9qekV0dllpSnBkUDd5QlU5Rm5laTFMRm91MDZqMnA5RHFUWXZ1YmdjTFg5eXNNTklOQmZHZ2VqTWxHUTFLc0tPVEVJZzY3dGdRU3ZVWW5ZMmlnS2EyUWlEMEtSV29HYXBib0JxVzYvMUtaM0RmYjc2dW42ZDVYS2tvV2xCZHZtY1JLZ0lqVzZrd3loV3hZbi9TekJzUHVRb2VSWVF5VzNtR1E3Njl5MmNHZ090Ui9rdlJhbG1QRnIwM290YzAvMnllWExldW5WaGFpNHRjTFBFTWZDZUJlSlp4NUwrTFB1NXVXQXJDaWR2VVdXVmxNa3ZnZzUwR25EQS9QL2IxcHk2UkpXNktMSm0xcGF0b1NIVk02ZS9NZHZ6MEwzS0QwMHRZLzNETXBqOG51UDJmVm9CZW5wVTRjMzlUUEpSOXlBSjU4QkY2NTh1cTZSZFhWOXZ3Yy9OQWs4dWdrcnJEMzZGcHZwa25KU1UyMi9KSUJRNmZOcVR3MHhydDQ0dlNoOWIyOWFXcUdWbHVMdlFON0RROE1qZXNjeFB4eXBSRlUwRnBxQnZibVFuWDNWSVFSSGJ2Qk5PdUtFQ3VDK0hZMHozdFpzbGprTzhVSldQbUd0ckhhdU0yenppRG8zQWtnMTRqcmoxKzViS0tlV0loc0Zud0N2dmZaaGcyZmdXTFFBSXB4S0RyM1pxVG5oV3ExVGEwR0syZlZPbExKRWovVk1WU3diSTZiU245QW90ZS90SjZjejhFcjU1Z21semtTamdPcWM2MGJQb1B2OVhqYjcyNkJDeDBkckliNFhXM3FVSzNQVWFaWmlPVUZDelZsRGg5VDI4TXdHLzRnaU5QR3IxOC9YZ2p0T25jdWNoZE5VQkVKVkcvY25rd2k0TXFiQ0YrSDEySmVqYU5IVS9nSU4yWG9xVnBWWk9URDE4TThXb3RwbGRlSUVqeFBiT1JyZlJPcXJyVldUWmhReFllcUp2aHFXUXJ6c3RGV0VCWUUraEhCOXYwSURQdHFqK0JrREVsOHBKYnFVYWFVempMRjVCRTlpbUJJQmpjVkZiSDFIRVVUKzZERVV2UW9JaW9PUmJmVytub1VJZHJVdll6QTluOVJIZ1l0YmY5L0tnK05PTkwvcy9MUW5lVXhvVkZML1U5S0l2NzFVakQvMXZ1eExJbGpWeUs2WVNFb251aTF1cmlyVE9MUnhCWHovRzVpNXhMM0grdmVsdXFUVGlZWHlFN0JNenF6WEo2WktaZW5hTUgzVm5jbXpFRFJ0ZWcyK0IyNngybXl1YlpzRGFjVDhLc1pMT3ZEUGdwc0JveFlwZEhiMGRIbUZ0a2RQcS9OcDBGSFRURUptL3pvRGhPQ3JlRXdDSVZDOE1lV0Z2aGpLQVJDNFRCc1JXZDFTd3RRaDdod0cyd0tSOXZhd3J0MmhkdG9XeGdjSVVHaE9lTjJEWEZ2RHprRTlhSVhrWnhpWEJpaWlLVEJJeFdkZlhiT1FKd3crelEraDhHSkNrSTBXbEVwaVQvZG1NRTZQaFA3ZFlNWWpWZ1k3cUFnZG00YjVpaUFzWHF4U0VXRWZoM0NHYUxZQ0VyRmhMRnoxQ2pxd1RkUWV1d0xXSGlLcFVEY1AyNDdGdnFqQ01IbkF3NUZLZEtEd2pUdVJmZ0JTc0RPUVJWRGRVcnJsQkY1WXo0c1JuV3ZWZmU2YVJ6eEdvTEVXam9NWHFlOXE2clllN0FkL1ZBLzg5bGpXYUhWdUU5QzZvcHJndjZFb2pOWWRJUTFubEN0bzFTNEhVVnk2TmVCYnFBcUNINHBjRVQ4RVliQUdBdlA0aDlOempEbUhKZ2NPMkpOUVpQdGo2aHdCN1ZiN0oyNEFicldnaHFNN3drMGlhTURYWWhNZHR4cmVaYUtOR0VBRkM2VVdVSmNGSVBiVlVVdkZEVUFHMndTWWtzeUkwMGxBeHBRcElwS3RMVVJFYi9LRkhZQ1Z3SDh6cmowQTlOdTdIQ3htNlhROG11cDhoZmw4Q2RnNjBBZHV3U2N5YlM4WUduS2pGRHhWd1BxbWhTbE9NU2dEZ0ZzbVNYTUVYU3ZDU1hLakJVQzkxTlJBbjVXRXZxbWxkUndhaXF4dXV3RUpQUjNobzFlSTBlY3BhQXhhY0RnRURhbkQrTjlGNVAxSW5aMzVTS1d6QUZpdXVZVFBHNWpQNlFhKzgybVR2ejlhU2F4ZFA5K3FkaWtzSm9ZK2RhdGpBeVlPbVorV2RkbnptMitMVm5aWUFEOXpwUnBjMWFzbUROdFNrR3p4YkxtK2NtNXVaT2ZYek9OcVJsWlZScHFxRUxzSkN3RmZ4azRzVHRFVVhHeGs2TzMwZHlUUmVrc1dBdllObEFNM3l1cjZkV2lVZ05nWDFETWl5ZS9ORm5NZTF2a0twb1daZFkzTFc2cXp4U3hkL243Y295NGp5ZFF4YUIxZHczajc0WS94SFcyRThZNk1GTWVLb2g3Z0JMeEh4bW9raG8vUlR5ZmVZanJUaHNMaUNFM3NWRFZzcWkyUWZvbXE2a3hzelpzb0Nkdm1EVUxqRDBFZjdwLzJlVkQ0dytoYnh3RVN0b3kvNFcvcllkL2VBcGVmdklKa1AwRXlGdjc4d3Z6UVdOaUxZR2JmamJyMVQrL2l2NnlvZ096d1B2d2RmZ1R5dUh5c3Z1Qjh0QWhXTGYxNTRlYUhvQWZ2dlFZL1BqNHRFZS9ZMFRkY2JDWWJyd2E0aTI1SHJUOUp2eG9nNlBMZ00xSWNQdTZzS25DT2tWSEs1WnVzaUdGTGp5aHFvT1FlaFpOQjJqc3hPOGRPUktQYk1MSll0SHNvSzdFRTBEd3lKSDRuWEFzTHVidlZZeHBOOVpsOVZIbDFBaHFMcGJGWUNrZHhwSFhkTXAvTzZXK2FQbmRlVUZReHVOSjJMaE1TOWh4SVlxRi9pS1RsZVY2Um9oYUVlMmtybU1LU29GbmxSV1pOT0hDMnNuc1JqZGxWaWloZ2N4Z2Z6Rk1YalhaQVA1Q3RnOHJxdkx6cS9MWkhlUHYycjFoOTEzait5MmMyc3hxNjdSczg5U0YvVHFvVzhXeUlleDlJUnBpd2lqTDlwKzc0SWs0R1hvcENaWDI3MTlLQXVwOG5IMWtVczNpS3J1OWFuR05iTnY3ejczRTIrMzhTOCs5djAxMnk5aEVHV2NlTlFqMVdqWE5HN1Z4bFljdUYxeHFiY0JGYXhJMjhjbHRFR1I4ZGpTbVRWWnNjYWRrREhiVXRkMGVsSVFMWHp4eTVLTFFKcVRJVFozWG5HQlBlZWVnSFl2NlJhaCtpM1lNMHBsTU9uekZ4cSs0TU95QTgyZk5ndk5oUndJNkV3ZDJvaEd4RTNBSktFMjlVOWM4L2RPR0RUODl2U2FWdDJmYStlNlhpYkxWUERJZi9jOXFtQVBzZXBNZG0wN1RiZ2VxMzcrc1ZsdUVrakEvU0tvWGJLdjd1bTdiZ3VwL3Z5WlZ3ZkwyUHV2K2VuSk5XdHFhazM5ZDExMHVqTXZlNno4ck80TjZ1d09OZzMrbjZDT1lrU05LL2MvUCtIckc4LzUvditUbm5uNDZvdHorZG5iMjI5dTc5NmYrLzd2K0pPTHRyditzTTkweG0zNWw5aDMvdTQ3azNiblRLM1NoaE8rZ29rcXhSenV1QjBrSkJNVUJqOWh0VjRwNXE5aWs2M0dYYStzcStXVEduRjVXV0Y4OE9qY25KM2QwY1gxaFdicVpZU08zaXAzYzlWUklxd3pqTXpxRUFzMGpHME8xZVpWV2k4VmFtVmNiYWh6WkhMaFZITmFWaVQrVW9EdEJvVmw4RnZvdVpMYzM1bEpkNHhZQ3FOUW12RTlFYUR3cWVrRG5qd0dPQ1duZGlVRjNFZkVGVGc3b1FRTFNKVXdLUUtoMmtVa3c0MlBRNHNnV0t2QlVrWU1EK04wdU00Mld4ZEk1VWhKYjVGWkswS215aUJNUHJ5eXQ2dFdjbm1LYnVrMHhWOVJTSHcwUG53UGZxOXMrUmNhSnRrNHM5Z3hndzdXKzhQaUNQbFVlT014NkFwL2I4aDN3a3JzQ0wzdVRzekxBTXhsWnYrQm8yKzJabFdLNnloTmU0UjNFZ1hCUnVyK1F2M3ZxTDk1U1dKZVVYOSt5WkRqSXJKbmVObVU3bUxqTzBMZHJyNmNKZmVOQ0NnTnk0V1p4Q0xZZ3lTQU93Z2hJeTZCbThjV3NSQndKNTg2MjhPTWxFczhJTEprYnhLeitoRzBLUDNONFhKV3RhbHpWQVZmSVY0dFZjVVAwVStsK3ZvNnJFdUp0ejJ4WmxLWXpUZGsrOHg1eG5mTDJvZEg2M25NellOaTdiOWJnb3UxVFRMbzBMbHpsaWJiUWFtd2VHdjN4Qm5YV1crdkxTWWVVTnpjZDdMV2xnSitJM2VpUDhRVDBEcy9yL2N2WjdWTTBvbTB6b1RJekI4NFowaHpJcDZucWtiUDJwWU9ucDJ4bnkrUDdRSUlPc0F2Tm9nT3B5ZGlQTVlmWFY0S1lKV0FYVk1ZN2thYTVtTG9TejRrWXpIOEs4RVY0UTRaMEdaNGpHTDA0S2dnWVp4eVdtalBFTUVjQ2VIdVNJWGNGRzM4KzVydWlISGlKYVNRVzlIQnM0Y21qRmFaZ0RRYzdadTNiTjJ0QjdzQ3grMlo1OHVqRmFBRHZtek1TUGo3dTdvTkhyUmxWSHJNZU5CUldnQkFPd1U4dDJoeTF1cUpJcndWTjFveHZvMHVUakw3YVBDZXRqSklWS1cyNjZway9wNkVHRE12eG95WG9lMXN5Y0x1WEZ2ZjF1T0E3NGUyRlBzNjZwSzlMdXUvQ1BvMWxmZjJzZlpxLzdwc1ZuZHE0MVREQ1JML1ZmNkF5WVBkVVNROUk2NHR1VUNpd1FTRTJHNXpHb3BEa2lETEFhSzZKYTMyWlZjb3pvZHBadGJQZXJNaVpIcUYwSTJSOWMrbjdmTFdyN1lYd2tpZll6M1ArZkw5YzhWQmY5Z0ROOXM2K1I5YURHUVFmRC9VazBPbkVyeHc0TzVrVi9CSGNRaGhvaWxIWElpd1h4cGpGNElZR2V3dzF5V3NuV2hXeFZRRWUxcmpmbWppTXpod1RmcTBwbjVkQjkxN2FVZy9EOVMzd2kraW45UzJQTGdNUFprY2JwdTRXVjdiVWkxckhSMy9yRGtVcXpTNUdyWkY2MDVoUXBCV0Z4UVB5NlBEWXpCSXVKQzFLZzMyckpxQ3hYS2hXZ1BLa1ZLeFVibmFKcUpMQ3lOL3VQd01QWVk4dkorOXVxYmN0ZXpTOGVjcVFHYmI2bHV1dFlNcWhOWXlpMkdXMk9UejZOSmZOWmM1VjVwYVZaS3BVcmFuT0NWVTJzNHMvclBDa3ZFRUVXQUltSHVidGlxakZtR2FoTlQ4YVRlVGdqMEc4cFlBWTFCczJxR1Zpa0NUWVpNbkJZTzEwQnhNSGs5SWxCRkdENlhBekZRV0FZS2pIYzc1aU13akV3VTRZaHc0SHdidURidE5OVTNDTCtWWGpOZXRIRFZ1bkh6WkR2MjdZNkkzS2NjdjVsZEtBc1NDOU1Ibm12dElpeUZXUEtIU1ZTeDVjczFOUzdpb0lNUnZNVXlSQlYzNFZzNWhueFZQRnhYYjZ1ZXgwMEZGU1c0eUc2dG5RQUlZTjVidkxKWXZOKzVpS0c5VEVXckN6MUp0bkJKK2tXTWR2a1k2WU0yTW9mQkNjR0RwajBTanBuZU9USEpEaWM5UldtV3pQekdDTEMyN3dpc0lGcnVoSWVveXJvQ3BmcFloK0F1NTFlcXM4U2psTXR5eTJ3dm0yTEROWW1kT251TWI4OVo5WUlBZVpDcTBzdjdyQUJhMTBpMUpaVUIzYjg4WHQ2aVVJSkZNSUV0ZXRLVjI1NEdUYzRVdVlCNFFBR3JWdVF1NjhaQ2JvbWdodUpueTZtSmNwL01PeXUzdXlxb29IQ3NUdm5OSEJqVXNxcVM4UnBvaUJmalJaRFBUUDNtdVVUaG1ZWDd5Z2YwcnFoSFdXY2VybXFtaVJRQWozenV6ZmE5K2ZiY0NHL3pnMEgwQUtodC94MXhVVElwaGlBQzFOa3k5bjlTN0pMTWZ6UUdoTVlFaXRyNGt1Q3d3Skg1eDloZTVyR01Wdm5uQjU4Vnk0SXpSVUlJTXo3M0hRamxuNzJtTjJhTUl2WVYvY1NiellUcUxXRVU4cmlWWDBhWmlZQ2xNYUVMQldNYUN2a1U4WHFRZ1VJZWxFcG5RbEUwT3dGS1lPMUs5UUZ6UmcvZmhBZlBvUXVpYUl0VGhEVUYvY3dycmFUeFpXS29DWFhweTRkLzUyMHdqRDFzYm8xRm43L3FyWk42dCt2VVdEQ0ZXS29lK1NsK3dCNWNEK2dhSjZSSnVxbmpRNkRXYXhZb08weW9PaWowaENIWlhpYTlOekt0NUVWS2syZEVaWmxlbXJaUzI1ZldVamROczFBN0o5UThXNS9jNmY5L1FMZXVDbFF2dnFXaDl6bTZuaTZNa0o0K0RqSStmc1E3d1N2VGpQTTJ2ZjJJRzVDekFoaGgxY1RTRERldlJnUlNGbzBKczlWWnZWNmh5dEJYNkt3eGxXMEtUVkYxV0FHY2FrNk5LKzh6MVhhUk9tdTlFd3JYVG0xYmIveFo4RGh0VTBqSVh2dUR4OWkwdnhySmV4QmI3bnErM0VnZUdmWVNrcW1mQ1BobHRyN2hRWk9aMlJKN0Z1R2NiMVNrY240dGpIN2ZMcEJPQlFIZG1VMWdtWU1LTjFDdmloVnJGWm9ZTi9WT2kwU2laWm9XT1ZnNEJFcXRnazF3TFBxMkxEY3Iza2xUeWdsVzlXU0NXRDBma3V2ZVNLVk1vbzJFOGsrdTBLTGRPMlJLR05YQ0FQNTJvVlM1UmFuVFJTb1pCSk5YSzZEbzdTNmNCajBhZmxHcWxVeVp5V2EzVFJhMGtwdkVOQ2kzV2F1QTZEc0thV1VObFVtV0NINEJiY09QaE5zYnE0bVM1dnN3SWdtVEFQR3VrZW15UlV3Z1lKM2pCaHRiM3R3MWMrVURXZytLeFlJdGJkcXhlL2ZsQ3JGUFNnWGVIZ2lNa2pha1I1OEFMODhZMGxTOTRBYXBBTDFDVDAwUzEySVpqS1Jyc1dmalB3TXR5cVVhbzFZQzU4QU9lRFlYQ1MwdTZiUG01M2hwVHhMM2tEL3RnalAxamJJeU1VU3F4M0hxSTF4Tk1WS0FyNDg3R1JINXFndUU1NG96VHNpcWtDY1ljZVZ1QVY3UDllc3B1YXBzZitFVDErZjdOU2xpZlNxbVVzcTlLbldKMjZ1c2xOQTUxOTFXcVpTaTMyS1ZTTU90ZlhrTGZuZDY4emNwUlVtaWZXL0l1a3U5OTQzWDF6WTBZZnZIbnpDT1EzYTdVTkNwWldNS3hjcFpUelV3ZlZUYkVvbFRKQXl3ZnJkYXc2TFZsL2VzZXVVemlWa3ZsWHFkakNXelE3TU56aUcrSnhGTHJSeHJkeU5xSlRRa2xZRSsrV2dJQ0VjUWRNRXNDai8zUWJKblRSSnZySUkwMERvQTIwbllhZjBVZm9JOUVtZEEzYW9PMDBzRGZCTU4yR2haejRCa21HbzlOd29sZ3kvTmpuVFNCTWRaTWI0WGU2RWVsRWJ6THhFbUFLdUNWY3dCMlFBRGZmcyt2U1o0RUtYbTFzYllKWGdTbHoxQnBZeHVTQ04yRVovRzlnUXJIQUJLOW1qbUxxYmxISjU3QXhTdU1wbEFRL0dFYVBWSUUzMGFQL2piSTdoYkpERHphQzY3Zm9sRmhXZlVWQ2NSbW9uRHJLRXZPeTJaY2FobnBvdUx0WGdQaXVLaGRUTC9NVEo4TEVWd3BKaGFsK1JpemtGZFRzbFlBQXNBRU16VlZrcFEzRlFUcXV5YXV6SzRsNk9wWUdZbzBPdERRbjhNVzBqNmpOMkluemMzcHJ3T1VPQk55dUFMc3VNRGdRR0J4eEx6aXlBUDJ4YXhmVUQxbTQ0RWlrNzlGRmk0OCsrUFZSZHQzUnhZdU9vb3ZJWi9DL1Q5MStZZFdxQzdlZlloNkQ4QU40R2k2NXNIL3NxTDNuNktId0o3Z091MVFBcTFtd0pqY29tWGNBWGp1NDhkdjYvQWJaQ0Z2OTFZMEg0YlVEOHlUQlhEQjNMN2p2aXpad0o1MGl2RDVBNDdmN0orQjNMbGdBU0JsYXlZdVBBdlQ3K2lqTUJLdUJhdFhGOW91cldObjhlV01QWEZpeTZQMTdKMFI1SEkwK0Ezb3R5M3JYZU85NTZUNTRiWC9MbEpLVnh0dWNVeGJzQitMN1hyb0h4VTlkMElMNnpQUWJGSHVBMEVVZDFoY21ZSTNvWU5CM0tlY0FLOEFleVhsVFRQa2RyVDVqeXVVQnJIWGtZUVE5SkN1TGFDbFdMTElDcGpmY0FuOEJVckFjU09HK0Y5YXZmMkU5eUZXd2lzdzg5Nkl6TlVCbXRjclRScWIxT1FOL1RodUpnbWxBTnVEZGhlNjhUSlJFbWxFUXNuUDZxZ0V0cFdNZmNycnNvWUlNZWdtUXZ2d0t5dW1YVjE0R0I5ZVBIN2QrL2JqeDBZZFQ4akt5N01rMWhnRWtGNFhWV24wRy90MktBaU54Zm9hYVpIdFdSbDZLM3FyVW1sbWx3MnowSmllYnRVcHJBbjRZVC9tcElORldqZS9hZTRDSVY5THBybndTd3BwSEpxd2toSjFrb1JrVlhhS2p2emlmeHZ3dnJYYlpSR3FqN1NieDhmM2pONHdmdndGNHBSbTkwcVN1VmV1V3BxU2s5Y3FRR2pQN0RMdmJlMWVoMFNneGxodFBMUnlFamhLajhWVHg5dUY5TXZ1L0J2LysybXRBVHE5SWhEcGxJTTVwZlBRWGZSS1hMRTdLek5CcWs3a2tmVjZ2WEoreStLNkNXQWFMNm9Rc1h5dFcrbko3QVMyUXY0WnpBOTkyeHpjVlpCQXZvSHByQmI5MWVKRkROS0VST1lnNUwrL2t5Q1dna3hVVnBWYU8yZklWUFAza1UvRDAxMXZHaGVqVCtRNnd4OW0zRUszOVg0V3ZPanlGZlRQQVhqc1hIbHNadmY0VWJQMTY4K2F2UWVncG1nK042N2hreHdDTGhYM3Q4QjNndC9jdDlLYkRWZmFZanZxOWlBYk13SDJPQTlqVXh1VnpVUmdRdXRqbHN4dVV0TWxJbWJDU09vMTZtNDh6Q0FwY1JMM09YK3dyUXFzT0ZNVXpScTBKZUdpVUFIOG1pdWMraEplVDRjK1Z3TmNBajQwMGpGMmNDK2orN3FIRmFqTzRQUy90STZQdXcxVFhVUnIwN21Pd3o3SE5xMGlxbmdoQ0YzZnJnZ3Z0RnhWZjhlQkZaZjllWnZBZUFGdUQwWi9zTStqbkM2TTNOZ0lBVGpQNmQ0b1dqZVJjNGlMYVV1Ym9GZGt4dFJ3Y3pIYURMMzE5NlNLUVQzczgvZjVhL2VIZVFDSE5aNGdBS0tTRFJiQ2ZQUW8xekhWWG9SSWdxcExMYnU4STFTYmdhVXVwSkdvaDRtcDNKVkE4dlBKVXNqd0lzazQ5ajdHeFVmdWpXcEpWUVJyWmJzV0FPQVF5RzlFcnNsNVNZVDQvZ0RFSjBVVSs4ZXlIT2QxOHNpNFFFZmR0VnV3UEdBM2xDalF3QlEyUHhCbTcyMnpBUEd0UE5ydlNpMUMyRXlSTE5tMmR5TUNqL1BJTjJ5YlFkell6bG1SVzBXdmdKK3ZWaUNFUUFmV0FnVzg5RHBKMENqUkk2QVdIMC9wS1pWeTFjaTV0VDJFVnlYcjlvTFlOS2xxQjBxbjZWN3ozcEZzdWM4N2ZuMVlpbGJHbHloRnJQb1NYNEV2dzBvZHIxbndJTWtFL2tQbmhaN2VZWU9qMVpoY3VqbjBZM1ZjOGQ5VzZzYUxvSy95OGxldkg5bjc3T0sxVkthVHBMWWRzZlZDVzFhcVp0TlBLS2xJem1kclBONmdZT1g3dGdEN25IZ2RHdFZ5a2s4dGJEbGhST3E1S01iZEVvZ2pWZnJwT1R1TXFLQVo4UTE2K0pyRkE5TnAveGtlQjJOeHFwTkl4T2c3QU8ydE9GL3BjL2d3Sk1MSUJ4b1ZtRXJYVHFLVVJ4WEFDUCszT3dQZ2tpTEF3dC8vNGgyK1hSODFINE4rOThMc3dtSWNXalVNSEFPT0JyeS9BaDk0Uy9hNk1tWHJ1N3EvaDM4SGVSdGswV05KKzhtVDdTUkZGcjlqMGcxdnk4Qzd3eVAyUHd6blJtWGZ2U1lYbDl1dGd6UlVnQyt5RHArQW4wV0VibGZUODlhQmlxZWdrZmdpUEt4cjNMKzV0c3B0Z285d3VHaTJzbVNBV1VRVHdHR0tJemlmTm05d2lLellFd2xnYlNoYk5nMjRyd0daQkhod3dvYkt6bE01SUt3SExiSVpmd2I1enlyVDk3cDBoa3kxVVpIKy8yTCtlVDY3MWpoQ3JaTW1jYVV5SmFxdlc0SzNQOGs2b2NaYVhTdER5eVpobDd2M283UU5QSHRrN095VkgzQ2R2MU5RVTFjNDdBQ0lwTEQzaWdVdnc2ZzBLNUYxYkQ0YUR2aUJuUFB4R3lXaUdMcVR6ZnQ5YmpCZy93QTExOEtZQzZhdDljZ2FWcFBBU3I1dG15ekpvWHFzUU14T0h5c3B6MG1xbSs4YSsrNFRMTmF6L2NUQm0vaUE0Rzc2eDVnWjE1Y1NVdUN3bmh1TWZFUHcxc2tURkZXdC9vdmtwUUF3L1hKamdZZGpaWHVpN0FUMU5vQlQ4V2w4eDdTYStGYlhjeFdPdkg0VGZUYThkemJLamE2Y0QvY0hYajkwR3p6NmFxbndTL3U3TFRiaHZQTWM4QWdyQmd3ZTJOQys5WSttQnQ5NDhzR3p6c3RtYjcrRXM4M2F0R2QrK1BYdDcrL2cxdStiTldRN0VlMzRBMVNlZnd6MEpMSXRjYTRXUHJhNFlYZ0ltZi9rbk1MbDBXT1h0OEVSc2ZhSkczKzFIS29meVVSVlVQK0x2eGk2c1doSGJna3VOQ29sMUxRSmFwNGpSVW1oMWdvSE1NQXlPa1NFa0czODNRR1IrV01FVjJNbWlGaEhGanJVZjc1bnllQkY0dU9RcmVPNlJseC85OHFIdjh6VGozZ0w2Ri81V0FWNEV5VllWZGVQcFVQT0lndHBwL1dZTm43UHJ0bmY3ZXErL09XbmtvbnRXUE8rWkRLN1JsN2hMZCsvNEl6MnFwR0RYRytPSDMvLzNqY01XQTM3UmtkNlBndVpmaHNEdjBZUXpFU3d4QnlaWExUNytISGhxMk9SKytZL08zOXl4YXVUNFlRTSszWFNXSG5qWGE2L0Y1V3hoWHZBemduRUJicm1yYWJocHY5Q1h1REZONlJUWHlZNmxTTmpOak5vQTJZaUlrSTBJMEJTMTRRMUxVYWhxQXJBeEpHRUU3MmN5WnlPQy9rdDh2eUVjMDNrUnltVkU4K0tmVWJsTWVPZFk1OFY3YVlJU05Qb2ZlM3RXcDdtam4rR3dUcCtiYkxVSnJxL1JxSEs2N255algwbUdSOGtrYVhVczdiV1dUb1EvRmxSWHM5K0NZblFxZVBxQ0d1YlErdXhCZ1pWMXR1enlkSWRCcXRXUDZKMDNxTlRyMElBTDFWdzROS0prNmNiWmh5YU8xa2wrR1B0WWMzVUJsNFFmYlArMm9Qb0RNR1ZhM3NCK2hYSnpWVXIxYTBlUG5obnN5Z29wNURKVGZxRnQ2cFBDK2xaNWcrSnVJL0tTZnRSajFCdG9WdVVGaUJCQkZSb3JrR01sN3BoWkZGbkU0U0JhSVJqNW02MVhBakhURlpPUjB4T0k0blNTaWM5QjhqRjVOVEdMSzBHVkhVV21nVGpzc2VDTFNSTkRieE11MFJvU3QxYnNNK3F4NVZzTUp3YVhnVEhxTzR1S1V4UE5kaklRVVkwVzdEcHc5Tmk5ZStZdkNHYkwyV0l2QjdTV291bVR3eHQyM0wweFBFa2tWY2tOR2RCUVZXR3dhRlJTU2JDS2s2clV0RlpjVmFXMmFoVWl2ckpTYTAwQmIzbnlodFovK05PSDlRMDVLaUFwTHBJNmV3Tm15c3c5dTgrL3Y2dk1iMUdwMFdyUEpXdmVNYUIvOCt6K29Ya2JtcDdlVkxOOTIxdG50dm1TYUxIVWJqU2tHVFRNWEtzMWNoRmtydkxNWFhIYmgvVkQ4enhwRXBuTXJKRHdzNmFGOTJ4Y202SkZwRSt4N3RFSDc3MURKbG9RRElVcVdscDJ6UmhwRVlzdGdCblRkOVgweWY2U2tnQXFNY3ZvbkhRREtiRzB2SXBUMHlvbEw2MnNVcWRxdWFwS2pUVmw0Tko1TTRmV2p4dFgzOUJzNTFNMGFzdVVhakNNM3RJMDQ5eXUzZWZWc2lLdm1HRkVkOCtZMXE5Ly9ZQkdPS1ZQemFhbkpyNjVmZHMyWHpvdGswakZuRWxGUDZJeXpZT3AyY04xbm5IMVEyZTJnUE5pdlZwaDVzZG1seFJLODVNVmFyWTBWSWI3VE9vTlN2UzVDR09QQmFuRldNTG05QnYxYURwd3BIdXdXMkRpbE5uRU92MU9qRGFET0RUVTJSRzNyNlFkU2lhYkZnQnUvRWFNMlplR0dSSXNMVkF5Wkp1ZUN3aGZIZzBVSnpGQXRESUdvQ2ZHQ1A1eW9HUkVLcFZScFFpdTNmL1owbVUvUEhOc2FycVlGVWtWWE9zY3NCRWNlQTNjSzlQbzA3MGFyY1NRcitFTWRuT3VMZ2VJbEdJSko4TDZ2NkpaUlo1VmNFT0swNlZVL0NsenNFNG5VN3FXYmRteHZqbFkwbmo3OG0xVGlnenBvMFNHM3NXOXRmQ2ozREdyVDA2ZitzQ2t5dVJvVTcrcW11RldaYS9tdVpXOVJhSlVuVG93dEU5aGNPeVM4VmtTbFlRRDdKTENwMFptZnFDZVhUZ3NTeW5WNWUwMzhoTHNRbFJ3Rmt2VDZnSVJMd2VQcGxVVlpjdGtiYzVCZXIzTTJHdFVwcWhnMk4xamgyOGJYNU5sa2RCckttMCsydWhzQ0tUMFhqcW5vYkNvWnZ5UTlPamhrZm01eHVUSmVTVVAwUHI4aVowMlAyRXlSM21KaHRic0JKdlFPS3B5bDIxdVo4Z1p3N1QweFRBdXVSN1hnbjdwcjFpcng0eTFpSXZ1bUdOd1JBZ3hzUlJPTnhJZE1DV0UyWEI3bUtFU2tBd1NnaHhWVjl5bHY5S0V5VzlUN0NqWW9nc2FoUW5oZGkwMlBhUkRQWE1pd1c3dG95SmVEcnhFZzgyUU9DY1VHYkcrM2IvR0F2MFhEWXJhaWtXVFFsUlFHMEZGaUtCVklaWkVkMVdkU2ZSUEZiNWxxNkVZY0NTZVJodjlnS1ZhYjZxekVCNTg2NGFxNjk0bjNJaHpJWDNDMlFWeDVpSlV1ZFAzVU13TzNXVFUvNSsxd3loc1pmN0tLNEtOK2F1dkNsYm44ZXRYWHBGRWJQOVowOXh6Nit3NnIySGIvNjY5OUdnZGxVbVZZS3hZaVFDYUZHdWxtTFgrLzFVRGNTWklTYzFTMkNZVS9Rb1E2dExSOUo4MUM5MGJVaElKc0FrTmduSWoyVWJML29QR0FKMDhiMnFNamdBeU5jZFBDZElKMEdwMjBVa2FVL3pvTWw4bmV2SWl5bVdPYkFTUEsxMW1LSnc2aEhoMEZPU0tyTEQySVY1SHFLSkFwNXc4RG43Z0pEc2xuU0lqUDNodFE1Q1lmUTRIajRCY2VBRTJ3Z3MwaFN1ejY1eldvbjBVdEtxaUMvQXI2THZaUXVFMnlBV1AxS0Y3NTNiaFpNc2VGV1NhVHZTZFB5WnpsSlBvNEJBUlZKZTRwZXRqWWFTbWVMRzZxR2tNdUFHemtRYlIrMUxwZGt0bU83RTNwVU9DVlNxVmFZbThBZ1FUVlliZ3BMVzNabHEyazVRMGFsdjJqK2lyYjdkZ1FFaUNCT1l5aHl3ZFY0aU92NWxwRlFEQ1VIS2NwclZWa0xlTEthNkQ2Qlhqc1V3SmU4azhFTG1kWEZ4ajJoOUEzQmZuOUhNYVR1TkUvd0U2ODE5YWpOcG9PQ2twZW0vMFhxbFNwMEdYTkxxa20rbG1XMGNTSGVwb29tMXNXN1NOKzFsdmJ3L3JiZndOU2liNzVSZE9wcmR6K0JLUVM4V0JEdW5YN0MrS0R1bGw5cGYyS1B2TDVRNXBvbXhZZzBybGk4ODNlS09XdENRcWovMFdNZkdOY0R5c2NMRnBTcUhUUUJzdlJpZlF4clBmZHJ2c2VFUXNvaW10VGlFV1FYUVNJV2E5UGFRWG84NmpRM083WGd4d29HY01jNE9TNnRvUms4NEFGT0FReng3ZnI3SHhlSmhqK3hvVGhSVmllM2hVaVo4RjdVNjNpQk1SVTh4QWtBOWdKUW1zNmtrTGpsUEF1OTFQUDhLcGY1ODM3WEhZWHB3dTF6TnNFdWRVMmxWbXBZcmI5ZkNQNEQ3d0xiaVByazJBOVJUK2dBYytDQzgvcG4yOFJNb0FwVXhsNU94S3A3bWdvSTk3VFBUdUo0RDdzY2M2N1hrVHl1MGhpSzQ5YklQaVo3eDNnc1pMR3NaelEvdzQ1c3N6L0dvWDBIZFdDTXVwZlM2L0M3dVU0QUxFSnhWMkNtTUZ0NnpaVmRnTUQ3MS85N3BSS1VtZWUxZm1sUFl0Znc5TWVmOTlNQlJYdUYvdG03QzlzSkpUSmJFTUI2UzBuT1lMREZsSlZ0bWhaN3RFSGZTek45Yzd2UFc3TzFyZUhWalVOSFpveFJ5WFNMejFPNkQ5RG01OUFqV0crTWsrU2pHaU02eWFWU0cyVU93emxYZ0daSTRHb24zcnZqOHhiZHFKNzhsM2xMQVU5dy9VQTBXVWxGSmdLcTFCZnlBWmtETTI0NFhvUDAxK2FNQ05CdTdvU1hpSldSWTlDVExad3poTUQ0R1hjU3lSR3piY2FCVTl6b1dJSGJvSVVJNTB4c1hRMkh0ck1HYjFxaFhXTndFL2l0UnlSdEhqVXZnYS9LK3Y3cHFjMnpoZ2hIYnVvS1JIUFBlTm1MallsR3NNVkhwblRCTXJWcFNHbG9OaEhVejdkM0FTSEFyNEk2QUtpT29tRys3SnZGTXNXYnNWZmo3eSttOStNMktyR2R3aEUzZXVZMFVDTG9PVUlHdmJBYU96b3c0c290b3B0dnlUVDZLYlB2a0VsS09KZ1FMSDZHVWdDLzR4ZWdjOEgrL1g4V2UxVkNVMUl2WThUekMzQSs2QUd6dmE1dEJLTjREVmxHT2dJTmdHQzYyaERIWWZXblZpalIxdndKR09PZW5pSUExOFJFblBwN0dqbFZ3c0hTNEhzMDFlbTVZOGUzWnlXcTE4b3MvbWcvdHN5ZUFKUjlXQXdvMGJtdXIwVWtVTmFOMHI0bWdBVHJtK0ViRXNJMCtobC9wNWpvYmZtNGFaNU1wK3VQaHNxMzNZd3VUUzB1U0Z3K3hOVFVkdCtZWkFyVk81NlBZQllURmNwNVFEdm5Ha0VnQ1dsWEpnZlZna1l1cFRVbEpsa2QrT1JFc2hSaTZpeGRPTXZCN2VwWlRRa3BGQzNhY1NHb1QzZTRaaUw2Tll6NUJzeU5oaW16QXhpSGFuTGdoTUhGRXR3V1BGNTJSWW91QUE4T3hDNWhuZ1J3dU05TmpDRkswWjlZTG5RVmNjQmxyUFU3Mks1QmZoRGxnUGQxNlVlWU9MaDQzby9SSElXc3drS2NFQzdZQ2NZR1BqcWxIdzZXYVErM0haaUdHTDJ4OFl0YXF4TVZqZXlDRDJYbXFWWlIwNWNpUkxacFhLWkRuM1RHaWNjSTl4MWFqRzhtQWovWFRaeEdSUDBVRjRiZjkrSUQ2WW41ODhxYXhoU2NXOVVscWlVRE5Eblhrb2wxSEJnVEJUY2svNUV2Z05lVWtqYkpKWlpWSnBkbVptdGxRcVRaUGxGRWtrUmRmd3kwYXRJbjI2N3cxYTlESnFsd0lzZlFneWVCc0thenJZclF6cTFCcVJITEYrR0pRb29BUzgzZTloODlFS3FpOVFqOWo1R2dCN3ZnSHo1amQzSEFRekgvbkRIOSt1R1FlL2h3OXNmL1ZubXZueUR3VzkxZlJLc1MwNHBLSGFhTng4L2MwRDlGZXJ2M2wzNzhnL3ZQbnlqVmZtSDIyd21mdDQ0ZWJBUU5wZkE1cCs5eE1ZUHJuMytnbURWZzhxTWFzQTRJYXN1eWZlWDRsdXZZQkduMEpScUtmRldBcmNJYkVSU1NlejVKVlFFNnF1SVFZSEczRmdNeFVSNGxIK2dlSnNkRk1VcTVpRGRHTENncmlndHJhcUNaMjZuUzhUdTVVQ1BMODd5WlljN2dpQ1A4a0E4U1lsQ0t3UmVVUXNIbVZQY0RocVloellQcVhJQ3BSQVZQRFJ3SiszNzc2Mlk4VE90K2F0djFyM3gzbncvbmQrQXorNnNIcjFCZUQ2elVXd0FJYm9aeGZEV3ZqRGMzRUo3M09BQmNkdXY5L2R0TVdXSjVmbS9USi8rWjA3cnUyYTk5Yk9FYmZOdWYzUjF0VVg0RWVJZXFBc1BxVDd3U05SK0ZFWHJZUS9YNFdMandCaVRvTGF5WWJxMFJiRDA0M2hFUVRzd0swQmFZak8wWGJBN1k0ZUdNZU1hbi8yQmZaKy9lN29kMkFjbEVjZUJWT1pYbURkUFpGUEZ6Tmpvc2xORXlNUGdTSDBtc2luZEs5NDI0UzVIOGwrN3Uyb294Q1A1SjB1YXpyREhMWkVJWm9zNkl5dUViOGFQL3M2ejBIYTZOVjAraVEyQ0hBNTZKZ3E3RDRnWW1rbzhsdnBicytnczBFam5PbXd1a21OL21ncWZvNkdXNDYwUkhGMDU0K1Q4MnBncytmYWJYa3V3eUMxcGpldjdwZWlyZEZsRmdFMUwrY1MwOUxxTm5YWFgxUU5RbGhoRGJiU1A2clZMWFFMT3BDZmlNY0d2NXRWRHBQTlpuS29ORktWU3YyQlNxR1Nid1NBNFVVdHNZVFJIUzFxd2NjajZhdXpCQVFzZ2QwcUIzYWp5Y29Sdmo0TzhpYXNKRkUvNDdDWExqdFIrQkc4UEdHcFZTQW82Z1ZpeEFmUHdJNTBKWXZWb2JIN1J6RXFIMndWaXlXOE92S1EwNlBXcEpuU2JKb214S2tUbmgraXBXU1RyU3pYWTNGcmRTWkxibDRTdk5kNFp5TlcybW04MDlpY2xKZHJNZW0wYm9zbnQ4dzIyekE1aUNzZG5HeVlyYkdoZkRScWo1TWRZMVBUSDR0ZDRsYU9sV3JEWmJPZEdVRmJocm9wbnJsVzJhUlA4YnZxM0ZtKzBwcjA0WFAyWGRnM1ozaDZUYWt2eTEzbjhxZm9TL3VqcjlLL1ZKMWhDMlk0WjVlRnRYcFpkOTBBSG8xaU8rRkppUElMcGNZMlFGNFM2cUhVc25wSVNUUmFBdWpuMThNaHowVFgwWnR2cGEwU2JCa01GUEFmZ0gwaEVnWUtNUE1XbXllWWhseEczOFdOdU9FeWFoQTFpZmdnZG92aStFMTRIMHVRVlJ0Tm1OeTdoUzErb2dIWDViMUQ4QkZuQlNiQkRUeCtUTzEyRVJGVmhyb3pDb3VkQ0JjZ21sdnQ0OVY4VnBKY25tYVJtbFo4c0hMVEYvNDU5Y2Jja0tsMkp2NGNySEhJL1AxdjM5WHg1MGQvUExNM0NJSy8vUXNZYTFxOHYzMlNLU3RKWjVacisvZlh5b3NydEpNQXRjbVVaZEtaRmRvNWM3UUtzem1vQmMvMW1takl5MCt5TU5KU2EvOEJLOTlmc2VzMnkyQlRLTmRZdS9mQzN2bUQ3enJ6MTBmM2YybDg0VXY0MjIrU1g3N3R5UjEyaGFiQzNBem9abk13UTJHK3F4b212Wld1MEFiTkQ3Nysyd2ZNRlJxdFBBWHhGQmszS080SzJZZWZoOWhJTXV2aHNTcmdNbUlQQ0J3MmY4R0NOS3llbXdhSVQxTFdqYmZmZlhFUkc4SDRjbVFERDBzc3ZvaFhVeXRqc29xNUs2dWZXYlBtbWRWWEZ4MjA3N282OTRXVmsvME91Y1NTTjJ4V1EyNksyR1NaNDg1Y3RFK2I1NTh3dnNhaVduelhqS3lzc1p2ZVdySDh6Tm94TG11T1AxZERpM1RtNGd5UFJhOXFkRHFycDJSTFhkV3JSOVhkUHI2bUlGMG5wUldqMTZ3WlBXYk5tbE9xSjVjT0RBM083ak55ZUlOWHFjdXY5R1k0OG51NWxlbjVLVllhVEc4dzUrVzZpdkxTRlh4Z3pNSTdKZ3plc1g1U2FYSERySmxlVDAxT3FsU3FkZmxIK2RVNkFJS0RuVWt1ZjBHdjFPUlNmeWpRejEvalRiVERFK3pYYjlvOWNQYTRUblRFVGJkcWxUZkkyaE9nSStoK0ZlN3BjN3VKSmlPNVN5Z1VDNE1iUFR4cmQvRnlncjVOZ0ZqVGQxckRVN1lnVUh2UUFoNm9qYzVFWDJtSnNvYllOWjNmM2FZZEhBYVo3YnQydGNOTDZBaCt3R1ZvN1NvVU9YQTlDOTd4eEs3MnpxY0dkeXQ2UXJnYi80bzlHdDdVa3QxY21JY1Njd0N0djlaV043VVAwNk45L21uckJCSnROZjlWYTh6cnFzLy9vQWw2NmtjNXFYTEVhK2lJUVRPQlZ3ZUlnU2RhM0lJU2ZPZTV5SWlGUTRJblBOSkdRdGh2TTRvK2NUQTZYZXIxY0twT3h6aEU0MGRlSHo2U3lVZ0dGRmswNFFPVm5BSFh1NHBkaUVhakk0YmpDc08zTEVhRHdXZ0JwVXoveUhXR1Q3SW5ldHkwLytZR0pmaWV3QlFxSHI3Lzg4OWpkbmI0WkNBSVJiMm9HbXhuQi9BVWxRUGlPcjh4RHhobzduSXpIc1FSRVRWclo3emtSbUdVZElaMWZxemp3b2p3cE9jSGpJUG9iY1krQTlHZnhYcXhPWEdVZjB5ZlNTbFZpOFFEUEIyVVo0QjRrUXBmZzJsbUIyMmpzNHJ4MFprTWptREhGOFV1RUk2ZG0yeTBvemdMM1hPWXVXUm54K3J4RzZicHRvMTVXTkJYZjNqTU50MjBEZU5sZmZNZXhyQmZLQ0t2TDROYk1EckwwN3UzaDk2SGdwRTJPc3NNanBnZGJKWVpOaVduaDFBWXd5dzBrZWJwQ2h0UU9JdDE0SXNzT3AzOUNFNEZMemJPeDdmbk44TCs0TDdjRWh3dVFmM2ZqdnJsWjJRTk5nUjd5SEl3ZVBQTHp0aUxURVlpWEdLSU5panFGWTdPRU80bFJJNlVFQ0pnMjBhZThYYUdjQTdNWnlFWVltQUpud1JmRElHQVNpcGxTemd6ZkhFb245U21sa3FZd1JDRlBsZVIwTnY0aEZLQy9pRWNKaWxCLzZGOGNwc3FsaklXd3ZsSXNEanFCZ1d1dFNYZG9PUktaVnNTZkFGTmIycFFFaitqUTFzU0VPNkJBVGdPbm9tZjVYSmgvVGtielRON1kvYWFHbUp4YitJMUpwNlJNQm9HNndvQ05QNkp0U1VhcEFSbGs2blpzM2Z2bnZYZ1BEd0hpbURCamZFZ0JGdkhVemZvMzRmbUh6Lzl5K25qODBQeEFQalRucjNNdHIxN0lwUEFlVkNFL3ArUEhxSnVqSWVuNENuMEFHaEJZL1d0dDFjVkZxNTZHNVNpOFZvcWhJV3htWG1EWWk1MWxvdHlCdHlhZ0Z1SEpRVlljUktkNk9HUG8zODJNRFg2RmZ6akhMQVlicHNEc3VpVUJTZE9nSGtuVGtUL0c5NFgvWkorQzE2YUE1YUFKWFBnSmZxdDZKZUNYVTFNMXd2TFk3S29Rb3JxbEJ4MVNwQkVCTTFQaDZWZlJINklwVitZT0xPeE94eFYxMXhYMXh5dEl5ZTI3bk1CcVcrdG9xTk5aME05VU1IYXlEbmFGTHZ6SGs1WHg1RGtkVEF0RHV6WHF0ZTJvMDV1MW1zNWRIbzVGazNrUnN5Ti9xSW85eUtSa3FoUlNWT3hQeGpzOWtXWEJVQWhKay8rSW9EZFBraEFJUTZibXBta3lIMWFKVDhObktQM3dPZWlQNzRKaTk0VUYzRUYwM2lsTm5JZmswUXV4VXd3SXFHWEtuSU1vRGdpRVkyTjNrZFBOVVUzd3ZjTU9Zcm9uY3cvMEpVcFFkN1docjRFM25VcHhINVJmUTVBYk1qZEdQQ0tJRXh5ZXJ4Y0Y5UW4wd1hsU2NIdEI1NHMwRng2NUFqVHQzbnI1dXROb1BIYW5yVXdrMkFiaEtlTWh0RVhWcHdyMDlYcHlzNnRlQUZHUjAvNUVSd0NYNE5EUDlLdGJkRUw0ekpvTUxHMnFYNFNBTGUzdGI1OGJQcWFRNS9PYkFTZ2NlYW5oOVpNUC9ieSs4SmtFTWR1aU10UGhIV1dqc3BFL0lCZzgyMXcrSFRFRTVtOTYwZEUvY0RORStPVDJCU0hWbVljK3V1aHQwY3prVWlFK1FrK0JrWmd0ZHhvRStPV2kyMXcwd2Nmd0UwMnNWd3VaaStKMFpMdFJUaUwzdm9KT253eE10aVJHUnc1TXNoZUNvNmtGNFREMUkwMWF5QkdQNkNFY09SQi9NUU42ckhIMEpnVWQyU2lQTmdKKy9idDAzYzlOcktiemtvYW5wVkFiTU5lbEFhd3RvN0p5dUo5VXh4REF3OUh1MjF5RkkvQjJRekFBWlMwaDJiQ3pTVmJ6NmRuakphNjNjRnBqYjVjQ1p0YnYzalI3dHI5QUJUNUxJUGVndzExQzRiMUt2UFV1dEV3T2cxOFYrOXNzSEpLaFFMMGFZYmZHTGMybjlqN0VuMytkdzN2TE5acE10WFd0SnhwR3lZTTE0aUgzM2w4M1JKYmxZaEp6ekNVb1pHL3V2ZTZRL2RlZVJNVWJSblFjdktScjQ3L2Fkbnc0U2I0SWtpbGs1UzBiU1NWb051V1QzYXdpSWQ1eWdONDF1WjBLY2xlc3BKRzlKVW9JQ0FLR3ZCaWRYSnZVU0NJb2U5cE4rYnhZeU9TN2JFVzZZbFMxSE90d2syVjU1bGhCL3dXZHBqejVDbm0xK2ZTS1dhTFJHcE1saWh6MVdLL0psdmpGNnR6bFpKa28xUmlNYWZRYzE4M3crZUpnSlBlT3Y5VjlPUVhzT1BWK2ZOZkJSeXdBdTVWV0F2UHdDL1ByVmh4RGxoQUNiQ1EwSmxiclg5R0ZLZUlna0ZSU25HZXlDTS8vT25vL29ia0FpbWJwZCs2ZlBsV2ZSWXJMVWcyOUIvOTZXRzVSM1NVaUZNWDlIZ1REczFaY1E1KzJlT0ZzT0JXYW1pbzExY2ordjF5ckkwSG9CZ2pNWWNocXg4ZGdiVjN4elE0VVh1aWJpL3lBS0tUaXhFYTBlVG1wQVdsYVQwb0NwQlZCYll0eEhxQ1JtNVZOWmZMbG1lSm1OeFN4bkYzWU04ZFk4L3UzRFQ5anVVUEF2SGVaKzJOWlp6dHIrWnFLL2cyUTY3Sk9Rc1daZTFwYnQ0ek0vTFJyREZiZDcyNnAyUFg0cTI5ejlLLzlNdVBYczR1QVV5ZlhQQzRlTUdhUy9mZE1XM1R6blBqN2x5WUFuSkgvY2JLVlRXbVhqVHhXdmlWSWI5UDBiZDY4R2d6enFiOXRmS3RpM2UxNzNsbHo5Ykd1VHZQVWoxOS9BNG12dUI2K1BqRktBRzhraFkydTBsMGtQbC8xWDBKZkJ2RjJmZk83S1g3V21sbDNiSk95NGRrUzdMazI0cnRPSWtkSjQ1eng0bmozUGNKT1VtSUllVGdoZ1JTSU9ScWdIQzJKZEJ3RlJxZ0paUVdTTGtiV3BvRTNyYVVFaWlVdHBCbzg4M015bzd0aE5LKzcvZitmdCtYV0RzN3M3T3pzN1BQekR6UHpQTTgvelR4YTBGZ2k0ZzJTMVJXTW9GZUhUUzRvYmNPSXBhelAzOUxMODlCRk8vSGJubmN0VVVocjh0S1loWkh3dU1xTDU2WXJBaTdFa3FEV3JGWXhmRHJQN3pxL1RQU3VVOGZtanYzb1U4QlEwSnc2MkNtdUwyM1JCTTRIVyt2Y2x0TVpxZWU3T00xK2FzRGZvUFdGdkFVVmp2TTlScXVnN2Vyamo0R0dsRngvWXVWbmhqRVNxUDJDSituMmNsRVBxeERYRXMzdHBIdFhjMUJMUkRDQ0dHb2IzbUFRQk5kRFNJTk83QjJEK2x6U0Vpa0Jka25wd2Z3MkFlakJ4TUVKbyt3SC92eUlZQjZXS1VEaUZnMXFCejhvR2ZxMUo1T2NFTk5vMDY2bGRjeE5LOWVEdzQwMnZUYWVMbkxSc01YMmZGK1JtVXk4N3pnTWFxWjZKdldLYTFlY0QvUEkyWktXbExVbVpjWDROUXhmMTBCOXJXMmdkN3BvWlZxTTdkUytpV3RvR2sxODR2T0labk96c3lRckQvdUY2M2dpSWFIdEVKN3ZiUlhTaDh0dEhOMm03YkdZWVNUd2Y1N1BzZ0xDRm9BYVkwNVR3OFJQN3JSVjVEOUI2dWhnZmErRlNjcjB0Tzh6UTVSNHhVTVNqQmRlcVJNd1VKV0hWRTlERDRHRElSS0JmRjlSbE1mS2luR2lVWmFOZUtleTZoV2FnNjFDYzl3Tkp2TTJRQUJvUTlkZ3NnRUlSbHVEWE1BL2VZSVJITTA3OGZ1TTVOUk9weHcwNTUvSThVSy92a1FvQ2ZONlU0bE94ZG5Yd0NDN2oyZElQMHVyVEpKWDFrRUxTeFdtc0JJblptdVBudE0ra0puTnV1QTVtVndCOUE3YTRzU29VcTdBUUNnczFlRWlpSjFMaU44Q3FYWFhVaTM5YVlmeWVXdkdKZ09vQnNvNzV1NFVOcXdFcnlTMWVEUzY4Ym9BMGI0bGM3OGtuVGxiMUVmK3B2T0xNMVdCeGJOV0ZOVXNtWkJwOE9oY0hWTzNWd2RXenR2c3QzK0g2YkwrNTlzRC9zRjFVSk5SUkxLMVdoYXdNRDMyS2srQVdjTW96WUpKZFBZa1FkWmdTUm82VEJuM2M0VFozbFlKTFJlMEZTckF3SWFzK1NsSFVUdlZoRVJxdWpEaGVBRklKSmk0T1VFSkZLR2NrbG9sdURoQWp2aUxCUktwVDVnN2NyemFUa1Zxd0RCSUZDd0trN3J5K3V5QnZSS3BRTEFnSDJpMTR6a2lzclI5UzRQUjVlRlFtVVZqdnJMYVRyanM1bTlFL2ZaUTBJd2lESC9XbHN0VDZaTWdyQjhPWTd0Mm5VUVI2Yk1tREVGUjVkY2Z2bVNPOVZkYTVWTWlVT2hVNnRaaStCaWVxUWVEQW5KcXRVNmhhT0VVYTd0VW91MUdvWEpHQnVmYnRUd2kwNUlYNXhZdEQ3Y0dRREFwTkRVMG9kQzVVSVF2U21HTEd4OXExWDRNY2FaV3dscVZ1S0VYZEtrWFMvamhNNC9BK3JQblRocENacnlmaVg5aWZoSk4rT0RvcWVQMS9VUWJLTTBWWS9tWW95bk5SM054OHVvTllqeXQxRTNVOStqOWhFN2U3S2pFc2lGTUJjT1R2L1dmSU4yTkw4dC9sM2h0OTBQb095NStQc2trUC9nOS91blpiOS9jWTZ2dmNUTE1seE9BbW41SldLc0hHUUh4QzZaTXhjRDNWMFhuZ0RsUU9xNk9HMUE1Snh1djN3My9nTzNYQnc1S3dmMGdOaWxNc3AvT2Q5bDNEbU82dk1JUDVJYVJ5MmdycUJ1UUt4QXJ0VlN2VWlaZ0FlOUZsVHliRWxiK295bFVnUldEWGM5WXUxRDFodUp2TmZiOWtFNVRWYnFrSmNqdldKUXhwM0RES3FNdnlheVlxL3VaaTVCbHZ2L1FJNWpBVFVGU2F5UGtBajgySm9NK0QydWtQN1VQaXlKTDl4bFRRUjhCZUdBakptQTh2UmlOMlJKZnRDTWdzM1RwbDZEZ3RkQTREVndIZUhuaEh5KzZXNkx3bUJNV3A0QVFhWEZwdFlVRzZhK0t2SUdROUx5eVgxazBlRXVlZW1oNUR3MUJWRGI1QWhWUFd0U0xPSVAxVFZFOXAzQ3F6SUxLMmVNTHcxSGt6UFNNb29LcmxNT0dPSjljZ3ZSOXNBdUhuRzQ0N1hYYnNhc25TZ2NYb1VlaENwdzdSYkM2cDNaamFMbzZUazlYUG84cGNqbTlDem1VVDhpL0h6TzhwMXd1eW5zZ1N0R3JHdHk0SXA0OXRFUjAyOCtMcXZFNGhhTkU4MThOTitGd2tFWjZnK2paQW9wVXpybHhxWkpmQ3FIaVlmT2lNZjhJSEhNUjNPeU5qdGVCVS8zZml0eUx2T0lkVVROSU8zcnU1RElKVmREMGNyaVFabFJWTnVNZGNIeTFvREtWeHFzTTlyZ1piMW4xYmtyMGdUalNIL2Q4RVFwcmFXbjdpa3dPZ0ltaThVVWNCZ0w5a3psREU3cGc4OTArZ0xqZnJWTy9QVnR4dHZYZVViSGVVOXo3SXBiQ3VvWnRyUmdYR3UwL0xKNUFUdjlhRjhPdTcvRVpaUHpNSXBBdW44dTA3OTRGTkE1Z1I4L0MyWmd1Uy9jV2w2UnIvQ0VmZVZYNTBKSVVvSEpiemQ2akdEMjJFQ3JVYWswdGdiR3pvYlFzWmIzZzR5MVRMc0dxSGNENDJ3Ylh6ZktYajEwbkJFOUc5VlRWYUtLbTFvM1NFZHhEdW1yM2RKbnMwVy9SODRCU2dOOU9RTGZVdllBbTJPQmFrSTg3RlM4MzAyMG8wTGVQajBweEp3U2JBb1NJejBSaVhhNWZzb1I5WCs1bjlKNGp3Ung4YjEyZHhodmh3NkZzYW9iNDhVZFJQcnRheWk0NXNscjV1TXVoQW1lUUpzRXdnVytRTUs2YXlHbTRYMm45Q0dYeHg5SVdqdDNaMTg0blgxVzQ5UGNyOUZ3R1hUNDJENnM0YXJPMTdVK2VEUkg3anR5NUE4K3hIQThPQ0wzay9TTVpEUmNPbjVHNVVLeXJMa3YwbEFYOGtkaWsyWlZvOTZUdlFFWGkwcjFhVGdPSGJVZjI0YmR1YUR6ZFUzL05Yd3pOWW1nTG1FSUQ5blBlRzZQQjIveDUxaUJNR2JsTVVzQWllMitySVh1OStHOURqUS80aDZWYzNwU1IzeUo1eFRHRXhkN1I2Tm5haEZEaUxoQ3M3b3EyZHprdERxTjRBK2p0Qlp0NXpaSWwzMlJWOXgxZTh1Qm5UYkFpTHJXa2tLTHl5M3llVU05L2tyYnZJa2RPeVpiT0lHbDFhdVhsSTRHTkt0OGNvQnhYdGJSR0g4NXJxWUJuSldaOUhCSWx5OVY2cTVnRlcxUVBEM2tZODU0NjArbTc5akxRZC9ZNU14WVhzeHJRNTJURjExTkhiNUppeGZ1YUJjbml4cXV4Z1NVVUQvUVRBOXhxVUhFUTUxZ3oxTTJ4S2RTeEY4ZGttZ2dCbVpCRFlTdGRFd3krbXBZdmtKYWtmYjcrbURTelppQWNOUFFhVVJzaGJKS0YwSFJUSGlOWnNqTHJvSGNBUDZKMGJxczRmQ0N4Y2JBMEJqajFKaFYwSkF4Q1BBTHZZSVQyek9lUTAvcU9aVkxZZTNhZkxoNzI3N3d4RlRvSHBBZmpYcnp2U1h0NVVVaXk2dFVLdkRoTjBPdmVIWnBNZ1ZXajJUcE9RY25pQjVoUGZONm5zdWp0MVpKLzdpMmVPeW9HQUNzUnRVR3l0czZzNGQ0TGFBTnlta0tJWEM5cC9QUk83b09iUy92V2REb0JOWndmSGdvdjZCKzJ1cnVRaVdrd1ZlbkY1OSs0VVpCS2QweFUvcCtnSzZzMC9JL1JUUUUwUHkzaVQxTDFWSWRpSStoTUdvcVhrYkFVakFxT1VkSTJHY0w5bEJTQXVTeERiQkJjb0lkNTFqanNvRWNGcEI0YXd6U3ZZcnNIdXl2amhPQmdCZUI5UUJidjVOeG1xZmxMVVVsa0VNaEZ4ZFFDK0pNcVRRaXNucXY0NFBhc2gwRjZ1RmN6SnY5cTdSZkdhNU1oUUFqWlNLVkVOYUV3ZFBaZjBUaUhGY1pWSUZUMG9GUUtjZWwvSndPSFAwTllJQlZiMzdhcjdNNUxFK2ZZQU5uQUEzeTFGNVBpK01teUFHdmliNVh6K2hMTmVtRk1MS2pQUE9CcnpBUi9NU204K1czNVFHVjlJM0ZFdlMzbXYrNlhXL3hCVWNabjUramNPY0JEYXlJaEN2bzZhYmJDaW9mak5aSXM3eEZUSVczb2lDWVlyMDFrWEFTWk5oTXhGOVMwNldxRHdaS1lIY1FSTFVicldQeVE2OXNETUlRNEFBTFBLTnNWclZ6SjJCaHlXSndTUHI3aUpiM3E1MnB1dGlEdFlXM1dZT2dJbjhNNHJxOTBuNXd6Tjh1bVBKODBsUXd4ai9LS05oRDBveWY2Vm16NFdTa0JsVEtZNkNicDlpWjZHdE5RL0lBWW1HQ01uZ0Jva2NPVFlWNHJaWFltcVN3Tm9kSVJnUWlpeUx4SFJLWC8zWWdSOE5vMXNNUVhYNXNuVXNUd0FMQkhMUUdCQmdrYmhvb1RQRmliaVJGbnkwWXRvTFJrSmx3YjZXRllWUzhqalBCSjRGbXFmRnlqVW0xWWVwc29BS3Y3elNiTzg5L0R5V3BCZFdHak5URVYwWG9mNTVSYXFzcmFha2lYSlFITnFoMTF6SUxUeGI3b0pmL0VaMHNBOFpISDVjK2JoemVKUzExbWllc2R4WTREMTlwQmgxSy9uRlkrYU9wN3JEU2JEQnJSSVdWUHJ2eUphMmd5aGorUzVBKy9aTm5wT2VtMzJkZTBwcVZLR0VObmVUenJLeVVrb2JUU09ibDZSSE9ncUpzSTZNcTVuNE85cFNYMDhVYTZTblYzTTVsd0FRc3l6TVBURjM0TEt3dWNLNmZZSFk2elZjZU5qSjhyeDdaOXhpSlhZQzQvQmpCeThXanFheGVTZ1lCSzhmbjFIRzlXSEpLcGNXd0dlcUJMNHhobnNKaTJCSUt1NUZnaFJmZHNGcVJQUHppZ1ZRR1ZtTHNPMi83dzU5MjdOeit4Yzd1Q1Y2K29lM1FoNmRBeDBsdlEyWGtWL3YyNlZ6NVl6Y05MOUhUNmZTSUxaT1daTWUyblJndXdNSVhGL2w5OXVpeTZpNUhTNTUzQmZqQnUvc09ITmozN3M1LzdQRFVaWngvdi8vQlR6OTljSEtiTmpDejlhajAybXpBZW0rOC80MGZkZzcxN2Y4K2ZPZDA5WG5wcWRhMW00SkMxNjIyVkhWd25MM1liUmhmdGVDMkpiVnRpM3I5WTVHNXcwNUZxQ2lhVDhjUkR4NUVmWXpMdVF2QU9Ca0VKZG1ib2duZ0ZTOVdnNVFSenhaaGtVMFNqUU1DY29qZk9NZUtEWm9zR0xzelVpemU5YWZkZDE5V1hzSllhNGJjOWZycklQbjZZYWp5eENkV1dpeXE5ME5NZTlWVWNGVWlNblpvZTE3TEZoZHpZMU95S2pIS1lnUWorazhPNExOUlEyM0tlR2JWd1lPckxudEFLQ3EyL0VaNjVhMjNRVFl2VnIvMjFzdG1pUFQxd0hENWt2WW53bmRINWc2ZllCV0dEaWtJR21jUFNhNEpKVnZLQ3orL2FFN29mZi9SUkc4dTJkdUhvTXloWS92RjNMU0liWDJ0c2tvUEoyTjU0ZlVnN0prS0VvVWZIQkRkS2pKMUR0enVQUzgyem5YeDRWZzRhTllVcUJrRmF3eHNIWDlzcEpGbFZKb0NsY1dQcnZDWnJlSzFVS0UzYUJJNmY2WjRXS1JvZUZIR3IwdG9EVG9GdkJhQXdhdGgxNGlzZmxKRzRQU2l4aVVLTmdPY0xvejJqNXA0cjMrME1CM3E4OHdXbDBiVWM4SjFMbGFNaW15aG9IVDczZWhQWVM1Z1JYQjI4RG9Zb1BTb0hWYWdkc0N0a0pKeHdHUkZKb0k3U0J4d1dYUHdZRkRXYThyWk04bk5KRGViVE9wWWd3TEtqaVlTOFJ4NE9kMis5ZTFLaDFLbk16V1lYS242MW5wTmNQTm9aOUw1UHE4d1c4M2p4S0ROVzVlcW01SktUcTVOMVhuc3dieXhScHRad2IrUHNvemFFdERVajZ4UHV2UU5acE5PNmNpOHgvYUE2NitvV2hlN2hYY0VuTjVpSWV6VU96dTI1MnZVbktzNVgxMFIxTEtzUDFMZ2NCUkUvQ3lyRDFhcDg1dGRuRnJqdlc0TXloZzJGM2tjUVR0L1UrbjZxbXZYRDZLQjZmOVhhV0N3QndPV2t1a2dpdWhBWGFBaGRMQmx3a3R0Sms2RkY5Zk1pUEVnZEhBZFZPZ00yb1RXUDBTbWd5RitiVktyMXl2QWRZQWEwQmtRRWVnbURjRmEwemtpcUUrT0NpQWlDTFdGUmtLRFRTWUN0UTRUUVF3VGdVb21BcVZRUkl1MGVsQmZBTEpPSXVLcjhhaW5ZMlgyQjcxZ2dPWDRPbEFQOE9JU1MrUW5tZ3NUQzJBdUNtTWdXWjVFbjlsRW9kZG5yZWs2QmpIVlNtcm84b1p5VWFSVkNhdStlVWk3SWpaZmVrajYvZFEzWTZNTSttRlBqdDB5OG1uRWN5dlZIUGVDM3R0emVvZEViZS9ZMmw2b0FkeDFIeDhGUzM3QkNwWGx6UlZKM1Z3WVNneWJrV3pZc0thQm82SlRtMGNVeGpqVHAxRlhmYWlZODd5c2U3ajhTb09iNXgydDNxRFdFNkk1VVMwZGN2RjVreUZ3Um4xR0FBQ1hCa3RCRFZEcWZTVWpvbzh5YmQxWDNES2tZMDFMZmo4L1dNMklaKzZpWmhQZE5qTWZSdU43djU4dm5PWkQvWDk0VlIrTjdmMSthSGprMCtLQVh4SUcvRVQ0d09RUU1BbEVMOXNvcTJlVEExdkkvdVdrRUg3bjBlTDZQZk5xUjQvV2hVYUdkS05hR3VidHFTNDcvRTVZT1BrcHk1NDVoVE5FYS9mT2F4eUJCdmR3U002eHR6YjY2TnRCQzhyaDNpTjl1WGZOZTN1bVR0M3ozcHE5UUx0blJIWlpkaG04RmY0c1c1T3RZWCtXSmZnRnNLZkVveHMxb2duZEdEdjhibEQ4NkhPT08zTmFLSGozY05HUXZmT0hEaCt0Sy9UNUMzV2pSelRPMzRkem9JZi9oZU0rUFNVVXZITTRWcnR2ZnQzb1VUcFBkRC9RNzVtMjU4VGFOU2V3eDJZOWRHZWhkQlhZQkNXdzZldGZncnZwTk5ndHpUbjNDN3J6WEkrVUFVZnBIbkMwVDgrUzJCSkZxQlRHTitOeitqQklvT2gxcGh4TUFCM0hZN05YMU1kQVFnREcvRlFhNjEyRzAyNEF4c0xIN05sNVMvZXNtMlp0TGJuaDJESDY5LytRM0ZaL3VuemsyTVYxQnl2Tlp1bkRqNTZoSjV6N3I2QUMzamVyM1Rabkl4c2F2bmZwdWV6MDJ3VjIrTXMzMFBRTkw1LzQ1b3ZhOGN0R2ppbkxoeS9hNzA2V3A1THdkOWtud0JkbkgwaWJHTjM0RzF5TnZzZW9YbC92T1YwK001VlBsVkNWYURSY1NxMmxicUgrZU1IYUFJbEpvWnozUVRUVFhUb3k4Qnh3T1RmWmFUUlVtSHE5eWxsVHZhNUdUV0Vza0hGWUNFdkxIdFhRMEVFVVNzamRPU1crM2l0a1JFYjlrY1gyOVl5K0YvV0syTEdIaVVSQ1JxeDBLRXhHWHpLUzBXUVN4eElkbExsMUl0VGhnWjI0cE9SRk9ZRWU1NnZ3K1NxdWp0UVVSRnp1eU1NRk5aR0kyeFg1UVFTRk5iMEIwSXlUM3Z2aEZXL2YwbUdaZi9WYWQyMkYyNXRHdjZWZWQ0V3pUTHY4NnB1R0c5M1RVNmZkWXcvdldEWkxLelZuWm1icVo5ZkRWYTNmbTlsMlM3cTBjMjc1NUlBeFVjNjBqZ2ZXeHBvcTZVd25VMTJVS3lDTmZyR0tLWXRYVDBzbFZ3ejFoaWUzSGkzTk01VU1XZHhRTFFwV2FLWlY5anpEeEsrMyt4M1ZFOGRXc2hvdElwZVFZVStCelYrU25zTDhxU29XcTRwOU0yNmx1NmpJdmRKZFhPeitsMmZ3bGYzSDVqMTBjdTJrQ1Q5ODkvdlNXM01xNCtTZng5WUZoTWRhT2VITENhczMzYmJyZDgybDhIQjg5T2g0WXZSbzZXVDNmWXVicS9jdG1iOVE0Q3FTZG5QVGl5dVhTWjgwWlBiWXdjcWlqSHgvWTJsVE94QTgzWHowNk1xSytaWFgzbjNsdUtUTFJwczVmVFJrWG5ZTms2bGtlZGFvRndDWHAwSHo4K2Z1c3ZiK01yeU5DaEl0Z1dRNDM1TG9VNkMxNWpnd1JHWEJSTG0vM0cveFd4S1d4SUE5dDlzNWFkZHZOQnZiWjkxd3c2eHBOZk1YMzc3LzVNbjk5LzRTVEY2eVpDbjZCMHlEV0FpNEp0OXp6Y2pKTjc5MGMvV2MyVmkvNG8wMVMwbkcxWU81QXp3M0JIUGpaWmlnMUdGcVJZTWNiL1Fib3prbmdSakJSbDR4STVzTGlFdzVxdXdIOTR5UVBoeC96MnY3NjBmMkhPa1pXZi9jbmJObTZWNU10azFTWDJlMmh4anEzRk9sdW1SMXFmUURkcEp0ZVZOblQwOW4wM0piVTdFZVJrd1ErOHJFNC9RWWd0UEJvdDQ0Z1pwSzNVWlJwbmdLZFE0MnlvWmxrTGg2RUlXb1BucmdOOGF4endDeStZMHh5YkJkTlptS1E5YUUwWS9kMHFGTTJLUUJUV1lwTndhakpsd05ROHFUSjJ0NTRVU0hQVmdoTGdEMFRkNVlkUmwxRzNSd2M5aXgraDN0WG0rN2wxT3FLdTF4ZjFUY09QWnNleVdvZWxTc0NvNVVUMjNZdTV2MWFodzZpd0pFTGxzK0tsYTV6TmhTYnZaQ1ZYNVJrNGUvcG52YW5vWjVoeVpYL3RycEtOcGEvTHdOeWE2R2RyTnJrVG9KS0ZJc1VJVHMwaWpIMHViODZlbkNqUTAxMTF5eHJGUTZKZDFGRkxQdTFUVzRxZ3RyTW9GVnN6bzZaaDN5WjhwUy9vUURzZDZ6N0NIUWs4bGtPRzJMTDFPWXRON1F4WFFQUGR6MG1sb05ZTVBlN0VtQXBEdTFRdnJ0c3BpNW9wS0xtOUpXVldGbWRCNmtIaC9aK0dYK3VQd0VqSit3MGdtUE1Da3ZjTDIrb1FVVmhiWFI3YUVoWTFXbGpacnlTc2FuRGpmRmdEMWtoL3Z0SVYyVE0ybDFxaXNxTk1hQXZkd3p4QkFhb0hNUkpGekVCUVlvamNSU3JHY0xyYWdCUlJDUXRST3dpWmFPOXVGdHJIQ0lrNVVZV0RjVHI2TjVxcXZobTB4RGwxcFJaMmx1WG4vdlVuWjZhWHRWZTN3cXQvVGU5YzNObGpxRk92c3J3SGVvYVVWSVlWZi9jVG5iVllhdWwzV3hUKzlSMjFFYXJlNEF2S285UHFxdHBXMU1hUWU5OGx5VVFMSzhvVmZ5YVdOVitiUjE3Y3p3L0dEUTE4eTJyNXRXWG1WTTg4cnMvVCt0VmRqVVNWVG9BMk5vZkRWL09MMzFjbFJXVW0xVDFQNVVVZU1yRWNXWXQzNmczbU1aMVk0bGNKRHpBYU9qaTdDaWwrekpJb2NJNkthcklWYUJENlJUb21CRUx4dU00bHhrcXgyMXdjVUlCQmordkE3ZmhGc01vbFo1SWF5Z1ZVV0hybVRDaGFOYmdnQUVXMFlWaDlpMWg4S29za0dGUTkzMUZ0dFdQRFFQZ0x5aHhXMHNnR20xL2FVcFF6dWxkK2oyd21hYzNGellUci83aTZweUhZK05CSW1iRDl6QWtTdkFTMXdnMnRhS3kyeHRpd2FLVHArZUZJSExFdWlOZlZmTm9MM2V1TlVhei9jdzA2NXlrN1pobENNT01uVWVuODlUeDd4VXJLQ3pJWHIvMklxV1A4QUd0OS92Ym9EMzdTdUxhL2h6R1BxVmZ1UWNzYWFsOTFlRVZvSVpyTnRmbHBkWDVuY0hIajdTZ2NtRlVsT1c4eFQ3U1QvN0RqdmxwbnhVQ01taWNXbzFJaU5yREZVcnpBSXJIUVpCR29VeE5LZHkyRVlic0hRUXBIa3JTVTZIZWFLSGtkYkRNSTlOV1dOWW81M2wvS0h5Y0lnTzFRUHNaRmMrcG9OeEt5dGFCR0xvYmJGaUh4dHBiTXVLWFcxZ1FSYmRERnBlOGIwSFRNQ2tsdDZTem54WStoVmlJbXQxMG41dzQzUTREMEptMUhnK1d3K29KdWxqWnE3K0R6QjdDcXdTcE1uMFhlYlQ4QllPOGdDNkh6TUx3eFRNbjNsK0pzOUk3ek5ROFJHVGhueHRGeGdPRlYxYllEZFVna2RaR3RSeVptNzFsU3k3anVYRzBleHJIUHNWQS9WbTVxY2NlT2N2YjB1SkUxKzlDN2ErRFliOUtudjZIZEQwc25Tdy9iUFJRSytrazgwYzNQc3krUFVqWngvNzh6MmZ3eFV2Z0tjT25udm00NXNXVEdmWU5WTS82UGtvdjJ3VlN6L0RzbU1Qc1BTZklRUmZNTURJTThFSkhKak9zeVd6RmVBTkZiME4zTW13VWhsUDE0NkgzQlV0REZPeGxLT3ZwT2x0RExkeUc4M0NPOW4rUEp3TGpmemp5YW9wN2RjeFdQRHp5YXVoaUd6cEM4eUtKZWNpWVNEbTFnWG5DUVBPbUVmVm50TDJCSmQySjJMUldNS2Q1aEx0cFI3MXVGcVlxUjMzeUozdjNJbis0QWFUcnJ1cjRXeUdJR1ljYmVnaUpodmRmVWRRV0RsN3pyQVNKdCtRcDFMbEdmS1prbUZ6WmxlT21ERUQ3bDU4eHgyTEY5MXhoelQ2cU01MEV0L09FdGlOazBUVHV5ZDN6TzBua0hkVVVrWFVaR29Cc1ovTGFZR2dFWXZwZlIzRVIxVUROeHV2WXk3eExuM09JUzU2Yzh0RkdHMk0vR3FsMFJFeHI0RWYzWkE5MmpCYTZTd1pVODd5Y1V1Skt4S0t1RW9zY2ZpWW9PMG1BTXE1NDRCVzBBcm5LVUY3bHFDS01LZzMweHZRcXk1Q3J5dzk2YXNkTVhsa3BISGV2TWJTem9WdFNjYWp0aXJSUDZ2YUF4alU3UWt5czN6czN5cTRNSmE0OXNGV3cwSU9KMGNoOHlUNWFJd2JRbzJoVm1GNzRTanNvd0JJM2dqMmdtWG40Rko2L1hFYnZ5TXVUdy9sc3RNQVl1cldlOVp2NVlneVJkb3J1VkpIY1dGaFliR2psS3RzajVoYVVwQktqZDN5a3kxYmZzTDQrcXZTVy9UWmwvVVdpeDVXNkMwRFZPelJiQ0x0NysrQVF5TFFMQng2ZHpDK1o5R3NTc2FwTnl1VlpyMlRxWnkxcUdjOHJNZUZiNUgrME9lQUFwZ3FjTW40QU5RWFVrZmhiOUtmSnVYdjB5VmpBMTdjZmx1SUpJR0pCRnZpa2FrdUhYY0QyTHVmUE1nZlIvbDN4SVVCdEhVSkZ3dVh3TFZocUphVVJLVmFMbTdZNi8rREprVVU5SFZHeHZydTc1OEJRMzZqbWVYclRGL3p2dDB6L3FJV0JzK1E1czEyOXpYa21iN1cvYW92N1Z5Y0lRU0pxYngvRXd2TXF4ZDZRdGZBdVJocmFCU2dlWU00SWZYSklMbUVSNWFkU2xLR1hzK012U3FPWDRxYjF6USs5ZHBUaldzMml3dEJDN2dTdEZ5YjB6YUdwMjc2VEhyOGlTTURGQVovdnZ0VlE4dllzUzJHVjNmdit1RVA0V0VaRGZ3VVNFbTNTVC8rNnlERndndjFNbEFCcXBqWWFvZ21pL21DbWlWMkRKbHpIbWd4VzAwSjBadU9oM0tWaGEvSUpkMklGU1IzU0k5L2hzcGtsdHgrUWEzeDlvYlBONFBGbXo5L0lGZGhqc0s2bEVkK2pDcDg4MDEvQmEzazlyUERYdjNtYmxuWFV2cm83bTllQmNONmVnN2thajBRajhValc5dUFBVU5ldWxlQndXS21TSzFTQmdGdkJjQXc1dzF6WkJlUmVUUTJmbHBEOGNzM25udnd4cGVMRzZhTmo0MGVjOTJ6eDUrOWJneVNPR1JkN0tKSkcvZnN2Rlc2K3RhZGV6Wk9ncC9yU21kdWVYUHpYZSsvZjlmbU43Zk1MTlZ0M0RrZjVVWTN6ZDhKaGR6TGZIUHE1cm1mQVRPL2FSTXYvZVd6dVRmMytadG1aWDhMTnNxUDlYcjc5U1l4UHFBcllZUGFTd0E3OWFGcER1Z0tZeXJhMzJ1dkdCUFp2dTI1YmR1ZUF3Zk9vZEdWbHJta2M0VFdNSmtmeGZTTlNIcEN6NFFKUFl0blY3YTJWczRHVHhGU1BydWY3ZjRHSXpteHIzNlQ2UjFXY3lNQ2hubnZIUXV3YmtrUlZVMjFVcDNVSER5ZWtuMUlKTDdMMjlXNHV0ODJuQTZPQi92R1MvbU5MaHBlKzFEajh3ZnYzZmJvZlUyeHpKT1pXSk5QWDE4TUhpeXU3eUdxTU14eTFNVkovNFBvWGFXZVh1TklRSnl1NUV5a1pKT3B2bHdZVE5Payt4ckYrWUVkdnlrMWJXSThrNGxQbkpaS3Q3V0JnMFRYUmpwNVllenM4K2ZTNzlBdkVTd2w3ZGUvcS8rcmR1d2oyUndod0c4YlU0T0Q0dXdnRGRpTHg5aExFeEp1eC9waWFVSnhmYi9XL08rM1k4L1hpT1M0bzRPSHp5YlVkdW0rbGdUdmtGYk1YbkNNOU1VbEd2RkMycm5EVFBkWlRKWURoMHhJZkpTZFJ2M0lUdEFaRGREdmcwYURDVHM1WklpU00xbVpBZ2tSYjRBalFZYVR2ZGxpNTQ2eVNTUmVPVW9nWHVhUGI1ejY0UGp4RDFvcVJWK3FmRVFrbWwrMjRLRnJEalUyZ3EycmtMZ3k0c2FwdzlaTWJjaWZzWGlYOU9IdnRtMzdBTGh1WC9mSnNUc25ITGd1TnEycXRnRitpc1NqU3VrbDZVWHBaOUl2akVVMXpVVXV3NHpPeFhOdWw3WTQycGQyRGdtMWRLUWRsLzhDUkI1NEVCUzljdm53RzU3OSt0cm5wSjh2YWg3UjJqc2V6RkZTN0c3S2l5U0dPNm1mRWh0UG9qYUZYa2NneXhDNVJYb0QwZmtQOWxtK2t1OW52cUFtMGV0VkQzVkNzcVNHc3ZSWGlMQ1F6WDlaZXhKdmxoTEVHS0l6UVpiWThNSUhZelc3V2FKWkVpSnh3Qm91NkEra1UwYUNMNFR0VFdWbm1FaUMrYm5YQWpUMXMwNjlIVjRlRXJ6MU04dldYQkdmQUcwNnM1S3Q5N3ZPSHJPSC9DNm0waDU2dDlFMk9XeFE4NFpRRktVWWFYMlJ0WUZXYWF0RWxxRzlvVlI1cU5BVk53Qmc0aHhyN2lnYjFseG1jem1FU0x3bVVoTjJHaFFjclZCcGpDcXJzMERsYUJoZUM5KzhUcWdhTmM1cmNGZU5WajRSU1ZZdGdLSmFVQ3U4UXZPVk03czFjSTRsbjladkJFNndIWXdIeHNRQ2grQ29uOXR4N0J2cGoyK01uMFRiRFRaeGd5c2NzcU1mSExGMVZtaU1XYVhobElYeDhkR1JxVUpXRTlPSzlwSDZLcjNOWXFzRURBTkwzY0c2YUxRdU9MT3V5TXl5a0Rhb2k1NWZuMTYzWlBHYVpIbWsxS0RVbUYxQ0l0R1NLY1grcEN5aTJtbTFqVE0zajl5L1RUcnpYOTcyYWJVZWczN1lXUFVmUU1ubTQ0dldMS0V0R3F2UnJCVHlIOWdzZmZSd1lmLzFoand5Nnd1cEVJK0VPQkc3cWJLS1BLZ0VmQng3Z0xuSUNQdmVuY3F3OTl4K2w4V1E5enNJTEdwZUxjMUFGTEw0WkFZdXZvUTl3bi9CSHhlSE5OSmphcWVOSHdvYWRRcFdKVjM3a1RqLzNnRGNmU21EQXE3UHQ1T1c3Q1FuQ0E0cWxkUDlTNldOQ2FNYldER0tvbXc0U0VqTW0wcWJpWi93TkRHRXRCaEZJV2Q1ZzM4UWp5ek5WVDFWelQxTk5laTBwdWtab0hxbVIxYnk2eUhuUFVmSlAyejhYalBiUWw5L2JwVmxkazNiMWhLYXdrbFpxbVJyMjVabm50bnlsUFExNEo4NnNoa2V3N0ZzNVdad25XeGNRd3hzL3Arb083dysrLzl0M2NIMTB2OUszY3NUbHYvMXVsOS8vWCtuNXYzcnJpVHpzbHo3dnJxanVlUS9yemY2KzNkcVBYckZpdEgvY1kwTmZSaE1lS1VKZTZ0dnBrWlJFNmd1YWk2MWxGcE5YVWx0cFc2aWRsRjdaWThYb05kWFlCU2taV3k1ZkdQT2tVcEt0R0xzVEpoelNjM2s3SUJTdmZIZU1DbW5CQWFuRDg3L0xmZjMzc2NOQ3RrN1ZhcnNUU3E3cWtPbEtoNHVWTFRNWGJqclBJVVo2WVhQRGV0NnJhTVlYY3FYRlhXbmtFQlc1TTNlbDFQZWxUV0NxUUdKL1ROS0ovcEhjaGxrQytRcC9ZNHNqNTZENm9HcVlWY1ZkLzVwMXJCZEM4OGlSaDF6OVIwdFlkZVFZcFZLT2tUdW0zTFJNVW1LNlBtV3F5Y3VTZ2xkbElJdFcvdDg5UVdwRW9LWU9wUnFvellpZWZ0RzZuWnFEM1V2OVFqMVkrcFo3TUVYNzNqMXNYekVVTDB2aHY2b1FkcmVvVndvRG9xSExzRmRWb01jSHA1SWxoWFJCTVFodXVsUE5uR1IrcFp5dnEzOHdlbTljYTVIZG81WVB5UkxEYWtYdE5oeE04eVluQ2FUczRNY28rUzRvOSs1ZkdRNlpHNGRTU2E3Rmk0ZUdaMGZFZFhxUXJWYWVva0VZa0RwRENiS1d6Rys0N21laSs1KzQxK215RThEUjQ4K3NPb0YvSVRWb3JqVWFMVWFuMTcxd0ZId0Ezek5GTzEzTkYyVWt1MFREMkRQd2wyakJKMTNZT1dpbDhmOUdIUEpCSTVlZEcvSHYweVIvd2pQaUhVZEtWWkM0MnlHR2s2dGtIVzhlQ1RPRWxiT0M4d1lOZ0dydnVMLzJIMTVBUEZ4aEdQRFBDUmU1a2ZjSDFZWFRRWFNLU1RQOTVsVm1HVmZlZGhiSHNDS3hZUzdKUFpnZUVzcFN2WmZVMjVBbnpaNjhrVHBuSmpuTVlLajBDMzk3VDBGUmwxZ0lGRHNlLzZJOVBLUE41dytNQjJBbiszaklVMERCUVI2eFcybjF5bjQxVDhGOU0zM2dOajdtN09uTnorOWVmUFQ0T0NpYVFyRTIxaDVWVlhEcXBkV2JEbXFWVFVPVWZGNUxEUW9waStDOURVZlhIM0xQMjhGa3lZc2UzZm1sQ2t6MzEwNjhYNUFmUzV0bUVCcmxLVW1yMTVKandIeEp4OEhKZmVyK01XUC9ISGprOUxybzJtbEpVOFoweWcxVE5YdlFkbWhtd0g3L0hxbGFzVng2ZjBnZnVibTg5VDZ0NGR4Q2xXeVFLVks3ZWhZOXZRTWpmNW5XNmJlWDZOU1JaSktCZGR5WXVQbTA5ZHkvTmEvNW55VHkzYkZBcG9QQ0pyN0lKUmxORXljUmQ5RDNvMlE1V1lNUDl6ZFgxNEJjamtBMnkxU2crVTNmc0M5SjhseVptNWhpTzd6NzBCVEdqVFdVeEZnakVBMGVzdnJzamtVcmd2VjZhc1RUV1VSb1dBb2VDVHYwK2dCMmYyOUN3R3dXM1p5RGxHbTgrZ0twSEM2dko2STAvRUtRVmVmWDNiODd0alhMaFZNcDVJeFFBNGhueDZFUTJRdkVqc3B6S0dnV0pIRVAzaWw3bnM3VktxUFAxYXBkcUJoRllWMjFhQTR2S3ovcTcvN2JkbHljVWJvMzZaMHYvcko2ejcvdGwvY1FiWDhHRC9uZ1FmazU2QlFOU2grVG52eEp3WVBYRHB2WDF4NmxhRzZCOHFzdldNOG9TVU1oSDBSV3g4RjhleEs2VFcyK3hJOFBKZ0xrOWxmZ2VPWDR0ZDVVallrdWgvWUYydVVhcVIrUnIyRnJVeDA2TFhyQU12SnBuSFlUczdhMTBSeXc0UjdyNG5tSU9ubUJMVUg5WGdoUmJZQStUcmdBYWt3M3ZERWNpRGU2VVFYMFRpQzljelNvYkNQYUZkaFdSTmJuM0RvQXI2T2NTN1JjSU5SY3ZCR2Rqb0srVG9tSVJJOUdWRyt6b3JXVUZqSG9BRW1aU0k2cHRpaWZURDJDS3ZXRjJqVXVxUkJtcUt3OGdvRmIxWHdlLzBhdnphazBjakJPcHpFSzBRRHVONjNNeFdLTWkxdG1SQVVlWUhUMFN6TnYwaGJ2VDZ1WU5KUW9WQ2pnUUVPMEhSUkJhZGFPSzVtc2RQTkJ4S2VrZ2s2WjQxQkd3OExVYTFXcXlvcDAwTElnNkRiSnZybitQS25IREVBbFY1dktTcU1EQmVnMG11MFZ1UjVMRnFkZ2k5WXlBS25Wc3U0UlkrZ2gwby9GRzJGZ2s0cmxMejBoR2ZDYWtkczBmejY4Ti9SaDN3TWZiSEh5QmRyUTErczdYTW1ZRFFXbUl4czRDMkZRaUhpVnhJNy9GcHRTT3ZUK2pXYXNNYS9HcWNyRkFaeFNxWW81R3liT2NIc0RrQUxaMUZaOUtJNVR6S1pYVHF6YWxqYW9GVURVRkppanFoVWVSM3hjVnRVZktJc01ic2xwV2N5Rll0WFd0UkNuaDJBdUJQZDVHSm81L1RyeTNXaVlVa3M2bnRpbUVHdE1kbXFSS05RNjRhY0VyQjZsZ2Q4SkZnK3QzVGU1YTVDanVQamtmcnF4Z1ozeXA3blRvV0t2V3JiWWFEc1RtNnFtRForTEEzQnVrdmFvSU8rZFZpTUVHZ1VpWDE1UFVqUWdwOW9KT1lXb2VvWWxNWkJqRlRqejJmTDhYY1hUR0hzbDZxY3pZK25NV0hnL0hqZEQzTHpIZzBHbTBxTStmTjAvRHlYdmlZMVVmckh4Q2xnanIrc05oWXZORTJiekNYWUhaK1VGR2R2a0xadmFpd0RDbG9OWTAyYndGcjQzUFdmY0FhR25lYjFUR2pPL3RhcFowZGtWd0NXcG1ISjhKdWs1NlRuTnpYRmdTTDcxcWhXUm0wTDF4VytGNVE2YWxrT2FPYmF0S1ZwdUJucytMSTJxczJicTNFMFphZE4zYkJ1bFRHM0gwSjBYSXhVTVZXS2VPNnh1WlU3SkEvb0dMOHg3cWFkZ01VUlNCU3VhMmpNWXBQRWhORVAwSThQaGYxSWhCTVNBb3U2Qyt2eis0cUFNWjRRVStFUVd5N2JjNVNqRE9sTDJxdmNCUUJrRlRxbEVrbnZFTlFBd0tnVlNwYWhHWTdsRkN3TnpuNndmajA0dkhDZjA2elp1NmhrWkJGNGdLVU5KcThsWXJRb21FNXo0SUVLR29CYVJ1OXpSVDJybHZMdVdOejdlUDh0T2ZqaEVVWlVHSGdGRGNxaGdqYXc0cXgxd0tyUWMwclZicWppMVJ3R0dPRFVyTzRNZUU4cUFPLzk3cllSS0tpUVhnYjF1a2Fyd1diUXNEUktTT3l1MjdmRjVmWHJmWGRKQmU1QUxXMGF0TmZCVXFYbm9hS1YvU2VhMFN5VUhiWGl6U2d4RkNaZXkwUUtEeXN4ck5NdjRORUU0TTBGb3FySjE5SFk4d1Vmd2twZkVJMXBzRjVHSXVEUis0ZXhnVFVlUE5CTjJOS041OEtjMzB2UnZwQ2Z3ekFFb2pWS3gwQVU1WVBXSEdPRWg3SUFnN2dpWmczSGFxTlhMbHJsTWU1dEFCM1N0UHR0WHBvWkYyVFhGL21LM2V6K0RXOUtIK3piS2YxdG9WdGZjOS8zdGtVSzhndVVESDNsTHcrdWIyYjBGYjRydm43ODFtQlE5TnNaWGZseEtidnRTT1M2N1J2RDRadlh2bmltUldkdi92M3JwYjdobllFZ1JzdHBBWWlramY0Z0dqeWl3eGJGWFRSa0t3c2F5aEkraFZCL01BUFZZeVBibk9WNm4zY3Y4SVBLWGI4OS9YTkFLOXl6bHp3MGtmYTlMYjBEcTUwam4waVZkOXcwQkpabXhrVkZhZThCRUhocjQ0THVxcm1KSVJhT29ZRXJHRlNwTFExdE5ZRVZYMVp4a1lZbVc1NUJLZGhtNU0wSW1wbnVBOU9HcURYVzBDeXdBU2kzdFIyWFBya3NYMjFYMFdBSzBJTDR4Z1dkZHJ1bU9YVHR6WnNMQzZGRmI4OXpPRFFxVDQzQ2UvdU5yeHk4YkpiVHAyK3BDWTI2VEdwRzN5OTRYc085eC82TnNxSmVrS0VtRW85VHFWQTRCNDJHRlQ3NEZOQkJKb0M1ekRvNnpkbUJCaUJXa3pkRE0vRWhSRFprQUJzRnhlZ0NCNjBoV01jUWZIazZSWVd4WHlVM282UFJCMmRyWGNNbVZHMmJZOUxvL1ZaUGxTTlFYeFRNTTJ2VktyQWkrZnhmcEMra2J6NS9mQjRMOUtvUWs1ai9CUmdIdXNHVXk4M3d5ekhiZjNMOEo5dkh5QUZZUHVTUDBxZlNMNlgzSmVsSXU3dU1IWG5UczZjKysvdnAxMXJ6cTJvMDBydi9WRUJvMy9qRzltNkxkZmF0cDdZdmZ1YkFUUGg1OFVPVllaZlpZVld4TktOWGFZUEJna0Irbmhaa2Y3bnA2Umw1aWMxSGdmV2V5TVRJV3UxeGFhc2szYVU1Y0k5RHkwRFA4ZWZ3SnRCemNzRHRQRDVMTWViUnYwdjNIRHNBU3Y3Mnh2Zm1SS3pqNzdrc2ZwTjAxZC9BcENZV2xUejF0bWQvL2ZwUGRreUc3dGs3WHBmMVNjZ1lRL1lCOFJwS1BkSHBYa1p0UW4xa0gvVkRpaElzZmgvMlVJbDRSK3k1TXZFL2pRL21oZEJZVmtSKzVkZ0ZhQ0plL2orTUgxMXVLRFdnditYZkVUSS9xaWc0ZHhUN1RLVXpCUldJTWZydVcwZ0lxQjZEd2VCRnYzLzNiUDgzR2Z3WUZqL3NyQUtub0N1ZmYwY282eERHMFB3MkJuMmJXekN2S2R2aHhyQTBGUXJUUWFNVmE5K0VZb0RZbmRUaWE4VEZpcEdsZFZpRTdsWDFJL2dwVnJZRXNNVHFvRGZGZzQzTlJLdkFHbVdBbFJ4MHNRdGJwN214MlprUit6NFc5VUMyN3RVRDhqZzB6UVMxSUlndGZ6bjNvYWV0V3EwdWJuMDZyWTBQMDg2Vi9ucmNBUFB5STRibG9XUm91U0dTbndjTng2Vy96dFVPaTJ2VFQxdmpPcTNXK3ZRaGwxMVo2QUlwQWd6NUNxTjArQmk3QXhka1Q0cTVjb0QrRXVVQS9hQnlISGJHNTFBeTBpc0UwekxsS2xUYXdjSDhSZHFFRlZWcTRmNVFRaFVFeFhkTHg4NllDajJDd3RUekR0WUZmS2ZIcEJBOGhhWXpvUEp1NmEyZ0toSGF2eENWWmsxb0YrVnowVmcrVjdkblR4MElGQmV5dUtTb1RpY1hKTDExTjZpOGRFSFNzYnRCOGNDQzJNTGlBTUFGY2ZteGFLL05qTXlIbTdCRUJUQ1RpeWNWRHM4cUFaTVNpQ1kwaHpBOEMwSllSa2JqVm9COW5tL2ZjWHpWNWUvZnU0QkhaNzlldFJ1WUh3YkRwSU5yMTZuVVI2UzNqcHl6Z1U1eURrcU9ISUozd2VtcmYzTmdEcytQdXZuMVZlUk11WjA2ejlSSzk2eVNYcm52Q2VubFk3WnJRT2ZsSUgzZms2RGltRTJjSks4LzV2RC9kS2hlSXFwWml2aWdVd08vRUU1YmVjUzhsQUFySHc2aUgvTmRjSDJQSDB6ODhLR3l4MFpaUHJkSVEwSHAxZEp4Y09MemVaK0JUVC90ZUE3VzRnbE5la0g2NE0wTkc5NEVQa1J0dmpmL2NpbDU0NXowQk9pU3ZnOVc1NWZOamNNRnFKU3IxOHo3Yk82VU1jK042U0ozYmVoZkVseHpDYTRReWF6bkFUK0ZQVTlOb21aU2k2azExRlhVUTlRVDFBdlVxOVI3MUVmVUdmU08yQWFuRG9SbFNHRWFXK0tnZVJxTEdMVHM3d3FiUFhORWhDQlNnbFdVVnlWU1pESENHaWZ6UFo1MVVvd29MMS9VQVNEcUFEa1JxZHk2QmRhM0UwbVh4QXFNSXJvbGpMUGsxanVpTUpYRzNZN2dsYVlRazRIWVlwQXJUYjZCbEVkZ2pYQ3lYQXpvZTU3WVAzTll6b0ZTMlJRVFM1YlE3TWdXVmpldnhFMHprS2Q1bHNjKzBOVUt0WnB6Qnh6QW9MUm8xQ2wzWktIVkVBOFdpV09hM1JFVGZ3dkxlWFFPRHM0RVhLTFp6SXh0NTh3V0Z3TTM4WnA0bWJHcE5YNXVDR2ZRNjJ3MGJYRENpUnJlRjlHbzBTRnJDZFNqU2R4a1FrZVdFVFFWUTBJYWgzUElOVVBMRjA5WllyNXFiNjBHelB2YnNEZzlkazFocUM3QWxDOXM4bTdkOStpdzRkdlhUWXB4eVdhTDkreEtuZElzbEduSjhXSEc1SE15dEdBd09wbDdHWXRaOENrc1puTitkckZCNzNUVUdnejZWQjM4aGpIbzliZ2FxREkvMFN0Rk1lVldGWmVEYUo0WjVObGpUejBhbmdPQkVVSkFBNXFob1paVnNSd05XSU1WNkhra1l6bTBwbWloODhZTnQ0Q2hzeGxvejllQ1ZRcTFqdGVIVEYrcVEwRnJTSEgvUHFVTGhBelMxODd5MlhsS0xlMjUzeTAvek01Sko0eVJQSVVSSCtoVVNpT1lNbmFIeGlSa2diTXhwS2xvTUFzYW1Ga2hmVDJ5bm03dll0TktNS3hrL29oTzNZcWJEMVRWYkY4NVZqbit5a3ByMnNJUG1iNXRoS0dqZXg1Y2JpN1RvYmNtUjFSQmwwSXdvdGRtaEhQVlpoL0RXQXA4TEdPbEZ6cnEwV3M3bkhVK1EzYWMzc2JRUnAzZWp1cHpXa3daOUtyaWxGZjFmd0JVQytHMkFBQUFlSnhqWUdSZ1lHQmhQRDNoZkVWa1BML05Wd1p1ZGdZUXVHSjgxZ2hHLy8vL240R1RrUTNFNVdCZ1lnRHFBQUJrSXd2WEFIaWNZMkJrWUdCaitNL0F3TURKOEI4SU9Ca1pnQ0xJZ0drckFIc0tCYzRBZUp5TlZrdHJGRUVRcm5uMFBJeWJMSVlWTlFSV1NVeVVMSXFvNkVYbXNCNjlpQjRNaUNMaVJTS0NKM05xL0JuK0Q4R2p2MHE4clZVelZUM2Z0Sk9zU3o2cXU3cTYzdFdUek5ObjRsLzZraWo1UlZUU2YrRjF3YlR3UFUvV0FpZDdQenhqZkhXZVBwbE1ZWGNZcnVOZEszVFBkKytaekJqa1h0N3Bia1F1MDMxcjIvZDYxWWNMenZ3RW1SenNyNDFWZmNtcHB4aHZPZVNkT3ZRZHpvdVVFdmJsTytQNHJOaEcwS2llQjRLeTUwK2NEN2s3eGR4WURoUlRGOVZDNVk1YmVJaWp5MlVqTWxXVWI4c0QyS2ZNUXg3Nm1vUzRrWnF2cmo4LzRweThDVG15V0hwN0VuZUtQcDhKVHpPTjIwVzFueXI5d3Z4RVpmSzRseGhiQTc4OTdaU1dkMFd0T25PdFplcXBTVFZ2eHNPZVV0MkgyRWVjcjhUeWhUMVRRdnhRdXdaekVzNThWeCtOSy9qSXVoYU1DZGZnbVlCOVd6REMzbXprWFkweFZzdjFzS2VqZm9IWnRMTkc1Mi9DKzRYZVRkbkgxSEtpOUsza2lmR083enNCeXllRitzTHlFNXRQWG1kTTk4YnFyWG01YUxOdnZNUVA4djNRK0d3M0U2eWJMNmpkL2V3YjA0eHlwM0V6ZlFROWRrUEEvQmFGd1VPdkUrMUlEMFk5dkJISG9YYVg3UXp4bjBEemFmTnNjdUV1KzNLa05MeERwZkswRHZQU3IxYjRwckxzYkdSV3dxeUtUQVgrVzcxbDl1dE8vZ1RmNlRCWDFMOFA1Vys2RmMrVCttbHZjeHRYalhkNk9xMTYvdHpxVWErcFdZUUQ4MW45bnpPMndjWlMvWG5NNjBzZ2h6NC80Zk1ySSs5Q2pLdU05M3orU3YyK3JYcHFwZ2UxK2g2RDVUWUYrRjFBdlZWRUxiOVFoM2JOUG03Z3U0eDF3RHVEdGRaWDk5c0Y2TlFlVDYydjRMMU5aVVpadnRDemxOZnRYTmhzUUoyRHJpcnlJZTZKNmcrOXFIVS9saWZyYll5N2dQT1N6dThOekNmbXN2d3hPQXY5eVBZK3RIZC85dnBEL01PYVhHYTVUYWE3WTMyaDcvaCtOYzUvSHZuM0ZHek56UmVJYlc4c0x0VjluZmNmV2UraDhyTnlxRnZXUzUxLzZjZk1abHoxQjNtM292MUN2MGNPN1huYXdoNnhiNVdlNzlkRFc3T292LzdwRGVEdjJ0MThCUEMvUlJMUFJVQUt2ZTdwcnVSY2Zid1RaRHpkRkhyZTd5LzFDbnp4ZUp5bGxudFV6MmNjeDkvUDQwNHV1WVlRR21uTlFwRmtpaEJpSWVNUWk3a3pzMm1iVFlhSlpZd2sxN2swbDYxTnlEM2tIaWMwY2crNWg1QnByaUhzWmYvNGYrdWM5L24rdnMvenViemY3OC96ZlU3U3YzOGUvd0V4a3FrSUZrZzJBbVJJaFlKQm5sUTRWQ3JxQ3E1SXhVZEtKY1lDOWt1eVhzb05uSkljb3FUU0E2VXlDVkpaM3N2eDdraFp4OFZTZVhJcTBLTkNwbFJ4SWlpUUt0R3ZzcGRVcFp6a1JKNVR1bFIxdEZRdENNUkoxZW5uekhvTjhtb1dCM0NxUlMrWEdRQk90ZU9sT3A1U1hSZkpsUmhYdU5VTGxPcG5TMjcwYkFBM2QvTGNVNUJIRDQ5SDBudjBiK2dQZUw0ZkR0anpSTFBuU3FrUlBSdkRxUWs5dmVEbHhiczN0YjNoNjUwc05lVjMwekJBVGpNNE5rT25qd09nanM4bXFUbGVOZWZwT3hUa1NpMzJTSDdvYVFrKzhBUHdhc1ZlSzNyN2srOVBuUUQ0QjFDN2RTK1FMN1doZHh1NEIxSXJrUGkyN0xYanZUMXg3Yk9rSU9wMlFIOUhINmxUb2hSTVRHZHl1cUMvQ3p5NzRQdUhTVklJbkVMZzF4VWRYZkdwR3p5N01ZUHV4SFZudnFIczk2Qm1UM3pzUmQzZStOUUhYL3BRT3d5dVlYRHBTMXcvL081SGo0K3BFWTZPQWVRUHdNZUJoUUZjQm9VQXpzSGdWR2tJTllmUWN4amNoNkY5T0xNWVFkOFJjQm9KdDArcFA0cjh6OWdmemRuNEhNKy9vUGNZemxJRTg0a2c5MHR5eGxFbmtuTVRpVC9qV1I5UDNIZlIwZ1RtTVpHMVNVNEFucFB4TUlyWlJWRi9DcmxUNERrVmpUL1FKeHJ1MCtBd25md1phZEpQeE05a2J4WTVNY3d4aHIzWm5JOVkrTVd5Rmd1ZldOWmlPWmR6NkQrSG5EZzB4bEVyRG8vbXduOGU1M0UrODEvQXJCWTZTNHZndW9qNS9FeXZ4Zml6aEhwTDJWdUtkOHVZV1R6N3YrRFBjalF2UjhNS1pyWUNuaXVaMXlycUpIRFdWdU43SXJVUzhYSU43MnR5cExYMFdvZkdkY3d4Q1c1Sm5PdjFlTFNlNzJNRDNEZndIV3lBMzBaNmJXUVdtNWpMWnZ6YVROMHQxTnFDSDFzNWgxdmhuVXplTnVLM3dXbDcrbHZzZ0VjS21uZWlieGM2ZDFOdkR6UGNoeC83OEdvLy9GTHBsWXJmQi9Ed0FEb1A0bjhhWnlZTlBvZm9kWWc2aDZsekJMNUhXRXVIeTUvRUhLWG5VWFFjZzM4R3RZNmovemp6TzRIV0V6eFAwdU1rNnlmUmZBcFBUck4vR3IvTzRQc1o4czR5cDB4MFo2TGhIR3ZuNEhVZWI4L0Q0UUsrWEtCSEZyeXo0SHlSMkl2b3ZJU1d5K3hkNXB1NEF1ZXJyRi9EbCt0b3VNNjV5SWJqRGVKdk11TmJ4TjJpZHc3cnQva1c3NEM3SUJmZjduR1cvK0pNM21mdkFiNDhSTk1qY2gvekhUM0JoeWZ3ZkVwK1B0N25VK3NaWitJNXZWN1FzNEJ2cFFDT0w5SDNFdDR2NGY4S3phOVllMTFjUmhWbGlteVNLZnBJcGxpK1RQRU1tUklEWlVxV0F3dGtTam5KT0JRR0syVktlOGlVNFNvdUd5M2p5Ry9IZUpueTZUSVZmRUEyMTNTTVRDVTNRR3psWHFCQXBzb2VHYWNvbWFwalphcEZ5bFFQbFhFK0pWUERIL0NzU1U0dDZ0ZGl6NFc4MnNUWEliWXUzT3FPbEhGbHo1VWU5WWZLdU9YSXVBZkxlRkNqSWM5R0VRRGVqYS9JTlBFRVNUSmVDVExlckRjbHBwbXJESGVoYVI0azQ0c2UzenlaRnZUemc0OWZwa3dyT1BvN3l3VFFzM1dhVEJzUXVGaW1MZkh0UVB2Uk1rRThPOENub3d0QVl5YzRCNk83TTc1MFFVTUk0QzR6M2VEUVBWQW1sTGdlY1Bzb0hCRGJreDY5dkFBeHZkSFNHKy82NEc4ZjRzUFEzQmNlL2RnTGo1UHBUNi8rS1RJRDRQa0plUU1UWlFhaFpURGFoMlRKREdWT3c4Smtoc05uRkJwRzAzc01kYjVDMjlkd0g0dTJiNmovN1F5WmNlUkU4aHlQUHU0cU00RzhDY3h6QWpPZWlLK1RxUHM5OFpQaE5wbjlLUEtuNE45VWZrZXpONDNjSDVucjlEZUEzMHcwemNUYldmZ2FRNy9abkpzNTVNZnhuSXV1dWN4NkhyWG5FN3NRWFl1b3Q1aTRKY3h4Q1JxWHNyWU16NVl4dy9oVW1lWE1aUVc5VjZKbEZYMS9uU2p6R3owUzRNc2RaQkp5MytKM3ZQaURjN1VhYjFkekZoTHhaUTFjMXZLK0ZyM3I2TCtPOXlUOFNPSjlDeDV1UldNeTNuRFBtTzNzYjhmZkhaeUhIZWhMZ1ZNS2ZYZlNiOWNic0xhYldudndmeThjOThKdlB6bjdtWGNxZWc2ZytTRDlEOElsRGQ2SHdHSDZIR0V2SGMxSDRYeU0raG4wUE01c1R6Q3JreUdBdmRQTTZReTl6bktXenVKUkp1ZjFQUHd2VURNTFhLUVdkNFc1UkwzTGNMbUtEOWZJeTRiSERmWnUrc25jZ3RjdDlPWEFQNGN6ZFpzK2QraDVoOTkzNFppTGo3bkpnTnIzcUhVZmZmZlJsSWVHUFB6NkcyMFA0UE9RdklmNC81aTZUL2grbjNEdW44THRLVDdsdys4WmE4OTVmNEZuQmNRVW9JVjd3N3prTEx5aXg1djc0bldHclBHU3RjNnloVHhrQ3crVkxYSkt0bGlJYkFuV1MvTGI0WXBzNlR6WnNrNnk1Vmh6ekphdDRDZGJrZmhLZ1ArdmJCVlBXU2NmMmFxdXN0V2laYXZ6dThZbTJacWhJRjNXSlZLMk5yWHJKTXE2QnN1K1EzeTlJTm42eExvOWttMHdROWFkTmZjczJYZmpaRDE0TnFSV3cxeFpUOUFvU3JheFB5aVFiWklzNnhVaDY4MStVM0tidThqNmt1OEwxeFlPZ0pwK2JpQlR0aVhjV2hIdnYwQTJBQjF0NG1VRHFkR085NkJ3UUg0SCtBV24vQi84QTJXOW4zUUFBSGljWTJCa1lHQTZ6Q1RKb000QUFreEF6QWlFREF3T1lENERBQjBvQVUwQWVKeVZrOTlxRTBFVXhyL2RwRTFycEdEUlVyeVFRVVRCaTkyMGxCYUNOOXMvNlUxb1lnaWxWK28yTzBtV0pydGhkcEtRYTE5QThBWEVLeDlBdkJlODlGVUVIOEZ2SjJNVHNVSk5TT1kzWitiOCtjN1pCYkR0UElXRCtjZkhHOHNPeXZoazJVVUozeXdYY0E4L0xSZFJkaDVhWHNHbVU3ZThTdnZVY2drdjNXZVcxM0RYZlc5NUhYZmNMNWJMZU9EK3NMeUJSNFdBV1p6aU9uZXZUTWFjSFd6aG5XV1h0ejViTHVBeHZsc3VZc3R4TGEvZ0NYWE5lWlgyMTVaTCtPaTh0YnlHYlhkbWVSMzMzUStXeTNqdWZyVzhnUmVGQW82UVlvUVpGR0wwMEllR3dERkNUQ0JKcDZRRUVjOEZkbEhCRHZiaGtRTU0rQlZMWHBuWlNhNlNhKzRkOFNhTzB0Rk14YjIrRnNmaFJJclRNSWxtWXJleXMrK0pZREFRNWlnVFNtWlNUV1JFaHhyclNSZ3Z3TlJFU3pIa2lscWE2R0FxczNUSVRZdVdIc2FzSUdRdXRHUnZQQWhWN3R2QUdkcW8wL3NRVmU3YXRKM2dBazF5aXp2VUdtZnRlbkJZYmJSckp4Zk5ScXQ5dTR6blJsVkd0ZmxkZ1QxcU8rQ3ZzdFFYbkV1VnhXa2k5cndEcjJKRTNpNTRrMElrcFdTbTVYa1R1eWFkb0Y5cS92dm01S1pSNVQ0ZDB1L0N1bHpWa2svWDVzOHRpamtpV29lbWJWZTBoYlJxRSsrUzdWeEVTYmptdTQ2cG1WTnBEbVNZU2M2cEs1WFFxZEI5S1JhanpXUkg1OEs3cVRJblhhb1RXb1dSSElicVNvUmFxL2h5Yks0a3FZNDdNck9EVnFheXYzcWp0TGh1emszUEloYlBFa3dmTlB0UzVTdnVYK3NOLzRqcEdXWG9hejJxK241ZVhqaVA3OFhwLzBUd09hbDVWeExUZWY4Zk1mMEJSU2FaOVBFTHo0dllFWGljZlZjRmRPUElzblZWbVdJbkdWaW10OHlVMkphY0xFOWdtWm05c3QyMk5aWXRqU0F3eTh6TXpNeVBtZll4djMzTXpMQ1BtYXFrOWt6bS9ITitUdElrM2I3ZGZXOVhLU2xNL2I4LytCb1hrTUlVcFc1S1haKzZMblZqNnBiVXJha2JVcmVsYmdZRWdqUmtJQXM1eU1NUUZLQUl3ekFDbzdBTWxzTUtXQWtid2Nhd0NXd0ttOEhtc0FWc0NWdkIxckFOdkFtMmhlMWdlOWdCZG9TZFlHZllCWGFGM1dCMzJBUDJoTDFnYjlnSDlvVXhHSWNTbEtFQ0JwaFFoUW1ZaFAxZ2Z6Z0FEb1NENEdBNEJGYkJGRXpERE16Q29YQVlIQTVId0pGd0ZCd054OEN4Y0J3Y0R5ZkFpWEFTbkF5bndLbHdHcHdPWjhDWmNCYWNEZWZBdVZDRDg4Q0NlbW8wOVVacUJCclFCQVV0YUVNSGJGZ05YWENnQjMxd3dZTTE0RU1BSVVRd0IvT3dBSXV3RnM2SEMrQkN1QWd1aGt2Z1VyZ01Mb2NyNEVxNENxNkdhK0JhdUE2dWh4dmdScmdKYm9aYjRGYTREVzZITytCT3VBdnVobnZnWHJnUDdvY0g0RUY0Q0I2R1IrQlJlQXdlaHlmZ1NYZ0tub1puNEZsNERwNkhGK0JGZUFsZWhsZmdWWGd6dkFYZUNtK0R0OE03NEozd0xuZzN2QWZlQysrRDk4TUg0SVB3SWZnd3ZBWWZnWS9DeCtEajhBbjRKSHdLUGcyZmdjL0M1K0R6OEFYNElyd09YNEl2dzFmZ3EvQTErRHA4QTc0SjM0SnZ3M2ZndS9BOStENzhBSDRJUDRJZncwL2dwL0F6K0RuOEFuNEp2NEpmdzIvZ3QvQUcvQTUrRDMrQVA4S2Y0TS93Ri9nci9BMytEditBZjhLLzROL3dIL2d2cGhBUWtUQ05HY3hpRHZPcEhYQUlDMWpFWVJ6QlVWeUd5M0VGcnNTTmNHUGNCRGZGelhCejNBSzN4SzF3YTl3RzM0VGI0bmE0UGU2QU8rSk91RFB1Z3J2aWJyZzc3b0Y3NGw2NE4rNkQrK0lZam1NSnkxaEJBMDJzNGdSTzRuNjRQeDZBQitKQmVEQWVncXR3Q3FkeEJtZnhVRHdNRDhjajhFZzhDby9HWS9CWVBBNlB4eFB3UkR3cDlUcWVqS2ZncVhnYW5vNW40Smw0RnA2TjUrQzVXTVB6ME1JNk5yQ0pDbHZZeGc3YXVCcTc2R0FQKytpaWgydlF4d0JEakhBTzUzRUJGM0V0bm84WDRJVjRFVjZNbCtDbGVCbGVqbGZnbFhnVlhvM1g0TFY0SFY2UE4rQ05lQlBlakxmZ3JYZ2IzbzUzNEoxNEY5Nk45K0M5ZUIvZWp3L2dnL2dRUG95UDRLUDRHRDZPVCtDVCtCUStqYy9ncy9nY1BvOHY0SXY0RXI2TXIrQ3IrR1o4Qzc0VjM0WnZ4M2ZnTy9GZCtHNThENzRYMzRmdnh3L2dCL0ZEK0dGOERUK0NIOFdQNGNmeEUvaEovQlIrR2orRG44WFA0ZWZ4Qy9oRmZCMi9oRi9HcitCWDhXdjRkZndHZmhPL2hkL0c3K0IzOFh2NGZmd0IvaEIvaEQvR24rQlA4V2Y0Yy93Ri9oSi9oYi9HMytCdjhRMzhIZjRlLzRCL3hEL2huL0V2K0ZmOEcvNGQvNEgveEgvaHYvRS8rRjlLRVJBU1Vab3lsS1VjNVdtSUNsU2tZUnFoVVZwR3kya0ZyYVNOYUdQYWhEYWx6V2h6Mm9LMnBLMW9hOXFHM2tUYjBuYTBQZTFBTzlKT3REUHRRcnZTYnJRNzdVRjcwbDYwTisxRCs5SVlqVk9KeWxRaGcweXEwZ1JOMG42MFB4MUFCOUpCZERBZFFxdG9pcVpwaG1icFVEcU1EcWNqNkVnNmlvNm1ZK2hZT282T3B4UG9SRHFKVHFaVDZGUTZqVTZuTStoTU9vdk9wblBvWEtyUmVXUlJuUnJVSkVVdGFsT0hiRnBOWFhLb1IzMXl5YU0xNUZOQUlVVTBSL08wUUl1MGxzNm5DK2hDdW9ndXBrdm9VcnFNTHFjcjZFcTZpcTZtYStoYXVvNnVweHZvUnJxSmJxWmI2RmE2alc2bk8raE91b3Z1cG52b1hycVA3cWNINkVGNmlCNm1SK2hSZW93ZXB5Zm9TWHFLbnFabjZGbDZqcDZuRitoRmVvbGVwbGZvMWRRZG1iWmpCVUdtRndWMkl4c295MjkwOHFvL3B4elhVNWtPOThOMEVGcCtRWXFhNm5uaFlqb0tsSjl1MlU0dkgzWnFqdVczRllhZG5MVHRJRVMzbS9WVno1MVR1Yld1MjZ2Wi9YeGN1MUZJYnF1VkRleDIzM0tvNGJZem9XOEZuWFRIN2FrOHo2WnFsaE9tUTd1bjByNXJOWWViN256ZjRZWU01d2VkYk9SSmxiSDdkWGVoNkRuV1lxMWgrdzFITWFlbnJERG5xNWF2Z2s1ZWxoSlA2TGlOYnJybFdPMENiNmJwZGR5K0NncHpyaFAxVkkzWFU5Uk5JUmpTN2NqTHJ2RWJibFBsNmxaY1UyaTEwL3dYcE91dTI4MUwwYlA4YnNiejdYNlliVmc5NVZ2cGx0c1ArYm5Uek5xaDVkaU5ZcWdXd2xwSDJlMU9XSWpiODNZejdCVDRXYnRmYzFRckhFNmFEZFVQbFY5TU9yNjhQcEswVjBkQmFMY1cwN0tYb3Qxdjhuc0pUcmZqZDBkYlZrUEpxZFhtN0taeWM1N2RDQ05mWlQzVmI5aE9vV2Q1TlZtcjhyTldVeWJrRStaMXFxWWRab0tPNWF0TW82UDRoRVN3a1NCVVhxMXVOYnJ6bHQ4Y2FWbDhoSU5lZnRCSXk2Rm5QSXROd01ad3ZWekw5V1Y4T0g1OTBJbG4wcDJNV3EwYTRURHp6UGx1c3ZPUlFTZmV3cERuUkVGTmpGSG8yWDNkTENZbWl0czV0eHZYSTJzaXhVZkNPT2tOMmYyV204Q0NocTlVUCtpNDRZaUdKYTRZWW1EU0t0U3QvcUJwK2I0N0g2K2ptRFRqVmVTVGR1VHA1N0VqNGlNU0gvRnlBbnV0cXJVaXh4blc3YUJuT2M1eXRkQndySjYxYmxucHR0MWkyeW1yeFhmRVYzbTF5RVpqTllhazBYRGNRQTN6cWZUdGZqdCtQY1BuMlZmNWh1V29mdFB5czc3VmI3cTlYTVB0OVZqamJNOXE5MVZZR0p4WDVLMDdSMWtmMnoyY1Z5b2M0YTE3bmt6WjRBczczR0lYS2o4aEsrcU9MR0daWHZpYzhrT2JHVmZvZnNmMTdiVnNYOHNaWXNmWEdoMlpKSnkzUS9abGN2QmlNckY5M0J0T0hGOWpjdCtscmxwTTgyME84bnJKd1VqWWlYcjFnTmNxQjdkTTkyUzUwaCtLQTBuSGNsckZPTG9rTVNVbjgzS0lHSEhzZnBmTm1SeGx6b3VDRG05cmhHK1A4amxzMU9SeEhFTHNmcGJKdmM1aXNXMHpRejN4UVJJZGhDYmpzQS80Y09XK0YyT0xKMFNqZzh1YmRBdnhDd21aM25CK3NOZHNNbk0yNmtzTUtiTEYrTkxJQVRmSkR3THFOUGxTc0J2NDhQcnB1bktjWWtPT3RjVUhHNnBDaDJYVTdvNmI0clpjM0lxOFpFUU9aRVhpeU5wNlI2N2NZQ1NlWU5rR1E1RzNJVWltNFJqdTFsVjIzdWM3MzhtRVZ0QU5zaHhSZVRORGRkOVdyWVlWcUlJNE43a25tYmJ2Umw1YXpqTERIb21hMmJxeU9FSlFJd3BaU285UHhmSmkvOWhlT3JEbVZFSE9wMVpubzNiWmNhN1Bmc0xJUWRmaGlPSGJYUlYyZU1KMlp5aml1T1R6dElyWFVIZFVoczFyTnpqTVI0M3VFTXZJNitIck83cXVGUi83OHJicnRuazM2MkpBY2NsQWhqVlVpd1UrY3hYR084MG5UYjZrU1NPK3hFa3pQaXUrTnh6QyswRTZjSDIyR2hmSlBZbGJmSGtHbVMxT0tnT3ZwWG5kTGh1bXpmNXZja3FxdTZ4eFVkdFozaHdlV0R2T0tCempRL1pycURpMjV0bmJQbXR2Y1VUa21GZHdaQkUxdGtVOXozR0JkVzZyMGZpSWE0TU1OcHgwRTZmbUpKWFdlczBpWThPT0cvRGhxM3dRMmFFb2xoZFRDV08yd1lsS0tjNHdMa2RseVpSeE9wRXQxQ1BiNFIyMDh3ejJKTzhNV1QxbXQvb05sZTJwWnRjT2l5MVpFck9zVnJ4MHhYbWdrNFNwMWxoTHJXaTZVVjJzMUpjVGovMjN3VWppdncyRzJIOGI5R1ZmaGZYNDRoSmdmb0Fvckg4MTExUkJsOU5HMXJFOHFXS2poTU05dHk3N2ltL2pzUFozN0xmQ21zZ045ZFJKTTlHWmQ5dnY4MmFTZHpPYy9aM0ZnZzRGZkRETGw0YkFPQXd0Q1lQU0w2Z0ZUMjVob2k0TDZDWHZaWUllTHlUVDRxdlZwNTdxNU5vYzZ6eXJtZWN3Ri9zaUw5OFM4dVpvM0loREM3dTVtZWN6NXV4bE9XbjVZaGlLRjhTdk9jdld4VHNkZ0RpWUpNa2l2ci9wQmtleElZRkl1dXhLc0dGWHBtdWw2bVJ4U1dZcEJoSGZTTDYrdHNlMmp1cEppMStiS0E5NzBkcTFjbmEyYWloT29ES2hIT1BvK21ZdC92RHEyTXBwamc0U1RiS2FGWktpYXV3bTlsQmtCeDArVVorRG5aTEVzOUJvY29EUzJTWVlmTFNzM0dCRUI2aWxReEtnbHZiakFOVUplNDZSYmdSQk9jdmU1SkJaU0tLcU5qRkhKczZPRzdIZmJTK3dneVVKYWNXNnNVSFNTdGZLWStXaCtOTlA1cy95SUs5M2RQMlhRNXl1azVBZkQrWWR4WmRlYkpnMFlzY216K1BQaURpc3gxZWlWaDR2RlpLVUgyY0V2dlo4clNXekpRWlo3eFMycnJ4ZEpSWDUxSzU3RkFWTnN2cytyZllXeVkvcTFQWG5xUjQyNUROWkRhMjdzOHZqT0ZRWFkzZ2RxODQzc2xZdVRhNWNOeHB5T0sxSG9RbzIvYjlEc3EyUndYQWNnMWRzMEl0alU2MWNya2hoREM5eU5vM3FlaU82azE1Z21ZY1dCcDhlNjk2Unc4dzEyU3o4VWMwaG5iLzBCc0dMdjdHNDMvYXRYcmJGMzdSZG42d21oNDd4NnZobzNRN3JrUnk5bG9Fam9lTVhreW9lV3VhNFRMUStTNDBzNlVmZTBxZmlxK1ZMK3NrVm4rZlBYSGMreVBFMTlWMjdtZUdMRVMzd011MjY1SmFndStoeFVuTWpQMWdUc1dMOE9jQldjYk10RHN1T1Nrc2hDVHkwUFFvaWtkWTBjL0xQalQybnFCNjFjYTZibVZkMjNlVi9IUHI4eXk5VVM2UHgzbXVEemN0WVpaTmtTWU9jNnlRNVJ4NlpvMDAzWFBKQXhpYUc1L2hUbkw5SzR6WHh5TVRZU0pMWjRvR2FLME1sS2NwU2lGWVRoaFNtRkZVcEpxU1l6RVY5KzlEeFZXTjgxdFk0ajB3S2FMSXNYUUZOQ21oU1FKTUNtaFRRNUdTNlZobUxFWFZwbGFRb1MxRkpacHNhbDQ0cFJWV0tDU2tFTkQ0bWhUd2RGOUM0Z01ZclVoaFNDR0pjRU9PQ0dOZHJteDdUdGVCS2dpc0pyaVM0a3VCS2dpc0pyaVM0a2pDVmhha3NpTElneW9JbzYrWE42QWxueG5VZHZ5SFFzcWFjTVhSdDZsb21yOGdjRldHdENHdEZXQ3Z4QTRGV05IUldpQTBoTm1SYVEwQ0dnQXdCR1FJeUJHUUl5SkNsbW9Jd0JXRUt3aFNFcVpkNmFQeE1RR2FWejdzVlB4TlFWUjVVQlZRVlVGVWVWSVdtS2pSVlUxNXVTRXRvcW9LWUVNU0VJTVFYRmZGRlJYeFJFVjlVeEJjVjhVVkZmRkdaRU1Ta0lDWUZJYWFvVEFwaXNwSnVsV0laMlJUY2loOElRa3hoc0NtNEdKZWlKRVZaaW9vVWhoU21GRlVwSnFTWXpNd3BEcHZjRkVzWU1wY2hsakRFRW9aWXdoQkxHR0lKUXl4aGpBdEpTVWhLZ2hBekdHSUdROHhnaUJrTU1ZTWhaakRFRElhWXdSQXpHR0lHUTh4Z2lCa01DVjlHV1JCbFFaUUZJUjR3eW9Lb0NLSWlpSW9nUkhwRHBEZEVla09rTjBSNlE2UTNLb0l3QkNHNkc2SzdJYm9ib3JzaHVodWl1eUc2RzZLN0lib2JvcnNodWh1aXV5RzZHNllnVEVHSTZJWXBDRk1RTEhxcnhBZ3VCTUdpYzBzUUlyb2hvaHRWUVZRRklhSWJJcm9ob2hzaXVpR2lHeUs2SWFJYklyb2hvaHNpdWlHaUd5SzZJYUliSXJvaG9oc2l1akVwQ0lrRWhrUUNReUtCd2FLM1NsVVYyN1EwTWFacnhwa2l2U25TbXpvZWxDWU1YWnN5V0pWaVFncm1NOFZMcHVodml2Nm02RytLL3Fib2I0citwdWh2aXY2bTZHK0svcWJvYjRyK3B1aHZpdjZtNkcrSy9xYm9iNHIrWmltNWxxVlZlb1dyeG5WZDBuVloxM3FwcS9SU1Y1bTZydXA2UXRlRCtWYnBla3JYMDdxZTBmVnNVazlwM2luTk82VjVwelR2bE9hZDByeFRtbmRLODA1cDNpbk5PNlY1cHpUdmxPYWQwcnhUbWxjSHpkSzA1cDNXdk5PYWQxcnpUbXZlYWMwN3JYbW5OZSswNXAzV3ZOT2FkMXJ6VG12ZWFjMnJZMnRKeDliU2pPYWQwYnd6bWxkSDJKS09zS1VaelR1amVXYzA3NHptbmRHOE01cDNSdlBPYU41WnpUdXJlV2MxNzZ6bW5kVzhzNXAzVnZQT2lsTW1OZW1zSnAzVnBMT2FkRmFUem1yUzJkbi9BYm9KQjR3QUFBQT0nO1xuXG5leHBvcnQgZGVmYXVsdCBGT05UX0FXRVNPTUU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmV2aS90ZXh0L0ZvbnRBd2Vzb21lLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVW5jaGFydGVkIFNvZnR3YXJlIEluYy5cbiAqIGh0dHA6Ly93d3cudW5jaGFydGVkLnNvZnR3YXJlL1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IElPYmplY3QgZnJvbSAnLi4vY29yZS9JT2JqZWN0LmpzJztcbmltcG9ydCBXb3JkIGZyb20gJy4vV29yZC5qcyc7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgbGluZSBvZiB0ZXh0LlxuICpcbiAqIEBjbGFzcyBMaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBMaW5lIGV4dGVuZHMgSU9iamVjdCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNwYWNlV2lkdGggLSBUaGUgd2lkdGggb2YgYSBzcGFjZSBpbiBlbXMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BhY2VXaWR0aCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tV29yZHMgPSBbXTtcbiAgICAgICAgdGhpcy5tRW1XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubUVtSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5tTWluQmFzZWxpbmUgPSAwO1xuICAgICAgICB0aGlzLm1TcGFjZVdpZHRoID0gc3BhY2VXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoaXMgb2JqZWN0IHJlYWNoZXMgemVyby5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubVdvcmRzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubVdvcmRzO1xuICAgICAgICBkZWxldGUgdGhpcy5tRW1XaWR0aDtcbiAgICAgICAgZGVsZXRlIHRoaXMubUVtSGVpZ2h0O1xuICAgICAgICBkZWxldGUgdGhpcy5tTWluQmFzZWxpbmU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1TcGFjZVdpZHRoO1xuXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSB3b3JkcyBpbiB0aGlzIGxpbmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IHdvcmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tV29yZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIHdpZHRoIG9mIHRoaXMgbGluZSBpbiBlbXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBlbVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tRW1XaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgaGVpZ2h0IG9mIHRoaXMgbGluZSBpbiBlbXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBlbUhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubUVtSGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIGJhc2VsaW5lIG9mIHRoaXMgbGluZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IG1pbkJhc2VsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tTWluQmFzZWxpbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGxlZnQgb2Zmc2V0IG9mIHRoaXMgbGluZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IG9mZnNldExlZnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm1Xb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1Xb3Jkc1swXS5vZmZzZXRMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBhIHNwYWNlLCBpbiBlbXMsIHdpdGhpbiB0aGlzIGxpbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBzcGFjZVdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tU3BhY2VXaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzcGVjaWZpZWQgd29yZCB0byB0aGlzIGxpbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dvcmR9IHdvcmQgLSBUaGUgd29yZCB0byBhZGQuXG4gICAgICovXG4gICAgYWRkV29yZCh3b3JkKSB7XG4gICAgICAgIHRoaXMubVdvcmRzLnB1c2god29yZCk7XG5cbiAgICAgICAgaWYgKHdvcmQgPT09IFdvcmQuU1BBQ0VfV09SRCkge1xuICAgICAgICAgICAgdGhpcy5tRW1XaWR0aCArPSB0aGlzLm1TcGFjZVdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKHdvcmQgIT09IFdvcmQuTElORV9CUkVBS19XT1JEKSB7XG4gICAgICAgICAgICB0aGlzLm1FbVdpZHRoICs9IHdvcmQuZW1XaWR0aDtcbiAgICAgICAgICAgIHRoaXMubUVtSGVpZ2h0ID0gTWF0aC5tYXgod29yZC5lbUhlaWdodCwgdGhpcy5tRW1IZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5tTWluQmFzZWxpbmUgPSBNYXRoLm1heCh3b3JkLmFzY2VuZGluZywgdGhpcy5tTWluQmFzZWxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBlbGxpcHNlcyB0byB0aGlzIGxpbmUgYW5kIG1ha2VzIHN1cmUgaXQgZml0cyB3aXRoaW4gdGhlIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkRWxsaXBzZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGFyZ2V0RW1XaWR0aCAtIFRoZSBtYXhpbXVtIHdpZHRoLCBpbiBlbXMsIHRoaXMgbGluZSBzaG91bGQgb2NjdXB5LlxuICAgICAqIEBwYXJhbSB7Rm9udH0gZm9udCAtIFRoZSBmb250IHRvIHVzZSB0byByZW5kZXIgdGhpcyB3b3JkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0cmFja2luZyAtIFRoZSB0cmFja2luZyBmb3IgdGhlIGNoYXJhY3RlcnMgaW4gdGhpcyB3b3JkLlxuICAgICAqL1xuICAgIGFkZEVsbGlwc2VzKHRhcmdldEVtV2lkdGgsIGZvbnQsIHRyYWNraW5nKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgd29yZCA9IG51bGw7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLm1Xb3Jkcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1Xb3Jkc1tpXSA9PT0gV29yZC5TUEFDRV9XT1JEKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMubVNwYWNlV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubVdvcmRzW2ldICE9PSBXb3JkLkxJTkVfQlJFQUtfV09SRCkge1xuICAgICAgICAgICAgICAgIHdvcmQgPSB0aGlzLm1Xb3Jkc1tpXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gd29yZC5lbVdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiB0YXJnZXRFbVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmQgPSB3b3JkIHx8IFdvcmQuaW5zdGFuY2UoJycsIGZvbnQsIHRyYWNraW5nKTtcblxuICAgICAgICBjb25zdCBlbGxpcHNlc1dvcmQgPSBXb3JkLndvcmRXaXRoRWxsaXBzZXMod29yZCwgdGFyZ2V0RW1XaWR0aCAtIG9mZnNldCArIHdvcmQuZW1XaWR0aCk7XG4gICAgICAgIGNvbnN0IG9sZFdvcmRzID0gdGhpcy5tV29yZHMuc2xpY2UoMCwgdGhpcy5tV29yZHMuaW5kZXhPZih3b3JkKSk7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIG9sZFdvcmRzLmZvckVhY2gob2xkV29yZCA9PiB0aGlzLmFkZFdvcmQob2xkV29yZCkpO1xuICAgICAgICB0aGlzLmFkZFdvcmQoZWxsaXBzZXNXb3JkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgYmxhbmsgc3BhY2Ugb2ZmIHRoaXMgbGluZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdHJpbUJsYW5rU3BhY2VcbiAgICAgKi9cbiAgICB0cmltQmxhbmtTcGFjZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubVdvcmRzLmxlbmd0aCAmJiB0aGlzLm1Xb3Jkc1swXSA9PT0gV29yZC5TUEFDRV9XT1JEKSB7XG4gICAgICAgICAgICB0aGlzLm1Xb3Jkcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5tRW1XaWR0aCAtPSB0aGlzLm1TcGFjZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMubVdvcmRzLmxlbmd0aCAmJiB0aGlzLm1Xb3Jkc1t0aGlzLm1Xb3Jkcy5sZW5ndGggLSAxXSA9PT0gV29yZC5TUEFDRV9XT1JEKSB7XG4gICAgICAgICAgICB0aGlzLm1Xb3Jkcy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMubUVtV2lkdGggLT0gdGhpcy5tU3BhY2VXaWR0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhpcyBsaW5lIHRvIHRoZSBnaXZlbiBwYXRoIGZvciByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFRvUGF0aFxuICAgICAqIEBwYXJhbSB7UGF0aH0gcGF0aCAtIFRoZSBPcGVuVHlwZSBwYXRoIHRvIHdoaWNoIHRoaXMgd29yZCB3aWxsIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZSAtIFRoZSBkZXNpcmVkIGZvbnQgc2l6ZSBmb3IgdGhpcyBsaW5lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIFRoZSBzY2FsZSBvZiB0aGlzIGZvbnQgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgZm9yIHRoaXMgbGluZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgZm9yIHRoaXMgbGluZS5cbiAgICAgKi9cbiAgICBhZGRUb1BhdGgocGF0aCwgZm9udFNpemUsIHNjYWxlLCB4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BhY2VXaWR0aCA9IHRoaXMubVNwYWNlV2lkdGggKiBzY2FsZTtcbiAgICAgICAgY29uc3Qgc3BhY2VXb3JkID0gV29yZC5TUEFDRV9XT1JEO1xuICAgICAgICBjb25zdCBsaW5lQnJlYWtXb3JkID0gV29yZC5MSU5FX0JSRUFLX1dPUkQ7XG4gICAgICAgIGxldCBvZmZzZXRYID0geDtcbiAgICAgICAgbGV0IG9mZnNldFkgPSB5O1xuICAgICAgICB0aGlzLm1Xb3Jkcy5mb3JFYWNoKHdvcmQgPT4ge1xuICAgICAgICAgICAgaWYgKHdvcmQgPT09IHNwYWNlV29yZCkge1xuICAgICAgICAgICAgICAgIG9mZnNldFggKz0gc3BhY2VXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod29yZCAhPT0gbGluZUJyZWFrV29yZCkge1xuICAgICAgICAgICAgICAgIG9mZnNldFggKz0gd29yZC5hZGRUb1BhdGgocGF0aCwgZm9udFNpemUsIHNjYWxlLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIHdvcmRzIGluIHRoaXMgbGluZSBhbmQgcmVzZXRzIGl0cyBzaXplLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfcmVzZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldCgpIHtcbiAgICAgICAgdGhpcy5tV29yZHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5tRW1XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubUVtSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5tTWluQmFzZWxpbmUgPSAwO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGluZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZXZpL3RleHQvTGluZS5qcyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYXNlNjQtanMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlJlZ0V4cC5lc2NhcGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgU1BFQ0lFUyAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcbiAgdmFyIEM7XG4gIGlmKGlzQXJyYXkob3JpZ2luYWwpKXtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZih0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpQyA9IHVuZGVmaW5lZDtcbiAgICBpZihpc09iamVjdChDKSl7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmKEMgPT09IG51bGwpQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwsIGxlbmd0aCl7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgTlVNQkVSICAgICAgPSAnbnVtYmVyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihoaW50KXtcbiAgaWYoaGludCAhPT0gJ3N0cmluZycgJiYgaGludCAhPT0gTlVNQkVSICYmIGhpbnQgIT09ICdkZWZhdWx0Jyl0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19rZXlvZi5qc1xuLy8gbW9kdWxlIGlkID0gMTk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXRoICAgICAgPSByZXF1aXJlKCcuL19wYXRoJylcbiAgLCBpbnZva2UgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oLyogLi4ucGFyZ3MgKi8pe1xuICB2YXIgZm4gICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBwYXJncyAgPSBBcnJheShsZW5ndGgpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBfICAgICAgPSBwYXRoLl9cbiAgICAsIGhvbGRlciA9IGZhbHNlO1xuICB3aGlsZShsZW5ndGggPiBpKWlmKChwYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdKSA9PT0gXylob2xkZXIgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGogPSAwLCBrID0gMCwgYXJncztcbiAgICBpZighaG9sZGVyICYmICFhTGVuKXJldHVybiBpbnZva2UoZm4sIHBhcmdzLCB0aGF0KTtcbiAgICBhcmdzID0gcGFyZ3Muc2xpY2UoKTtcbiAgICBpZihob2xkZXIpZm9yKDtsZW5ndGggPiBqOyBqKyspaWYoYXJnc1tqXSA9PT0gXylhcmdzW2pdID0gYXJndW1lbnRzW2srK107XG4gICAgd2hpbGUoYUxlbiA+IGspYXJncy5wdXNoKGFyZ3VtZW50c1trKytdKTtcbiAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFydGlhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVnRXhwLCByZXBsYWNlKXtcbiAgdmFyIHJlcGxhY2VyID0gcmVwbGFjZSA9PT0gT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24ocGFydCl7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBTdHJpbmcoaXQpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlcik7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbWluZ3IvUmV4RXhwLmVzY2FwZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZSAgICAgPSByZXF1aXJlKCcuL19yZXBsYWNlcicpKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZ0V4cCcsIHtlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCl7IHJldHVybiAkcmUoaXQpOyB9fSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZS5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanNcbi8vIG1vZHVsZSBpZCA9IDIwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGV2ZXJ5ICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg0KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmV2ZXJ5LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge2ZpbGw6IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKX0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmlsbCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbmQgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg2KVxuICAsIEtFWSAgICAgPSAnZmluZEluZGV4J1xuICAsIGZvcmNlZCAgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmKEtFWSBpbiBbXSlBcnJheSgxKVtLRVldKGZ1bmN0aW9uKCl7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbmQgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KVxuICAsIEtFWSAgICAgPSAnZmluZCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgU1RSSUNUICAgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qc1xuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5kZXhPZiAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCAkbmF0aXZlICAgICAgID0gW10uaW5kZXhPZlxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5Jywge2lzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvSW50ZWdlciAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCB0b0xlbmd0aCAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCAkbmF0aXZlICAgICAgID0gW10ubGFzdEluZGV4T2ZcbiAgLCBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTQgLyAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IEBbKi0xXSAqLyl7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmKE5FR0FUSVZFX1pFUk8pcmV0dXJuICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QodGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IGxlbmd0aCAtIDE7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmKGluZGV4IDwgMClpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgIGZvcig7aW5kZXggPj0gMDsgaW5kZXgtLSlpZihpbmRleCBpbiBPKWlmKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KXJldHVybiBpbmRleCB8fCAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkbWFwICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ubWFwLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIEYoKXt9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGFMZW4gICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZShhTGVuID4gaW5kZXgpY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIHRydWUpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDIxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaHRtbCAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNvZiAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIHRvSW5kZXggICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgaWYoaHRtbClhcnJheVNsaWNlLmNhbGwoaHRtbCk7XG59KSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCl7XG4gICAgdmFyIGxlbiAgID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpXG4gICAgICAsIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmKGtsYXNzID09ICdBcnJheScpcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgID0gdG9JbmRleChiZWdpbiwgbGVuKVxuICAgICAgLCB1cFRvICAgPSB0b0luZGV4KGVuZCwgbGVuKVxuICAgICAgLCBzaXplICAgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpXG4gICAgICAsIGNsb25lZCA9IEFycmF5KHNpemUpXG4gICAgICAsIGkgICAgICA9IDA7XG4gICAgZm9yKDsgaSA8IHNpemU7IGkrKyljbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qc1xuLy8gbW9kdWxlIGlkID0gMjE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkc29tZSAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBmYWlscyAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgJHNvcnQgICAgID0gW10uc29ydFxuICAsIHRlc3QgICAgICA9IFsxLCAyLCAzXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHtub3c6IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdldFRpbWUgPSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lO1xuXG52YXIgbHogPSBmdW5jdGlvbihudW0pe1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKC01ZTEzIC0gMSkudG9JU09TdHJpbmcoKSAhPSAnMDM4NS0wNy0yNVQwNzowNjozOS45OTlaJztcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICBuZXcgRGF0ZShOYU4pLnRvSVNPU3RyaW5nKCk7XG59KSksICdEYXRlJywge1xuICB0b0lTT1N0cmluZzogZnVuY3Rpb24gdG9JU09TdHJpbmcoKXtcbiAgICBpZighaXNGaW5pdGUoZ2V0VGltZS5jYWxsKHRoaXMpKSl0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgICB2YXIgZCA9IHRoaXNcbiAgICAgICwgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKVxuICAgICAgLCBtID0gZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICAgICAgLCBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICAgIHJldHVybiBzICsgKCcwMDAwMCcgKyBNYXRoLmFicyh5KSkuc2xpY2UocyA/IC02IDogLTQpICtcbiAgICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICAgJzonICsgbHooZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKG0gPiA5OSA/IG0gOiAnMCcgKyBseihtKSkgKyAnWic7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbCB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7dG9JU09TdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9fSkgIT09IDE7XG59KSwgJ0RhdGUnLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSl7XG4gICAgdmFyIE8gID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgcHYgPSB0b1ByaW1pdGl2ZShPKTtcbiAgICByZXR1cm4gdHlwZW9mIHB2ID09ICdudW1iZXInICYmICFpc0Zpbml0ZShwdikgPyBudWxsIDogTy50b0lTT1N0cmluZygpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgVE9fUFJJTUlUSVZFID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvUHJpbWl0aXZlJylcbiAgLCBwcm90byAgICAgICAgPSBEYXRlLnByb3RvdHlwZTtcblxuaWYoIShUT19QUklNSVRJVkUgaW4gcHJvdG8pKXJlcXVpcmUoJy4vX2hpZGUnKShwcm90bywgVE9fUFJJTUlUSVZFLCByZXF1aXJlKCcuL19kYXRlLXRvLXByaW1pdGl2ZScpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBEYXRlUHJvdG8gICAgPSBEYXRlLnByb3RvdHlwZVxuICAsIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnXG4gICwgVE9fU1RSSU5HICAgID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyAgICA9IERhdGVQcm90b1tUT19TVFJJTkddXG4gICwgZ2V0VGltZSAgICAgID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZihuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7YmluZDogcmVxdWlyZSgnLi9fYmluZCcpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBIQVNfSU5TVEFOQ0UgICA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpXG4gICwgRnVuY3Rpb25Qcm90byAgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKXJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7dmFsdWU6IGZ1bmN0aW9uKE8pe1xuICBpZih0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSlyZXR1cm4gZmFsc2U7XG4gIGlmKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpaWYodGhpcy5wcm90b3R5cGUgPT09IE8pcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn19KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDIyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgaGFzICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgRlByb3RvICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZVxuICAsIG5hbWVSRSAgICAgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS9cbiAgLCBOQU1FICAgICAgID0gJ25hbWUnO1xuXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgLCBuYW1lID0gKCcnICsgdGhhdCkubWF0Y2gobmFtZVJFKVsxXTtcbiAgICAgIGhhcyh0aGF0LCBOQU1FKSB8fCAhaXNFeHRlbnNpYmxlKHRoYXQpIHx8IGRQKHRoYXQsIE5BTUUsIGNyZWF0ZURlc2MoNSwgbmFtZSkpO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanNcbi8vIG1vZHVsZSBpZCA9IDIyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbG9nMXAgICA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKVxuICAsIHNxcnQgICAgPSBNYXRoLnNxcnRcbiAgLCAkYWNvc2ggID0gTWF0aC5hY29zaDtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaFxuICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4gICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTBcbiAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU4gXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yXG4gICAgICA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanNcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGFzaW5oICA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpe1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XG59XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hc2luaCgwKSAtPiAtMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHthc2luaDogYXNpbmh9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdGFuaCAgPSBNYXRoLmF0YW5oO1xuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDAgXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qc1xuLy8gbW9kdWxlIGlkID0gMjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpe1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanNcbi8vIG1vZHVsZSBpZCA9IDIzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCl7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpe1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGV4cG0xICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoJGV4cG0xICE9IE1hdGguZXhwbTEpLCAnTWF0aCcsIHtleHBtMTogJGV4cG0xfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qc1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2lnbiAgICAgID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJylcbiAgLCBwb3cgICAgICAgPSBNYXRoLnBvd1xuICAsIEVQU0lMT04gICA9IHBvdygyLCAtNTIpXG4gICwgRVBTSUxPTjMyID0gcG93KDIsIC0yMylcbiAgLCBNQVgzMiAgICAgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKVxuICAsIE1JTjMyICAgICA9IHBvdygyLCAtMTI2KTtcblxudmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnJvdW5kOiBmdW5jdGlvbiBmcm91bmQoeCl7XG4gICAgdmFyICRhYnMgID0gTWF0aC5hYnMoeClcbiAgICAgICwgJHNpZ24gPSBzaWduKHgpXG4gICAgICAsIGEsIHJlc3VsdDtcbiAgICBpZigkYWJzIDwgTUlOMzIpcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gICAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gICAgaWYocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdClyZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYWJzICAgICA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtICA9IDBcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbGFyZyA9IDBcbiAgICAgICwgYXJnLCBkaXY7XG4gICAgd2hpbGUoaSA8IGFMZW4pe1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmKGxhcmcgPCBhcmcpe1xuICAgICAgICBkaXYgID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtICA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYoYXJnID4gMCl7XG4gICAgICAgIGRpdiAgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbXVsICAgPSBNYXRoLmltdWw7XG5cbi8vIHNvbWUgV2ViS2l0IHZlcnNpb25zIGZhaWxzIHdpdGggYmlnIG51bWJlcnMsIHNvbWUgaGFzIHdyb25nIGFyaXR5XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgeG4gPSAreFxuICAgICAgLCB5biA9ICt5XG4gICAgICAsIHhsID0gVUlOVDE2ICYgeG5cbiAgICAgICwgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanNcbi8vIG1vZHVsZSBpZCA9IDIzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCl7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qc1xuLy8gbW9kdWxlIGlkID0gMjQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge3NpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpe1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KXtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreClcbiAgICAgICwgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanNcbi8vIG1vZHVsZSBpZCA9IDI0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpe1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgY29mICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZ09QRCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmZcbiAgLCBkUCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCAkdHJpbSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIE5VTUJFUiAgICAgICAgICAgID0gJ051bWJlcidcbiAgLCAkTnVtYmVyICAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkTnVtYmVyXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkTnVtYmVyLnByb3RvdHlwZVxuICAvLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbiAgLCBCUk9LRU5fQ09GICAgICAgICA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVJcbiAgLCBUUklNICAgICAgICAgICAgICA9ICd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlO1xuXG4vLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uKGFyZ3VtZW50KXtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpe1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApXG4gICAgICAsIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZihmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KXtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKXJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYoZmlyc3QgPT09IDQ4KXtcbiAgICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcbiAgICAgICAgY2FzZSA2NiA6IGNhc2UgOTggIDogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0IDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKyl7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSlyZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZighJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpe1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKXtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZVxuICAgICAgLCB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbigpeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKXtcbiAgICBpZihoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKXtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7RVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KXtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge2lzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpe1xuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpXG4gICwgYWJzICAgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcil7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywge3BhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgJ051bWJlcicsIHtwYXJzZUludDogJHBhcnNlSW50fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW50ZWdlciAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJylcbiAgLCByZXBlYXQgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0JylcbiAgLCAkdG9GaXhlZCAgICAgPSAxLi50b0ZpeGVkXG4gICwgZmxvb3IgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGRhdGEgICAgICAgICA9IFswLCAwLCAwLCAwLCAwLCAwXVxuICAsIEVSUk9SICAgICAgICA9ICdOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hJ1xuICAsIFpFUk8gICAgICAgICA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24obiwgYyl7XG4gIHZhciBpICA9IC0xXG4gICAgLCBjMiA9IGM7XG4gIHdoaWxlKCsraSA8IDYpe1xuICAgIGMyICs9IG4gKiBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBjMiAlIDFlNztcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgfVxufTtcbnZhciBkaXZpZGUgPSBmdW5jdGlvbihuKXtcbiAgdmFyIGkgPSA2XG4gICAgLCBjID0gMDtcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgdmFyIGkgPSA2XG4gICAgLCBzID0gJyc7XG4gIHdoaWxlKC0taSA+PSAwKXtcbiAgICBpZihzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApe1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpXSk7XG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKFpFUk8sIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgIH1cbiAgfSByZXR1cm4gcztcbn07XG52YXIgcG93ID0gZnVuY3Rpb24oeCwgbiwgYWNjKXtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbih4KXtcbiAgdmFyIG4gID0gMFxuICAgICwgeDIgPSB4O1xuICB3aGlsZSh4MiA+PSA0MDk2KXtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUoeDIgPj0gMil7XG4gICAgbiAgKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gIDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAxMDAwMDAwMDAwMDAwMDAwMTI4Li50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpe1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKVxuICAgICAgLCBmID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKVxuICAgICAgLCBzID0gJydcbiAgICAgICwgbSA9IFpFUk9cbiAgICAgICwgZSwgeiwgaiwgaztcbiAgICBpZihmIDwgMCB8fCBmID4gMjApdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7XG4gICAgaWYoeCAhPSB4KXJldHVybiAnTmFOJztcbiAgICBpZih4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSlyZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmKHggPCAwKXtcbiAgICAgIHMgPSAnLSc7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGlmKHggPiAxZS0yMSl7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmKGUgPiAwKXtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZShqID49IDcpe1xuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgaiAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICBqID0gZSAtIDE7XG4gICAgICAgIHdoaWxlKGogPj0gMjMpe1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoZiA+IDApe1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH0gcmV0dXJuIG07XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qc1xuLy8gbW9kdWxlIGlkID0gMjU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmYWlscyAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpXG4gICwgJHRvUHJlY2lzaW9uID0gMS4udG9QcmVjaXNpb247XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbigpe1xuICAvLyBJRTctXG4gIHJldHVybiAkdG9QcmVjaXNpb24uY2FsbCgxLCB1bmRlZmluZWQpICE9PSAnMSc7XG59KSB8fCAhJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b1ByZWNpc2lvbi5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbil7XG4gICAgdmFyIHRoYXQgPSBhTnVtYmVyVmFsdWUodGhpcywgJ051bWJlciN0b1ByZWNpc2lvbjogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gICAgcmV0dXJuIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gJHRvUHJlY2lzaW9uLmNhbGwodGhhdCkgOiAkdG9QcmVjaXNpb24uY2FsbCh0aGF0LCBwcmVjaXNpb24pOyBcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDI1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qc1xuLy8gbW9kdWxlIGlkID0gMjYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDI2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uKCRmcmVlemUpe1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24oJGlzRXh0ZW5zaWJsZSl7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24oJGlzRnJvemVuKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDI2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uKCRpc1NlYWxlZCl7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRrZXlzICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDI3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24oJHByZXZlbnRFeHRlbnNpb25zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KXtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTcgT2JqZWN0LnNlYWwoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnc2VhbCcsIGZ1bmN0aW9uKCRzZWFsKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpe1xuICAgIHJldHVybiAkc2VhbCAmJiBpc09iamVjdChpdCkgPyAkc2VhbChtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDI3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgdGVzdCAgICA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZih0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHtwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHtwYXJzZUludDogJHBhcnNlSW50fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMjc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCByQXBwbHkgICAgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHlcbiAgLCBmQXBwbHkgICAgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByQXBwbHkoZnVuY3Rpb24oKXt9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KXtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpXG4gICAgICAsIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmFpbHMgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBiaW5kICAgICAgID0gcmVxdWlyZSgnLi9fYmluZCcpXG4gICwgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbigpe30sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgckNvbnN0cnVjdChmdW5jdGlvbigpe30pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiwgbmV3VGFyZ2V0Ki8pe1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRylyZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYoVGFyZ2V0ID09IG5ld1RhcmdldCl7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldDtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gICAgPSBuZXdUYXJnZXQucHJvdG90eXBlXG4gICAgICAsIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSlcbiAgICAgICwgcmVzdWx0ICAgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7dmFsdWU6IDF9KSwgMSwge3ZhbHVlOiAyfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ09QRCAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmZcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAyODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBFbnVtZXJhdGUgPSBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdICAgICAgIC8vIGtleXNcbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBpdGVyYXRlZClrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ID0gdGhpc1xuICAgICwga2V5cyA9IHRoYXQuX2tcbiAgICAsIGtleTtcbiAgZG8ge1xuICAgIGlmKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgfSB3aGlsZSghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHt2YWx1ZToga2V5LCBkb25lOiBmYWxzZX07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpe1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCl7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDI4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXG52YXIgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleS8qLCByZWNlaXZlciovKXtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl1cbiAgICAsIGRlc2MsIHByb3RvO1xuICBpZihhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcilyZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYoZGVzYyA9IGdPUEQuZih0YXJnZXQsIHByb3BlcnR5S2V5KSlyZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSlyZXR1cm4gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7Z2V0OiBnZXR9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qc1xuLy8gbW9kdWxlIGlkID0gMjg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMjg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG52YXIgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICBpZigkcHJldmVudEV4dGVuc2lvbnMpJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDI5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYoc2V0UHJvdG8pJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90byl7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDI5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdXG4gICAgLCBvd25EZXNjICA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSlcbiAgICAsIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmKCFvd25EZXNjKXtcbiAgICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmKGhhcyhvd25EZXNjLCAndmFsdWUnKSl7XG4gICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgY3JlYXRlRGVzYygwKTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7c2V0OiBzZXR9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCBkUCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBnT1BOICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGlzUmVnRXhwICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCAkZmxhZ3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCAkUmVnRXhwICAgICAgICAgICA9IGdsb2JhbC5SZWdFeHBcbiAgLCBCYXNlICAgICAgICAgICAgICA9ICRSZWdFeHBcbiAgLCBwcm90byAgICAgICAgICAgICA9ICRSZWdFeHAucHJvdG90eXBlXG4gICwgcmUxICAgICAgICAgICAgICAgPSAvYS9nXG4gICwgcmUyICAgICAgICAgICAgICAgPSAvYS9nXG4gIC8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxuICAsIENPUlJFQ1RfTkVXICAgICAgID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICghQ09SUkVDVF9ORVcgfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7XG4gIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKXtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKXtcbiAgICB2YXIgdGlSRSA9IHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwXG4gICAgICAsIHBpUkUgPSBpc1JlZ0V4cChwKVxuICAgICAgLCBmaVUgID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcFxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZilcbiAgICAgICAgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZilcbiAgICAgICwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uKGtleSl7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAoJFJlZ0V4cCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGl0KXsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yKHZhciBrZXlzID0gZ09QTihCYXNlKSwgaSA9IDA7IGtleXMubGVuZ3RoID4gaTsgKXByb3h5KGtleXNbaSsrXSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbn1cblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpe1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbihkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSl7XG4gIC8vIDIxLjEuMy4xNCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSlcbiAgcmV0dXJuIFtmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gIH0sICRyZXBsYWNlXTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKXtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRzZWFyY2hdO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qc1xuLy8gbW9kdWxlIGlkID0gMjk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbihkZWZpbmVkLCBTUExJVCwgJHNwbGl0KXtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgaXNSZWdFeHAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICAgLCBfc3BsaXQgICAgID0gJHNwbGl0XG4gICAgLCAkcHVzaCAgICAgID0gW10ucHVzaFxuICAgICwgJFNQTElUICAgICA9ICdzcGxpdCdcbiAgICAsIExFTkdUSCAgICAgPSAnbGVuZ3RoJ1xuICAgICwgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZihcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKXtcbiAgICB2YXIgTlBDRyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdW5kZWZpbmVkOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKXJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZighaXNSZWdFeHAoc2VwYXJhdG9yKSlyZXR1cm4gX3NwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoLCBpO1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBpZighTlBDRylzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgd2hpbGUobWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKSl7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZihsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KXtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3IgTlBDR1xuICAgICAgICAgIGlmKCFOUENHICYmIG1hdGNoW0xFTkdUSF0gPiAxKW1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZvcihpID0gMTsgaSA8IGFyZ3VtZW50c1tMRU5HVEhdIC0gMjsgaSsrKWlmKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKW1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZihvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KWJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KXNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pe1xuICAgICAgICBpZihsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKW91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZignMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pe1xuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9XG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpXG4gIHJldHVybiBbZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6ICRzcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gIH0sICRzcGxpdF07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanNcbi8vIG1vZHVsZSBpZCA9IDI5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGZsYWdzICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgVE9fU1RSSU5HICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uKGZuKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHtzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJ30pICE9ICcvYS9iJzsgfSkpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZigkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDI5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanNcbi8vIG1vZHVsZSBpZCA9IDI5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanNcbi8vIG1vZHVsZSBpZCA9IDMwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy40IFN0cmluZy5wcm90b3R5cGUuYmxpbmsoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmxpbmsnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JsaW5rJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNSBTdHJpbmcucHJvdG90eXBlLmJvbGQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYm9sZCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanNcbi8vIG1vZHVsZSBpZCA9IDMwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qc1xuLy8gbW9kdWxlIGlkID0gMzAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIEVORFNfV0lUSCA9ICdlbmRzV2l0aCdcbiAgLCAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKVxuICAgICAgLCBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIGxlbiAgICA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKVxuICAgICAgLCBlbmQgICAgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmaXhlZCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qc1xuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcil7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDMwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmb250c2l6ZShzaXplKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JbmRleCAgICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgZnJvbUNoYXJDb2RlICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICwgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzICA9IFtdXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGkgICAgPSAwXG4gICAgICAsIGNvZGU7XG4gICAgd2hpbGUoYUxlbiA+IGkpe1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmKHRvSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKXRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDMwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb250ZXh0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanNcbi8vIG1vZHVsZSBpZCA9IDMxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMzExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5rKHVybCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxuICByYXc6IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZSl7XG4gICAgdmFyIHRwbCAgPSB0b0lPYmplY3QoY2FsbFNpdGUucmF3KVxuICAgICAgLCBsZW4gID0gdG9MZW5ndGgodHBsLmxlbmd0aClcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzICA9IFtdXG4gICAgICAsIGkgICAgPSAwO1xuICAgIHdoaWxlKGxlbiA+IGkpe1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZihpIDwgYUxlbilyZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzXG4vLyBtb2R1bGUgaWQgPSAzMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDMxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMzE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJ1xuICAsICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgdmFyIHRoYXQgICA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSClcbiAgICAgICwgaW5kZXggID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSlcbiAgICAgICwgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcbiAgICAgIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanNcbi8vIG1vZHVsZSBpZCA9IDMxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5zdWIoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3ViJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdWIoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qc1xuLy8gbW9kdWxlIGlkID0gMzE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3VwKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanNcbi8vIG1vZHVsZSBpZCA9IDMxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanNcbi8vIG1vZHVsZSBpZCA9IDMyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgTUVUQSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCB3a3NEZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fa2V5b2YnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJylcbiAgLCBpc0FycmF5ICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBfY3JlYXRlICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGdPUE5FeHQgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JylcbiAgLCAkR09QRCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkRFAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGtleXMgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QRCAgICAgICAgICAgPSAkR09QRC5mXG4gICwgZFAgICAgICAgICAgICAgPSAkRFAuZlxuICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxuICAsIGlzRW51bSAgICAgICAgID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgT1BTeW1ib2xzICAgICAgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKVxuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0W1BST1RPVFlQRV1cbiAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBRT2JqZWN0ICAgICAgICA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8pJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZih0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgaXQgID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIElTX09QICA9IGl0ID09PSBPYmplY3RQcm90b1xuICAgICwgbmFtZXMgID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighVVNFX05BVElWRSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvKSRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiAgID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuZm9yKHZhciBzeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3Moc3ltYm9sc1tpKytdKTtcblxuZm9yKHZhciBzeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrc0RlZmluZShzeW1ib2xzW2krK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuICAgIHRocm93IFR5cGVFcnJvcihrZXkgKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF1cbiAgICAgICwgaSAgICA9IDFcbiAgICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDMyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdHlwZWQgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgYnVmZmVyICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgLCBhbk9iamVjdCAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSW5kZXggICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgQXJyYXlCdWZmZXIgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXJcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXJcbiAgLCAkRGF0YVZpZXcgICAgPSBidWZmZXIuRGF0YVZpZXdcbiAgLCAkaXNWaWV3ICAgICAgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlld1xuICAsICRzbGljZSAgICAgICA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2VcbiAgLCBWSUVXICAgICAgICAgPSAkdHlwZWQuVklFV1xuICAsIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7QXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlcn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpe1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgaWYoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIHZhciBsZW4gICAgPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoXG4gICAgICAsIGZpcnN0ICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAgICwgZmluYWwgID0gdG9JbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKVxuICAgICAgLCByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW5hbCAtIGZpcnN0KSlcbiAgICAgICwgdmlld1MgID0gbmV3ICREYXRhVmlldyh0aGlzKVxuICAgICAgLCB2aWV3VCAgPSBuZXcgJERhdGFWaWV3KHJlc3VsdClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICB3aGlsZShmaXJzdCA8IGZpbmFsKXtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3R5cGVkJykuQUJWLCB7XG4gIERhdGFWaWV3OiByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKS5EYXRhVmlld1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanNcbi8vIG1vZHVsZSBpZCA9IDMzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDMzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBwcm9jZXNzICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wcm9jZXNzXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge1xuICBhc2FwOiBmdW5jdGlvbiBhc2FwKGZuKXtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFzYXAuanNcbi8vIG1vZHVsZSBpZCA9IDMzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWlzLWVycm9yXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29mICAgICA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0Vycm9yJywge1xuICBpc0Vycm9yOiBmdW5jdGlvbiBpc0Vycm9yKGl0KXtcbiAgICByZXR1cm4gY29mKGl0KSA9PT0gJ0Vycm9yJztcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDMzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanNcbi8vIG1vZHVsZSBpZCA9IDMzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpbXVsaDogZnVuY3Rpb24gaW11bGgodSwgdil7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCAkdSA9ICt1XG4gICAgICAsICR2ID0gK3ZcbiAgICAgICwgdTAgPSAkdSAmIFVJTlQxNlxuICAgICAgLCB2MCA9ICR2ICYgVUlOVDE2XG4gICAgICAsIHUxID0gJHUgPj4gMTZcbiAgICAgICwgdjEgPSAkdiA+PiAxNlxuICAgICAgLCB0ICA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qc1xuLy8gbW9kdWxlIGlkID0gMzM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qc1xuLy8gbW9kdWxlIGlkID0gMzQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHVtdWxoOiBmdW5jdGlvbiB1bXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+Pj4gMTZcbiAgICAgICwgdjEgPSAkdiA+Pj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qc1xuLy8gbW9kdWxlIGlkID0gMzQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjIgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZUdldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcil7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4zIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpe1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7c2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KXtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMzQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIG93bktleXMgICAgICAgID0gcmVxdWlyZSgnLi9fb3duLWtleXMnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KXtcbiAgICB2YXIgTyAgICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgICAsIGdldERlc2MgPSBnT1BELmZcbiAgICAgICwga2V5cyAgICA9IG93bktleXMoTylcbiAgICAgICwgcmVzdWx0ICA9IHt9XG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShrZXlzLmxlbmd0aCA+IGkpY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXkgPSBrZXlzW2krK10sIGdldERlc2MoTywga2V5KSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDM0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi40IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwR2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwR2V0dGVyX18oUCl7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcbiAgICAgICwgRDtcbiAgICBkbyB7XG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELmdldDtcbiAgICB9IHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApe1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpXG4gICAgICAsIEQ7XG4gICAgZG8ge1xuICAgICAgaWYoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSlyZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR2YWx1ZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCl7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBtaWNyb3Rhc2sgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBPQlNFUlZBQkxFICA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJylcbiAgLCBhRnVuY3Rpb24gICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgaGlkZSAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgUkVUVVJOICAgICAgPSBmb3JPZi5SRVRVUk47XG5cbnZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihmbil7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XG4gIGlmKGNsZWFudXApe1xuICAgIHN1YnNjcmlwdGlvbi5fYyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwKCk7XG4gIH1cbn07XG5cbnZhciBzdWJzY3JpcHRpb25DbG9zZWQgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gIH1cbn07XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihvYnNlcnZlciwgc3Vic2NyaWJlcil7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCAgICAgID0gc3Vic2NyaWJlcihvYnNlcnZlcilcbiAgICAgICwgc3Vic2NyaXB0aW9uID0gY2xlYW51cDtcbiAgICBpZihjbGVhbnVwICE9IG51bGwpe1xuICAgICAgaWYodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpY2xlYW51cCA9IGZ1bmN0aW9uKCl7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgZWxzZSBhRnVuY3Rpb24oY2xlYW51cCk7XG4gICAgICB0aGlzLl9jID0gY2xlYW51cDtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgcmV0dXJuO1xuICB9IGlmKHN1YnNjcmlwdGlvbkNsb3NlZCh0aGlzKSljbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpeyBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTsgfVxufSk7XG5cbnZhciBTdWJzY3JpcHRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmKG0pcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcih2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpdGhyb3cgdmFsdWU7XG4gICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgaWYoIW0pdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZighc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpe1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuY29tcGxldGUpO1xuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciAkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlcil7XG4gIGFuSW5zdGFuY2UodGhpcywgJE9ic2VydmFibGUsICdPYnNlcnZhYmxlJywgJ19mJykuX2YgPSBhRnVuY3Rpb24oc3Vic2NyaWJlcik7XG59O1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpe1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbil7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgKGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0IDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCl7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZTtcbiAgICB2YXIgbWV0aG9kID0gZ2V0TWV0aG9kKGFuT2JqZWN0KHgpW09CU0VSVkFCTEVdKTtcbiAgICBpZihtZXRob2Qpe1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZihmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24oaXQpe1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcbiAgICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm4gUkVUVVJOO1xuICAgICAgICAgICAgfSkgPT09IFJFVFVSTilyZXR1cm47XG4gICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIGlmKGRvbmUpdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH0sXG4gIG9mOiBmdW5jdGlvbiBvZigpe1xuICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IEFycmF5KGwpOyBpIDwgbDspaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICBpZighZG9uZSl7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbaV0pO1xuICAgICAgICAgICAgaWYoZG9uZSlyZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7T2JzZXJ2YWJsZTogJE9ic2VydmFibGV9KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnT2JzZXJ2YWJsZScpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHtkZWZpbmVNZXRhZGF0YTogZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5tYXBcbiAgLCBzdG9yZSAgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEuc3RvcmU7XG5cbm1ldGFkYXRhLmV4cCh7ZGVsZXRlTWV0YWRhdGE6IGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHZhciB0YXJnZXRLZXkgICA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSlcbiAgICAsIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChhbk9iamVjdCh0YXJnZXQpLCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgaWYobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSlyZXR1cm4gZmFsc2U7XG4gIGlmKG1ldGFkYXRhTWFwLnNpemUpcmV0dXJuIHRydWU7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbn19KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTZXQgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vZXM2LnNldCcpXG4gICwgZnJvbSAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJylcbiAgLCBtZXRhZGF0YSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5TWV0YWRhdGFLZXlzID0gZnVuY3Rpb24oTywgUCl7XG4gIHZhciBvS2V5cyAgPSBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxuICAgICwgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmKHBhcmVudCA9PT0gbnVsbClyZXR1cm4gb0tleXM7XG4gIHZhciBwS2V5cyAgPSBvcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xuICByZXR1cm4gcEtleXMubGVuZ3RoID8gb0tleXMubGVuZ3RoID8gZnJvbShuZXcgU2V0KG9LZXlzLmNvbmNhdChwS2V5cykpKSA6IHBLZXlzIDogb0tleXM7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5TWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDM1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlHZXRNZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZihoYXNPd24pcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogdW5kZWZpbmVkO1xufTtcblxubWV0YWRhdGEuZXhwKHtnZXRNZXRhZGF0YTogZnVuY3Rpb24gZ2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtnZXRPd25NZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn19KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMzU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlIYXNNZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZihoYXNPd24pcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7aGFzTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2hhc093bk1ldGFkYXRhOiBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe21ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpe1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDM1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qc1xuLy8gbW9kdWxlIGlkID0gMzYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbC9cbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgaXNSZWdFeHAgICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsIGdldEZsYWdzICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsIFJlZ0V4cFByb3RvID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uKHJlZ2V4cCwgc3RyaW5nKXtcbiAgdGhpcy5fciA9IHJlZ2V4cDtcbiAgdGhpcy5fcyA9IHN0cmluZztcbn07XG5cbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yLCAnUmVnRXhwIFN0cmluZycsIGZ1bmN0aW9uIG5leHQoKXtcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xuICByZXR1cm4ge3ZhbHVlOiBtYXRjaCwgZG9uZTogbWF0Y2ggPT09IG51bGx9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBtYXRjaEFsbDogZnVuY3Rpb24gbWF0Y2hBbGwocmVnZXhwKXtcbiAgICBkZWZpbmVkKHRoaXMpO1xuICAgIGlmKCFpc1JlZ0V4cChyZWdleHApKXRocm93IFR5cGVFcnJvcihyZWdleHAgKyAnIGlzIG5vdCBhIHJlZ2V4cCEnKTtcbiAgICB2YXIgUyAgICAgPSBTdHJpbmcodGhpcylcbiAgICAgICwgZmxhZ3MgPSAnZmxhZ3MnIGluIFJlZ0V4cFByb3RvID8gU3RyaW5nKHJlZ2V4cC5mbGFncykgOiBnZXRGbGFncy5jYWxsKHJlZ2V4cClcbiAgICAgICwgcnggICAgPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIH5mbGFncy5pbmRleE9mKCdnJykgPyBmbGFncyA6ICdnJyArIGZsYWdzKTtcbiAgICByeC5sYXN0SW5kZXggPSB0b0xlbmd0aChyZWdleHAubGFzdEluZGV4KTtcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDM2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanNcbi8vIG1vZHVsZSBpZCA9IDM2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qLCBmaWxsU3RyaW5nID0gJyAnICovKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qc1xuLy8gbW9kdWxlIGlkID0gMzYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdC5qc1xuLy8gbW9kdWxlIGlkID0gMzY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1SaWdodCcsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1SaWdodCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAyKTtcbiAgfTtcbn0sICd0cmltRW5kJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDM2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDM2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5c3RlbScsIHtnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkaXRlcmF0b3JzICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAsIHJlZGVmaW5lICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHdrcyAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIElURVJBVE9SICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgLCBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpXG4gICwgQXJyYXlWYWx1ZXMgICA9IEl0ZXJhdG9ycy5BcnJheTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAgLCBrZXk7XG4gIGlmKHByb3RvKXtcbiAgICBpZighcHJvdG9bSVRFUkFUT1JdKWhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYoIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGZvcihrZXkgaW4gJGl0ZXJhdG9ycylpZighcHJvdG9ba2V5XSlyZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBwYXJ0aWFsICAgID0gcmVxdWlyZSgnLi9fcGFydGlhbCcpXG4gICwgbmF2aWdhdG9yICA9IGdsb2JhbC5uYXZpZ2F0b3JcbiAgLCBNU0lFICAgICAgID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbihzZXQpe1xuICByZXR1cm4gTVNJRSA/IGZ1bmN0aW9uKGZuLCB0aW1lIC8qLCAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gc2V0KGludm9rZShcbiAgICAgIHBhcnRpYWwsXG4gICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pXG4gICAgKSwgdGltZSk7XG4gIH0gOiBzZXQ7XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6ICB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaXN1YmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pbXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSAzNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBEcmF3aW5nIHV0aWxpdHkgZnVuY3Rpb25zLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIERyYXcgYSBsaW5lIG9uIHRoZSBnaXZlbiBjb250ZXh0IGZyb20gcG9pbnQgYHgxLHkxYCB0byBwb2ludCBgeDIseTJgLlxuZnVuY3Rpb24gbGluZShjdHgsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xufVxuXG5leHBvcnRzLmxpbmUgPSBsaW5lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy9kcmF3LmpzXG4vLyBtb2R1bGUgaWQgPSAzNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhlIEZvbnQgb2JqZWN0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcbnZhciBzZm50ID0gcmVxdWlyZSgnLi90YWJsZXMvc2ZudCcpO1xudmFyIGVuY29kaW5nID0gcmVxdWlyZSgnLi9lbmNvZGluZycpO1xudmFyIGdseXBoc2V0ID0gcmVxdWlyZSgnLi9nbHlwaHNldCcpO1xudmFyIFN1YnN0aXR1dGlvbiA9IHJlcXVpcmUoJy4vc3Vic3RpdHV0aW9uJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIEB0eXBlZGVmIEZvbnRPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW1wdHkgLSB3aGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBlbXB0eSBmb250XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmFtaWx5TmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0eWxlTmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBmdWxsTmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBwb3N0U2NyaXB0TmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNpZ25lclxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNpZ25lclVSTFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBtYW51ZmFjdHVyZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbWFudWZhY3R1cmVyVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGxpY2Vuc2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbGljZW5zZVVSTFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSB2ZXJzaW9uXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2NyaXB0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGNvcHlyaWdodFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSB0cmFkZW1hcmtcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1bml0c1BlckVtXG4gKiBAcHJvcGVydHkge051bWJlcn0gYXNjZW5kZXJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZXNjZW5kZXJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjcmVhdGVkVGltZXN0YW1wXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHdlaWdodENsYXNzXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHdpZHRoQ2xhc3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZnNTZWxlY3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgRm9udCByZXByZXNlbnRzIGEgbG9hZGVkIE9wZW5UeXBlIGZvbnQgZmlsZS5cbiAqIEl0IGNvbnRhaW5zIGEgc2V0IG9mIGdseXBocyBhbmQgbWV0aG9kcyB0byBkcmF3IHRleHQgb24gYSBkcmF3aW5nIGNvbnRleHQsXG4gKiBvciB0byBnZXQgYSBwYXRoIHJlcHJlc2VudGluZyB0aGUgdGV4dC5cbiAqIEBleHBvcnRzIG9wZW50eXBlLkZvbnRcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGb250T3B0aW9uc31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGb250KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghb3B0aW9ucy5lbXB0eSkge1xuICAgICAgICAvLyBDaGVjayB0aGF0IHdlJ3ZlIHByb3ZpZGVkIHRoZSBtaW5pbXVtIHNldCBvZiBuYW1lcy5cbiAgICAgICAgdXRpbC5jaGVja0FyZ3VtZW50KG9wdGlvbnMuZmFtaWx5TmFtZSwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGZhbWlseU5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIHV0aWwuY2hlY2tBcmd1bWVudChvcHRpb25zLnN0eWxlTmFtZSwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHN0eWxlTmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgdXRpbC5jaGVja0FyZ3VtZW50KG9wdGlvbnMudW5pdHNQZXJFbSwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHVuaXRzUGVyRW0gaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIHV0aWwuY2hlY2tBcmd1bWVudChvcHRpb25zLmFzY2VuZGVyLCAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgYXNjZW5kZXIgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIHV0aWwuY2hlY2tBcmd1bWVudChvcHRpb25zLmRlc2NlbmRlciwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGRlc2NlbmRlciBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgdXRpbC5jaGVja0FyZ3VtZW50KG9wdGlvbnMuZGVzY2VuZGVyIDwgMCwgJ0Rlc2NlbmRlciBzaG91bGQgYmUgbmVnYXRpdmUgKGUuZy4gLTUxMikuJyk7XG5cbiAgICAgICAgLy8gT1MgWCB3aWxsIGNvbXBsYWluIGlmIHRoZSBuYW1lcyBhcmUgZW1wdHksIHNvIHdlIHB1dCBhIHNpbmdsZSBzcGFjZSBldmVyeXdoZXJlIGJ5IGRlZmF1bHQuXG4gICAgICAgIHRoaXMubmFtZXMgPSB7XG4gICAgICAgICAgICBmb250RmFtaWx5OiB7ZW46IG9wdGlvbnMuZmFtaWx5TmFtZSB8fCAnICd9LFxuICAgICAgICAgICAgZm9udFN1YmZhbWlseToge2VuOiBvcHRpb25zLnN0eWxlTmFtZSB8fCAnICd9LFxuICAgICAgICAgICAgZnVsbE5hbWU6IHtlbjogb3B0aW9ucy5mdWxsTmFtZSB8fCBvcHRpb25zLmZhbWlseU5hbWUgKyAnICcgKyBvcHRpb25zLnN0eWxlTmFtZX0sXG4gICAgICAgICAgICBwb3N0U2NyaXB0TmFtZToge2VuOiBvcHRpb25zLnBvc3RTY3JpcHROYW1lIHx8IG9wdGlvbnMuZmFtaWx5TmFtZSArIG9wdGlvbnMuc3R5bGVOYW1lfSxcbiAgICAgICAgICAgIGRlc2lnbmVyOiB7ZW46IG9wdGlvbnMuZGVzaWduZXIgfHwgJyAnfSxcbiAgICAgICAgICAgIGRlc2lnbmVyVVJMOiB7ZW46IG9wdGlvbnMuZGVzaWduZXJVUkwgfHwgJyAnfSxcbiAgICAgICAgICAgIG1hbnVmYWN0dXJlcjoge2VuOiBvcHRpb25zLm1hbnVmYWN0dXJlciB8fCAnICd9LFxuICAgICAgICAgICAgbWFudWZhY3R1cmVyVVJMOiB7ZW46IG9wdGlvbnMubWFudWZhY3R1cmVyVVJMIHx8ICcgJ30sXG4gICAgICAgICAgICBsaWNlbnNlOiB7ZW46IG9wdGlvbnMubGljZW5zZSB8fCAnICd9LFxuICAgICAgICAgICAgbGljZW5zZVVSTDoge2VuOiBvcHRpb25zLmxpY2Vuc2VVUkwgfHwgJyAnfSxcbiAgICAgICAgICAgIHZlcnNpb246IHtlbjogb3B0aW9ucy52ZXJzaW9uIHx8ICdWZXJzaW9uIDAuMSd9LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHtlbjogb3B0aW9ucy5kZXNjcmlwdGlvbiB8fCAnICd9LFxuICAgICAgICAgICAgY29weXJpZ2h0OiB7ZW46IG9wdGlvbnMuY29weXJpZ2h0IHx8ICcgJ30sXG4gICAgICAgICAgICB0cmFkZW1hcms6IHtlbjogb3B0aW9ucy50cmFkZW1hcmsgfHwgJyAnfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuaXRzUGVyRW0gPSBvcHRpb25zLnVuaXRzUGVyRW0gfHwgMTAwMDtcbiAgICAgICAgdGhpcy5hc2NlbmRlciA9IG9wdGlvbnMuYXNjZW5kZXI7XG4gICAgICAgIHRoaXMuZGVzY2VuZGVyID0gb3B0aW9ucy5kZXNjZW5kZXI7XG4gICAgICAgIHRoaXMuY3JlYXRlZFRpbWVzdGFtcCA9IG9wdGlvbnMuY3JlYXRlZFRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy50YWJsZXMgPSB7IG9zMjoge1xuICAgICAgICAgICAgdXNXZWlnaHRDbGFzczogb3B0aW9ucy53ZWlnaHRDbGFzcyB8fCB0aGlzLnVzV2VpZ2h0Q2xhc3Nlcy5NRURJVU0sXG4gICAgICAgICAgICB1c1dpZHRoQ2xhc3M6IG9wdGlvbnMud2lkdGhDbGFzcyB8fCB0aGlzLnVzV2lkdGhDbGFzc2VzLk1FRElVTSxcbiAgICAgICAgICAgIGZzU2VsZWN0aW9uOiBvcHRpb25zLmZzU2VsZWN0aW9uIHx8IHRoaXMuZnNTZWxlY3Rpb25WYWx1ZXMuUkVHVUxBUlxuICAgICAgICB9IH07XG4gICAgfVxuXG4gICAgdGhpcy5zdXBwb3J0ZWQgPSB0cnVlOyAvLyBEZXByZWNhdGVkOiBwYXJzZUJ1ZmZlciB3aWxsIHRocm93IGFuIGVycm9yIGlmIGZvbnQgaXMgbm90IHN1cHBvcnRlZC5cbiAgICB0aGlzLmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldCh0aGlzLCBvcHRpb25zLmdseXBocyB8fCBbXSk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG5ldyBlbmNvZGluZy5EZWZhdWx0RW5jb2RpbmcodGhpcyk7XG4gICAgdGhpcy5zdWJzdGl0dXRpb24gPSBuZXcgU3Vic3RpdHV0aW9uKHRoaXMpO1xuICAgIHRoaXMudGFibGVzID0gdGhpcy50YWJsZXMgfHwge307XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGZvbnQgaGFzIGEgZ2x5cGggZm9yIHRoZSBnaXZlbiBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Gb250LnByb3RvdHlwZS5oYXNDaGFyID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoYykgIT09IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBnbHlwaCBpbmRleC5cbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG4gKiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGFuZCBhIGdseXBoOyBmb3IgY29tcGxleCBzY3JpcHRzIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBjYXNlLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgocyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBHbHlwaCBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuICogdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaCA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgZ2x5cGhJbmRleCA9IHRoaXMuY2hhclRvR2x5cGhJbmRleChjKTtcbiAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyAubm90ZGVmXG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gdGV4dCB0byBhIGxpc3Qgb2YgR2x5cGggb2JqZWN0cy5cbiAqIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBzdHJpY3Qgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gY2hhcmFjdGVycyBhbmRcbiAqIGdseXBocywgc28gdGhlIGxpc3Qgb2YgcmV0dXJuZWQgZ2x5cGhzIGNhbiBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGhbXX1cbiAqL1xuRm9udC5wcm90b3R5cGUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbihzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucztcbiAgICB2YXIgaTtcbiAgICAvLyBHZXQgZ2x5cGggaW5kZXhlc1xuICAgIHZhciBpbmRleGVzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBzW2ldO1xuICAgICAgICBpbmRleGVzLnB1c2godGhpcy5jaGFyVG9HbHlwaEluZGV4KGMpKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoO1xuXG4gICAgLy8gQXBwbHkgc3Vic3RpdHV0aW9ucyBvbiBnbHlwaCBpbmRleGVzXG4gICAgaWYgKG9wdGlvbnMuZmVhdHVyZXMpIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IG9wdGlvbnMuc2NyaXB0IHx8IHRoaXMuc3Vic3RpdHV0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCk7XG4gICAgICAgIHZhciBtYW55VG9PbmUgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmVhdHVyZXMubGlnYSkgbWFueVRvT25lID0gbWFueVRvT25lLmNvbmNhdCh0aGlzLnN1YnN0aXR1dGlvbi5nZXRGZWF0dXJlKCdsaWdhJywgc2NyaXB0LCBvcHRpb25zLmxhbmd1YWdlKSk7XG4gICAgICAgIGlmIChvcHRpb25zLmZlYXR1cmVzLnJsaWcpIG1hbnlUb09uZSA9IG1hbnlUb09uZS5jb25jYXQodGhpcy5zdWJzdGl0dXRpb24uZ2V0RmVhdHVyZSgncmxpZycsIHNjcmlwdCwgb3B0aW9ucy5sYW5ndWFnZSkpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFueVRvT25lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpZ2F0dXJlID0gbWFueVRvT25lW2pdO1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gbGlnYXR1cmUuc3ViO1xuICAgICAgICAgICAgICAgIHZhciBjb21wQ291bnQgPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPCBjb21wQ291bnQgJiYgY29tcG9uZW50c1trXSA9PT0gaW5kZXhlc1tpICsga10pIGsrKztcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gY29tcENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMuc3BsaWNlKGksIGNvbXBDb3VudCwgbGlnYXR1cmUuYnkpO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBsZW5ndGggLSBjb21wQ291bnQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZ2x5cGggaW5kZXhlcyB0byBnbHlwaCBvYmplY3RzXG4gICAgdmFyIGdseXBocyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHZhciBub3RkZWYgPSB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoc1tpXSA9IHRoaXMuZ2x5cGhzLmdldChpbmRleGVzW2ldKSB8fCBub3RkZWY7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaHM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nbHlwaE5hbWVzLm5hbWVUb0dseXBoSW5kZXgobmFtZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5Gb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgZ2x5cGhJbmRleCA9IHRoaXMubmFtZVRvR2x5cGhJbmRleChuYW1lKTtcbiAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyAubm90ZGVmXG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5Gb250LnByb3RvdHlwZS5nbHlwaEluZGV4VG9OYW1lID0gZnVuY3Rpb24oZ2lkKSB7XG4gICAgaWYgKCF0aGlzLmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGdpZCk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUga2VybmluZyBwYWlyIGJldHdlZW4gdGhlIGxlZnQgZ2x5cGggKG9yIGl0cyBpbmRleClcbiAqIGFuZCB0aGUgcmlnaHQgZ2x5cGggKG9yIGl0cyBpbmRleCkuIElmIG5vIGtlcm5pbmcgcGFpciBpcyBmb3VuZCwgcmV0dXJuIDAuXG4gKiBUaGUga2VybmluZyB2YWx1ZSBnZXRzIGFkZGVkIHRvIHRoZSBhZHZhbmNlIHdpZHRoIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHNwYWNpbmdcbiAqIGJldHdlZW4gZ2x5cGhzLlxuICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IGxlZnRHbHlwaFxuICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IHJpZ2h0R2x5cGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24obGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgbGVmdEdseXBoID0gbGVmdEdseXBoLmluZGV4IHx8IGxlZnRHbHlwaDtcbiAgICByaWdodEdseXBoID0gcmlnaHRHbHlwaC5pbmRleCB8fCByaWdodEdseXBoO1xuICAgIHZhciBncG9zS2VybmluZyA9IHRoaXMuZ2V0R3Bvc0tlcm5pbmdWYWx1ZTtcbiAgICByZXR1cm4gZ3Bvc0tlcm5pbmcgPyBncG9zS2VybmluZyhsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIDpcbiAgICAgICAgKHRoaXMua2VybmluZ1BhaXJzW2xlZnRHbHlwaCArICcsJyArIHJpZ2h0R2x5cGhdIHx8IDApO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBHbHlwaFJlbmRlck9wdGlvbnNcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzY3JpcHRdIC0gc2NyaXB0IHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGZlYXR1cmVzIHRvIGFwcGx5LiBCeSBkZWZhdWx0LCAnREZMVCcgb3IgJ2xhdG4nIGlzIHVzZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9zY3JpcHR0YWdzLmh0bVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddIC0gbGFuZ3VhZ2Ugc3lzdGVtIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGZlYXR1cmVzIHRvIGFwcGx5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9kZXZlbG9wZXJzL29wZW50eXBlL2xhbmd1YWdldGFncy5hc3B4XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZXJuaW5nPXRydWVdIC0gd2hldGhlciB0byBpbmNsdWRlIGtlcm5pbmcgdmFsdWVzXG4gKiBAcHJvcGVydHkge29iamVjdH0gW2ZlYXR1cmVzXSAtIE9wZW5UeXBlIExheW91dCBmZWF0dXJlIHRhZ3MuIFVzZWQgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGZlYXR1cmVzIG9mIHRoZSBnaXZlbiBzY3JpcHQvbGFuZ3VhZ2Ugc3lzdGVtLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9mZWF0dXJldGFncy5odG1cbiAqL1xuRm9udC5wcm90b3R5cGUuZGVmYXVsdFJlbmRlck9wdGlvbnMgPSB7XG4gICAga2VybmluZzogdHJ1ZSxcbiAgICBmZWF0dXJlczoge1xuICAgICAgICBsaWdhOiB0cnVlLFxuICAgICAgICBybGlnOiB0cnVlXG4gICAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZWFjaCBnbHlwaCBpbiB0aGUgZ2l2ZW4gdGV4dC5cbiAqIFRoZSBjYWxsYmFjayBnZXRzIGAoZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKWAuKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gYXBwbHkuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5Gb250LnByb3RvdHlwZS5mb3JFYWNoR2x5cGggPSBmdW5jdGlvbih0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucztcbiAgICB2YXIgZm9udFNjYWxlID0gMSAvIHRoaXMudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIHZhciBnbHlwaHMgPSB0aGlzLnN0cmluZ1RvR2x5cGhzKHRleHQsIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgY2FsbGJhY2soZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGdseXBoLmFkdmFuY2VXaWR0aCkge1xuICAgICAgICAgICAgeCArPSBnbHlwaC5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5rZXJuaW5nICYmIGkgPCBnbHlwaHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdmFyIGtlcm5pbmdWYWx1ZSA9IHRoaXMuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcbiAgICAgICAgICAgIHggKz0ga2VybmluZ1ZhbHVlICogZm9udFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgeCArPSBvcHRpb25zLmxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRyYWNraW5nKSB7XG4gICAgICAgICAgICB4ICs9IChvcHRpb25zLnRyYWNraW5nIC8gMTAwMCkgKiBmb250U2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24odGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZnVsbFBhdGggPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICB2YXIgZ2x5cGhQYXRoID0gZ2x5cGguZ2V0UGF0aChnWCwgZ1ksIGdGb250U2l6ZSk7XG4gICAgICAgIGZ1bGxQYXRoLmV4dGVuZChnbHlwaFBhdGgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgUGF0aCBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSBnbHlwcyBvZiBhIGdpdmVuIHRleHQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGhbXX1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0UGF0aHMgPSBmdW5jdGlvbih0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHZhciBnbHlwaFBhdGhzID0gW107XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICB2YXIgZ2x5cGhQYXRoID0gZ2x5cGguZ2V0UGF0aChnWCwgZ1ksIGdGb250U2l6ZSk7XG4gICAgICAgIGdseXBoUGF0aHMucHVzaChnbHlwaFBhdGgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdseXBoUGF0aHM7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHRleHQgb24gdGhlIGdpdmVuIGRyYXdpbmcgY29udGV4dC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5nZXRQYXRoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKS5kcmF3KGN0eCk7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHBvaW50cyBvZiBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuICogT24tY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gYmx1ZSwgb2ZmLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIHJlZC5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbihjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICBnbHlwaC5kcmF3UG9pbnRzKGN0eCwgZ1gsIGdZLCBnRm9udFNpemUpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzIGZvciBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuICogQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4gKiBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4gKiBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICovXG5Gb250LnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIGdseXBoLmRyYXdNZXRyaWNzKGN0eCwgZ1gsIGdZLCBnRm9udFNpemUpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldEVuZ2xpc2hOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmFuc2xhdGlvbnMgPSB0aGlzLm5hbWVzW25hbWVdO1xuICAgIGlmICh0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9ucy5lbjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGFzc2VydChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnROYW1lUHJlc2VudChuYW1lKSB7XG4gICAgICAgIHZhciBlbmdsaXNoTmFtZSA9IF90aGlzLmdldEVuZ2xpc2hOYW1lKG5hbWUpO1xuICAgICAgICBhc3NlcnQoZW5nbGlzaE5hbWUgJiYgZW5nbGlzaE5hbWUudHJpbSgpLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAnTm8gRW5nbGlzaCAnICsgbmFtZSArICcgc3BlY2lmaWVkLicpO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZpY2F0aW9uIGluZm9ybWF0aW9uXG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ2ZvbnRGYW1pbHknKTtcbiAgICBhc3NlcnROYW1lUHJlc2VudCgnd2VpZ2h0TmFtZScpO1xuICAgIGFzc2VydE5hbWVQcmVzZW50KCdtYW51ZmFjdHVyZXInKTtcbiAgICBhc3NlcnROYW1lUHJlc2VudCgnY29weXJpZ2h0Jyk7XG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ3ZlcnNpb24nKTtcblxuICAgIC8vIERpbWVuc2lvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydCh0aGlzLnVuaXRzUGVyRW0gPiAwLCAnTm8gdW5pdHNQZXJFbSBzcGVjaWZpZWQuJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbiAqIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuICogQHJldHVybiB7b3BlbnR5cGUuVGFibGV9XG4gKi9cbkZvbnQucHJvdG90eXBlLnRvVGFibGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNmbnQuZm9udFRvVGFibGUodGhpcyk7XG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBGb250LnRvQnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBGb250LnRvQXJyYXlCdWZmZXIgaW5zdGVhZC5cbiAqL1xuRm9udC5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ZvbnQudG9CdWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIEZvbnQudG9BcnJheUJ1ZmZlciBpbnN0ZWFkLicpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIoKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYG9wZW50eXBlLkZvbnRgIGludG8gYW4gYEFycmF5QnVmZmVyYFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2ZudFRhYmxlID0gdGhpcy50b1RhYmxlcygpO1xuICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzLmxlbmd0aCk7XG4gICAgdmFyIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludEFycmF5W2ldID0gYnl0ZXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8qKlxuICogSW5pdGlhdGUgYSBkb3dubG9hZCBvZiB0aGUgT3BlblR5cGUgZm9udC5cbiAqL1xuRm9udC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbihmaWxlTmFtZSkge1xuICAgIHZhciBmYW1pbHlOYW1lID0gdGhpcy5nZXRFbmdsaXNoTmFtZSgnZm9udEZhbWlseScpO1xuICAgIHZhciBzdHlsZU5hbWUgPSB0aGlzLmdldEVuZ2xpc2hOYW1lKCdmb250U3ViZmFtaWx5Jyk7XG4gICAgZmlsZU5hbWUgPSBmaWxlTmFtZSB8fCBmYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyBzdHlsZU5hbWUgKyAnLm90Zic7XG4gICAgdmFyIGFycmF5QnVmZmVyID0gdGhpcy50b0FycmF5QnVmZmVyKCk7XG5cbiAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0gPSB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0gfHwgd2luZG93LndlYmtpdFJlcXVlc3RGaWxlU3lzdGVtO1xuICAgICAgICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0od2luZG93LlRFTVBPUkFSWSwgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCwgZnVuY3Rpb24oZnMpIHtcbiAgICAgICAgICAgIGZzLnJvb3QuZ2V0RmlsZShmaWxlTmFtZSwge2NyZWF0ZTogdHJ1ZX0sIGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgIGZpbGVFbnRyeS5jcmVhdGVXcml0ZXIoZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2RhdGFWaWV3XSwge3R5cGU6ICdmb250L29wZW50eXBlJ30pO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGUoYmxvYik7XG5cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dyaXRlZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOYXZpZ2F0aW5nIHRvIHRoZSBmaWxlIHdpbGwgZG93bmxvYWQgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmID0gZmlsZUVudHJ5LnRvVVJMKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIubmFtZSArICc6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICAgIHZhciBidWZmZXIgPSB1dGlsLmFycmF5QnVmZmVyVG9Ob2RlQnVmZmVyKGFycmF5QnVmZmVyKTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlTmFtZSwgYnVmZmVyKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Gb250LnByb3RvdHlwZS5mc1NlbGVjdGlvblZhbHVlcyA9IHtcbiAgICBJVEFMSUM6ICAgICAgICAgICAgICAweDAwMSwgLy8xXG4gICAgVU5ERVJTQ09SRTogICAgICAgICAgMHgwMDIsIC8vMlxuICAgIE5FR0FUSVZFOiAgICAgICAgICAgIDB4MDA0LCAvLzRcbiAgICBPVVRMSU5FRDogICAgICAgICAgICAweDAwOCwgLy84XG4gICAgU1RSSUtFT1VUOiAgICAgICAgICAgMHgwMTAsIC8vMTZcbiAgICBCT0xEOiAgICAgICAgICAgICAgICAweDAyMCwgLy8zMlxuICAgIFJFR1VMQVI6ICAgICAgICAgICAgIDB4MDQwLCAvLzY0XG4gICAgVVNFUl9UWVBPX01FVFJJQ1M6ICAgMHgwODAsIC8vMTI4XG4gICAgV1dTOiAgICAgICAgICAgICAgICAgMHgxMDAsIC8vMjU2XG4gICAgT0JMSVFVRTogICAgICAgICAgICAgMHgyMDAgIC8vNTEyXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLnVzV2lkdGhDbGFzc2VzID0ge1xuICAgIFVMVFJBX0NPTkRFTlNFRDogMSxcbiAgICBFWFRSQV9DT05ERU5TRUQ6IDIsXG4gICAgQ09OREVOU0VEOiAzLFxuICAgIFNFTUlfQ09OREVOU0VEOiA0LFxuICAgIE1FRElVTTogNSxcbiAgICBTRU1JX0VYUEFOREVEOiA2LFxuICAgIEVYUEFOREVEOiA3LFxuICAgIEVYVFJBX0VYUEFOREVEOiA4LFxuICAgIFVMVFJBX0VYUEFOREVEOiA5XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLnVzV2VpZ2h0Q2xhc3NlcyA9IHtcbiAgICBUSElOOiAxMDAsXG4gICAgRVhUUkFfTElHSFQ6IDIwMCxcbiAgICBMSUdIVDogMzAwLFxuICAgIE5PUk1BTDogNDAwLFxuICAgIE1FRElVTTogNTAwLFxuICAgIFNFTUlfQk9MRDogNjAwLFxuICAgIEJPTEQ6IDcwMCxcbiAgICBFWFRSQV9CT0xEOiA4MDAsXG4gICAgQkxBQ0s6ICAgIDkwMFxufTtcblxuZXhwb3J0cy5Gb250ID0gRm9udDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvZm9udC5qc1xuLy8gbW9kdWxlIGlkID0gMzc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSBMYXlvdXQgb2JqZWN0IGlzIHRoZSBwcm90b3R5cGUgb2YgU3Vic3RpdGlvbiBvYmplY3RzLCBhbmQgcHJvdmlkZXMgdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGVcbi8vIGNvbW1vbiBsYXlvdXQgdGFibGVzIChHUE9TLCBHU1VCLCBHREVGLi4uKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcblxuZnVuY3Rpb24gc2VhcmNoVGFnKGFyciwgdGFnKSB7XG4gICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgdmFyIGltaW4gPSAwO1xuICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF0udGFnO1xuICAgICAgICBpZiAodmFsID09PSB0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWlkO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8IHRhZykge1xuICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICB9IGVsc2UgeyBpbWF4ID0gaW1pZCAtIDE7IH1cbiAgICB9XG4gICAgLy8gTm90IGZvdW5kOiByZXR1cm4gLTEtaW5zZXJ0aW9uIHBvaW50XG4gICAgcmV0dXJuIC1pbWluIC0gMTtcbn1cblxuZnVuY3Rpb24gYmluU2VhcmNoKGFyciwgdmFsdWUpIHtcbiAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgICB2YXIgaW1pbiA9IDA7XG4gICAgdmFyIGltYXggPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG4gICAgICAgIHZhciBpbWlkID0gKGltaW4gKyBpbWF4KSA+Pj4gMTtcbiAgICAgICAgdmFyIHZhbCA9IGFycltpbWlkXTtcbiAgICAgICAgaWYgKHZhbCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWlkO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8IHZhbHVlKSB7XG4gICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7IGltYXggPSBpbWlkIC0gMTsgfVxuICAgIH1cbiAgICAvLyBOb3QgZm91bmQ6IHJldHVybiAtMS1pbnNlcnRpb24gcG9pbnRcbiAgICByZXR1cm4gLWltaW4gLSAxO1xufVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkxheW91dFxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIExheW91dChmb250LCB0YWJsZU5hbWUpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xufVxuXG5MYXlvdXQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQmluYXJ5IHNlYXJjaCBhbiBvYmplY3QgYnkgXCJ0YWdcIiBwcm9wZXJ0eVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBzZWFyY2hUYWdcbiAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGFnXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNlYXJjaFRhZzogc2VhcmNoVGFnLFxuXG4gICAgLyoqXG4gICAgICogQmluYXJ5IHNlYXJjaCBpbiBhIGxpc3Qgb2YgbnVtYmVyc1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBiaW5TZWFyY2hcbiAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgYmluU2VhcmNoOiBiaW5TZWFyY2gsXG5cbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIHRoZSBMYXlvdXQgdGFibGUgKEdTVUIsIEdQT1MgZXRjKS5cbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjcmVhdGUgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgR1NVQiBvciBHUE9TIHRhYmxlLlxuICAgICAqL1xuICAgIGdldFRhYmxlOiBmdW5jdGlvbihjcmVhdGUpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdO1xuICAgICAgICBpZiAoIWxheW91dCAmJiBjcmVhdGUpIHtcbiAgICAgICAgICAgIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdID0gdGhpcy5jcmVhdGVEZWZhdWx0VGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBzY3JpcHRzIGluIHRoZSBzdWJzdGl0dXRpb24gdGFibGUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0U2NyaXB0TmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZSgpO1xuICAgICAgICBpZiAoIWxheW91dCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIGxheW91dC5zY3JpcHRzLm1hcChmdW5jdGlvbihzY3JpcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQudGFnO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmVzdCBiZXQgZm9yIGEgc2NyaXB0IG5hbWUuXG4gICAgICogUmV0dXJucyAnREZMVCcgaWYgaXQgZXhpc3RzLlxuICAgICAqIElmIG5vdCwgcmV0dXJucyAnbGF0bicgaWYgaXQgZXhpc3RzLlxuICAgICAqIElmIG5laXRoZXIgZXhpc3QsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRTY3JpcHROYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoKTtcbiAgICAgICAgaWYgKCFsYXlvdXQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBoYXNMYXRuID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0LnNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGF5b3V0LnNjcmlwdHNbaV0udGFnO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdERkxUJykgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xhdG4nKSBoYXNMYXRuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzTGF0bikgcmV0dXJuICdsYXRuJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgTGFuZ1N5c1JlY29yZHMgaW4gdGhlIGdpdmVuIHNjcmlwdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoaXMgc2NyaXB0IHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0YWcgYW5kIHNjcmlwdCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdldFNjcmlwdFRhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZShjcmVhdGUpO1xuICAgICAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBzY3JpcHQgfHwgJ0RGTFQnO1xuICAgICAgICAgICAgdmFyIHNjcmlwdHMgPSBsYXlvdXQuc2NyaXB0cztcbiAgICAgICAgICAgIHZhciBwb3MgPSBzZWFyY2hUYWcobGF5b3V0LnNjcmlwdHMsIHNjcmlwdCk7XG4gICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1twb3NdLnNjcmlwdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IHsgcmVzZXJ2ZWQ6IDAsIHJlcUZlYXR1cmVJbmRleDogMHhmZmZmLCBmZWF0dXJlSW5kZXhlczogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY3JpcHRzLnNwbGljZSgtMSAtIHBvcywgMCwgc2NyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyLnNjcmlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGFuZ3VhZ2Ugc3lzdGVtIHRhYmxlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGlzIGxhbmdTeXNUYWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRMYW5nU3lzVGFibGU6IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgc2NyaXB0VGFibGUgPSB0aGlzLmdldFNjcmlwdFRhYmxlKHNjcmlwdCwgY3JlYXRlKTtcbiAgICAgICAgaWYgKHNjcmlwdFRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoIWxhbmd1YWdlIHx8IGxhbmd1YWdlID09PSAnZGZsdCcgfHwgbGFuZ3VhZ2UgPT09ICdERkxUJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRUYWJsZS5kZWZhdWx0TGFuZ1N5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3MgPSBzZWFyY2hUYWcoc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHMsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRUYWJsZS5sYW5nU3lzUmVjb3Jkc1twb3NdLmxhbmdTeXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICBsYW5nU3lzOiB7IHJlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLnNwbGljZSgtMSAtIHBvcywgMCwgbGFuZ1N5c1JlY29yZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmdTeXNSZWNvcmQubGFuZ1N5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzcGVjaWZpYyBmZWF0dXJlIHRhYmxlLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIE9uZSBvZiB0aGUgY29kZXMgbGlzdGVkIGF0IGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZmVhdHVyZWxpc3QuaHRtXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBmZWF0dXJlIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldEZlYXR1cmVUYWJsZTogZnVuY3Rpb24oc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgY3JlYXRlKSB7XG4gICAgICAgIHZhciBsYW5nU3lzVGFibGUgPSB0aGlzLmdldExhbmdTeXNUYWJsZShzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpO1xuICAgICAgICBpZiAobGFuZ1N5c1RhYmxlKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZVJlY29yZDtcbiAgICAgICAgICAgIHZhciBmZWF0SW5kZXhlcyA9IGxhbmdTeXNUYWJsZS5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgICAgIHZhciBhbGxGZWF0dXJlcyA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdLmZlYXR1cmVzO1xuICAgICAgICAgICAgLy8gVGhlIEZlYXR1cmVJbmRleCBhcnJheSBvZiBpbmRpY2VzIGlzIGluIGFyYml0cmFyeSBvcmRlcixcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgYWxsRmVhdHVyZXMgaXMgc29ydGVkIGFscGhhYmV0aWNhbGx5IGJ5IGZlYXR1cmUgdGFnLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVSZWNvcmQgPSBhbGxGZWF0dXJlc1tmZWF0SW5kZXhlc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVSZWNvcmQudGFnID09PSBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFsbEZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWMgb3JkZXJpbmcgb2YgZmVhdHVyZXMgd291bGQgcmVxdWlyZSB0byBzaGlmdCBmZWF0dXJlIGluZGV4ZXMgaW4gdGhlIHNjcmlwdCBsaXN0LlxuICAgICAgICAgICAgICAgIGNoZWNrLmFzc2VydChpbmRleCA9PT0gMCB8fCBmZWF0dXJlID49IGFsbEZlYXR1cmVzW2luZGV4IC0gMV0udGFnLCAnRmVhdHVyZXMgbXVzdCBiZSBhZGRlZCBpbiBhbHBoYWJldGljYWwgb3JkZXIuJyk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZVJlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBmZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlOiB7IHBhcmFtczogMCwgbG9va3VwTGlzdEluZGV4ZXM6IFtdIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnB1c2goZmVhdHVyZVJlY29yZCk7XG4gICAgICAgICAgICAgICAgZmVhdEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxvb2t1cCB0YWJsZXMgb2YgYSBnaXZlbiB0eXBlIGZvciBhIHNjcmlwdC9sYW5ndWFnZS9mZWF0dXJlLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgY29kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb29rdXBUeXBlIC0gMSB0byA4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBsb29rdXAgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdCwgd2l0aCBubyBzdWJ0YWJsZXMuXG4gICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0TG9va3VwVGFibGVzOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBsb29rdXBUeXBlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIGZlYXR1cmVUYWJsZSA9IHRoaXMuZ2V0RmVhdHVyZVRhYmxlKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGNyZWF0ZSk7XG4gICAgICAgIHZhciB0YWJsZXMgPSBbXTtcbiAgICAgICAgaWYgKGZlYXR1cmVUYWJsZSkge1xuICAgICAgICAgICAgdmFyIGxvb2t1cFRhYmxlO1xuICAgICAgICAgICAgdmFyIGxvb2t1cExpc3RJbmRleGVzID0gZmVhdHVyZVRhYmxlLmxvb2t1cExpc3RJbmRleGVzO1xuICAgICAgICAgICAgdmFyIGFsbExvb2t1cHMgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXS5sb29rdXBzO1xuICAgICAgICAgICAgLy8gbG9va3VwTGlzdEluZGV4ZXMgYXJlIGluIG5vIHBhcnRpY3VsYXIgb3JkZXIsIHNvIHVzZSBuYcOvdmUgc2VhcmNoLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb29rdXBMaXN0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlID0gYWxsTG9va3Vwc1tsb29rdXBMaXN0SW5kZXhlc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgPT09IGxvb2t1cFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVzLnB1c2gobG9va3VwVGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWJsZXMubGVuZ3RoID09PSAwICYmIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlID0ge1xuICAgICAgICAgICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBGbGFnOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0YWJsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFsbExvb2t1cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGFsbExvb2t1cHMucHVzaChsb29rdXBUYWJsZSk7XG4gICAgICAgICAgICAgICAgbG9va3VwTGlzdEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsb29rdXBUYWJsZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhYmxlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBnbHlwaCBpbmRleGVzIG9mIGEgY292ZXJhZ2UgdGFibGUuXG4gICAgICogRm9ybWF0IDE6IHRoZSBsaXN0IGlzIHN0b3JlZCByYXdcbiAgICAgKiBGb3JtYXQgMjogY29tcGFjdCBsaXN0IGFzIHJhbmdlIHJlY29yZHMuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjb3ZlcmFnZVRhYmxlXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZXhwYW5kQ292ZXJhZ2U6IGZ1bmN0aW9uKGNvdmVyYWdlVGFibGUpIHtcbiAgICAgICAgaWYgKGNvdmVyYWdlVGFibGUuZm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY292ZXJhZ2VUYWJsZS5nbHlwaHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gW107XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gY292ZXJhZ2VUYWJsZS5yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdseXBocy5wdXNoKGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnbHlwaHM7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy9sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDM3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgU3Vic3RpdHV0aW9uIG9iamVjdCBwcm92aWRlcyB1dGlsaXR5IG1ldGhvZHMgdG8gbWFuaXB1bGF0ZVxuLy8gdGhlIEdTVUIgc3Vic3RpdHV0aW9uIHRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcbnZhciBMYXlvdXQgPSByZXF1aXJlKCcuL2xheW91dCcpO1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLlN1YnN0aXR1dGlvblxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5MYXlvdXRcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU3Vic3RpdHV0aW9uID0gZnVuY3Rpb24oZm9udCkge1xuICAgIExheW91dC5jYWxsKHRoaXMsIGZvbnQsICdnc3ViJyk7XG59O1xuXG4vLyBDaGVjayBpZiAyIGFycmF5cyBvZiBwcmltaXRpdmVzIGFyZSBlcXVhbC5cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKGFyMSwgYXIyKSB7XG4gICAgdmFyIG4gPSBhcjEubGVuZ3RoO1xuICAgIGlmIChuICE9PSBhcjIubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChhcjFbaV0gIT09IGFyMltpXSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IHN1YnRhYmxlIG9mIGEgbG9va3VwIHRhYmxlIGluIGEgcGFydGljdWxhciBmb3JtYXQuXG5mdW5jdGlvbiBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgZm9ybWF0LCBkZWZhdWx0U3VidGFibGUpIHtcbiAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGUuc3VidGFibGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSBmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJ0YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFN1YnRhYmxlKSB7XG4gICAgICAgIHN1YnRhYmxlcy5wdXNoKGRlZmF1bHRTdWJ0YWJsZSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3VidGFibGU7XG4gICAgfVxufVxuXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlID0gTGF5b3V0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBkZWZhdWx0IEdTVUIgdGFibGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGdzdWIgLSBUaGUgR1NVQiB0YWJsZS5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBHZW5lcmF0ZSBhIGRlZmF1bHQgZW1wdHkgR1NVQiB0YWJsZSB3aXRoIGp1c3QgYSBERkxUIHNjcmlwdCBhbmQgZGZsdCBsYW5nIHN5cy5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBzY3JpcHRzOiBbe1xuICAgICAgICAgICAgdGFnOiAnREZMVCcsXG4gICAgICAgICAgICBzY3JpcHQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czogeyByZXNlcnZlZDogMCwgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsIGZlYXR1cmVJbmRleGVzOiBbXSB9LFxuICAgICAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICBsb29rdXBzOiBbXVxuICAgIH07XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIHNpbmdsZSBzdWJzdGl0dXRpb25zIChsb29rdXAgdHlwZSAxKSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWNoYXJhY3RlciBmZWF0dXJlIG5hbWUgKCdhYWx0JywgJ3NhbHQnLCAnc3MwMScuLi4pXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0U2luZ2xlID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDEpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHN1YnRhYmxlLmRlbHRhR2x5cGhJZDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaCwgYnk6IGdseXBoICsgZGVsdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0ZSA9IHN1YnRhYmxlLnN1YnN0aXR1dGU7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoc1tqXSwgYnk6IHN1YnN0aXR1dGVbal0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb25zO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBhbHRlcm5hdGVzIChsb29rdXAgdHlwZSAzKSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWNoYXJhY3RlciBmZWF0dXJlIG5hbWUgKCdhYWx0JywgJ3NhbHQnLi4uKVxuICogQHJldHVybiB7QXJyYXl9IGFsdGVybmF0ZXMgLSBUaGUgbGlzdCBvZiBhbHRlcm5hdGVzXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0QWx0ZXJuYXRlcyA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgYWx0ZXJuYXRlcyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAzKTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGFsdGVybmF0ZVNldHMgPSBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGVzLnB1c2goeyBzdWI6IGdseXBoc1tqXSwgYnk6IGFsdGVybmF0ZVNldHNbal0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsdGVybmF0ZXM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGxpZ2F0dXJlcyAobG9va3VwIHR5cGUgNCkgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gKiBUaGUgcmVzdWx0IGlzIGFuIGFycmF5IG9mIGxpZ2F0dXJlIG9iamVjdHMgbGlrZSB7IHN1YjogW2lkc10sIGJ5OiBpZCB9XG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHJldHVybiB7QXJyYXl9IGxpZ2F0dXJlcyAtIFRoZSBsaXN0IG9mIGxpZ2F0dXJlcy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRMaWdhdHVyZXMgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxpZ2F0dXJlcyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCA0KTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGxpZ2F0dXJlU2V0cyA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0cztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0R2x5cGggPSBnbHlwaHNbal07XG4gICAgICAgICAgICAgICAgdmFyIGxpZ1NldCA9IGxpZ2F0dXJlU2V0c1tqXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpZ1NldC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlnID0gbGlnU2V0W2tdO1xuICAgICAgICAgICAgICAgICAgICBsaWdhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWI6IFtzdGFydEdseXBoXS5jb25jYXQobGlnLmNvbXBvbmVudHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnk6IGxpZy5saWdHbHlwaFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpZ2F0dXJlcztcbn07XG5cbi8qKlxuICogQWRkIG9yIG1vZGlmeSBhIHNpbmdsZSBzdWJzdGl0dXRpb24gKGxvb2t1cCB0eXBlIDEpXG4gKiBGb3JtYXQgMiwgbW9yZSBmbGV4aWJsZSwgaXMgYWx3YXlzIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGRlbHRhOiBudW1iZXIgfSBmb3IgZm9ybWF0IDEgb3IgeyBzdWI6IGlkLCBieTogaWQgfSBmb3IgZm9ybWF0IDIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRTaW5nbGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzdWJzdGl0dXRpb24sIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAxLCB0cnVlKVswXTtcbiAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMiwgeyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAxIHN1YnRhYmxlLCBmb3JtYXQgMiwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgIGNvdmVyYWdlOiB7IGZvcm1hdDogMSwgZ2x5cGhzOiBbXSB9LFxuICAgICAgICBzdWJzdGl0dXRlOiBbXVxuICAgIH0pO1xuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdMaWdhdHVyZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLnN1YnN0aXR1dGUuc3BsaWNlKHBvcywgMCwgMCk7XG4gICAgfVxuICAgIHN1YnRhYmxlLnN1YnN0aXR1dGVbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcbn07XG5cbi8qKlxuICogQWRkIG9yIG1vZGlmeSBhbiBhbHRlcm5hdGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAxKVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBieTogW2lkc10gfVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkQWx0ZXJuYXRlID0gZnVuY3Rpb24oZmVhdHVyZSwgc3Vic3RpdHV0aW9uLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMywgdHJ1ZSlbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDEsIHsgICAgICAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgMyBzdWJ0YWJsZSwgZm9ybWF0IDEsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgYWx0ZXJuYXRlU2V0czogW11cbiAgICB9KTtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnTGlnYXR1cmU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgKyBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQpO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1YjtcbiAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzLnNwbGljZShwb3MsIDAsIDApO1xuICAgIH1cbiAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpZ2F0dXJlIChsb29rdXAgdHlwZSA0KVxuICogTGlnYXR1cmVzIHdpdGggbW9yZSBjb21wb25lbnRzIG11c3QgYmUgc3RvcmVkIGFoZWFkIG9mIHRob3NlIHdpdGggZmV3ZXIgY29tcG9uZW50cyBpbiBvcmRlciB0byBiZSBmb3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gbGlnYXR1cmUgLSB7IHN1YjogW2lkc10sIGJ5OiBpZCB9XG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRMaWdhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIGxpZ2F0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgNCwgdHJ1ZSlbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gbG9va3VwVGFibGUuc3VidGFibGVzWzBdO1xuICAgIGlmICghc3VidGFibGUpIHtcbiAgICAgICAgc3VidGFibGUgPSB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDQgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgICAgIGxpZ2F0dXJlU2V0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgbG9va3VwVGFibGUuc3VidGFibGVzWzBdID0gc3VidGFibGU7XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdMaWdhdHVyZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBsaWdhdHVyZS5zdWJbMF07XG4gICAgdmFyIGxpZ0NvbXBvbmVudHMgPSBsaWdhdHVyZS5zdWIuc2xpY2UoMSk7XG4gICAgdmFyIGxpZ2F0dXJlVGFibGUgPSB7XG4gICAgICAgIGxpZ0dseXBoOiBsaWdhdHVyZS5ieSxcbiAgICAgICAgY29tcG9uZW50czogbGlnQ29tcG9uZW50c1xuICAgIH07XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIC8vIGxpZ2F0dXJlU2V0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgIHZhciBsaWdhdHVyZVNldCA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0c1twb3NdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpZ2F0dXJlU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBJZiBsaWdhdHVyZSBhbHJlYWR5IGV4aXN0cywgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKGFycmF5c0VxdWFsKGxpZ2F0dXJlU2V0W2ldLmNvbXBvbmVudHMsIGxpZ0NvbXBvbmVudHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxpZ2F0dXJlIGRvZXMgbm90IGV4aXN0OiBhZGQgaXQuXG4gICAgICAgIGxpZ2F0dXJlU2V0LnB1c2gobGlnYXR1cmVUYWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpZ2F0dXJlU2V0IGFuZCBhZGQgY292ZXJhZ2UgZm9yIHRoZSBmaXJzdCBnbHlwaC5cbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUubGlnYXR1cmVTZXRzLnNwbGljZShwb3MsIDAsIFtsaWdhdHVyZVRhYmxlXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBmZWF0dXJlIGRhdGEgZm9yIGEgZ2l2ZW4gc2NyaXB0IGFuZCBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICgvc3NcXGRcXGQvLnRlc3QoZmVhdHVyZSkpIHsgICAgICAgICAgICAgICAvLyBzczAxIC0gc3MyMFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaW5nbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIHN3aXRjaCAoZmVhdHVyZSkge1xuICAgICAgICBjYXNlICdhYWx0JzpcbiAgICAgICAgY2FzZSAnc2FsdCc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaW5nbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSlcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLmdldEFsdGVybmF0ZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkpO1xuICAgICAgICBjYXNlICdkbGlnJzpcbiAgICAgICAgY2FzZSAnbGlnYSc6XG4gICAgICAgIGNhc2UgJ3JsaWcnOiByZXR1cm4gdGhpcy5nZXRMaWdhdHVyZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYSBzdWJzdGl0dXRpb24gdG8gYSBmZWF0dXJlIGZvciBhIGdpdmVuIHNjcmlwdCBhbmQgbGFuZ3VhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IHN1YiAtIHRoZSBzdWJzdGl0dXRpb24gdG8gYWRkIChhbiBvYmplY3QgbGlrZSB7IHN1YjogaWQgb3IgW2lkc10sIGJ5OiBpZCBvciBbaWRzXSB9KVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgaWYgKC9zc1xcZFxcZC8udGVzdChmZWF0dXJlKSkgeyAgICAgICAgICAgICAgIC8vIHNzMDEgLSBzczIwXG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNpbmdsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcbiAgICAgICAgY2FzZSAnYWFsdCc6XG4gICAgICAgIGNhc2UgJ3NhbHQnOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWIuYnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2luZ2xlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBbHRlcm5hdGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgY2FzZSAnZGxpZyc6XG4gICAgICAgIGNhc2UgJ2xpZ2EnOlxuICAgICAgICBjYXNlICdybGlnJzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZExpZ2F0dXJlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdWJzdGl0dXRpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL3N1YnN0aXR1dGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoZSBgZnZhcmAgdGFibGUgc3RvcmVzIGZvbnQgdmFyaWF0aW9uIGF4ZXMgYW5kIGluc3RhbmNlcy5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDYvQ2hhcDZmdmFyLmh0bWxcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbmZ1bmN0aW9uIGFkZE5hbWUobmFtZSwgbmFtZXMpIHtcbiAgICB2YXIgbmFtZVN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG5hbWUpO1xuICAgIHZhciBuYW1lSUQgPSAyNTY7XG4gICAgZm9yICh2YXIgbmFtZUtleSBpbiBuYW1lcykge1xuICAgICAgICB2YXIgbiA9IHBhcnNlSW50KG5hbWVLZXkpO1xuICAgICAgICBpZiAoIW4gfHwgbiA8IDI1Nikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkobmFtZXNbbmFtZUtleV0pID09PSBuYW1lU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lSUQgPD0gbikge1xuICAgICAgICAgICAgbmFtZUlEID0gbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lc1tuYW1lSURdID0gbmFtZTtcbiAgICByZXR1cm4gbmFtZUlEO1xufVxuXG5mdW5jdGlvbiBtYWtlRnZhckF4aXMobiwgYXhpcywgbmFtZXMpIHtcbiAgICB2YXIgbmFtZUlEID0gYWRkTmFtZShheGlzLm5hbWUsIG5hbWVzKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB7bmFtZTogJ3RhZ18nICsgbiwgdHlwZTogJ1RBRycsIHZhbHVlOiBheGlzLnRhZ30sXG4gICAgICAgIHtuYW1lOiAnbWluVmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLm1pblZhbHVlIDw8IDE2fSxcbiAgICAgICAge25hbWU6ICdkZWZhdWx0VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLmRlZmF1bHRWYWx1ZSA8PCAxNn0sXG4gICAgICAgIHtuYW1lOiAnbWF4VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLm1heFZhbHVlIDw8IDE2fSxcbiAgICAgICAge25hbWU6ICdmbGFnc18nICsgbiwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICduYW1lSURfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG4gICAgdmFyIGF4aXMgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGF4aXMudGFnID0gcC5wYXJzZVRhZygpO1xuICAgIGF4aXMubWluVmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBheGlzLmRlZmF1bHRWYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIGF4aXMubWF4VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuICAgIGF4aXMubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG4gICAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIG1ha2VGdmFySW5zdGFuY2UobiwgaW5zdCwgYXhlcywgbmFtZXMpIHtcbiAgICB2YXIgbmFtZUlEID0gYWRkTmFtZShpbnN0Lm5hbWUsIG5hbWVzKTtcbiAgICB2YXIgZmllbGRzID0gW1xuICAgICAgICB7bmFtZTogJ25hbWVJRF8nICsgbiwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lSUR9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzXycgKyBuLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYXhpc1RhZyA9IGF4ZXNbaV0udGFnO1xuICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiAnYXhpc18nICsgbiArICcgJyArIGF4aXNUYWcsXG4gICAgICAgICAgICB0eXBlOiAnRklYRUQnLFxuICAgICAgICAgICAgdmFsdWU6IGluc3QuY29vcmRpbmF0ZXNbYXhpc1RhZ10gPDwgMTZcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gcGFyc2VGdmFySW5zdGFuY2UoZGF0YSwgc3RhcnQsIGF4ZXMsIG5hbWVzKSB7XG4gICAgdmFyIGluc3QgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGluc3QubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTsgIC8vIHJlc2VydmVkIGZvciBmbGFnczsgbm8gdmFsdWVzIGRlZmluZWRcblxuICAgIGluc3QuY29vcmRpbmF0ZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW5zdC5jb29yZGluYXRlc1theGVzW2ldLnRhZ10gPSBwLnBhcnNlRml4ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbn1cblxuZnVuY3Rpb24gbWFrZUZ2YXJUYWJsZShmdmFyLCBuYW1lcykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ2Z2YXInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdvZmZzZXRUb0RhdGEnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NvdW50U2l6ZVBhaXJzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyfSxcbiAgICAgICAge25hbWU6ICdheGlzQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGZ2YXIuYXhlcy5sZW5ndGh9LFxuICAgICAgICB7bmFtZTogJ2F4aXNTaXplJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyMH0sXG4gICAgICAgIHtuYW1lOiAnaW5zdGFuY2VDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZnZhci5pbnN0YW5jZXMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdpbnN0YW5jZVNpemUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDQgKyBmdmFyLmF4ZXMubGVuZ3RoICogNH1cbiAgICBdKTtcbiAgICByZXN1bHQub2Zmc2V0VG9EYXRhID0gcmVzdWx0LnNpemVPZigpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdmFyLmF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LmZpZWxkcyA9IHJlc3VsdC5maWVsZHMuY29uY2F0KG1ha2VGdmFyQXhpcyhpLCBmdmFyLmF4ZXNbaV0sIG5hbWVzKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBmdmFyLmluc3RhbmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICByZXN1bHQuZmllbGRzID0gcmVzdWx0LmZpZWxkcy5jb25jYXQobWFrZUZ2YXJJbnN0YW5jZShqLCBmdmFyLmluc3RhbmNlc1tqXSwgZnZhci5heGVzLCBuYW1lcykpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhclRhYmxlKGRhdGEsIHN0YXJ0LCBuYW1lcykge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMHgwMDAxMDAwMCwgJ1Vuc3VwcG9ydGVkIGZ2YXIgdGFibGUgdmVyc2lvbi4nKTtcbiAgICB2YXIgb2Zmc2V0VG9EYXRhID0gcC5wYXJzZU9mZnNldDE2KCk7XG4gICAgLy8gU2tpcCBjb3VudFNpemVQYWlycy5cbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpO1xuICAgIHZhciBheGlzQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGF4aXNTaXplID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBpbnN0YW5jZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBpbnN0YW5jZVNpemUgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICB2YXIgYXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0NvdW50OyBpKyspIHtcbiAgICAgICAgYXhlcy5wdXNoKHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQgKyBvZmZzZXRUb0RhdGEgKyBpICogYXhpc1NpemUsIG5hbWVzKSk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgIHZhciBpbnN0YW5jZVN0YXJ0ID0gc3RhcnQgKyBvZmZzZXRUb0RhdGEgKyBheGlzQ291bnQgKiBheGlzU2l6ZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluc3RhbmNlQ291bnQ7IGorKykge1xuICAgICAgICBpbnN0YW5jZXMucHVzaChwYXJzZUZ2YXJJbnN0YW5jZShkYXRhLCBpbnN0YW5jZVN0YXJ0ICsgaiAqIGluc3RhbmNlU2l6ZSwgYXhlcywgbmFtZXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2F4ZXM6IGF4ZXMsIGluc3RhbmNlczogaW5zdGFuY2VzfTtcbn1cblxuZXhwb3J0cy5tYWtlID0gbWFrZUZ2YXJUYWJsZTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZUZ2YXJUYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2Z2YXIuanNcbi8vIG1vZHVsZSBpZCA9IDM3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgYGdseWZgIHRhYmxlIGRlc2NyaWJlcyB0aGUgZ2x5cGhzIGluIFRydWVUeXBlIG91dGxpbmUgZm9ybWF0LlxuLy8gaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2dseWYuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciBnbHlwaHNldCA9IHJlcXVpcmUoJy4uL2dseXBoc2V0Jyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi9wYXRoJyk7XG5cbi8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGRhdGEgZm9yIGEgZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBwcmV2aW91c1ZhbHVlLCBzaG9ydFZlY3RvckJpdE1hc2ssIHNhbWVCaXRNYXNrKSB7XG4gICAgdmFyIHY7XG4gICAgaWYgKChmbGFnICYgc2hvcnRWZWN0b3JCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgLy8gVGhlIGNvb3JkaW5hdGUgaXMgMSBieXRlIGxvbmcuXG4gICAgICAgIHYgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAvLyBUaGUgYHNhbWVgIGJpdCBpcyByZS11c2VkIGZvciBzaG9ydCB2YWx1ZXMgdG8gc2lnbmlmeSB0aGUgc2lnbiBvZiB0aGUgdmFsdWUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA9PT0gMCkge1xuICAgICAgICAgICAgdiA9IC12O1xuICAgICAgICB9XG5cbiAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBUaGUgY29vcmRpbmF0ZSBpcyAyIGJ5dGVzIGxvbmcuXG4gICAgICAgIC8vIElmIHRoZSBgc2FtZWAgYml0IGlzIHNldCwgdGhlIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGNvb3JkaW5hdGUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgYXMgYSBzaWduZWQgMTYtYml0IGRlbHRhIHZhbHVlLlxuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2O1xufVxuXG4vLyBQYXJzZSBhIFRydWVUeXBlIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VHbHlwaChnbHlwaCwgZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGdseXBoLm51bWJlck9mQ29udG91cnMgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl95TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3hNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHZhciBmbGFncztcbiAgICB2YXIgZmxhZztcbiAgICBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA+IDApIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuICAgICAgICB2YXIgZW5kUG9pbnRJbmRpY2VzID0gZ2x5cGguZW5kUG9pbnRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaC5udW1iZXJPZkNvbnRvdXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGVuZFBvaW50SW5kaWNlcy5wdXNoKHAucGFyc2VVU2hvcnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMucHVzaChwLnBhcnNlQnl0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudW1iZXJPZkNvb3JkaW5hdGVzID0gZW5kUG9pbnRJbmRpY2VzW2VuZFBvaW50SW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgIGZsYWdzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZsYWcgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgICAgICAgIC8vIElmIGJpdCAzIGlzIHNldCwgd2UgcmVwZWF0IHRoaXMgZmxhZyBuIHRpbWVzLCB3aGVyZSBuIGlzIHRoZSBuZXh0IGJ5dGUuXG4gICAgICAgICAgICBpZiAoKGZsYWcgJiA4KSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwZWF0Q291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2suYXJndW1lbnQoZmxhZ3MubGVuZ3RoID09PSBudW1iZXJPZkNvb3JkaW5hdGVzLCAnQmFkIGZsYWdzLicpO1xuXG4gICAgICAgIGlmIChlbmRQb2ludEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHBvaW50O1xuICAgICAgICAgICAgLy8gWC9ZIGNvb3JkaW5hdGVzIGFyZSByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgcG9pbnQsIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IHBvaW50IHdoaWNoIGlzIHJlbGF0aXZlIHRvIDAsMC5cbiAgICAgICAgICAgIGlmIChudW1iZXJPZkNvb3JkaW5hdGVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5vbkN1cnZlID0gISEoZmxhZyAmIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5sYXN0UG9pbnRPZkNvbnRvdXIgPSBlbmRQb2ludEluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHB4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnggPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweCwgMiwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBweCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHB5ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnkgPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweSwgNCwgMzIpO1xuICAgICAgICAgICAgICAgICAgICBweSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA9PT0gMCkge1xuICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbHlwaC5pc0NvbXBvc2l0ZSA9IHRydWU7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICBnbHlwaC5jb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciBtb3JlQ29tcG9uZW50cyA9IHRydWU7XG4gICAgICAgIHdoaWxlIChtb3JlQ29tcG9uZW50cykge1xuICAgICAgICAgICAgZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXg6IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICB4U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgc2NhbGUwMTogMCxcbiAgICAgICAgICAgICAgICBzY2FsZTEwOiAwLFxuICAgICAgICAgICAgICAgIHlTY2FsZTogMSxcbiAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICBkeTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSB3b3Jkc1xuICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPSBbcC5wYXJzZVVTaG9ydCgpLCBwLnBhcnNlVVNob3J0KCldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSBieXRlc1xuICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR4ID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR5ID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG1hdGNoZWQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID0gW3AucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmbGFncyAmIDgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgNjQpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gWCAvIFkgc2NhbGVcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgMTI4KSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgMngyIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMDEgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zY2FsZTEwID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2x5cGguY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBtb3JlQ29tcG9uZW50cyA9ICEhKGZsYWdzICYgMzIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgcG9pbnRzIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgbmV3UG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgbmV3UHQgPSB7XG4gICAgICAgICAgICB4OiB0cmFuc2Zvcm0ueFNjYWxlICogcHQueCArIHRyYW5zZm9ybS5zY2FsZTAxICogcHQueSArIHRyYW5zZm9ybS5keCxcbiAgICAgICAgICAgIHk6IHRyYW5zZm9ybS5zY2FsZTEwICogcHQueCArIHRyYW5zZm9ybS55U2NhbGUgKiBwdC55ICsgdHJhbnNmb3JtLmR5LFxuICAgICAgICAgICAgb25DdXJ2ZTogcHQub25DdXJ2ZSxcbiAgICAgICAgICAgIGxhc3RQb2ludE9mQ29udG91cjogcHQubGFzdFBvaW50T2ZDb250b3VyXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKG5ld1B0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBnZXRDb250b3Vycyhwb2ludHMpIHtcbiAgICB2YXIgY29udG91cnMgPSBbXTtcbiAgICB2YXIgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXRoLlBhdGgoKTtcbiAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgY29udG91cnMgPSBnZXRDb250b3Vycyhwb2ludHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udG91cnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNvbnRvdXIgPSBjb250b3Vyc1tpXTtcbiAgICAgICAgdmFyIGZpcnN0UHQgPSBjb250b3VyWzBdO1xuICAgICAgICB2YXIgbGFzdFB0ID0gY29udG91cltjb250b3VyLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgY3VydmVQdDtcbiAgICAgICAgdmFyIHJlYWxGaXJzdFBvaW50O1xuICAgICAgICBpZiAoZmlyc3RQdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCB3aWxsIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb3ZlVG8gY29tbWFuZCxcbiAgICAgICAgICAgIC8vIHNvIHNraXAgaXQgaW4gdGhlIGxvb3AuXG4gICAgICAgICAgICByZWFsRmlyc3RQb2ludCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFzdFB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgcG9pbnQgaXMgb2ZmLWN1cnZlIGFuZCB0aGUgbGFzdCBwb2ludCBpcyBvbi1jdXJ2ZSxcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCB0aGUgbGFzdCBwb2ludC5cbiAgICAgICAgICAgICAgICBmaXJzdFB0ID0gbGFzdFB0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG4gICAgICAgICAgICAgICAgZmlyc3RQdCA9IHsgeDogKGZpcnN0UHQueCArIGxhc3RQdC54KSAvIDIsIHk6IChmaXJzdFB0LnkgKyBsYXN0UHQueSkgLyAyIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnZlUHQgPSBmaXJzdFB0O1xuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHBvaW50IGlzIHN5bnRoZXNpemVkLCBzbyBkb24ndCBza2lwIHRoZSByZWFsIGZpcnN0IHBvaW50LlxuICAgICAgICAgICAgcmVhbEZpcnN0UG9pbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHAubW92ZVRvKGZpcnN0UHQueCwgZmlyc3RQdC55KTtcblxuICAgICAgICBmb3IgKHZhciBqID0gcmVhbEZpcnN0UG9pbnQgPyAxIDogMDsgaiA8IGNvbnRvdXIubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBwdCA9IGNvbnRvdXJbal07XG4gICAgICAgICAgICB2YXIgcHJldlB0ID0gaiA9PT0gMCA/IGZpcnN0UHQgOiBjb250b3VyW2ogLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2UHQub25DdXJ2ZSAmJiBwdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHN0cmFpZ2h0IGxpbmUuXG4gICAgICAgICAgICAgICAgcC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZQdC5vbkN1cnZlICYmICFwdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgY3VydmVQdCA9IHB0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcHJldlB0Lm9uQ3VydmUgJiYgIXB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWlkUHQgPSB7IHg6IChwcmV2UHQueCArIHB0LngpIC8gMiwgeTogKHByZXZQdC55ICsgcHQueSkgLyAyIH07XG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKHByZXZQdC54LCBwcmV2UHQueSwgbWlkUHQueCwgbWlkUHQueSk7XG4gICAgICAgICAgICAgICAgY3VydmVQdCA9IHB0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcHJldlB0Lm9uQ3VydmUgJiYgcHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZpb3VzIHBvaW50IG9mZi1jdXJ2ZSwgdGhpcyBwb2ludCBvbi1jdXJ2ZS5cbiAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3VydmVQdC54LCBjdXJ2ZVB0LnksIHB0LngsIHB0LnkpO1xuICAgICAgICAgICAgICAgIGN1cnZlUHQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RQdCAhPT0gbGFzdFB0KSB7XG4gICAgICAgICAgICAvLyBDb25uZWN0IHRoZSBsYXN0IGFuZCBmaXJzdCBwb2ludHNcbiAgICAgICAgICAgIGlmIChjdXJ2ZVB0KSB7XG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnZlUHQueCwgY3VydmVQdC55LCBmaXJzdFB0LngsIGZpcnN0UHQueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAubGluZVRvKGZpcnN0UHQueCwgZmlyc3RQdC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChnbHlwaHMsIGdseXBoKSB7XG4gICAgaWYgKGdseXBoLmlzQ29tcG9zaXRlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGguY29tcG9uZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGdseXBoLmNvbXBvbmVudHNbal07XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50R2x5cGggPSBnbHlwaHMuZ2V0KGNvbXBvbmVudC5nbHlwaEluZGV4KTtcbiAgICAgICAgICAgIC8vIEZvcmNlIHRoZSB0dGZHbHlwaExvYWRlciB0byBwYXJzZSB0aGUgZ2x5cGguXG4gICAgICAgICAgICBjb21wb25lbnRHbHlwaC5nZXRQYXRoKCk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50R2x5cGgucG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBwb3NpdGlvbmVkIGJ5IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjb21wb25lbnQubWF0Y2hlZFBvaW50c1swXSA+IGdseXBoLnBvaW50cy5sZW5ndGggLSAxKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdID4gY29tcG9uZW50R2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTWF0Y2hlZCBwb2ludHMgb3V0IG9mIHJhbmdlIGluICcgKyBnbHlwaC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RQdCA9IGdseXBoLnBvaW50c1tjb21wb25lbnQubWF0Y2hlZFBvaW50c1swXV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRQdCA9IGNvbXBvbmVudEdseXBoLnBvaW50c1tjb21wb25lbnQubWF0Y2hlZFBvaW50c1sxXV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4U2NhbGU6IGNvbXBvbmVudC54U2NhbGUsIHNjYWxlMDE6IGNvbXBvbmVudC5zY2FsZTAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUxMDogY29tcG9uZW50LnNjYWxlMTAsIHlTY2FsZTogY29tcG9uZW50LnlTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4OiAwLCBkeTogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZWNvbmRQdCA9IHRyYW5zZm9ybVBvaW50cyhbc2Vjb25kUHRdLCB0cmFuc2Zvcm0pWzBdO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZHggPSBmaXJzdFB0LnggLSBzZWNvbmRQdC54O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZHkgPSBmaXJzdFB0LnkgLSBzZWNvbmRQdC55O1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IGdseXBoLnBvaW50cy5jb25jYXQodHJhbnNmb3JtZWRQb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFBhdGgoZ2x5cGgucG9pbnRzKTtcbn1cblxuLy8gUGFyc2UgYWxsIHRoZSBnbHlwaHMgYWNjb3JkaW5nIHRvIHRoZSBvZmZzZXRzIGZyb20gdGhlIGBsb2NhYCB0YWJsZS5cbmZ1bmN0aW9uIHBhcnNlR2x5ZlRhYmxlKGRhdGEsIHN0YXJ0LCBsb2NhLCBmb250KSB7XG4gICAgdmFyIGdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcbiAgICB2YXIgaTtcblxuICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvY2EgdGFibGUgaXMgaW52YWxpZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbG9jYS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGxvY2FbaV07XG4gICAgICAgIHZhciBuZXh0T2Zmc2V0ID0gbG9jYVtpICsgMV07XG4gICAgICAgIGlmIChvZmZzZXQgIT09IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LnR0ZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlR2x5cGgsIGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBidWlsZFBhdGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LmdseXBoTG9hZGVyKGZvbnQsIGkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbHlwaHM7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUdseWZUYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dseWYuanNcbi8vIG1vZHVsZSBpZCA9IDM4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcblxuLy8gUGFyc2UgU2NyaXB0TGlzdCBhbmQgRmVhdHVyZUxpc3QgdGFibGVzIG9mIEdQT1MsIEdTVUIsIEdERUYsIEJBU0UsIEpTVEYgdGFibGVzLlxuLy8gVGhlc2UgbGlzdHMgYXJlIHVudXNlZCBieSBub3csIHRoaXMgZnVuY3Rpb24gaXMganVzdCB0aGUgYmFzaXMgZm9yIGEgcmVhbCBwYXJzaW5nLlxuZnVuY3Rpb24gcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBuID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGlzdFtwLnBhcnNlVGFnKCldID0geyBvZmZzZXQ6IHAucGFyc2VVU2hvcnQoKSB9O1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyBQYXJzZSBhIGNvdmVyYWdlIHRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gRm9ybWF0IDEgaXMgYSBzaW1wbGUgbGlzdCBvZiBnbHlwaCBpZHMsXG4vLyBGb3JtYXQgMiBpcyBhIGxpc3Qgb2YgcmFuZ2VzLiBJdCBpcyBleHBhbmRlZCBpbiBhIGxpc3Qgb2YgZ2x5cGhzLCBtYXliZSBub3QgdGhlIGJlc3QgaWRlYS5cbmZ1bmN0aW9uIHBhcnNlQ292ZXJhZ2VUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY291bnQgPSAgcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHAucGFyc2VVU2hvcnRMaXN0KGNvdW50KTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgY292ZXJhZ2UgPSBbXTtcbiAgICAgICAgZm9yICg7IGNvdW50LS07KSB7XG4gICAgICAgICAgICB2YXIgYmVnaW4gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2VbaW5kZXgrK10gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdmVyYWdlO1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBDbGFzcyBEZWZpbml0aW9uIFRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBhIGNsYXNzIHZhbHVlIGZyb20gYSBnbHlwaCBJRC5cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NEZWZUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIC8vIEZvcm1hdCAxIHNwZWNpZmllcyBhIHJhbmdlIG9mIGNvbnNlY3V0aXZlIGdseXBoIGluZGljZXMsIG9uZSBjbGFzcyBwZXIgZ2x5cGggSUQuXG4gICAgICAgIHZhciBzdGFydEdseXBoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgZ2x5cGhDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBwLnBhcnNlVVNob3J0TGlzdChnbHlwaENvdW50KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGdseXBoSUQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzW2dseXBoSUQgLSBzdGFydEdseXBoXSB8fCAwO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIC8vIEZvcm1hdCAyIGRlZmluZXMgbXVsdGlwbGUgZ3JvdXBzIG9mIGdseXBoIGluZGljZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHNhbWUgY2xhc3MuXG4gICAgICAgIHZhciByYW5nZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgc3RhcnRHbHlwaHMgPSBbXTtcbiAgICAgICAgdmFyIGVuZEdseXBocyA9IFtdO1xuICAgICAgICB2YXIgY2xhc3NWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZW5kR2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY2xhc3NWYWx1ZXNbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZ2x5cGhJRCkge1xuICAgICAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICAgICAgdmFyIHIgPSBzdGFydEdseXBocy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGwgPCByKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSAobCArIHIgKyAxKSA+PiAxO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaElEIDwgc3RhcnRHbHlwaHNbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IGMgLSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXJ0R2x5cGhzW2xdIDw9IGdseXBoSUQgJiYgZ2x5cGhJRCA8PSBlbmRHbHlwaHNbbF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NWYWx1ZXNbbF0gfHwgMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vLyBQYXJzZSBhIHBhaXIgYWRqdXN0bWVudCBwb3NpdGlvbmluZyBzdWJ0YWJsZSwgZm9ybWF0IDEgb3IgZm9ybWF0IDJcbi8vIFRoZSBzdWJ0YWJsZSBpcyByZXR1cm5lZCBpbiB0aGUgZm9ybSBvZiBhIGxvb2t1cCBmdW5jdGlvbi5cbmZ1bmN0aW9uIHBhcnNlUGFpclBvc1N1YlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICAvLyBUaGlzIHBhcnQgaXMgY29tbW9uIHRvIGZvcm1hdCAxIGFuZCBmb3JtYXQgMiBzdWJ0YWJsZXNcbiAgICB2YXIgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBjb3ZlcmFnZU9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY292ZXJhZ2UgPSBwYXJzZUNvdmVyYWdlVGFibGUoZGF0YSwgc3RhcnQgKyBjb3ZlcmFnZU9mZnNldCk7XG4gICAgLy8gdmFsdWVGb3JtYXQgNDogWEFkdmFuY2Ugb25seSwgMTogWFBsYWNlbWVudCBvbmx5LCAwOiBubyBWYWx1ZVJlY29yZCBmb3Igc2Vjb25kIGdseXBoXG4gICAgLy8gT25seSB2YWx1ZUZvcm1hdDE9NCBhbmQgdmFsdWVGb3JtYXQyPTAgaXMgc3VwcG9ydGVkLlxuICAgIHZhciB2YWx1ZUZvcm1hdDEgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHZhbHVlRm9ybWF0MiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgdmFsdWUxO1xuICAgIHZhciB2YWx1ZTI7XG4gICAgaWYgKHZhbHVlRm9ybWF0MSAhPT0gNCB8fCB2YWx1ZUZvcm1hdDIgIT09IDApIHJldHVybjtcbiAgICB2YXIgc2hhcmVkUGFpclNldHMgPSB7fTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIC8vIFBhaXIgUG9zaXRpb25pbmcgQWRqdXN0bWVudDogRm9ybWF0IDFcbiAgICAgICAgdmFyIHBhaXJTZXRDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHBhaXJTZXQgPSBbXTtcbiAgICAgICAgLy8gQXJyYXkgb2Ygb2Zmc2V0cyB0byBQYWlyU2V0IHRhYmxlcy1mcm9tIGJlZ2lubmluZyBvZiBQYWlyUG9zIHN1YnRhYmxlLW9yZGVyZWQgYnkgQ292ZXJhZ2UgSW5kZXhcbiAgICAgICAgdmFyIHBhaXJTZXRPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChwYWlyU2V0Q291bnQpO1xuICAgICAgICBmb3IgKHZhciBmaXJzdEdseXBoID0gMDsgZmlyc3RHbHlwaCA8IHBhaXJTZXRDb3VudDsgZmlyc3RHbHlwaCsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpclNldE9mZnNldCA9IHBhaXJTZXRPZmZzZXRzW2ZpcnN0R2x5cGhdO1xuICAgICAgICAgICAgdmFyIHNoYXJlZFBhaXJTZXQgPSBzaGFyZWRQYWlyU2V0c1twYWlyU2V0T2Zmc2V0XTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkUGFpclNldCkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcGFpcnNldCB0YWJsZSBpbiBhIHBhaXIgYWRqdXN0bWVudCBzdWJ0YWJsZSBmb3JtYXQgMVxuICAgICAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBwLnJlbGF0aXZlT2Zmc2V0ID0gcGFpclNldE9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgcGFpclZhbHVlQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgZm9yICg7IHBhaXJWYWx1ZUNvdW50LS07KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRHbHlwaCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MSkgdmFsdWUxID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUZvcm1hdDIpIHZhbHVlMiA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdmFsdWVGb3JtYXQxID0gNCBhbmQgdmFsdWVGb3JtYXQyID0gMCxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdmFsdWUxIGlzIHRoZSBYQWR2YW5jZSBhbmQgdmFsdWUyIGlzIGVtcHR5LlxuICAgICAgICAgICAgICAgICAgICBzaGFyZWRQYWlyU2V0W3NlY29uZEdseXBoXSA9IHZhbHVlMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhaXJTZXRbY292ZXJhZ2VbZmlyc3RHbHlwaF1dID0gc2hhcmVkUGFpclNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICAgICAgICAgIHZhciBwYWlycyA9IHBhaXJTZXRbbGVmdEdseXBoXTtcbiAgICAgICAgICAgIGlmIChwYWlycykgcmV0dXJuIHBhaXJzW3JpZ2h0R2x5cGhdO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIC8vIFBhaXIgUG9zaXRpb25pbmcgQWRqdXN0bWVudDogRm9ybWF0IDJcbiAgICAgICAgdmFyIGNsYXNzRGVmMU9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGNsYXNzRGVmMk9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGNsYXNzMUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgY2xhc3MyQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBnZXRDbGFzczEgPSBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQgKyBjbGFzc0RlZjFPZmZzZXQpO1xuICAgICAgICB2YXIgZ2V0Q2xhc3MyID0gcGFyc2VDbGFzc0RlZlRhYmxlKGRhdGEsIHN0YXJ0ICsgY2xhc3NEZWYyT2Zmc2V0KTtcblxuICAgICAgICAvLyBQYXJzZSBrZXJuaW5nIHZhbHVlcyBieSBjbGFzcyBwYWlyLlxuICAgICAgICB2YXIga2VybmluZ01hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzMUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXJuaW5nUm93ID0ga2VybmluZ01hdHJpeFtpXSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzczJDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MSkgdmFsdWUxID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MikgdmFsdWUyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgLy8gc28gdmFsdWUxIGlzIHRoZSBYQWR2YW5jZSBhbmQgdmFsdWUyIGlzIGVtcHR5LlxuICAgICAgICAgICAgICAgIGtlcm5pbmdSb3dbal0gPSB2YWx1ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGNvdmVyYWdlIGxpc3QgdG8gYSBoYXNoXG4gICAgICAgIHZhciBjb3ZlcmVkID0ge307XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3ZlcmFnZS5sZW5ndGg7IGkrKykgY292ZXJlZFtjb3ZlcmFnZVtpXV0gPSAxO1xuXG4gICAgICAgIC8vIEdldCB0aGUga2VybmluZyB2YWx1ZSBmb3IgYSBzcGVjaWZpYyBnbHlwaCBwYWlyLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24obGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgICAgICAgICBpZiAoIWNvdmVyZWRbbGVmdEdseXBoXSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGNsYXNzMSA9IGdldENsYXNzMShsZWZ0R2x5cGgpO1xuICAgICAgICAgICAgdmFyIGNsYXNzMiA9IGdldENsYXNzMihyaWdodEdseXBoKTtcbiAgICAgICAgICAgIHZhciBrZXJuaW5nUm93ID0ga2VybmluZ01hdHJpeFtjbGFzczFdO1xuXG4gICAgICAgICAgICBpZiAoa2VybmluZ1Jvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXJuaW5nUm93W2NsYXNzMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vLyBQYXJzZSBhIExvb2t1cFRhYmxlIChwcmVzZW50IGluIG9mIEdQT1MsIEdTVUIsIEdERUYsIEJBU0UsIEpTVEYgdGFibGVzKS5cbmZ1bmN0aW9uIHBhcnNlTG9va3VwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBsb29rdXBUeXBlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBsb29rdXBGbGFnID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgdmFyIHN1YlRhYmxlQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHN1YlRhYmxlT2Zmc2V0cyA9IHAucGFyc2VPZmZzZXQxNkxpc3Qoc3ViVGFibGVDb3VudCk7XG4gICAgdmFyIHRhYmxlID0ge1xuICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICBsb29rdXBGbGFnOiBsb29rdXBGbGFnLFxuICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gcC5wYXJzZVVTaG9ydCgpIDogLTFcbiAgICB9O1xuICAgIC8vIExvb2t1cFR5cGUgMiwgUGFpciBhZGp1c3RtZW50XG4gICAgaWYgKGxvb2t1cFR5cGUgPT09IDIpIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YlRhYmxlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhaXJQb3NTdWJUYWJsZSA9IHBhcnNlUGFpclBvc1N1YlRhYmxlKGRhdGEsIHN0YXJ0ICsgc3ViVGFibGVPZmZzZXRzW2ldKTtcbiAgICAgICAgICAgIGlmIChwYWlyUG9zU3ViVGFibGUpIHN1YnRhYmxlcy5wdXNoKHBhaXJQb3NTdWJUYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggZmluZHMgdGhlIGtlcm5pbmcgdmFsdWVzIGluIHRoZSBzdWJ0YWJsZXMuXG4gICAgICAgIHRhYmxlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN1YnRhYmxlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdWJ0YWJsZXNbaV0obGVmdEdseXBoLCByaWdodEdseXBoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIFBhcnNlIHRoZSBgR1BPU2AgdGFibGUgd2hpY2ggY29udGFpbnMsIGFtb25nIG90aGVyIHRoaW5ncywga2VybmluZyBwYWlycy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cbmZ1bmN0aW9uIHBhcnNlR3Bvc1RhYmxlKGRhdGEsIHN0YXJ0LCBmb250KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxLCAnVW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSB2ZXJzaW9uLicpO1xuXG4gICAgLy8gU2NyaXB0TGlzdCBhbmQgRmVhdHVyZUxpc3QgLSBpZ25vcmVkIGZvciBub3dcbiAgICBwYXJzZVRhZ2dlZExpc3RUYWJsZShkYXRhLCBzdGFydCArIHAucGFyc2VVU2hvcnQoKSk7XG4gICAgLy8gJ2tlcm4nIGlzIHRoZSBmZWF0dXJlIHdlIGFyZSBsb29raW5nIGZvci5cbiAgICBwYXJzZVRhZ2dlZExpc3RUYWJsZShkYXRhLCBzdGFydCArIHAucGFyc2VVU2hvcnQoKSk7XG5cbiAgICAvLyBMb29rdXBMaXN0XG4gICAgdmFyIGxvb2t1cExpc3RPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgcC5yZWxhdGl2ZU9mZnNldCA9IGxvb2t1cExpc3RPZmZzZXQ7XG4gICAgdmFyIGxvb2t1cENvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBsb29rdXBUYWJsZU9mZnNldHMgPSBwLnBhcnNlT2Zmc2V0MTZMaXN0KGxvb2t1cENvdW50KTtcbiAgICB2YXIgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0ID0gc3RhcnQgKyBsb29rdXBMaXN0T2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9va3VwQ291bnQ7IGkrKykge1xuICAgICAgICB2YXIgdGFibGUgPSBwYXJzZUxvb2t1cFRhYmxlKGRhdGEsIGxvb2t1cExpc3RBYnNvbHV0ZU9mZnNldCArIGxvb2t1cFRhYmxlT2Zmc2V0c1tpXSk7XG4gICAgICAgIGlmICh0YWJsZS5sb29rdXBUeXBlID09PSAyICYmICFmb250LmdldEdwb3NLZXJuaW5nVmFsdWUpIGZvbnQuZ2V0R3Bvc0tlcm5pbmdWYWx1ZSA9IHRhYmxlLmdldEtlcm5pbmdWYWx1ZTtcbiAgICB9XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUdwb3NUYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dwb3MuanNcbi8vIG1vZHVsZSBpZCA9IDM4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgYGtlcm5gIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMuXG4vLyBOb3RlIHRoYXQgc29tZSBmb250cyB1c2UgdGhlIEdQT1MgT3BlblR5cGUgbGF5b3V0IHRhYmxlIHRvIHNwZWNpZnkga2VybmluZy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMva2Vybi5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApIHtcbiAgICB2YXIgcGFpcnMgPSB7fTtcbiAgICAvLyBTa2lwIG5UYWJsZXMuXG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICB2YXIgc3VidGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gc3ViLXRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBzdWJ0YWJsZUxlbmd0aCwgc3VidGFibGVDb3ZlcmFnZVxuICAgIHAuc2tpcCgndVNob3J0JywgMik7XG4gICAgdmFyIG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIHBhaXJzW2xlZnRJbmRleCArICcsJyArIHJpZ2h0SW5kZXhdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cblxuZnVuY3Rpb24gcGFyc2VNYWNLZXJuVGFibGUocCkge1xuICAgIHZhciBwYWlycyA9IHt9O1xuICAgIC8vIFRoZSBNYWMga2VybiB0YWJsZSBzdG9yZXMgdGhlIHZlcnNpb24gYXMgYSBmaXhlZCAoMzIgYml0cykgYnV0IHdlIG9ubHkgbG9hZGVkIHRoZSBmaXJzdCAxNiBiaXRzLlxuICAgIC8vIFNraXAgdGhlIHJlc3QuXG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICB2YXIgblRhYmxlcyA9IHAucGFyc2VVTG9uZygpO1xuICAgIC8vY2hlY2suYXJndW1lbnQoblRhYmxlcyA9PT0gMSwgJ09ubHkgMSBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQgKGdvdCAnICsgblRhYmxlcyArICcpLicpO1xuICAgIGlmIChuVGFibGVzID4gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ09ubHkgdGhlIGZpcnN0IGtlcm4gc3VidGFibGUgaXMgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICBwLnNraXAoJ3VMb25nJyk7XG4gICAgdmFyIGNvdmVyYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBzdWJ0YWJsZVZlcnNpb24gPSBjb3ZlcmFnZSAmIDB4RkY7XG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICBpZiAoc3VidGFibGVWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHZhciBuUGFpcnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5cbi8vIFBhcnNlIHRoZSBga2VybmAgdGFibGUgd2hpY2ggY29udGFpbnMga2VybmluZyBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlS2VyblRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlV2luZG93c0tlcm5UYWJsZShwKTtcbiAgICB9IGVsc2UgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcGFyc2VNYWNLZXJuVGFibGUocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24gKCcgKyB0YWJsZVZlcnNpb24gKyAnKS4nKTtcbiAgICB9XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUtlcm5UYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2tlcm4uanNcbi8vIG1vZHVsZSBpZCA9IDM4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGUgYGxvY2FgIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2xvY2EuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcblxuLy8gUGFyc2UgdGhlIGBsb2NhYCB0YWJsZS4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LFxuLy8gcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2x5cGhEYXRhIHRhYmxlLlxuLy8gVGhlIG51bWJlciBvZiBnbHlwaHMgc3RvcmVkIGluIHRoZSBgbG9jYWAgdGFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBgbWF4cGAgdGFibGUgKHVuZGVyIG51bUdseXBocylcbi8vIFRoZSBsb2NhIHRhYmxlIGhhcyB0d28gdmVyc2lvbnM6IGEgc2hvcnQgdmVyc2lvbiB3aGVyZSBvZmZzZXRzIGFyZSBzdG9yZWQgYXMgdVNob3J0cywgYW5kIGEgbG9uZ1xuLy8gdmVyc2lvbiB3aGVyZSBvZmZzZXRzIGFyZSBzdG9yZWQgYXMgdUxvbmdzLiBUaGUgYGhlYWRgIHRhYmxlIHNwZWNpZmllcyB3aGljaCB2ZXJzaW9uIHRvIHVzZVxuLy8gKHVuZGVyIGluZGV4VG9Mb2NGb3JtYXQpLlxuZnVuY3Rpb24gcGFyc2VMb2NhVGFibGUoZGF0YSwgc3RhcnQsIG51bUdseXBocywgc2hvcnRWZXJzaW9uKSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgcGFyc2VGbiA9IHNob3J0VmVyc2lvbiA/IHAucGFyc2VVU2hvcnQgOiBwLnBhcnNlVUxvbmc7XG4gICAgLy8gVGhlcmUgaXMgYW4gZXh0cmEgZW50cnkgYWZ0ZXIgdGhlIGxhc3QgaW5kZXggZWxlbWVudCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIGxhc3QgZ2x5cGguXG4gICAgLy8gVGhhdCdzIHdoeSB3ZSB1c2UgbnVtR2x5cGhzICsgMS5cbiAgICB2YXIgZ2x5cGhPZmZzZXRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHMgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoT2Zmc2V0ID0gcGFyc2VGbi5jYWxsKHApO1xuICAgICAgICBpZiAoc2hvcnRWZXJzaW9uKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2hvcnQgdGFibGUgdmVyc2lvbiBzdG9yZXMgdGhlIGFjdHVhbCBvZmZzZXQgZGl2aWRlZCBieSAyLlxuICAgICAgICAgICAgZ2x5cGhPZmZzZXQgKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoT2Zmc2V0cy5wdXNoKGdseXBoT2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhPZmZzZXRzO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VMb2NhVGFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9sb2NhLmpzXG4vLyBtb2R1bGUgaWQgPSAzODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhlIGBzZm50YCB3cmFwcGVyIHByb3ZpZGVzIG9yZ2FuaXphdGlvbiBmb3IgdGhlIHRhYmxlcyBpbiB0aGUgZm9udC5cbi8vIEl0IGlzIHRoZSB0b3AtbGV2ZWwgZGF0YSBzdHJ1Y3R1cmUgaW4gYSBmb250LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9vdGZmLmh0bVxuLy8gUmVjb21tZW5kYXRpb25zIGZvciBjcmVhdGluZyBPcGVuVHlwZSBGb250czpcbi8vIGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYzE0MC9yZWNvbS5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxudmFyIGNtYXAgPSByZXF1aXJlKCcuL2NtYXAnKTtcbnZhciBjZmYgPSByZXF1aXJlKCcuL2NmZicpO1xudmFyIGhlYWQgPSByZXF1aXJlKCcuL2hlYWQnKTtcbnZhciBoaGVhID0gcmVxdWlyZSgnLi9oaGVhJyk7XG52YXIgaG10eCA9IHJlcXVpcmUoJy4vaG10eCcpO1xudmFyIGx0YWcgPSByZXF1aXJlKCcuL2x0YWcnKTtcbnZhciBtYXhwID0gcmVxdWlyZSgnLi9tYXhwJyk7XG52YXIgX25hbWUgPSByZXF1aXJlKCcuL25hbWUnKTtcbnZhciBvczIgPSByZXF1aXJlKCcuL29zMicpO1xudmFyIHBvc3QgPSByZXF1aXJlKCcuL3Bvc3QnKTtcbnZhciBnc3ViID0gcmVxdWlyZSgnLi9nc3ViJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vbWV0YScpO1xuXG5mdW5jdGlvbiBsb2cyKHYpIHtcbiAgICByZXR1cm4gTWF0aC5sb2codikgLyBNYXRoLmxvZygyKSB8IDA7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaGVja1N1bShieXRlcykge1xuICAgIHdoaWxlIChieXRlcy5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgfVxuXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBzdW0gKz0gKGJ5dGVzW2ldIDw8IDI0KSArXG4gICAgICAgICAgICAoYnl0ZXNbaSArIDFdIDw8IDE2KSArXG4gICAgICAgICAgICAoYnl0ZXNbaSArIDJdIDw8IDgpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgM10pO1xuICAgIH1cblxuICAgIHN1bSAlPSBNYXRoLnBvdygyLCAzMik7XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gbWFrZVRhYmxlUmVjb3JkKHRhZywgY2hlY2tTdW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ1RhYmxlIFJlY29yZCcsIFtcbiAgICAgICAge25hbWU6ICd0YWcnLCB0eXBlOiAnVEFHJywgdmFsdWU6IHRhZyAhPT0gdW5kZWZpbmVkID8gdGFnIDogJyd9LFxuICAgICAgICB7bmFtZTogJ2NoZWNrU3VtJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGNoZWNrU3VtICE9PSB1bmRlZmluZWQgPyBjaGVja1N1bSA6IDB9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBvZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9mZnNldCA6IDB9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBsZW5ndGggIT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IDB9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTZm50VGFibGUodGFibGVzKSB7XG4gICAgdmFyIHNmbnQgPSBuZXcgdGFibGUuVGFibGUoJ3NmbnQnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdUQUcnLCB2YWx1ZTogJ09UVE8nfSxcbiAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlYXJjaFJhbmdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdlbnRyeVNlbGVjdG9yJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyYW5nZVNoaWZ0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuICAgIHNmbnQudGFibGVzID0gdGFibGVzO1xuICAgIHNmbnQubnVtVGFibGVzID0gdGFibGVzLmxlbmd0aDtcbiAgICB2YXIgaGlnaGVzdFBvd2VyT2YyID0gTWF0aC5wb3coMiwgbG9nMihzZm50Lm51bVRhYmxlcykpO1xuICAgIHNmbnQuc2VhcmNoUmFuZ2UgPSAxNiAqIGhpZ2hlc3RQb3dlck9mMjtcbiAgICBzZm50LmVudHJ5U2VsZWN0b3IgPSBsb2cyKGhpZ2hlc3RQb3dlck9mMik7XG4gICAgc2ZudC5yYW5nZVNoaWZ0ID0gc2ZudC5udW1UYWJsZXMgKiAxNiAtIHNmbnQuc2VhcmNoUmFuZ2U7XG5cbiAgICB2YXIgcmVjb3JkRmllbGRzID0gW107XG4gICAgdmFyIHRhYmxlRmllbGRzID0gW107XG5cbiAgICB2YXIgb2Zmc2V0ID0gc2ZudC5zaXplT2YoKSArIChtYWtlVGFibGVSZWNvcmQoKS5zaXplT2YoKSAqIHNmbnQubnVtVGFibGVzKTtcbiAgICB3aGlsZSAob2Zmc2V0ICUgNCAhPT0gMCkge1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogJ3BhZGRpbmcnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHQgPSB0YWJsZXNbaV07XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KHQudGFibGVOYW1lLmxlbmd0aCA9PT0gNCwgJ1RhYmxlIG5hbWUnICsgdC50YWJsZU5hbWUgKyAnIGlzIGludmFsaWQuJyk7XG4gICAgICAgIHZhciB0YWJsZUxlbmd0aCA9IHQuc2l6ZU9mKCk7XG4gICAgICAgIHZhciB0YWJsZVJlY29yZCA9IG1ha2VUYWJsZVJlY29yZCh0LnRhYmxlTmFtZSwgY29tcHV0ZUNoZWNrU3VtKHQuZW5jb2RlKCkpLCBvZmZzZXQsIHRhYmxlTGVuZ3RoKTtcbiAgICAgICAgcmVjb3JkRmllbGRzLnB1c2goe25hbWU6IHRhYmxlUmVjb3JkLnRhZyArICcgVGFibGUgUmVjb3JkJywgdHlwZTogJ1JFQ09SRCcsIHZhbHVlOiB0YWJsZVJlY29yZH0pO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiB0LnRhYmxlTmFtZSArICcgdGFibGUnLCB0eXBlOiAnUkVDT1JEJywgdmFsdWU6IHR9KTtcbiAgICAgICAgb2Zmc2V0ICs9IHRhYmxlTGVuZ3RoO1xuICAgICAgICBjaGVjay5hcmd1bWVudCghaXNOYU4ob2Zmc2V0KSwgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXQuJyk7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFibGUgcmVjb3JkcyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cbiAgICByZWNvcmRGaWVsZHMuc29ydChmdW5jdGlvbihyMSwgcjIpIHtcbiAgICAgICAgaWYgKHIxLnZhbHVlLnRhZyA+IHIyLnZhbHVlLnRhZykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNmbnQuZmllbGRzID0gc2ZudC5maWVsZHMuY29uY2F0KHJlY29yZEZpZWxkcyk7XG4gICAgc2ZudC5maWVsZHMgPSBzZm50LmZpZWxkcy5jb25jYXQodGFibGVGaWVsZHMpO1xuICAgIHJldHVybiBzZm50O1xufVxuXG4vLyBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgY2hhcmFjdGVyLiBJZiB0aGUgc3RyaW5nIGhhcyBtb3JlIHRoYW4gb25lIGNoYXJhY3RlclxuLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIG1ldHJpY3MgZm9yIHRoZSBmaXJzdCBhdmFpbGFibGUgY2hhcmFjdGVyLlxuLy8gWW91IGNhbiBwcm92aWRlIG9wdGlvbmFsIGZhbGxiYWNrIG1ldHJpY3MgaWYgbm8gY2hhcmFjdGVycyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gbWV0cmljc0ZvckNoYXIoZm9udCwgY2hhcnMsIG5vdEZvdW5kTWV0cmljcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSBmb250LmNoYXJUb0dseXBoSW5kZXgoY2hhcnNbaV0pO1xuICAgICAgICBpZiAoZ2x5cGhJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm90Rm91bmRNZXRyaWNzO1xufVxuXG5mdW5jdGlvbiBhdmVyYWdlKHZzKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdW0gKz0gdnNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bSAvIHZzLmxlbmd0aDtcbn1cblxuLy8gQ29udmVydCB0aGUgZm9udCBvYmplY3QgdG8gYSBTRk5UIGRhdGEgc3RydWN0dXJlLlxuLy8gVGhpcyBzdHJ1Y3R1cmUgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgdGFibGVzIGFuZCBtZXRhZGF0YSB0byBjcmVhdGUgYSBiaW5hcnkgT1RGIGZpbGUuXG5mdW5jdGlvbiBmb250VG9TZm50VGFibGUoZm9udCkge1xuICAgIHZhciB4TWlucyA9IFtdO1xuICAgIHZhciB5TWlucyA9IFtdO1xuICAgIHZhciB4TWF4cyA9IFtdO1xuICAgIHZhciB5TWF4cyA9IFtdO1xuICAgIHZhciBhZHZhbmNlV2lkdGhzID0gW107XG4gICAgdmFyIGxlZnRTaWRlQmVhcmluZ3MgPSBbXTtcbiAgICB2YXIgcmlnaHRTaWRlQmVhcmluZ3MgPSBbXTtcbiAgICB2YXIgZmlyc3RDaGFySW5kZXg7XG4gICAgdmFyIGxhc3RDaGFySW5kZXggPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTEgPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTIgPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTMgPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSk7XG4gICAgICAgIHZhciB1bmljb2RlID0gZ2x5cGgudW5pY29kZSB8IDA7XG5cbiAgICAgICAgaWYgKGlzTmFOKGdseXBoLmFkdmFuY2VXaWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2x5cGggJyArIGdseXBoLm5hbWUgKyAnICgnICsgaSArICcpOiBhZHZhbmNlV2lkdGggaXMgbm90IGEgbnVtYmVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0Q2hhckluZGV4ID4gdW5pY29kZSB8fCBmaXJzdENoYXJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgLm5vdGRlZiBjaGFyXG4gICAgICAgICAgICBpZiAodW5pY29kZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoYXJJbmRleCA9IHVuaWNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdENoYXJJbmRleCA8IHVuaWNvZGUpIHtcbiAgICAgICAgICAgIGxhc3RDaGFySW5kZXggPSB1bmljb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gb3MyLmdldFVuaWNvZGVSYW5nZSh1bmljb2RlKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMzIpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMSB8PSAxIDw8IHBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgNjQpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMiB8PSAxIDw8IHBvc2l0aW9uIC0gMzI7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCA5Nikge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UzIHw9IDEgPDwgcG9zaXRpb24gLSA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDEyMykge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2U0IHw9IDEgPDwgcG9zaXRpb24gLSA5NjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pY29kZSByYW5nZXMgYml0cyA+IDEyMyBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub24taW1wb3J0YW50IGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChnbHlwaC5uYW1lID09PSAnLm5vdGRlZicpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWV0cmljcyA9IGdseXBoLmdldE1ldHJpY3MoKTtcbiAgICAgICAgeE1pbnMucHVzaChtZXRyaWNzLnhNaW4pO1xuICAgICAgICB5TWlucy5wdXNoKG1ldHJpY3MueU1pbik7XG4gICAgICAgIHhNYXhzLnB1c2gobWV0cmljcy54TWF4KTtcbiAgICAgICAgeU1heHMucHVzaChtZXRyaWNzLnlNYXgpO1xuICAgICAgICBsZWZ0U2lkZUJlYXJpbmdzLnB1c2gobWV0cmljcy5sZWZ0U2lkZUJlYXJpbmcpO1xuICAgICAgICByaWdodFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MucmlnaHRTaWRlQmVhcmluZyk7XG4gICAgICAgIGFkdmFuY2VXaWR0aHMucHVzaChnbHlwaC5hZHZhbmNlV2lkdGgpO1xuICAgIH1cblxuICAgIHZhciBnbG9iYWxzID0ge1xuICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4TWlucyksXG4gICAgICAgIHlNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHlNaW5zKSxcbiAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeE1heHMpLFxuICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5TWF4cyksXG4gICAgICAgIGFkdmFuY2VXaWR0aE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgYWR2YW5jZVdpZHRocyksXG4gICAgICAgIGFkdmFuY2VXaWR0aEF2ZzogYXZlcmFnZShhZHZhbmNlV2lkdGhzKSxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBNYXRoLm1pbi5hcHBseShudWxsLCBsZWZ0U2lkZUJlYXJpbmdzKSxcbiAgICAgICAgbWF4TGVmdFNpZGVCZWFyaW5nOiBNYXRoLm1heC5hcHBseShudWxsLCBsZWZ0U2lkZUJlYXJpbmdzKSxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgcmlnaHRTaWRlQmVhcmluZ3MpXG4gICAgfTtcbiAgICBnbG9iYWxzLmFzY2VuZGVyID0gZm9udC5hc2NlbmRlcjtcbiAgICBnbG9iYWxzLmRlc2NlbmRlciA9IGZvbnQuZGVzY2VuZGVyO1xuXG4gICAgdmFyIGhlYWRUYWJsZSA9IGhlYWQubWFrZSh7XG4gICAgICAgIGZsYWdzOiAzLCAvLyAwMDAwMDAxMSAoYmFzZWxpbmUgZm9yIGZvbnQgYXQgeT0wOyBsZWZ0IHNpZGViZWFyaW5nIHBvaW50IGF0IHg9MClcbiAgICAgICAgdW5pdHNQZXJFbTogZm9udC51bml0c1BlckVtLFxuICAgICAgICB4TWluOiBnbG9iYWxzLnhNaW4sXG4gICAgICAgIHlNaW46IGdsb2JhbHMueU1pbixcbiAgICAgICAgeE1heDogZ2xvYmFscy54TWF4LFxuICAgICAgICB5TWF4OiBnbG9iYWxzLnlNYXgsXG4gICAgICAgIGxvd2VzdFJlY1BQRU06IDMsXG4gICAgICAgIGNyZWF0ZWRUaW1lc3RhbXA6IGZvbnQuY3JlYXRlZFRpbWVzdGFtcFxuICAgIH0pO1xuXG4gICAgdmFyIGhoZWFUYWJsZSA9IGhoZWEubWFrZSh7XG4gICAgICAgIGFzY2VuZGVyOiBnbG9iYWxzLmFzY2VuZGVyLFxuICAgICAgICBkZXNjZW5kZXI6IGdsb2JhbHMuZGVzY2VuZGVyLFxuICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IGdsb2JhbHMuYWR2YW5jZVdpZHRoTWF4LFxuICAgICAgICBtaW5MZWZ0U2lkZUJlYXJpbmc6IGdsb2JhbHMubWluTGVmdFNpZGVCZWFyaW5nLFxuICAgICAgICBtaW5SaWdodFNpZGVCZWFyaW5nOiBnbG9iYWxzLm1pblJpZ2h0U2lkZUJlYXJpbmcsXG4gICAgICAgIHhNYXhFeHRlbnQ6IGdsb2JhbHMubWF4TGVmdFNpZGVCZWFyaW5nICsgKGdsb2JhbHMueE1heCAtIGdsb2JhbHMueE1pbiksXG4gICAgICAgIG51bWJlck9mSE1ldHJpY3M6IGZvbnQuZ2x5cGhzLmxlbmd0aFxuICAgIH0pO1xuXG4gICAgdmFyIG1heHBUYWJsZSA9IG1heHAubWFrZShmb250LmdseXBocy5sZW5ndGgpO1xuXG4gICAgdmFyIG9zMlRhYmxlID0gb3MyLm1ha2Uoe1xuICAgICAgICB4QXZnQ2hhcldpZHRoOiBNYXRoLnJvdW5kKGdsb2JhbHMuYWR2YW5jZVdpZHRoQXZnKSxcbiAgICAgICAgdXNXZWlnaHRDbGFzczogZm9udC50YWJsZXMub3MyLnVzV2VpZ2h0Q2xhc3MsXG4gICAgICAgIHVzV2lkdGhDbGFzczogZm9udC50YWJsZXMub3MyLnVzV2lkdGhDbGFzcyxcbiAgICAgICAgdXNGaXJzdENoYXJJbmRleDogZmlyc3RDaGFySW5kZXgsXG4gICAgICAgIHVzTGFzdENoYXJJbmRleDogbGFzdENoYXJJbmRleCxcbiAgICAgICAgdWxVbmljb2RlUmFuZ2UxOiB1bFVuaWNvZGVSYW5nZTEsXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMjogdWxVbmljb2RlUmFuZ2UyLFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTM6IHVsVW5pY29kZVJhbmdlMyxcbiAgICAgICAgdWxVbmljb2RlUmFuZ2U0OiB1bFVuaWNvZGVSYW5nZTQsXG4gICAgICAgIGZzU2VsZWN0aW9uOiBmb250LnRhYmxlcy5vczIuZnNTZWxlY3Rpb24sIC8vIFJFR1VMQVJcbiAgICAgICAgLy8gU2VlIGh0dHA6Ly90eXBvcGhpbGUuY29tL25vZGUvMTMwODEgZm9yIG1vcmUgaW5mbyBvbiB2ZXJ0aWNhbCBtZXRyaWNzLlxuICAgICAgICAvLyBXZSBnZXQgbWV0cmljcyBmb3IgdHlwaWNhbCBjaGFyYWN0ZXJzIChzdWNoIGFzIFwieFwiIGZvciB4SGVpZ2h0KS5cbiAgICAgICAgLy8gV2UgcHJvdmlkZSBzb21lIGZhbGxiYWNrIGNoYXJhY3RlcnMgaWYgY2hhcmFjdGVycyBhcmUgdW5hdmFpbGFibGU6IHRoZWlyXG4gICAgICAgIC8vIG9yZGVyaW5nIHdhcyBjaG9zZW4gZXhwZXJpbWVudGFsbHkuXG4gICAgICAgIHNUeXBvQXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG4gICAgICAgIHNUeXBvRGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgc1R5cG9MaW5lR2FwOiAwLFxuICAgICAgICB1c1dpbkFzY2VudDogZ2xvYmFscy55TWF4LFxuICAgICAgICB1c1dpbkRlc2NlbnQ6IE1hdGguYWJzKGdsb2JhbHMueU1pbiksXG4gICAgICAgIHVsQ29kZVBhZ2VSYW5nZTE6IDEsIC8vIEZJWE1FOiBoYXJkLWNvZGUgTGF0aW4gMSBzdXBwb3J0IGZvciBub3dcbiAgICAgICAgc3hIZWlnaHQ6IG1ldHJpY3NGb3JDaGFyKGZvbnQsICd4eXZ3Jywge3lNYXg6IE1hdGgucm91bmQoZ2xvYmFscy5hc2NlbmRlciAvIDIpfSkueU1heCxcbiAgICAgICAgc0NhcEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ0hJS0xFRkpNTlRaQkRQUkFHT1FTVVZXWFknLCBnbG9iYWxzKS55TWF4LFxuICAgICAgICB1c0RlZmF1bHRDaGFyOiBmb250Lmhhc0NoYXIoJyAnKSA/IDMyIDogMCwgLy8gVXNlIHNwYWNlIGFzIHRoZSBkZWZhdWx0IGNoYXJhY3RlciwgaWYgYXZhaWxhYmxlLlxuICAgICAgICB1c0JyZWFrQ2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAgLy8gVXNlIHNwYWNlIGFzIHRoZSBicmVhayBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cbiAgICB9KTtcblxuICAgIHZhciBobXR4VGFibGUgPSBobXR4Lm1ha2UoZm9udC5nbHlwaHMpO1xuICAgIHZhciBjbWFwVGFibGUgPSBjbWFwLm1ha2UoZm9udC5nbHlwaHMpO1xuXG4gICAgdmFyIGVuZ2xpc2hGYW1pbHlOYW1lID0gZm9udC5nZXRFbmdsaXNoTmFtZSgnZm9udEZhbWlseScpO1xuICAgIHZhciBlbmdsaXNoU3R5bGVOYW1lID0gZm9udC5nZXRFbmdsaXNoTmFtZSgnZm9udFN1YmZhbWlseScpO1xuICAgIHZhciBlbmdsaXNoRnVsbE5hbWUgPSBlbmdsaXNoRmFtaWx5TmFtZSArICcgJyArIGVuZ2xpc2hTdHlsZU5hbWU7XG4gICAgdmFyIHBvc3RTY3JpcHROYW1lID0gZm9udC5nZXRFbmdsaXNoTmFtZSgncG9zdFNjcmlwdE5hbWUnKTtcbiAgICBpZiAoIXBvc3RTY3JpcHROYW1lKSB7XG4gICAgICAgIHBvc3RTY3JpcHROYW1lID0gZW5nbGlzaEZhbWlseU5hbWUucmVwbGFjZSgvXFxzL2csICcnKSArICctJyArIGVuZ2xpc2hTdHlsZU5hbWU7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVzID0ge307XG4gICAgZm9yICh2YXIgbiBpbiBmb250Lm5hbWVzKSB7XG4gICAgICAgIG5hbWVzW25dID0gZm9udC5uYW1lc1tuXTtcbiAgICB9XG5cbiAgICBpZiAoIW5hbWVzLnVuaXF1ZUlEKSB7XG4gICAgICAgIG5hbWVzLnVuaXF1ZUlEID0ge2VuOiBmb250LmdldEVuZ2xpc2hOYW1lKCdtYW51ZmFjdHVyZXInKSArICc6JyArIGVuZ2xpc2hGdWxsTmFtZX07XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lcy5wb3N0U2NyaXB0TmFtZSkge1xuICAgICAgICBuYW1lcy5wb3N0U2NyaXB0TmFtZSA9IHtlbjogcG9zdFNjcmlwdE5hbWV9O1xuICAgIH1cblxuICAgIGlmICghbmFtZXMucHJlZmVycmVkRmFtaWx5KSB7XG4gICAgICAgIG5hbWVzLnByZWZlcnJlZEZhbWlseSA9IGZvbnQubmFtZXMuZm9udEZhbWlseTtcbiAgICB9XG5cbiAgICBpZiAoIW5hbWVzLnByZWZlcnJlZFN1YmZhbWlseSkge1xuICAgICAgICBuYW1lcy5wcmVmZXJyZWRTdWJmYW1pbHkgPSBmb250Lm5hbWVzLmZvbnRTdWJmYW1pbHk7XG4gICAgfVxuXG4gICAgdmFyIGxhbmd1YWdlVGFncyA9IFtdO1xuICAgIHZhciBuYW1lVGFibGUgPSBfbmFtZS5tYWtlKG5hbWVzLCBsYW5ndWFnZVRhZ3MpO1xuICAgIHZhciBsdGFnVGFibGUgPSAobGFuZ3VhZ2VUYWdzLmxlbmd0aCA+IDAgPyBsdGFnLm1ha2UobGFuZ3VhZ2VUYWdzKSA6IHVuZGVmaW5lZCk7XG5cbiAgICB2YXIgcG9zdFRhYmxlID0gcG9zdC5tYWtlKCk7XG4gICAgdmFyIGNmZlRhYmxlID0gY2ZmLm1ha2UoZm9udC5nbHlwaHMsIHtcbiAgICAgICAgdmVyc2lvbjogZm9udC5nZXRFbmdsaXNoTmFtZSgndmVyc2lvbicpLFxuICAgICAgICBmdWxsTmFtZTogZW5nbGlzaEZ1bGxOYW1lLFxuICAgICAgICBmYW1pbHlOYW1lOiBlbmdsaXNoRmFtaWx5TmFtZSxcbiAgICAgICAgd2VpZ2h0TmFtZTogZW5nbGlzaFN0eWxlTmFtZSxcbiAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHBvc3RTY3JpcHROYW1lLFxuICAgICAgICB1bml0c1BlckVtOiBmb250LnVuaXRzUGVyRW0sXG4gICAgICAgIGZvbnRCQm94OiBbMCwgZ2xvYmFscy55TWluLCBnbG9iYWxzLmFzY2VuZGVyLCBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heF1cbiAgICB9KTtcblxuICAgIHZhciBtZXRhVGFibGUgPSAoZm9udC5tZXRhcyAmJiBPYmplY3Qua2V5cyhmb250Lm1ldGFzKS5sZW5ndGggPiAwKSA/IG1ldGEubWFrZShmb250Lm1ldGFzKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIFRoZSBvcmRlciBkb2VzIG5vdCBtYXR0ZXIgYmVjYXVzZSBtYWtlU2ZudFRhYmxlKCkgd2lsbCBzb3J0IHRoZW0uXG4gICAgdmFyIHRhYmxlcyA9IFtoZWFkVGFibGUsIGhoZWFUYWJsZSwgbWF4cFRhYmxlLCBvczJUYWJsZSwgbmFtZVRhYmxlLCBjbWFwVGFibGUsIHBvc3RUYWJsZSwgY2ZmVGFibGUsIGhtdHhUYWJsZV07XG4gICAgaWYgKGx0YWdUYWJsZSkge1xuICAgICAgICB0YWJsZXMucHVzaChsdGFnVGFibGUpO1xuICAgIH1cbiAgICAvLyBPcHRpb25hbCB0YWJsZXNcbiAgICBpZiAoZm9udC50YWJsZXMuZ3N1Yikge1xuICAgICAgICB0YWJsZXMucHVzaChnc3ViLm1ha2UoZm9udC50YWJsZXMuZ3N1YikpO1xuICAgIH1cbiAgICBpZiAobWV0YVRhYmxlKSB7XG4gICAgICAgIHRhYmxlcy5wdXNoKG1ldGFUYWJsZSk7XG4gICAgfVxuXG4gICAgdmFyIHNmbnRUYWJsZSA9IG1ha2VTZm50VGFibGUodGFibGVzKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGZvbnQncyBjaGVja1N1bSBhbmQgc3RvcmUgaXQgaW4gaGVhZC5jaGVja1N1bUFkanVzdG1lbnQuXG4gICAgdmFyIGJ5dGVzID0gc2ZudFRhYmxlLmVuY29kZSgpO1xuICAgIHZhciBjaGVja1N1bSA9IGNvbXB1dGVDaGVja1N1bShieXRlcyk7XG4gICAgdmFyIHRhYmxlRmllbGRzID0gc2ZudFRhYmxlLmZpZWxkcztcbiAgICB2YXIgY2hlY2tTdW1BZGp1c3RlZCA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0YWJsZUZpZWxkcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodGFibGVGaWVsZHNbaV0ubmFtZSA9PT0gJ2hlYWQgdGFibGUnKSB7XG4gICAgICAgICAgICB0YWJsZUZpZWxkc1tpXS52YWx1ZS5jaGVja1N1bUFkanVzdG1lbnQgPSAweEIxQjBBRkJBIC0gY2hlY2tTdW07XG4gICAgICAgICAgICBjaGVja1N1bUFkanVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGVja1N1bUFkanVzdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaGVhZCB0YWJsZSB3aXRoIGNoZWNrU3VtIHRvIGFkanVzdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2ZudFRhYmxlO1xufVxuXG5leHBvcnRzLmNvbXB1dGVDaGVja1N1bSA9IGNvbXB1dGVDaGVja1N1bTtcbmV4cG9ydHMubWFrZSA9IG1ha2VTZm50VGFibGU7XG5leHBvcnRzLmZvbnRUb1RhYmxlID0gZm9udFRvU2ZudFRhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L29wZW50eXBlLmpzL3NyYy90YWJsZXMvc2ZudC5qc1xuLy8gbW9kdWxlIGlkID0gMzg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMzg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFRJTkZfT0sgPSAwO1xudmFyIFRJTkZfREFUQV9FUlJPUiA9IC0zO1xuXG5mdW5jdGlvbiBUcmVlKCkge1xuICB0aGlzLnRhYmxlID0gbmV3IFVpbnQxNkFycmF5KDE2KTsgICAvKiB0YWJsZSBvZiBjb2RlIGxlbmd0aCBjb3VudHMgKi9cbiAgdGhpcy50cmFucyA9IG5ldyBVaW50MTZBcnJheSgyODgpOyAgLyogY29kZSAtPiBzeW1ib2wgdHJhbnNsYXRpb24gdGFibGUgKi9cbn1cblxuZnVuY3Rpb24gRGF0YShzb3VyY2UsIGRlc3QpIHtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMuc291cmNlSW5kZXggPSAwO1xuICB0aGlzLnRhZyA9IDA7XG4gIHRoaXMuYml0Y291bnQgPSAwO1xuICBcbiAgdGhpcy5kZXN0ID0gZGVzdDtcbiAgdGhpcy5kZXN0TGVuID0gMDtcbiAgXG4gIHRoaXMubHRyZWUgPSBuZXcgVHJlZSgpOyAgLyogZHluYW1pYyBsZW5ndGgvc3ltYm9sIHRyZWUgKi9cbiAgdGhpcy5kdHJlZSA9IG5ldyBUcmVlKCk7ICAvKiBkeW5hbWljIGRpc3RhbmNlIHRyZWUgKi9cbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIHVuaW5pdGlhbGl6ZWQgZ2xvYmFsIGRhdGEgKHN0YXRpYyBzdHJ1Y3R1cmVzKSAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxudmFyIHNsdHJlZSA9IG5ldyBUcmVlKCk7XG52YXIgc2R0cmVlID0gbmV3IFRyZWUoKTtcblxuLyogZXh0cmEgYml0cyBhbmQgYmFzZSB0YWJsZXMgZm9yIGxlbmd0aCBjb2RlcyAqL1xudmFyIGxlbmd0aF9iaXRzID0gbmV3IFVpbnQ4QXJyYXkoMzApO1xudmFyIGxlbmd0aF9iYXNlID0gbmV3IFVpbnQxNkFycmF5KDMwKTtcblxuLyogZXh0cmEgYml0cyBhbmQgYmFzZSB0YWJsZXMgZm9yIGRpc3RhbmNlIGNvZGVzICovXG52YXIgZGlzdF9iaXRzID0gbmV3IFVpbnQ4QXJyYXkoMzApO1xudmFyIGRpc3RfYmFzZSA9IG5ldyBVaW50MTZBcnJheSgzMCk7XG5cbi8qIHNwZWNpYWwgb3JkZXJpbmcgb2YgY29kZSBsZW5ndGggY29kZXMgKi9cbnZhciBjbGNpZHggPSBuZXcgVWludDhBcnJheShbXG4gIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsXG4gIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLFxuICAxNCwgMSwgMTVcbl0pO1xuXG4vKiB1c2VkIGJ5IHRpbmZfZGVjb2RlX3RyZWVzLCBhdm9pZHMgYWxsb2NhdGlvbnMgZXZlcnkgY2FsbCAqL1xudmFyIGNvZGVfdHJlZSA9IG5ldyBUcmVlKCk7XG52YXIgbGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDI4OCArIDMyKTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gdXRpbGl0eSBmdW5jdGlvbnMgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogYnVpbGQgZXh0cmEgYml0cyBhbmQgYmFzZSB0YWJsZXMgKi9cbmZ1bmN0aW9uIHRpbmZfYnVpbGRfYml0c19iYXNlKGJpdHMsIGJhc2UsIGRlbHRhLCBmaXJzdCkge1xuICB2YXIgaSwgc3VtO1xuXG4gIC8qIGJ1aWxkIGJpdHMgdGFibGUgKi9cbiAgZm9yIChpID0gMDsgaSA8IGRlbHRhOyArK2kpIGJpdHNbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgMzAgLSBkZWx0YTsgKytpKSBiaXRzW2kgKyBkZWx0YV0gPSBpIC8gZGVsdGEgfCAwO1xuXG4gIC8qIGJ1aWxkIGJhc2UgdGFibGUgKi9cbiAgZm9yIChzdW0gPSBmaXJzdCwgaSA9IDA7IGkgPCAzMDsgKytpKSB7XG4gICAgYmFzZVtpXSA9IHN1bTtcbiAgICBzdW0gKz0gMSA8PCBiaXRzW2ldO1xuICB9XG59XG5cbi8qIGJ1aWxkIHRoZSBmaXhlZCBodWZmbWFuIHRyZWVzICovXG5mdW5jdGlvbiB0aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKGx0LCBkdCkge1xuICB2YXIgaTtcblxuICAvKiBidWlsZCBmaXhlZCBsZW5ndGggdHJlZSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSBsdC50YWJsZVtpXSA9IDA7XG5cbiAgbHQudGFibGVbN10gPSAyNDtcbiAgbHQudGFibGVbOF0gPSAxNTI7XG4gIGx0LnRhYmxlWzldID0gMTEyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAyNDsgKytpKSBsdC50cmFuc1tpXSA9IDI1NiArIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNDQ7ICsraSkgbHQudHJhbnNbMjQgKyBpXSA9IGk7XG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIGx0LnRyYW5zWzI0ICsgMTQ0ICsgaV0gPSAyODAgKyBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTEyOyArK2kpIGx0LnRyYW5zWzI0ICsgMTQ0ICsgOCArIGldID0gMTQ0ICsgaTtcblxuICAvKiBidWlsZCBmaXhlZCBkaXN0YW5jZSB0cmVlICovXG4gIGZvciAoaSA9IDA7IGkgPCA1OyArK2kpIGR0LnRhYmxlW2ldID0gMDtcblxuICBkdC50YWJsZVs1XSA9IDMyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgKytpKSBkdC50cmFuc1tpXSA9IGk7XG59XG5cbi8qIGdpdmVuIGFuIGFycmF5IG9mIGNvZGUgbGVuZ3RocywgYnVpbGQgYSB0cmVlICovXG52YXIgb2ZmcyA9IG5ldyBVaW50MTZBcnJheSgxNik7XG5cbmZ1bmN0aW9uIHRpbmZfYnVpbGRfdHJlZSh0LCBsZW5ndGhzLCBvZmYsIG51bSkge1xuICB2YXIgaSwgc3VtO1xuXG4gIC8qIGNsZWFyIGNvZGUgbGVuZ3RoIGNvdW50IHRhYmxlICovXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB0LnRhYmxlW2ldID0gMDtcblxuICAvKiBzY2FuIHN5bWJvbCBsZW5ndGhzLCBhbmQgc3VtIGNvZGUgbGVuZ3RoIGNvdW50cyAqL1xuICBmb3IgKGkgPSAwOyBpIDwgbnVtOyArK2kpIHQudGFibGVbbGVuZ3Roc1tvZmYgKyBpXV0rKztcblxuICB0LnRhYmxlWzBdID0gMDtcblxuICAvKiBjb21wdXRlIG9mZnNldCB0YWJsZSBmb3IgZGlzdHJpYnV0aW9uIHNvcnQgKi9cbiAgZm9yIChzdW0gPSAwLCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBvZmZzW2ldID0gc3VtO1xuICAgIHN1bSArPSB0LnRhYmxlW2ldO1xuICB9XG5cbiAgLyogY3JlYXRlIGNvZGUtPnN5bWJvbCB0cmFuc2xhdGlvbiB0YWJsZSAoc3ltYm9scyBzb3J0ZWQgYnkgY29kZSkgKi9cbiAgZm9yIChpID0gMDsgaSA8IG51bTsgKytpKSB7XG4gICAgaWYgKGxlbmd0aHNbb2ZmICsgaV0pIHQudHJhbnNbb2Zmc1tsZW5ndGhzW29mZiArIGldXSsrXSA9IGk7XG4gIH1cbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSBkZWNvZGUgZnVuY3Rpb25zIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogZ2V0IG9uZSBiaXQgZnJvbSBzb3VyY2Ugc3RyZWFtICovXG5mdW5jdGlvbiB0aW5mX2dldGJpdChkKSB7XG4gIC8qIGNoZWNrIGlmIHRhZyBpcyBlbXB0eSAqL1xuICBpZiAoIWQuYml0Y291bnQtLSkge1xuICAgIC8qIGxvYWQgbmV4dCB0YWcgKi9cbiAgICBkLnRhZyA9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK107XG4gICAgZC5iaXRjb3VudCA9IDc7XG4gIH1cblxuICAvKiBzaGlmdCBiaXQgb3V0IG9mIHRhZyAqL1xuICB2YXIgYml0ID0gZC50YWcgJiAxO1xuICBkLnRhZyA+Pj49IDE7XG5cbiAgcmV0dXJuIGJpdDtcbn1cblxuLyogcmVhZCBhIG51bSBiaXQgdmFsdWUgZnJvbSBhIHN0cmVhbSBhbmQgYWRkIGJhc2UgKi9cbmZ1bmN0aW9uIHRpbmZfcmVhZF9iaXRzKGQsIG51bSwgYmFzZSkge1xuICBpZiAoIW51bSlcbiAgICByZXR1cm4gYmFzZTtcblxuICB3aGlsZSAoZC5iaXRjb3VudCA8IDI0KSB7XG4gICAgZC50YWcgfD0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXSA8PCBkLmJpdGNvdW50O1xuICAgIGQuYml0Y291bnQgKz0gODtcbiAgfVxuXG4gIHZhciB2YWwgPSBkLnRhZyAmICgweGZmZmYgPj4+ICgxNiAtIG51bSkpO1xuICBkLnRhZyA+Pj49IG51bTtcbiAgZC5iaXRjb3VudCAtPSBudW07XG4gIHJldHVybiB2YWwgKyBiYXNlO1xufVxuXG4vKiBnaXZlbiBhIGRhdGEgc3RyZWFtIGFuZCBhIHRyZWUsIGRlY29kZSBhIHN5bWJvbCAqL1xuZnVuY3Rpb24gdGluZl9kZWNvZGVfc3ltYm9sKGQsIHQpIHtcbiAgd2hpbGUgKGQuYml0Y291bnQgPCAyNCkge1xuICAgIGQudGFnIHw9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK10gPDwgZC5iaXRjb3VudDtcbiAgICBkLmJpdGNvdW50ICs9IDg7XG4gIH1cbiAgXG4gIHZhciBzdW0gPSAwLCBjdXIgPSAwLCBsZW4gPSAwO1xuICB2YXIgdGFnID0gZC50YWc7XG5cbiAgLyogZ2V0IG1vcmUgYml0cyB3aGlsZSBjb2RlIHZhbHVlIGlzIGFib3ZlIHN1bSAqL1xuICBkbyB7XG4gICAgY3VyID0gMiAqIGN1ciArICh0YWcgJiAxKTtcbiAgICB0YWcgPj4+PSAxO1xuICAgICsrbGVuO1xuXG4gICAgc3VtICs9IHQudGFibGVbbGVuXTtcbiAgICBjdXIgLT0gdC50YWJsZVtsZW5dO1xuICB9IHdoaWxlIChjdXIgPj0gMCk7XG4gIFxuICBkLnRhZyA9IHRhZztcbiAgZC5iaXRjb3VudCAtPSBsZW47XG5cbiAgcmV0dXJuIHQudHJhbnNbc3VtICsgY3VyXTtcbn1cblxuLyogZ2l2ZW4gYSBkYXRhIHN0cmVhbSwgZGVjb2RlIGR5bmFtaWMgdHJlZXMgZnJvbSBpdCAqL1xuZnVuY3Rpb24gdGluZl9kZWNvZGVfdHJlZXMoZCwgbHQsIGR0KSB7XG4gIHZhciBobGl0LCBoZGlzdCwgaGNsZW47XG4gIHZhciBpLCBudW0sIGxlbmd0aDtcblxuICAvKiBnZXQgNSBiaXRzIEhMSVQgKDI1Ny0yODYpICovXG4gIGhsaXQgPSB0aW5mX3JlYWRfYml0cyhkLCA1LCAyNTcpO1xuXG4gIC8qIGdldCA1IGJpdHMgSERJU1QgKDEtMzIpICovXG4gIGhkaXN0ID0gdGluZl9yZWFkX2JpdHMoZCwgNSwgMSk7XG5cbiAgLyogZ2V0IDQgYml0cyBIQ0xFTiAoNC0xOSkgKi9cbiAgaGNsZW4gPSB0aW5mX3JlYWRfYml0cyhkLCA0LCA0KTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTk7ICsraSkgbGVuZ3Roc1tpXSA9IDA7XG5cbiAgLyogcmVhZCBjb2RlIGxlbmd0aHMgZm9yIGNvZGUgbGVuZ3RoIGFscGhhYmV0ICovXG4gIGZvciAoaSA9IDA7IGkgPCBoY2xlbjsgKytpKSB7XG4gICAgLyogZ2V0IDMgYml0cyBjb2RlIGxlbmd0aCAoMC03KSAqL1xuICAgIHZhciBjbGVuID0gdGluZl9yZWFkX2JpdHMoZCwgMywgMCk7XG4gICAgbGVuZ3Roc1tjbGNpZHhbaV1dID0gY2xlbjtcbiAgfVxuXG4gIC8qIGJ1aWxkIGNvZGUgbGVuZ3RoIHRyZWUgKi9cbiAgdGluZl9idWlsZF90cmVlKGNvZGVfdHJlZSwgbGVuZ3RocywgMCwgMTkpO1xuXG4gIC8qIGRlY29kZSBjb2RlIGxlbmd0aHMgZm9yIHRoZSBkeW5hbWljIHRyZWVzICovXG4gIGZvciAobnVtID0gMDsgbnVtIDwgaGxpdCArIGhkaXN0Oykge1xuICAgIHZhciBzeW0gPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgY29kZV90cmVlKTtcblxuICAgIHN3aXRjaCAoc3ltKSB7XG4gICAgICBjYXNlIDE2OlxuICAgICAgICAvKiBjb3B5IHByZXZpb3VzIGNvZGUgbGVuZ3RoIDMtNiB0aW1lcyAocmVhZCAyIGJpdHMpICovXG4gICAgICAgIHZhciBwcmV2ID0gbGVuZ3Roc1tudW0gLSAxXTtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCAyLCAzKTsgbGVuZ3RoOyAtLWxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTc6XG4gICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAzLTEwIHRpbWVzIChyZWFkIDMgYml0cykgKi9cbiAgICAgICAgZm9yIChsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCAzLCAzKTsgbGVuZ3RoOyAtLWxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTg6XG4gICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAxMS0xMzggdGltZXMgKHJlYWQgNyBiaXRzKSAqL1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDcsIDExKTsgbGVuZ3RoOyAtLWxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8qIHZhbHVlcyAwLTE1IHJlcHJlc2VudCB0aGUgYWN0dWFsIGNvZGUgbGVuZ3RocyAqL1xuICAgICAgICBsZW5ndGhzW251bSsrXSA9IHN5bTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyogYnVpbGQgZHluYW1pYyB0cmVlcyAqL1xuICB0aW5mX2J1aWxkX3RyZWUobHQsIGxlbmd0aHMsIDAsIGhsaXQpO1xuICB0aW5mX2J1aWxkX3RyZWUoZHQsIGxlbmd0aHMsIGhsaXQsIGhkaXN0KTtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gYmxvY2sgaW5mbGF0ZSBmdW5jdGlvbnMgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogZ2l2ZW4gYSBzdHJlYW0gYW5kIHR3byB0cmVlcywgaW5mbGF0ZSBhIGJsb2NrIG9mIGRhdGEgKi9cbmZ1bmN0aW9uIHRpbmZfaW5mbGF0ZV9ibG9ja19kYXRhKGQsIGx0LCBkdCkge1xuICB3aGlsZSAoMSkge1xuICAgIHZhciBzeW0gPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgbHQpO1xuXG4gICAgLyogY2hlY2sgZm9yIGVuZCBvZiBibG9jayAqL1xuICAgIGlmIChzeW0gPT09IDI1Nikge1xuICAgICAgcmV0dXJuIFRJTkZfT0s7XG4gICAgfVxuXG4gICAgaWYgKHN5bSA8IDI1Nikge1xuICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IHN5bTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbmd0aCwgZGlzdCwgb2ZmcztcbiAgICAgIHZhciBpO1xuXG4gICAgICBzeW0gLT0gMjU3O1xuXG4gICAgICAvKiBwb3NzaWJseSBnZXQgbW9yZSBiaXRzIGZyb20gbGVuZ3RoIGNvZGUgKi9cbiAgICAgIGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIGxlbmd0aF9iaXRzW3N5bV0sIGxlbmd0aF9iYXNlW3N5bV0pO1xuXG4gICAgICBkaXN0ID0gdGluZl9kZWNvZGVfc3ltYm9sKGQsIGR0KTtcblxuICAgICAgLyogcG9zc2libHkgZ2V0IG1vcmUgYml0cyBmcm9tIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgIG9mZnMgPSBkLmRlc3RMZW4gLSB0aW5mX3JlYWRfYml0cyhkLCBkaXN0X2JpdHNbZGlzdF0sIGRpc3RfYmFzZVtkaXN0XSk7XG5cbiAgICAgIC8qIGNvcHkgbWF0Y2ggKi9cbiAgICAgIGZvciAoaSA9IG9mZnM7IGkgPCBvZmZzICsgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IGQuZGVzdFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogaW5mbGF0ZSBhbiB1bmNvbXByZXNzZWQgYmxvY2sgb2YgZGF0YSAqL1xuZnVuY3Rpb24gdGluZl9pbmZsYXRlX3VuY29tcHJlc3NlZF9ibG9jayhkKSB7XG4gIHZhciBsZW5ndGgsIGludmxlbmd0aDtcbiAgdmFyIGk7XG4gIFxuICAvKiB1bnJlYWQgZnJvbSBiaXRidWZmZXIgKi9cbiAgd2hpbGUgKGQuYml0Y291bnQgPiA4KSB7XG4gICAgZC5zb3VyY2VJbmRleC0tO1xuICAgIGQuYml0Y291bnQgLT0gODtcbiAgfVxuXG4gIC8qIGdldCBsZW5ndGggKi9cbiAgbGVuZ3RoID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDFdO1xuICBsZW5ndGggPSAyNTYgKiBsZW5ndGggKyBkLnNvdXJjZVtkLnNvdXJjZUluZGV4XTtcblxuICAvKiBnZXQgb25lJ3MgY29tcGxlbWVudCBvZiBsZW5ndGggKi9cbiAgaW52bGVuZ3RoID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDNdO1xuICBpbnZsZW5ndGggPSAyNTYgKiBpbnZsZW5ndGggKyBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgMl07XG5cbiAgLyogY2hlY2sgbGVuZ3RoICovXG4gIGlmIChsZW5ndGggIT09ICh+aW52bGVuZ3RoICYgMHgwMDAwZmZmZikpXG4gICAgcmV0dXJuIFRJTkZfREFUQV9FUlJPUjtcblxuICBkLnNvdXJjZUluZGV4ICs9IDQ7XG5cbiAgLyogY29weSBibG9jayAqL1xuICBmb3IgKGkgPSBsZW5ndGg7IGk7IC0taSlcbiAgICBkLmRlc3RbZC5kZXN0TGVuKytdID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXTtcblxuICAvKiBtYWtlIHN1cmUgd2Ugc3RhcnQgbmV4dCBibG9jayBvbiBhIGJ5dGUgYm91bmRhcnkgKi9cbiAgZC5iaXRjb3VudCA9IDA7XG5cbiAgcmV0dXJuIFRJTkZfT0s7XG59XG5cbi8qIGluZmxhdGUgc3RyZWFtIGZyb20gc291cmNlIHRvIGRlc3QgKi9cbmZ1bmN0aW9uIHRpbmZfdW5jb21wcmVzcyhzb3VyY2UsIGRlc3QpIHtcbiAgdmFyIGQgPSBuZXcgRGF0YShzb3VyY2UsIGRlc3QpO1xuICB2YXIgYmZpbmFsLCBidHlwZSwgcmVzO1xuXG4gIGRvIHtcbiAgICAvKiByZWFkIGZpbmFsIGJsb2NrIGZsYWcgKi9cbiAgICBiZmluYWwgPSB0aW5mX2dldGJpdChkKTtcblxuICAgIC8qIHJlYWQgYmxvY2sgdHlwZSAoMiBiaXRzKSAqL1xuICAgIGJ0eXBlID0gdGluZl9yZWFkX2JpdHMoZCwgMiwgMCk7XG5cbiAgICAvKiBkZWNvbXByZXNzIGJsb2NrICovXG4gICAgc3dpdGNoIChidHlwZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvKiBkZWNvbXByZXNzIHVuY29tcHJlc3NlZCBibG9jayAqL1xuICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfdW5jb21wcmVzc2VkX2Jsb2NrKGQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLyogZGVjb21wcmVzcyBibG9jayB3aXRoIGZpeGVkIGh1ZmZtYW4gdHJlZXMgKi9cbiAgICAgICAgcmVzID0gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgc2x0cmVlLCBzZHRyZWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLyogZGVjb21wcmVzcyBibG9jayB3aXRoIGR5bmFtaWMgaHVmZm1hbiB0cmVlcyAqL1xuICAgICAgICB0aW5mX2RlY29kZV90cmVlcyhkLCBkLmx0cmVlLCBkLmR0cmVlKTtcbiAgICAgICAgcmVzID0gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgZC5sdHJlZSwgZC5kdHJlZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzID0gVElORl9EQVRBX0VSUk9SO1xuICAgIH1cblxuICAgIGlmIChyZXMgIT09IFRJTkZfT0spXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgZXJyb3InKTtcblxuICB9IHdoaWxlICghYmZpbmFsKTtcblxuICBpZiAoZC5kZXN0TGVuIDwgZC5kZXN0Lmxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgZC5kZXN0LnNsaWNlID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmV0dXJuIGQuZGVzdC5zbGljZSgwLCBkLmRlc3RMZW4pO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBkLmRlc3Quc3ViYXJyYXkoMCwgZC5kZXN0TGVuKTtcbiAgfVxuICBcbiAgcmV0dXJuIGQuZGVzdDtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gaW5pdGlhbGl6YXRpb24gLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xudGluZl9idWlsZF9maXhlZF90cmVlcyhzbHRyZWUsIHNkdHJlZSk7XG5cbi8qIGJ1aWxkIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzICovXG50aW5mX2J1aWxkX2JpdHNfYmFzZShsZW5ndGhfYml0cywgbGVuZ3RoX2Jhc2UsIDQsIDMpO1xudGluZl9idWlsZF9iaXRzX2Jhc2UoZGlzdF9iaXRzLCBkaXN0X2Jhc2UsIDIsIDEpO1xuXG4vKiBmaXggYSBzcGVjaWFsIGNhc2UgKi9cbmxlbmd0aF9iaXRzWzI4XSA9IDA7XG5sZW5ndGhfYmFzZVsyOF0gPSAyNTg7XG5cbm1vZHVsZS5leHBvcnRzID0gdGluZl91bmNvbXByZXNzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RpbnktaW5mbGF0ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=